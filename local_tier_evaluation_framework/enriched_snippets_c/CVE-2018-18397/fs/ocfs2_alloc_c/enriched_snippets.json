[
  {
    "function_name": "ocfs2_trim_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "7535-7679",
    "snippet": "int ocfs2_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 start, len, trimmed, first_group, last_group, group;\n\tint ret, cnt;\n\tu32 first_bit, last_bit, minlen;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_dinode *main_bm;\n\tstruct ocfs2_group_desc *gd = NULL;\n\tstruct ocfs2_trim_fs_info info, *pinfo = NULL;\n\n\tstart = range->start >> osb->s_clustersize_bits;\n\tlen = range->len >> osb->s_clustersize_bits;\n\tminlen = range->minlen >> osb->s_clustersize_bits;\n\n\tif (minlen >= osb->bitmap_cpg || range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\tmain_bm = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (start >= le32_to_cpu(main_bm->i_clusters)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = range->len >> osb->s_clustersize_bits;\n\tif (start + len > le32_to_cpu(main_bm->i_clusters))\n\t\tlen = le32_to_cpu(main_bm->i_clusters) - start;\n\n\ttrace_ocfs2_trim_fs(start, len, minlen);\n\n\tocfs2_trim_fs_lock_res_init(osb);\n\tret = ocfs2_trim_fs_lock(osb, NULL, 1);\n\tif (ret < 0) {\n\t\tif (ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmlog(ML_NOTICE, \"Wait for trim on device (%s) to \"\n\t\t     \"finish, which is running from another node.\\n\",\n\t\t     osb->dev_str);\n\t\tret = ocfs2_trim_fs_lock(osb, &info, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (info.tf_valid && info.tf_success &&\n\t\t    info.tf_start == start && info.tf_len == len &&\n\t\t    info.tf_minlen == minlen) {\n\t\t\t/* Avoid sending duplicated trim to a shared device */\n\t\t\tmlog(ML_NOTICE, \"The same trim on device (%s) was \"\n\t\t\t     \"just done from node (%u), return.\\n\",\n\t\t\t     osb->dev_str, info.tf_nodenum);\n\t\t\trange->len = info.tf_trimlen;\n\t\t\tgoto out_trimunlock;\n\t\t}\n\t}\n\n\tinfo.tf_nodenum = osb->node_num;\n\tinfo.tf_start = start;\n\tinfo.tf_len = len;\n\tinfo.tf_minlen = minlen;\n\n\t/* Determine first and last group to examine based on start and len */\n\tfirst_group = ocfs2_which_cluster_group(main_bm_inode, start);\n\tif (first_group == osb->first_cluster_group_blkno)\n\t\tfirst_bit = start;\n\telse\n\t\tfirst_bit = start - ocfs2_blocks_to_clusters(sb, first_group);\n\tlast_group = ocfs2_which_cluster_group(main_bm_inode, start + len - 1);\n\tlast_bit = osb->bitmap_cpg;\n\n\ttrimmed = 0;\n\tfor (group = first_group; group <= last_group;) {\n\t\tif (first_bit + len >= osb->bitmap_cpg)\n\t\t\tlast_bit = osb->bitmap_cpg;\n\t\telse\n\t\t\tlast_bit = first_bit + len;\n\n\t\tret = ocfs2_read_group_descriptor(main_bm_inode,\n\t\t\t\t\t\t  main_bm, group,\n\t\t\t\t\t\t  &gd_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\t\tcnt = ocfs2_trim_group(sb, gd, group,\n\t\t\t\t       first_bit, last_bit, minlen);\n\t\tbrelse(gd_bh);\n\t\tgd_bh = NULL;\n\t\tif (cnt < 0) {\n\t\t\tret = cnt;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrimmed += cnt;\n\t\tlen -= osb->bitmap_cpg - first_bit;\n\t\tfirst_bit = 0;\n\t\tif (group == osb->first_cluster_group_blkno)\n\t\t\tgroup = ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t\telse\n\t\t\tgroup += ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t}\n\trange->len = trimmed * sb->s_blocksize;\n\n\tinfo.tf_trimlen = range->len;\n\tinfo.tf_success = (ret ? 0 : 1);\n\tpinfo = &info;\nout_trimunlock:\n\tocfs2_trim_fs_unlock(osb, pinfo);\n\tocfs2_trim_fs_lock_res_uninit(osb);\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 0);\n\tbrelse(main_bm_bh);\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "main_bm_inode"
          ],
          "line": 7676
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "main_bm_inode"
          ],
          "line": 7675
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "main_bm_bh"
          ],
          "line": 7673
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "main_bm_inode",
            "0"
          ],
          "line": 7672
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "2589-2603",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_trim_fs_lock_res_uninit",
          "args": [
            "osb"
          ],
          "line": 7670
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trim_fs_lock_res_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "695-701",
          "snippet": "void ocfs2_trim_fs_lock_res_uninit(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tocfs2_simple_drop_lockres(osb, lockres);\n\tocfs2_lock_res_free(lockres);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_trim_fs_lock_res_uninit(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tocfs2_simple_drop_lockres(osb, lockres);\n\tocfs2_lock_res_free(lockres);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_trim_fs_unlock",
          "args": [
            "osb",
            "pinfo"
          ],
          "line": 7669
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trim_fs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "2907-2928",
          "snippet": "void ocfs2_trim_fs_unlock(struct ocfs2_super *osb,\n\t\t\t  struct ocfs2_trim_fs_info *info)\n{\n\tstruct ocfs2_trim_fs_lvb *lvb;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn;\n\n\tif (info) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tlvb->lvb_version = OCFS2_TRIMFS_LVB_VERSION;\n\t\tlvb->lvb_success = info->tf_success;\n\t\tlvb->lvb_nodenum = cpu_to_be32(info->tf_nodenum);\n\t\tlvb->lvb_start = cpu_to_be64(info->tf_start);\n\t\tlvb->lvb_len = cpu_to_be64(info->tf_len);\n\t\tlvb->lvb_minlen = cpu_to_be64(info->tf_minlen);\n\t\tlvb->lvb_trimlen = cpu_to_be64(info->tf_trimlen);\n\t}\n\n\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_trim_fs_unlock(struct ocfs2_super *osb,\n\t\t\t  struct ocfs2_trim_fs_info *info)\n{\n\tstruct ocfs2_trim_fs_lvb *lvb;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn;\n\n\tif (info) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tlvb->lvb_version = OCFS2_TRIMFS_LVB_VERSION;\n\t\tlvb->lvb_success = info->tf_success;\n\t\tlvb->lvb_nodenum = cpu_to_be32(info->tf_nodenum);\n\t\tlvb->lvb_start = cpu_to_be64(info->tf_start);\n\t\tlvb->lvb_len = cpu_to_be64(info->tf_len);\n\t\tlvb->lvb_minlen = cpu_to_be64(info->tf_minlen);\n\t\tlvb->lvb_trimlen = cpu_to_be64(info->tf_trimlen);\n\t}\n\n\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "osb->bitmap_cpg"
          ],
          "line": 7661
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trim_group",
          "args": [
            "sb",
            "gd",
            "group",
            "first_bit",
            "last_bit",
            "minlen"
          ],
          "line": 7645
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trim_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "7490-7533",
          "snippet": "static int ocfs2_trim_group(struct super_block *sb,\n\t\t\t    struct ocfs2_group_desc *gd, u64 group,\n\t\t\t    u32 start, u32 max, u32 minbits)\n{\n\tint ret = 0, count = 0, next;\n\tvoid *bitmap = gd->bg_bitmap;\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) < minbits)\n\t\treturn 0;\n\n\ttrace_ocfs2_trim_group((unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t       start, max, minbits);\n\n\twhile (start < max) {\n\t\tstart = ocfs2_find_next_zero_bit(bitmap, max, start);\n\t\tif (start >= max)\n\t\t\tbreak;\n\t\tnext = ocfs2_find_next_bit(bitmap, max, start);\n\n\t\tif ((next - start) >= minbits) {\n\t\t\tret = ocfs2_trim_extent(sb, gd, group,\n\t\t\t\t\t\tstart, next - start);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += next - start;\n\t\t}\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((le16_to_cpu(gd->bg_free_bits_count) - count) < minbits)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_trim_group(struct super_block *sb,\n\t\t\t    struct ocfs2_group_desc *gd, u64 group,\n\t\t\t    u32 start, u32 max, u32 minbits)\n{\n\tint ret = 0, count = 0, next;\n\tvoid *bitmap = gd->bg_bitmap;\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) < minbits)\n\t\treturn 0;\n\n\ttrace_ocfs2_trim_group((unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t       start, max, minbits);\n\n\twhile (start < max) {\n\t\tstart = ocfs2_find_next_zero_bit(bitmap, max, start);\n\t\tif (start >= max)\n\t\t\tbreak;\n\t\tnext = ocfs2_find_next_bit(bitmap, max, start);\n\n\t\tif ((next - start) >= minbits) {\n\t\t\tret = ocfs2_trim_extent(sb, gd, group,\n\t\t\t\t\t\tstart, next - start);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += next - start;\n\t\t}\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((le16_to_cpu(gd->bg_free_bits_count) - count) < minbits)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_group_descriptor",
          "args": [
            "main_bm_inode",
            "main_bm",
            "group",
            "&gd_bh"
          ],
          "line": 7636
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "309-332",
          "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_cluster_group",
          "args": [
            "main_bm_inode",
            "start + len - 1"
          ],
          "line": 7626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "2267-2279",
          "snippet": "u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "sb",
            "first_group"
          ],
          "line": 7625
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "748-755",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"The same trim on device (%s) was \"\n\t\t\t     \"just done from node (%u), return.\\n\"",
            "osb->dev_str",
            "info.tf_nodenum"
          ],
          "line": 7607
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "149-155",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trim_fs_lock",
          "args": [
            "osb",
            "&info",
            "0"
          ],
          "line": 7596
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trim_fs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "2866-2905",
          "snippet": "int ocfs2_trim_fs_lock(struct ocfs2_super *osb,\n\t\t       struct ocfs2_trim_fs_info *info, int trylock)\n{\n\tint status;\n\tstruct ocfs2_trim_fs_lvb *lvb;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tif (info)\n\t\tinfo->tf_valid = 0;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX,\n\t\t\t\t    trylock ? DLM_LKF_NOQUEUE : 0, 0);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (info) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t\t    lvb->lvb_version == OCFS2_TRIMFS_LVB_VERSION) {\n\t\t\tinfo->tf_valid = 1;\n\t\t\tinfo->tf_success = lvb->lvb_success;\n\t\t\tinfo->tf_nodenum = be32_to_cpu(lvb->lvb_nodenum);\n\t\t\tinfo->tf_start = be64_to_cpu(lvb->lvb_start);\n\t\t\tinfo->tf_len = be64_to_cpu(lvb->lvb_len);\n\t\t\tinfo->tf_minlen = be64_to_cpu(lvb->lvb_minlen);\n\t\t\tinfo->tf_trimlen = be64_to_cpu(lvb->lvb_trimlen);\n\t\t}\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_trim_fs_lock(struct ocfs2_super *osb,\n\t\t       struct ocfs2_trim_fs_info *info, int trylock)\n{\n\tint status;\n\tstruct ocfs2_trim_fs_lvb *lvb;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tif (info)\n\t\tinfo->tf_valid = 0;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX,\n\t\t\t\t    trylock ? DLM_LKF_NOQUEUE : 0, 0);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tif (info) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t\t    lvb->lvb_version == OCFS2_TRIMFS_LVB_VERSION) {\n\t\t\tinfo->tf_valid = 1;\n\t\t\tinfo->tf_success = lvb->lvb_success;\n\t\t\tinfo->tf_nodenum = be32_to_cpu(lvb->lvb_nodenum);\n\t\t\tinfo->tf_start = be64_to_cpu(lvb->lvb_start);\n\t\t\tinfo->tf_len = be64_to_cpu(lvb->lvb_len);\n\t\t\tinfo->tf_minlen = be64_to_cpu(lvb->lvb_minlen);\n\t\t\tinfo->tf_trimlen = be64_to_cpu(lvb->lvb_trimlen);\n\t\t}\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"Wait for trim on device (%s) to \"\n\t\t     \"finish, which is running from another node.\\n\"",
            "osb->dev_str"
          ],
          "line": 7593
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "141-147",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trim_fs_lock_res_init",
          "args": [
            "osb"
          ],
          "line": 7584
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trim_fs_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "685-693",
          "snippet": "void ocfs2_trim_fs_lock_res_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_TRIM_FS, 0, 0, lockres->l_name);\n\tocfs2_lock_res_init_common(osb, lockres, OCFS2_LOCK_TYPE_TRIM_FS,\n\t\t\t\t   &ocfs2_trim_fs_lops, osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_lock_res_ops ocfs2_trim_fs_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_trim_fs_lops = {\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_trim_fs_lock_res_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_lock_res *lockres = &osb->osb_trim_fs_lockres;\n\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_TRIM_FS, 0, 0, lockres->l_name);\n\tocfs2_lock_res_init_common(osb, lockres, OCFS2_LOCK_TYPE_TRIM_FS,\n\t\t\t\t   &ocfs2_trim_fs_lops, osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_trim_fs",
          "args": [
            "start",
            "len",
            "minlen"
          ],
          "line": 7582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "main_bm->i_clusters"
          ],
          "line": 7580
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "main_bm_inode",
            "&main_bm_bh",
            "0"
          ],
          "line": 7566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "main_bm_inode"
          ],
          "line": 7564
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 7555
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/sysfile.c",
          "lines": "139-182",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 7537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 start, len, trimmed, first_group, last_group, group;\n\tint ret, cnt;\n\tu32 first_bit, last_bit, minlen;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_dinode *main_bm;\n\tstruct ocfs2_group_desc *gd = NULL;\n\tstruct ocfs2_trim_fs_info info, *pinfo = NULL;\n\n\tstart = range->start >> osb->s_clustersize_bits;\n\tlen = range->len >> osb->s_clustersize_bits;\n\tminlen = range->minlen >> osb->s_clustersize_bits;\n\n\tif (minlen >= osb->bitmap_cpg || range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\tmain_bm = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (start >= le32_to_cpu(main_bm->i_clusters)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = range->len >> osb->s_clustersize_bits;\n\tif (start + len > le32_to_cpu(main_bm->i_clusters))\n\t\tlen = le32_to_cpu(main_bm->i_clusters) - start;\n\n\ttrace_ocfs2_trim_fs(start, len, minlen);\n\n\tocfs2_trim_fs_lock_res_init(osb);\n\tret = ocfs2_trim_fs_lock(osb, NULL, 1);\n\tif (ret < 0) {\n\t\tif (ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmlog(ML_NOTICE, \"Wait for trim on device (%s) to \"\n\t\t     \"finish, which is running from another node.\\n\",\n\t\t     osb->dev_str);\n\t\tret = ocfs2_trim_fs_lock(osb, &info, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (info.tf_valid && info.tf_success &&\n\t\t    info.tf_start == start && info.tf_len == len &&\n\t\t    info.tf_minlen == minlen) {\n\t\t\t/* Avoid sending duplicated trim to a shared device */\n\t\t\tmlog(ML_NOTICE, \"The same trim on device (%s) was \"\n\t\t\t     \"just done from node (%u), return.\\n\",\n\t\t\t     osb->dev_str, info.tf_nodenum);\n\t\t\trange->len = info.tf_trimlen;\n\t\t\tgoto out_trimunlock;\n\t\t}\n\t}\n\n\tinfo.tf_nodenum = osb->node_num;\n\tinfo.tf_start = start;\n\tinfo.tf_len = len;\n\tinfo.tf_minlen = minlen;\n\n\t/* Determine first and last group to examine based on start and len */\n\tfirst_group = ocfs2_which_cluster_group(main_bm_inode, start);\n\tif (first_group == osb->first_cluster_group_blkno)\n\t\tfirst_bit = start;\n\telse\n\t\tfirst_bit = start - ocfs2_blocks_to_clusters(sb, first_group);\n\tlast_group = ocfs2_which_cluster_group(main_bm_inode, start + len - 1);\n\tlast_bit = osb->bitmap_cpg;\n\n\ttrimmed = 0;\n\tfor (group = first_group; group <= last_group;) {\n\t\tif (first_bit + len >= osb->bitmap_cpg)\n\t\t\tlast_bit = osb->bitmap_cpg;\n\t\telse\n\t\t\tlast_bit = first_bit + len;\n\n\t\tret = ocfs2_read_group_descriptor(main_bm_inode,\n\t\t\t\t\t\t  main_bm, group,\n\t\t\t\t\t\t  &gd_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\t\tcnt = ocfs2_trim_group(sb, gd, group,\n\t\t\t\t       first_bit, last_bit, minlen);\n\t\tbrelse(gd_bh);\n\t\tgd_bh = NULL;\n\t\tif (cnt < 0) {\n\t\t\tret = cnt;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrimmed += cnt;\n\t\tlen -= osb->bitmap_cpg - first_bit;\n\t\tfirst_bit = 0;\n\t\tif (group == osb->first_cluster_group_blkno)\n\t\t\tgroup = ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t\telse\n\t\t\tgroup += ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t}\n\trange->len = trimmed * sb->s_blocksize;\n\n\tinfo.tf_trimlen = range->len;\n\tinfo.tf_success = (ret ? 0 : 1);\n\tpinfo = &info;\nout_trimunlock:\n\tocfs2_trim_fs_unlock(osb, pinfo);\n\tocfs2_trim_fs_lock_res_uninit(osb);\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 0);\n\tbrelse(main_bm_bh);\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_trim_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "7490-7533",
    "snippet": "static int ocfs2_trim_group(struct super_block *sb,\n\t\t\t    struct ocfs2_group_desc *gd, u64 group,\n\t\t\t    u32 start, u32 max, u32 minbits)\n{\n\tint ret = 0, count = 0, next;\n\tvoid *bitmap = gd->bg_bitmap;\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) < minbits)\n\t\treturn 0;\n\n\ttrace_ocfs2_trim_group((unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t       start, max, minbits);\n\n\twhile (start < max) {\n\t\tstart = ocfs2_find_next_zero_bit(bitmap, max, start);\n\t\tif (start >= max)\n\t\t\tbreak;\n\t\tnext = ocfs2_find_next_bit(bitmap, max, start);\n\n\t\tif ((next - start) >= minbits) {\n\t\t\tret = ocfs2_trim_extent(sb, gd, group,\n\t\t\t\t\t\tstart, next - start);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += next - start;\n\t\t}\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((le16_to_cpu(gd->bg_free_bits_count) - count) < minbits)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gd->bg_free_bits_count"
          ],
          "line": 7525
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 7520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trim_extent",
          "args": [
            "sb",
            "gd",
            "group",
            "start",
            "next - start"
          ],
          "line": 7510
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trim_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "7464-7488",
          "snippet": "static int ocfs2_trim_extent(struct super_block *sb,\n\t\t\t     struct ocfs2_group_desc *gd,\n\t\t\t     u64 group, u32 start, u32 count)\n{\n\tu64 discard, bcount;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tbcount = ocfs2_clusters_to_blocks(sb, count);\n\tdiscard = ocfs2_clusters_to_blocks(sb, start);\n\n\t/*\n\t * For the first cluster group, the gd->bg_blkno is not at the start\n\t * of the group, but at an offset from the start. If we add it while\n\t * calculating discard for first group, we will wrongly start fstrim a\n\t * few blocks after the desried start block and the range can cross\n\t * over into the next cluster group. So, add it only if this is not\n\t * the first cluster group.\n\t */\n\tif (group != osb->first_cluster_group_blkno)\n\t\tdiscard += le64_to_cpu(gd->bg_blkno);\n\n\ttrace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);\n\n\treturn sb_issue_discard(sb, discard, bcount, GFP_NOFS, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_trim_extent(struct super_block *sb,\n\t\t\t     struct ocfs2_group_desc *gd,\n\t\t\t     u64 group, u32 start, u32 count)\n{\n\tu64 discard, bcount;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tbcount = ocfs2_clusters_to_blocks(sb, count);\n\tdiscard = ocfs2_clusters_to_blocks(sb, start);\n\n\t/*\n\t * For the first cluster group, the gd->bg_blkno is not at the start\n\t * of the group, but at an offset from the start. If we add it while\n\t * calculating discard for first group, we will wrongly start fstrim a\n\t * few blocks after the desried start block and the range can cross\n\t * over into the next cluster group. So, add it only if this is not\n\t * the first cluster group.\n\t */\n\tif (group != osb->first_cluster_group_blkno)\n\t\tdiscard += le64_to_cpu(gd->bg_blkno);\n\n\ttrace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);\n\n\treturn sb_issue_discard(sb, discard, bcount, GFP_NOFS, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_bit",
          "args": [
            "bitmap",
            "max",
            "start"
          ],
          "line": 7507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_zero_bit",
          "args": [
            "bitmap",
            "max",
            "start"
          ],
          "line": 7504
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "932-944",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_trim_group",
          "args": [
            "(unsigned long long)le64_to_cpu(gd->bg_blkno)",
            "start",
            "max",
            "minbits"
          ],
          "line": 7500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "gd->bg_blkno"
          ],
          "line": 7500
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_trim_group(struct super_block *sb,\n\t\t\t    struct ocfs2_group_desc *gd, u64 group,\n\t\t\t    u32 start, u32 max, u32 minbits)\n{\n\tint ret = 0, count = 0, next;\n\tvoid *bitmap = gd->bg_bitmap;\n\n\tif (le16_to_cpu(gd->bg_free_bits_count) < minbits)\n\t\treturn 0;\n\n\ttrace_ocfs2_trim_group((unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t\t       start, max, minbits);\n\n\twhile (start < max) {\n\t\tstart = ocfs2_find_next_zero_bit(bitmap, max, start);\n\t\tif (start >= max)\n\t\t\tbreak;\n\t\tnext = ocfs2_find_next_bit(bitmap, max, start);\n\n\t\tif ((next - start) >= minbits) {\n\t\t\tret = ocfs2_trim_extent(sb, gd, group,\n\t\t\t\t\t\tstart, next - start);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += next - start;\n\t\t}\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((le16_to_cpu(gd->bg_free_bits_count) - count) < minbits)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}"
  },
  {
    "function_name": "ocfs2_trim_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "7464-7488",
    "snippet": "static int ocfs2_trim_extent(struct super_block *sb,\n\t\t\t     struct ocfs2_group_desc *gd,\n\t\t\t     u64 group, u32 start, u32 count)\n{\n\tu64 discard, bcount;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tbcount = ocfs2_clusters_to_blocks(sb, count);\n\tdiscard = ocfs2_clusters_to_blocks(sb, start);\n\n\t/*\n\t * For the first cluster group, the gd->bg_blkno is not at the start\n\t * of the group, but at an offset from the start. If we add it while\n\t * calculating discard for first group, we will wrongly start fstrim a\n\t * few blocks after the desried start block and the range can cross\n\t * over into the next cluster group. So, add it only if this is not\n\t * the first cluster group.\n\t */\n\tif (group != osb->first_cluster_group_blkno)\n\t\tdiscard += le64_to_cpu(gd->bg_blkno);\n\n\ttrace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);\n\n\treturn sb_issue_discard(sb, discard, bcount, GFP_NOFS, 0);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_issue_discard",
          "args": [
            "sb",
            "discard",
            "bcount",
            "GFP_NOFS",
            "0"
          ],
          "line": 7487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_trim_extent",
          "args": [
            "sb",
            "(unsigned long long)discard",
            "bcount"
          ],
          "line": 7485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "gd->bg_blkno"
          ],
          "line": 7483
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "start"
          ],
          "line": 7472
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 7469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_trim_extent(struct super_block *sb,\n\t\t\t     struct ocfs2_group_desc *gd,\n\t\t\t     u64 group, u32 start, u32 count)\n{\n\tu64 discard, bcount;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tbcount = ocfs2_clusters_to_blocks(sb, count);\n\tdiscard = ocfs2_clusters_to_blocks(sb, start);\n\n\t/*\n\t * For the first cluster group, the gd->bg_blkno is not at the start\n\t * of the group, but at an offset from the start. If we add it while\n\t * calculating discard for first group, we will wrongly start fstrim a\n\t * few blocks after the desried start block and the range can cross\n\t * over into the next cluster group. So, add it only if this is not\n\t * the first cluster group.\n\t */\n\tif (group != osb->first_cluster_group_blkno)\n\t\tdiscard += le64_to_cpu(gd->bg_blkno);\n\n\ttrace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);\n\n\treturn sb_issue_discard(sb, discard, bcount, GFP_NOFS, 0);\n}"
  },
  {
    "function_name": "ocfs2_truncate_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "7392-7462",
    "snippet": "int ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  unsigned int start, unsigned int end, int trunc)\n{\n\tint ret;\n\tunsigned int numbytes;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\tBUG_ON(start > end);\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||\n\t    !ocfs2_supports_inline_data(osb)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inline data flags for inode %llu don't agree! Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    le16_to_cpu(di->i_dyn_features),\n\t\t\t    OCFS2_I(inode)->ip_dyn_features,\n\t\t\t    osb->s_feature_incompat);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnumbytes = end - start;\n\tmemset(idata->id_data + start, 0, numbytes);\n\n\t/*\n\t * No need to worry about the data page here - it's been\n\t * truncated already and inline data doesn't need it for\n\t * pushing zero's to disk, so we'll let readpage pick it up\n\t * later.\n\t */\n\tif (trunc) {\n\t\ti_size_write(inode, start);\n\t\tdi->i_size = cpu_to_le64(start);\n\t}\n\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = current_time(inode);\n\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 7458
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 7455
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 7454
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 7452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 7451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 7449
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 7448
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "159-164",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "start"
          ],
          "line": 7445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "start"
          ],
          "line": 7444
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2436-2448",
          "snippet": "static inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "idata->id_data + start",
            "0",
            "numbytes"
          ],
          "line": 7435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 7427
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "725-729",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 7427
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "129-132",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 7422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 7421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 7420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inline data flags for inode %llu don't agree! Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "le16_to_cpu(di->i_dyn_features)",
            "OCFS2_I(inode)->ip_dyn_features",
            "osb->s_feature_incompat"
          ],
          "line": 7410
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 7414
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_dyn_features"
          ],
          "line": 7413
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_inline_data",
          "args": [
            "osb"
          ],
          "line": 7409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "529-534",
          "snippet": "static inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_inline_data(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_INLINE_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start > end"
          ],
          "line": 7405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 7403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 7402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 7398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  unsigned int start, unsigned int end, int trunc)\n{\n\tint ret;\n\tunsigned int numbytes;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\tBUG_ON(start > end);\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||\n\t    !ocfs2_supports_inline_data(osb)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inline data flags for inode %llu don't agree! Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    le16_to_cpu(di->i_dyn_features),\n\t\t\t    OCFS2_I(inode)->ip_dyn_features,\n\t\t\t    osb->s_feature_incompat);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnumbytes = end - start;\n\tmemset(idata->id_data + start, 0, numbytes);\n\n\t/*\n\t * No need to worry about the data page here - it's been\n\t * truncated already and inline data doesn't need it for\n\t * pushing zero's to disk, so we'll let readpage pick it up\n\t * later.\n\t */\n\tif (trunc) {\n\t\ti_size_write(inode, start);\n\t\tdi->i_size = cpu_to_le64(start);\n\t}\n\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = current_time(inode);\n\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_commit_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "7218-7387",
    "snippet": "int ocfs2_commit_truncate(struct ocfs2_super *osb,\n\t\t\t  struct inode *inode,\n\t\t\t  struct buffer_head *di_bh)\n{\n\tint status = 0, i, flags = 0;\n\tu32 new_highest_cpos, range, trunc_cpos, trunc_len, phys_cpos, coff;\n\tu64 blkno = 0;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_extent_list *root_el = &(di->id2.i_list);\n\tu64 refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tnew_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,\n\t\t\t\t\t\t     i_size_read(inode));\n\n\tpath = ocfs2_new_path(di_bh, &di->id2.i_list,\n\t\t\t      ocfs2_journal_access_di);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_extent_map_trunc(inode, new_highest_cpos);\n\nstart:\n\t/*\n\t * Check that we still have allocation to delete.\n\t */\n\tif (OCFS2_I(inode)->ip_clusters == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Truncate always works against the rightmost tree branch.\n\t */\n\tstatus = ocfs2_find_path(INODE_CACHE(inode), path, UINT_MAX);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_commit_truncate(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tnew_highest_cpos,\n\t\tOCFS2_I(inode)->ip_clusters,\n\t\tpath->p_tree_depth);\n\n\t/*\n\t * By now, el will point to the extent list on the bottom most\n\t * portion of this tree. Only the tail record is considered in\n\t * each pass.\n\t *\n\t * We handle the following cases, in order:\n\t * - empty extent: delete the remaining branch\n\t * - remove the entire record\n\t * - remove a partial record\n\t * - no record needs to be removed (truncate has completed)\n\t */\n\tel = path_leaf_el(path);\n\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has empty extent block at %llu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)path_leaf_bh(path)->b_blocknr);\n\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\tflags = rec->e_flags;\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (i == 0 && ocfs2_is_empty_extent(rec)) {\n\t\t/*\n\t\t * Lower levels depend on this never happening, but it's best\n\t\t * to check it up here before changing the tree.\n\t\t*/\n\t\tif (root_el->l_tree_depth && rec->e_int_clusters == 0) {\n\t\t\tmlog(ML_ERROR, \"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\", inode->i_ino,\n\t\t\t\t    le16_to_cpu(root_el->l_tree_depth));\n\t\t\tstatus = ocfs2_remove_rightmost_empty_extent(osb,\n\t\t\t\t\t&et, path, &dealloc);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tocfs2_reinit_path(path, 1);\n\t\t\tgoto start;\n\t\t} else {\n\t\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\t\ttrunc_len = 0;\n\t\t\tblkno = 0;\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) >= new_highest_cpos) {\n\t\t/*\n\t\t * Truncate entire record.\n\t\t */\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = ocfs2_rec_clusters(el, rec);\n\t\tblkno = le64_to_cpu(rec->e_blkno);\n\t} else if (range > new_highest_cpos) {\n\t\t/*\n\t\t * Partial truncate. it also should be\n\t\t * the last truncate we're doing.\n\t\t */\n\t\ttrunc_cpos = new_highest_cpos;\n\t\ttrunc_len = range - new_highest_cpos;\n\t\tcoff = new_highest_cpos - le32_to_cpu(rec->e_cpos);\n\t\tblkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t} else {\n\t\t/*\n\t\t * Truncate completed, leave happily.\n\t\t */\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && trunc_len && !ref_tree) {\n\t\tstatus = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t&ref_tree, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t  phys_cpos, trunc_len, flags, &dealloc,\n\t\t\t\t\t  refcount_loc, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_reinit_path(path, 1);\n\n\t/*\n\t * The check above will catch the case where we've truncated\n\t * away all allocation.\n\t */\n\tgoto start;\n\nbail:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tocfs2_free_path(path);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 7384
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&dealloc"
          ],
          "line": 7382
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6532-6573",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 7380
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6090-6103",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(osb->ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(osb->ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 7378
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/refcounttree.c",
          "lines": "524-534",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"file.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"file.h\"\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "path",
            "1"
          ],
          "line": 7368
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "589-616",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 7364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_btree_range",
          "args": [
            "inode",
            "&et",
            "trunc_cpos",
            "phys_cpos",
            "trunc_len",
            "flags",
            "&dealloc",
            "refcount_loc",
            "true"
          ],
          "line": 7360
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_btree_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5707-5818",
          "snippet": "int ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tinode_lock(tl_inode);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tinode_unlock(tl_inode);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tinode_lock(tl_inode);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tinode_unlock(tl_inode);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 7355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "refcount_loc",
            "1",
            "&ref_tree",
            "NULL"
          ],
          "line": 7352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/refcounttree.c",
          "lines": "451-522",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"file.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"file.h\"\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "blkno"
          ],
          "line": 7349
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "748-755",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "coff"
          ],
          "line": 7340
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 7339
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 7338
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 7329
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 7313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_rightmost_empty_extent",
          "args": [
            "osb",
            "&et",
            "path",
            "&dealloc"
          ],
          "line": 7310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_rightmost_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3120-3142",
          "snippet": "static int ocfs2_remove_rightmost_empty_extent(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\thandle_t *handle;\n\tint ret;\n\tint credits = path->p_tree_depth * 2 + 1;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_remove_rightmost_path(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_remove_rightmost_empty_extent(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\thandle_t *handle;\n\tint ret;\n\tint credits = path->p_tree_depth * 2 + 1;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_remove_rightmost_path(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\"",
            "inode->i_ino",
            "le16_to_cpu(root_el->l_tree_depth)"
          ],
          "line": 7307
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "149-155",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_tree_depth"
          ],
          "line": 7309
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "rec"
          ],
          "line": 7301
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %llu has empty extent block at %llu\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)path_leaf_bh(path)->b_blocknr"
          ],
          "line": 7288
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 7291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 7290
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 7286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_commit_truncate",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "new_highest_cpos",
            "OCFS2_I(inode)->ip_clusters",
            "path->p_tree_depth"
          ],
          "line": 7269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 7265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "INODE_CACHE(inode)",
            "path",
            "UINT_MAX"
          ],
          "line": 7263
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 7263
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "129-132",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_trunc",
          "args": [
            "inode",
            "new_highest_cpos"
          ],
          "line": 7249
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/extent_map.c",
          "lines": "115-145",
          "snippet": "void ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"aops.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"aops.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 7245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path",
          "args": [
            "di_bh",
            "&di->id2.i_list",
            "ocfs2_journal_access_di"
          ],
          "line": 7241
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "696-714",
          "snippet": "static struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "osb->sb",
            "i_size_read(inode)"
          ],
          "line": 7238
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "757-768",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 7239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&dealloc"
          ],
          "line": 7236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "207-211",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "di_bh"
          ],
          "line": 7235
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "467-473",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_commit_truncate(struct ocfs2_super *osb,\n\t\t\t  struct inode *inode,\n\t\t\t  struct buffer_head *di_bh)\n{\n\tint status = 0, i, flags = 0;\n\tu32 new_highest_cpos, range, trunc_cpos, trunc_len, phys_cpos, coff;\n\tu64 blkno = 0;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_extent_list *root_el = &(di->id2.i_list);\n\tu64 refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tnew_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,\n\t\t\t\t\t\t     i_size_read(inode));\n\n\tpath = ocfs2_new_path(di_bh, &di->id2.i_list,\n\t\t\t      ocfs2_journal_access_di);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_extent_map_trunc(inode, new_highest_cpos);\n\nstart:\n\t/*\n\t * Check that we still have allocation to delete.\n\t */\n\tif (OCFS2_I(inode)->ip_clusters == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Truncate always works against the rightmost tree branch.\n\t */\n\tstatus = ocfs2_find_path(INODE_CACHE(inode), path, UINT_MAX);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_commit_truncate(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tnew_highest_cpos,\n\t\tOCFS2_I(inode)->ip_clusters,\n\t\tpath->p_tree_depth);\n\n\t/*\n\t * By now, el will point to the extent list on the bottom most\n\t * portion of this tree. Only the tail record is considered in\n\t * each pass.\n\t *\n\t * We handle the following cases, in order:\n\t * - empty extent: delete the remaining branch\n\t * - remove the entire record\n\t * - remove a partial record\n\t * - no record needs to be removed (truncate has completed)\n\t */\n\tel = path_leaf_el(path);\n\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has empty extent block at %llu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)path_leaf_bh(path)->b_blocknr);\n\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\tflags = rec->e_flags;\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (i == 0 && ocfs2_is_empty_extent(rec)) {\n\t\t/*\n\t\t * Lower levels depend on this never happening, but it's best\n\t\t * to check it up here before changing the tree.\n\t\t*/\n\t\tif (root_el->l_tree_depth && rec->e_int_clusters == 0) {\n\t\t\tmlog(ML_ERROR, \"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\", inode->i_ino,\n\t\t\t\t    le16_to_cpu(root_el->l_tree_depth));\n\t\t\tstatus = ocfs2_remove_rightmost_empty_extent(osb,\n\t\t\t\t\t&et, path, &dealloc);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tocfs2_reinit_path(path, 1);\n\t\t\tgoto start;\n\t\t} else {\n\t\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\t\ttrunc_len = 0;\n\t\t\tblkno = 0;\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) >= new_highest_cpos) {\n\t\t/*\n\t\t * Truncate entire record.\n\t\t */\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = ocfs2_rec_clusters(el, rec);\n\t\tblkno = le64_to_cpu(rec->e_blkno);\n\t} else if (range > new_highest_cpos) {\n\t\t/*\n\t\t * Partial truncate. it also should be\n\t\t * the last truncate we're doing.\n\t\t */\n\t\ttrunc_cpos = new_highest_cpos;\n\t\ttrunc_len = range - new_highest_cpos;\n\t\tcoff = new_highest_cpos - le32_to_cpu(rec->e_cpos);\n\t\tblkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t} else {\n\t\t/*\n\t\t * Truncate completed, leave happily.\n\t\t */\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && trunc_len && !ref_tree) {\n\t\tstatus = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t&ref_tree, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t  phys_cpos, trunc_len, flags, &dealloc,\n\t\t\t\t\t  refcount_loc, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_reinit_path(path, 1);\n\n\t/*\n\t * The check above will catch the case where we've truncated\n\t * away all allocation.\n\t */\n\tgoto start;\n\nbail:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tocfs2_free_path(path);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_convert_inline_data_to_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "7044-7210",
    "snippet": "int ocfs2_convert_inline_data_to_extents(struct inode *inode,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret, i, has_data, num_pages = 0;\n\tint need_free = 0;\n\tu32 bit_off, num;\n\thandle_t *handle;\n\tu64 uninitialized_var(block);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct page **pages = NULL;\n\tloff_t end = osb->s_clustersize;\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\thas_data = i_size_read(inode) ? 1 : 0;\n\n\tif (has_data) {\n\t\tpages = kcalloc(ocfs2_pages_per_cluster(osb->sb),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (pages == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto free_pages;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_inline_to_extents_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (has_data) {\n\t\tunsigned int page_end;\n\t\tu64 phys;\n\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t\tdid_quota = 1;\n\n\t\tdata_ac->ac_resv = &oi->ip_la_data_resv;\n\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &num);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * Save two copies, one for insert, and one that can\n\t\t * be changed by ocfs2_map_and_dirty_page() below.\n\t\t */\n\t\tblock = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\t\t/*\n\t\t * Non sparse file systems zero on extend, so no need\n\t\t * to do that now.\n\t\t */\n\t\tif (!ocfs2_sparse_alloc(osb) &&\n\t\t    PAGE_SIZE < osb->s_clustersize)\n\t\t\tend = PAGE_SIZE;\n\n\t\tret = ocfs2_grab_eof_pages(inode, 0, end, pages, &num_pages);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * This should populate the 1st page for us and mark\n\t\t * it up to date.\n\t\t */\n\t\tret = ocfs2_read_inline_data(inode, pages[0], di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_end = PAGE_SIZE;\n\t\tif (PAGE_SIZE > osb->s_clustersize)\n\t\t\tpage_end = osb->s_clustersize;\n\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tocfs2_map_and_dirty_page(inode, handle, 0, page_end,\n\t\t\t\t\t\t pages[i], i > 0, &phys);\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_dinode_new_extent_list(inode, di);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (has_data) {\n\t\t/*\n\t\t * An error at this point should be extremely rare. If\n\t\t * this proves to be false, we could always re-build\n\t\t * the in-inode data from our pages.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\t\tret = ocfs2_insert_extent(handle, &et, 0, block, 1, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t}\n\nout_unlock:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, num_pages);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(osb->sb, 1));\n\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\nfree_pages:\n\tkfree(pages);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 7208
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "data_ac"
          ],
          "line": 7206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "154-158",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 7202
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_clusters",
          "args": [
            "handle",
            "data_ac->ac_inode",
            "data_ac->ac_bh",
            "ocfs2_clusters_to_blocks(osb->sb, bit_off)",
            "num"
          ],
          "line": 7195
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "2601-2610",
          "snippet": "int ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "bit_off"
          ],
          "line": 7198
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_local_alloc_bits",
          "args": [
            "osb",
            "handle",
            "data_ac",
            "bit_off",
            "num"
          ],
          "line": 7192
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_local_alloc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/localalloc.c",
          "lines": "780-820",
          "snippet": "int ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
            "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nint ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(osb->sb, 1)"
          ],
          "line": 7187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "osb->sb",
            "1"
          ],
          "line": 7188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "787-791",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_and_free_pages",
          "args": [
            "pages",
            "num_pages"
          ],
          "line": 7183
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "803-814",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 7178
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "159-164",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "&et",
            "0",
            "block",
            "1",
            "0",
            "NULL"
          ],
          "line": 7171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4716-4777",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "di_bh"
          ],
          "line": 7170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "467-473",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 7170
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "129-132",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 7162
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dinode_new_extent_list",
          "args": [
            "inode",
            "di"
          ],
          "line": 7160
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dinode_new_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "7014-7022",
          "snippet": "void ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 7159
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 7157
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 7156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 7154
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_map_and_dirty_page",
          "args": [
            "inode",
            "handle",
            "0",
            "page_end",
            "pages[i]",
            "i > 0",
            "&phys"
          ],
          "line": 7150
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_map_and_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6804-6837",
          "snippet": "void ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inline_data",
          "args": [
            "inode",
            "pages[0]",
            "di_bh"
          ],
          "line": 7138
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "235-270",
          "snippet": "int ocfs2_read_inline_data(struct inode *inode, struct page *page,\n\t\t\t   struct buffer_head *di_bh)\n{\n\tvoid *kaddr;\n\tloff_t size;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu lost inline data flag\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\treturn -EROFS;\n\t}\n\n\tsize = i_size_read(inode);\n\n\tif (size > PAGE_SIZE ||\n\t    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has with inline data has bad size: %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)size);\n\t\treturn -EROFS;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tif (size)\n\t\tmemcpy(kaddr, di->id2.i_data.id_data, size);\n\t/* Clear the remaining part of the page */\n\tmemset(kaddr + size, 0, PAGE_SIZE - size);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inline_data(struct inode *inode, struct page *page,\n\t\t\t   struct buffer_head *di_bh)\n{\n\tvoid *kaddr;\n\tloff_t size;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu lost inline data flag\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\treturn -EROFS;\n\t}\n\n\tsize = i_size_read(inode);\n\n\tif (size > PAGE_SIZE ||\n\t    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has with inline data has bad size: %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)size);\n\t\treturn -EROFS;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tif (size)\n\t\tmemcpy(kaddr, di->id2.i_data.id_data, size);\n\t/* Clear the remaining part of the page */\n\tmemset(kaddr + size, 0, PAGE_SIZE - size);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grab_eof_pages",
          "args": [
            "inode",
            "0",
            "end",
            "pages",
            "&num_pages"
          ],
          "line": 7127
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grab_eof_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6911-6920",
          "snippet": "static int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 7123
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "501-506",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_clusters",
          "args": [
            "handle",
            "data_ac",
            "1",
            "&bit_off",
            "&num"
          ],
          "line": 7106
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "2380-2390",
          "snippet": "int ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(osb->sb, 1)"
          ],
          "line": 7098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 7087
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "725-729",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 7082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 7081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_inline_to_extents_credits(osb->sb)"
          ],
          "line": 7079
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inline_to_extents_credits",
          "args": [
            "osb->sb"
          ],
          "line": 7080
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inline_to_extents_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.h",
          "lines": "399-403",
          "snippet": "static inline int ocfs2_inline_to_extents_credits(struct super_block *sb)\n{\n\treturn OCFS2_SUBALLOC_ALLOC + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)",
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_inline_to_extents_credits(struct super_block *sb)\n{\n\treturn OCFS2_SUBALLOC_ALLOC + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "1",
            "&data_ac"
          ],
          "line": 7072
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "1235-1241",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 7068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "ocfs2_pages_per_cluster(osb->sb)",
            "sizeof(struct page *)",
            "GFP_NOFS"
          ],
          "line": 7064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_pages_per_cluster",
          "args": [
            "osb->sb"
          ],
          "line": 7064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_pages_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "859-868",
          "snippet": "static inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int pages_per_cluster = 1;\n\n\tif (PAGE_SHIFT < cbits)\n\t\tpages_per_cluster = 1 << (cbits - PAGE_SHIFT);\n\n\treturn pages_per_cluster;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int pages_per_cluster = 1;\n\n\tif (PAGE_SHIFT < cbits)\n\t\tpages_per_cluster = 1 << (cbits - PAGE_SHIFT);\n\n\treturn pages_per_cluster;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 7061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 7053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 7052
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_convert_inline_data_to_extents(struct inode *inode,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret, i, has_data, num_pages = 0;\n\tint need_free = 0;\n\tu32 bit_off, num;\n\thandle_t *handle;\n\tu64 uninitialized_var(block);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct page **pages = NULL;\n\tloff_t end = osb->s_clustersize;\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\thas_data = i_size_read(inode) ? 1 : 0;\n\n\tif (has_data) {\n\t\tpages = kcalloc(ocfs2_pages_per_cluster(osb->sb),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (pages == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto free_pages;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_inline_to_extents_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (has_data) {\n\t\tunsigned int page_end;\n\t\tu64 phys;\n\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t\tdid_quota = 1;\n\n\t\tdata_ac->ac_resv = &oi->ip_la_data_resv;\n\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &num);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * Save two copies, one for insert, and one that can\n\t\t * be changed by ocfs2_map_and_dirty_page() below.\n\t\t */\n\t\tblock = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\t\t/*\n\t\t * Non sparse file systems zero on extend, so no need\n\t\t * to do that now.\n\t\t */\n\t\tif (!ocfs2_sparse_alloc(osb) &&\n\t\t    PAGE_SIZE < osb->s_clustersize)\n\t\t\tend = PAGE_SIZE;\n\n\t\tret = ocfs2_grab_eof_pages(inode, 0, end, pages, &num_pages);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * This should populate the 1st page for us and mark\n\t\t * it up to date.\n\t\t */\n\t\tret = ocfs2_read_inline_data(inode, pages[0], di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_end = PAGE_SIZE;\n\t\tif (PAGE_SIZE > osb->s_clustersize)\n\t\t\tpage_end = osb->s_clustersize;\n\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tocfs2_map_and_dirty_page(inode, handle, 0, page_end,\n\t\t\t\t\t\t pages[i], i > 0, &phys);\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_dinode_new_extent_list(inode, di);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (has_data) {\n\t\t/*\n\t\t * An error at this point should be extremely rare. If\n\t\t * this proves to be false, we could always re-build\n\t\t * the in-inode data from our pages.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\t\tret = ocfs2_insert_extent(handle, &et, 0, block, 1, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t}\n\nout_unlock:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, num_pages);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(osb->sb, 1));\n\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\nfree_pages:\n\tkfree(pages);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_set_inode_data_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "7024-7042",
    "snippet": "void ocfs2_set_inode_data_inline(struct inode *inode, struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\t/*\n\t * We clear the entire i_data structure here so that all\n\t * fields can be properly initialized.\n\t */\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\n\tidata->id_count = cpu_to_le16(\n\t\t\tocfs2_max_inline_data_with_xattr(inode->i_sb, di));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_max_inline_data_with_xattr(inode->i_sb, di)"
          ],
          "line": 7040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_max_inline_data_with_xattr",
          "args": [
            "inode->i_sb",
            "di"
          ],
          "line": 7041
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_max_inline_data_with_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1484-1494",
          "snippet": "static inline int ocfs2_max_inline_data_with_xattr(int blocksize,\n\t\t\t\t\t\t   struct ocfs2_dinode *di)\n{\n\tif (di && (di->i_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data) -\n\t\t\tdi->i_xattr_inline_size;\n\telse\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data);\n}",
          "includes": [
            "#include <linux/magic.h>"
          ],
          "macros_used": [
            "#define OCFS2_INLINE_XATTR_FL\t(0x0004)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n\n#define OCFS2_INLINE_XATTR_FL\t(0x0004)\n\nstatic inline int ocfs2_max_inline_data_with_xattr(int blocksize,\n\t\t\t\t\t\t   struct ocfs2_dinode *di)\n{\n\tif (di && (di->i_dyn_features & OCFS2_INLINE_XATTR_FL))\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data) -\n\t\t\tdi->i_xattr_inline_size;\n\telse\n\t\treturn blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_data.id_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_dinode_id2_with_xattr",
          "args": [
            "inode",
            "di"
          ],
          "line": 7038
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_dinode_id2_with_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6999-7012",
          "snippet": "static void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 7032
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 7031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 7029
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 7026
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_inode_data_inline(struct inode *inode, struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\t/*\n\t * We clear the entire i_data structure here so that all\n\t * fields can be properly initialized.\n\t */\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\n\tidata->id_count = cpu_to_le16(\n\t\t\tocfs2_max_inline_data_with_xattr(inode->i_sb, di));\n}"
  },
  {
    "function_name": "ocfs2_dinode_new_extent_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "7014-7022",
    "snippet": "void ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di)"
          ],
          "line": 7020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_inode_with_xattr",
          "args": [
            "inode->i_sb",
            "di"
          ],
          "line": 7021
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_inode_with_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1310-1326",
          "snippet": "static inline int ocfs2_extent_recs_per_inode_with_xattr(\n\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tint size;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tsize = sb->s_blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs) -\n\t\t\txattrsize;\n\telse\n\t\tsize = sb->s_blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [
            "#include <linux/magic.h>"
          ],
          "macros_used": [
            "#define OCFS2_INLINE_XATTR_FL\t(0x0004)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n\n#define OCFS2_INLINE_XATTR_FL\t(0x0004)\n\nstatic inline int ocfs2_extent_recs_per_inode_with_xattr(\n\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\tstruct ocfs2_dinode *di)\n{\n\tint size;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tsize = sb->s_blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs) -\n\t\t\txattrsize;\n\telse\n\t\tsize = sb->s_blocksize -\n\t\t\toffsetof(struct ocfs2_dinode, id2.i_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_dinode_id2_with_xattr",
          "args": [
            "inode",
            "di"
          ],
          "line": 7017
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_dinode_id2_with_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6999-7012",
          "snippet": "static void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_dinode_new_extent_list(struct inode *inode,\n\t\t\t\t  struct ocfs2_dinode *di)\n{\n\tocfs2_zero_dinode_id2_with_xattr(inode, di);\n\tdi->id2.i_list.l_tree_depth = 0;\n\tdi->id2.i_list.l_next_free_rec = 0;\n\tdi->id2.i_list.l_count = cpu_to_le16(\n\t\tocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));\n}"
  },
  {
    "function_name": "ocfs2_zero_dinode_id2_with_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6999-7012",
    "snippet": "static void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&di->id2",
            "0",
            "blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2)"
          ],
          "line": 7010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&di->id2",
            "0",
            "blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize"
          ],
          "line": 7006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->i_dyn_features"
          ],
          "line": 7005
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,\n\t\t\t\t\t     struct ocfs2_dinode *di)\n{\n\tunsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;\n\tunsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);\n\n\tif (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2) -\n\t\t\t\t    xattrsize);\n\telse\n\t\tmemset(&di->id2, 0, blocksize -\n\t\t\t\t    offsetof(struct ocfs2_dinode, id2));\n}"
  },
  {
    "function_name": "ocfs2_zero_range_for_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6931-6997",
    "snippet": "int ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 range_start, u64 range_end)\n{\n\tint ret = 0, numpages;\n\tstruct page **pages = NULL;\n\tu64 phys;\n\tunsigned int ext_flags;\n\tstruct super_block *sb = inode->i_sb;\n\n\t/*\n\t * File systems which don't support sparse files zero on every\n\t * extend.\n\t */\n\tif (!ocfs2_sparse_alloc(OCFS2_SB(sb)))\n\t\treturn 0;\n\n\tpages = kcalloc(ocfs2_pages_per_cluster(sb),\n\t\t\tsizeof(struct page *), GFP_NOFS);\n\tif (pages == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (range_start == range_end)\n\t\tgoto out;\n\n\tret = ocfs2_extent_map_get_blocks(inode,\n\t\t\t\t\t  range_start >> sb->s_blocksize_bits,\n\t\t\t\t\t  &phys, NULL, &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Tail is a hole, or is marked unwritten. In either case, we\n\t * can count on read and write to return/push zero's.\n\t */\n\tif (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\tgoto out;\n\n\tret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,\n\t\t\t\t   &numpages);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_zero_cluster_pages(inode, range_start, range_end, pages,\n\t\t\t\t numpages, phys, handle);\n\n\t/*\n\t * Initiate writeout of the pages we zero'd here. We don't\n\t * wait on them - the truncate_inode_pages() call later will\n\t * do that for us.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, range_start,\n\t\t\t\t       range_end - 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(pages);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 6994
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "inode->i_mapping",
            "range_start",
            "range_end - 1"
          ],
          "line": 6988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_cluster_pages",
          "args": [
            "inode",
            "range_start",
            "range_end",
            "pages",
            "numpages",
            "phys",
            "handle"
          ],
          "line": 6980
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_cluster_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6839-6872",
          "snippet": "static void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,\n\t\t\t\t     loff_t end, struct page **pages,\n\t\t\t\t     int numpages, u64 phys, handle_t *handle)\n{\n\tint i;\n\tstruct page *page;\n\tunsigned int from, to = PAGE_SIZE;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));\n\n\tif (numpages == 0)\n\t\tgoto out;\n\n\tto = PAGE_SIZE;\n\tfor(i = 0; i < numpages; i++) {\n\t\tpage = pages[i];\n\n\t\tfrom = start & (PAGE_SIZE - 1);\n\t\tif ((end >> PAGE_SHIFT) == page->index)\n\t\t\tto = end & (PAGE_SIZE - 1);\n\n\t\tBUG_ON(from > PAGE_SIZE);\n\t\tBUG_ON(to > PAGE_SIZE);\n\n\t\tocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,\n\t\t\t\t\t &phys);\n\n\t\tstart = (page->index + 1) << PAGE_SHIFT;\n\t}\nout:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, numpages);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,\n\t\t\t\t     loff_t end, struct page **pages,\n\t\t\t\t     int numpages, u64 phys, handle_t *handle)\n{\n\tint i;\n\tstruct page *page;\n\tunsigned int from, to = PAGE_SIZE;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));\n\n\tif (numpages == 0)\n\t\tgoto out;\n\n\tto = PAGE_SIZE;\n\tfor(i = 0; i < numpages; i++) {\n\t\tpage = pages[i];\n\n\t\tfrom = start & (PAGE_SIZE - 1);\n\t\tif ((end >> PAGE_SHIFT) == page->index)\n\t\t\tto = end & (PAGE_SIZE - 1);\n\n\t\tBUG_ON(from > PAGE_SIZE);\n\t\tBUG_ON(to > PAGE_SIZE);\n\n\t\tocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,\n\t\t\t\t\t &phys);\n\n\t\tstart = (page->index + 1) << PAGE_SHIFT;\n\t}\nout:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, numpages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grab_eof_pages",
          "args": [
            "inode",
            "range_start",
            "range_end",
            "pages",
            "&numpages"
          ],
          "line": 6973
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grab_eof_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6911-6920",
          "snippet": "static int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "inode",
            "range_start >> sb->s_blocksize_bits",
            "&phys",
            "NULL",
            "&ext_flags"
          ],
          "line": 6958
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/extent_map.c",
          "lines": "674-708",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"aops.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"aops.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "ocfs2_pages_per_cluster(sb)",
            "sizeof(struct page *)",
            "GFP_NOFS"
          ],
          "line": 6947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_pages_per_cluster",
          "args": [
            "sb"
          ],
          "line": 6947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_pages_per_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "859-868",
          "snippet": "static inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int pages_per_cluster = 1;\n\n\tif (PAGE_SHIFT < cbits)\n\t\tpages_per_cluster = 1 << (cbits - PAGE_SHIFT);\n\n\treturn pages_per_cluster;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_pages_per_cluster(struct super_block *sb)\n{\n\tunsigned int cbits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int pages_per_cluster = 1;\n\n\tif (PAGE_SHIFT < cbits)\n\t\tpages_per_cluster = 1 << (cbits - PAGE_SHIFT);\n\n\treturn pages_per_cluster;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "OCFS2_SB(sb)"
          ],
          "line": 6944
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "501-506",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 6944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 range_start, u64 range_end)\n{\n\tint ret = 0, numpages;\n\tstruct page **pages = NULL;\n\tu64 phys;\n\tunsigned int ext_flags;\n\tstruct super_block *sb = inode->i_sb;\n\n\t/*\n\t * File systems which don't support sparse files zero on every\n\t * extend.\n\t */\n\tif (!ocfs2_sparse_alloc(OCFS2_SB(sb)))\n\t\treturn 0;\n\n\tpages = kcalloc(ocfs2_pages_per_cluster(sb),\n\t\t\tsizeof(struct page *), GFP_NOFS);\n\tif (pages == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (range_start == range_end)\n\t\tgoto out;\n\n\tret = ocfs2_extent_map_get_blocks(inode,\n\t\t\t\t\t  range_start >> sb->s_blocksize_bits,\n\t\t\t\t\t  &phys, NULL, &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Tail is a hole, or is marked unwritten. In either case, we\n\t * can count on read and write to return/push zero's.\n\t */\n\tif (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\tgoto out;\n\n\tret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,\n\t\t\t\t   &numpages);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_zero_cluster_pages(inode, range_start, range_end, pages,\n\t\t\t\t numpages, phys, handle);\n\n\t/*\n\t * Initiate writeout of the pages we zero'd here. We don't\n\t * wait on them - the truncate_inode_pages() call later will\n\t * do that for us.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, range_start,\n\t\t\t\t       range_end - 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(pages);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_grab_eof_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6911-6920",
    "snippet": "static int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_grab_pages",
          "args": [
            "inode",
            "start",
            "end",
            "pages",
            "num"
          ],
          "line": 6919
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grab_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6874-6909",
          "snippet": "int ocfs2_grab_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t     struct page **pages, int *num)\n{\n\tint numpages, ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index;\n\tloff_t last_page_bytes;\n\n\tBUG_ON(start > end);\n\n\tnumpages = 0;\n\tlast_page_bytes = PAGE_ALIGN(end);\n\tindex = start >> PAGE_SHIFT;\n\tdo {\n\t\tpages[numpages] = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!pages[numpages]) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnumpages++;\n\t\tindex++;\n\t} while (index < (last_page_bytes >> PAGE_SHIFT));\n\nout:\n\tif (ret != 0) {\n\t\tif (pages)\n\t\t\tocfs2_unlock_and_free_pages(pages, numpages);\n\t\tnumpages = 0;\n\t}\n\n\t*num = numpages;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_grab_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t     struct page **pages, int *num)\n{\n\tint numpages, ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index;\n\tloff_t last_page_bytes;\n\n\tBUG_ON(start > end);\n\n\tnumpages = 0;\n\tlast_page_bytes = PAGE_ALIGN(end);\n\tindex = start >> PAGE_SHIFT;\n\tdo {\n\t\tpages[numpages] = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!pages[numpages]) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnumpages++;\n\t\tindex++;\n\t} while (index < (last_page_bytes >> PAGE_SHIFT));\n\nout:\n\tif (ret != 0) {\n\t\tif (pages)\n\t\t\tocfs2_unlock_and_free_pages(pages, numpages);\n\t\tnumpages = 0;\n\t}\n\n\t*num = numpages;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits"
          ],
          "line": 6916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 6917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 6916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t\t\tstruct page **pages, int *num)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=\n\t       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);\n\n\treturn ocfs2_grab_pages(inode, start, end, pages, num);\n}"
  },
  {
    "function_name": "ocfs2_grab_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6874-6909",
    "snippet": "int ocfs2_grab_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t     struct page **pages, int *num)\n{\n\tint numpages, ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index;\n\tloff_t last_page_bytes;\n\n\tBUG_ON(start > end);\n\n\tnumpages = 0;\n\tlast_page_bytes = PAGE_ALIGN(end);\n\tindex = start >> PAGE_SHIFT;\n\tdo {\n\t\tpages[numpages] = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!pages[numpages]) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnumpages++;\n\t\tindex++;\n\t} while (index < (last_page_bytes >> PAGE_SHIFT));\n\nout:\n\tif (ret != 0) {\n\t\tif (pages)\n\t\t\tocfs2_unlock_and_free_pages(pages, numpages);\n\t\tnumpages = 0;\n\t}\n\n\t*num = numpages;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlock_and_free_pages",
          "args": [
            "pages",
            "numpages"
          ],
          "line": 6902
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "803-814",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 6888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "end"
          ],
          "line": 6885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start > end"
          ],
          "line": 6882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_grab_pages(struct inode *inode, loff_t start, loff_t end,\n\t\t     struct page **pages, int *num)\n{\n\tint numpages, ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index;\n\tloff_t last_page_bytes;\n\n\tBUG_ON(start > end);\n\n\tnumpages = 0;\n\tlast_page_bytes = PAGE_ALIGN(end);\n\tindex = start >> PAGE_SHIFT;\n\tdo {\n\t\tpages[numpages] = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!pages[numpages]) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnumpages++;\n\t\tindex++;\n\t} while (index < (last_page_bytes >> PAGE_SHIFT));\n\nout:\n\tif (ret != 0) {\n\t\tif (pages)\n\t\t\tocfs2_unlock_and_free_pages(pages, numpages);\n\t\tnumpages = 0;\n\t}\n\n\t*num = numpages;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_zero_cluster_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6839-6872",
    "snippet": "static void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,\n\t\t\t\t     loff_t end, struct page **pages,\n\t\t\t\t     int numpages, u64 phys, handle_t *handle)\n{\n\tint i;\n\tstruct page *page;\n\tunsigned int from, to = PAGE_SIZE;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));\n\n\tif (numpages == 0)\n\t\tgoto out;\n\n\tto = PAGE_SIZE;\n\tfor(i = 0; i < numpages; i++) {\n\t\tpage = pages[i];\n\n\t\tfrom = start & (PAGE_SIZE - 1);\n\t\tif ((end >> PAGE_SHIFT) == page->index)\n\t\t\tto = end & (PAGE_SIZE - 1);\n\n\t\tBUG_ON(from > PAGE_SIZE);\n\t\tBUG_ON(to > PAGE_SIZE);\n\n\t\tocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,\n\t\t\t\t\t &phys);\n\n\t\tstart = (page->index + 1) << PAGE_SHIFT;\n\t}\nout:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, numpages);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlock_and_free_pages",
          "args": [
            "pages",
            "numpages"
          ],
          "line": 6871
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "803-814",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_map_and_dirty_page",
          "args": [
            "inode",
            "handle",
            "from",
            "to",
            "page",
            "1",
            "&phys"
          ],
          "line": 6864
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_map_and_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6804-6837",
          "snippet": "void ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "to > PAGE_SIZE"
          ],
          "line": 6862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "from > PAGE_SIZE"
          ],
          "line": 6861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_sparse_alloc(OCFS2_SB(sb))"
          ],
          "line": 6848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "OCFS2_SB(sb)"
          ],
          "line": 6848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "501-506",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 6848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,\n\t\t\t\t     loff_t end, struct page **pages,\n\t\t\t\t     int numpages, u64 phys, handle_t *handle)\n{\n\tint i;\n\tstruct page *page;\n\tunsigned int from, to = PAGE_SIZE;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));\n\n\tif (numpages == 0)\n\t\tgoto out;\n\n\tto = PAGE_SIZE;\n\tfor(i = 0; i < numpages; i++) {\n\t\tpage = pages[i];\n\n\t\tfrom = start & (PAGE_SIZE - 1);\n\t\tif ((end >> PAGE_SHIFT) == page->index)\n\t\t\tto = end & (PAGE_SIZE - 1);\n\n\t\tBUG_ON(from > PAGE_SIZE);\n\t\tBUG_ON(to > PAGE_SIZE);\n\n\t\tocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,\n\t\t\t\t\t &phys);\n\n\t\tstart = (page->index + 1) << PAGE_SHIFT;\n\t}\nout:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, numpages);\n}"
  },
  {
    "function_name": "ocfs2_map_and_dirty_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6804-6837",
    "snippet": "void ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 6836
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 6834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_jbd2_file_inode",
          "args": [
            "handle",
            "inode"
          ],
          "line": 6828
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_jbd2_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.h",
          "lines": "620-623",
          "snippet": "static inline int ocfs2_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\treturn jbd2_journal_inode_add_write(handle, &OCFS2_I(inode)->ip_jinode);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\treturn jbd2_journal_inode_add_write(handle, &OCFS2_I(inode)->ip_jinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_should_order_data",
          "args": [
            "inode"
          ],
          "line": 6827
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "492-499",
          "snippet": "static inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "from",
            "to",
            "&partial",
            "ocfs2_zero_func"
          ],
          "line": 6822
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "438-468",
          "snippet": "int walk_page_buffers(\thandle_t *handle,\n\t\t\tstruct buffer_head *head,\n\t\t\tunsigned from,\n\t\t\tunsigned to,\n\t\t\tint *partial,\n\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t    \tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint walk_page_buffers(\thandle_t *handle,\n\t\t\tstruct buffer_head *head,\n\t\t\tunsigned from,\n\t\t\tunsigned to,\n\t\t\tint *partial,\n\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t    \tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 6822
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "from",
            "to"
          ],
          "line": 6815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_map_page_blocks",
          "args": [
            "page",
            "phys",
            "inode",
            "from",
            "to",
            "0"
          ],
          "line": 6810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_map_page_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "617-707",
          "snippet": "int ocfs2_map_page_blocks(struct page *page, u64 *p_blkno,\n\t\t\t  struct inode *inode, unsigned int from,\n\t\t\t  unsigned int to, int new)\n{\n\tint ret = 0;\n\tstruct buffer_head *head, *bh, *wait[2], **wait_bh = wait;\n\tunsigned int block_end, block_start;\n\tunsigned int bsize = i_blocksize(inode);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, bsize, 0);\n\n\thead = page_buffers(page);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start += bsize) {\n\t\tblock_end = block_start + bsize;\n\n\t\tclear_buffer_new(bh);\n\n\t\t/*\n\t\t * Ignore blocks outside of our i/o range -\n\t\t * they may belong to unallocated clusters.\n\t\t */\n\t\tif (block_start >= to || block_end <= from) {\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For an allocating write with cluster size >= page\n\t\t * size, we always write the entire page.\n\t\t */\n\t\tif (new)\n\t\t\tset_buffer_new(bh);\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tmap_bh(bh, inode->i_sb, *p_blkno);\n\t\t\tclean_bdev_bh_alias(bh);\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t} else if (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t\t   !buffer_new(bh) &&\n\t\t\t   ocfs2_should_read_blk(inode, page, block_start) &&\n\t\t\t   (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\n\t\t*p_blkno = *p_blkno + 1;\n\t}\n\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\tret = -EIO;\n\t}\n\n\tif (ret == 0 || !new)\n\t\treturn ret;\n\n\t/*\n\t * If we get -EIO above, zero out any newly allocated blocks\n\t * to avoid exposing stale data.\n\t */\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bsize;\n\t\tif (block_end <= from)\n\t\t\tgoto next_bh;\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tzero_user(page, block_start, bh->b_size);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\nnext_bh:\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_map_page_blocks(struct page *page, u64 *p_blkno,\n\t\t\t  struct inode *inode, unsigned int from,\n\t\t\t  unsigned int to, int new)\n{\n\tint ret = 0;\n\tstruct buffer_head *head, *bh, *wait[2], **wait_bh = wait;\n\tunsigned int block_end, block_start;\n\tunsigned int bsize = i_blocksize(inode);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, bsize, 0);\n\n\thead = page_buffers(page);\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start += bsize) {\n\t\tblock_end = block_start + bsize;\n\n\t\tclear_buffer_new(bh);\n\n\t\t/*\n\t\t * Ignore blocks outside of our i/o range -\n\t\t * they may belong to unallocated clusters.\n\t\t */\n\t\tif (block_start >= to || block_end <= from) {\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For an allocating write with cluster size >= page\n\t\t * size, we always write the entire page.\n\t\t */\n\t\tif (new)\n\t\t\tset_buffer_new(bh);\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tmap_bh(bh, inode->i_sb, *p_blkno);\n\t\t\tclean_bdev_bh_alias(bh);\n\t\t}\n\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t} else if (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t\t   !buffer_new(bh) &&\n\t\t\t   ocfs2_should_read_blk(inode, page, block_start) &&\n\t\t\t   (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\n\t\t*p_blkno = *p_blkno + 1;\n\t}\n\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\tret = -EIO;\n\t}\n\n\tif (ret == 0 || !new)\n\t\treturn ret;\n\n\t/*\n\t * If we get -EIO above, zero out any newly allocated blocks\n\t * to avoid exposing stale data.\n\t */\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bsize;\n\t\tif (block_end <= from)\n\t\t\tgoto next_bh;\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tzero_user(page, block_start, bh->b_size);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\nnext_bh:\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}"
  },
  {
    "function_name": "ocfs2_zero_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6797-6802",
    "snippet": "static int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 6800
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 6799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_cache_extent_block_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6787-6795",
    "snippet": "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb)\n{\n\treturn ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_slot),\n\t\t\t\t\t le64_to_cpu(eb->h_suballoc_loc),\n\t\t\t\t\t le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_bit));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cache_block_dealloc",
          "args": [
            "ctxt",
            "EXTENT_ALLOC_SYSTEM_INODE",
            "le16_to_cpu(eb->h_suballoc_slot)",
            "le64_to_cpu(eb->h_suballoc_loc)",
            "le64_to_cpu(eb->h_blkno)",
            "le16_to_cpu(eb->h_suballoc_bit)"
          ],
          "line": 6790
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cache_block_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6749-6785",
          "snippet": "int ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "eb->h_suballoc_bit"
          ],
          "line": 6794
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 6793
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb)\n{\n\treturn ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_slot),\n\t\t\t\t\t le64_to_cpu(eb->h_suballoc_loc),\n\t\t\t\t\t le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_bit));\n}"
  },
  {
    "function_name": "ocfs2_cache_block_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6749-6785",
    "snippet": "int ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_cache_block_dealloc",
          "args": [
            "type",
            "slot",
            "(unsigned long long)suballoc",
            "(unsigned long long)blkno",
            "bit"
          ],
          "line": 6771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*item)",
            "GFP_NOFS"
          ],
          "line": 6764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_per_slot_free_list",
          "args": [
            "type",
            "slot",
            "ctxt"
          ],
          "line": 6757
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_per_slot_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6575-6599",
          "snippet": "static struct ocfs2_per_slot_free_list *\nocfs2_find_per_slot_free_list(int type,\n\t\t\t      int slot,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == slot)\n\t\t\treturn fl;\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\tfl = kmalloc(sizeof(*fl), GFP_NOFS);\n\tif (fl) {\n\t\tfl->f_inode_type = type;\n\t\tfl->f_slot = slot;\n\t\tfl->f_first = NULL;\n\t\tfl->f_next_suballocator = ctxt->c_first_suballocator;\n\n\t\tctxt->c_first_suballocator = fl;\n\t}\n\treturn fl;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_per_slot_free_list *\nocfs2_find_per_slot_free_list(int type,\n\t\t\t      int slot,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == slot)\n\t\t\treturn fl;\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\tfl = kmalloc(sizeof(*fl), GFP_NOFS);\n\tif (fl) {\n\t\tfl->f_inode_type = type;\n\t\tfl->f_slot = slot;\n\t\tfl->f_first = NULL;\n\t\tfl->f_next_suballocator = ctxt->c_first_suballocator;\n\n\t\tctxt->c_first_suballocator = fl;\n\t}\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reuse_blk_from_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6651-6747",
    "snippet": "static int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given)\n{\n\tint i, status = 0, real_slot;\n\tstruct ocfs2_cached_dealloc_ctxt *dealloc;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *bf;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\t*blk_given = 0;\n\n\t/* If extent tree doesn't have a dealloc, this is not faulty. Just\n\t * tell upper caller dealloc can't provide any block and it should\n\t * ask for alloc to claim more space.\n\t */\n\tdealloc = et->et_dealloc;\n\tif (!dealloc)\n\t\tgoto bail;\n\n\tfor (i = 0; i < blk_wanted; i++) {\n\t\t/* Prefer to use local slot */\n\t\tfl = ocfs2_find_preferred_free_list(EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t\t    osb->slot_num, &real_slot,\n\t\t\t\t\t\t    dealloc);\n\t\t/* If no more block can be reused, we should claim more\n\t\t * from alloc. Just return here normally.\n\t\t */\n\t\tif (!fl) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tbf = fl->f_first;\n\t\tfl->f_first = bf->free_next;\n\n\t\tnew_eb_bh[i] = sb_getblk(osb->sb, bf->free_blk);\n\t\tif (new_eb_bh[i] == NULL) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmlog(0, \"Reusing block(%llu) from \"\n\t\t     \"dealloc(local slot:%d, real slot:%d)\\n\",\n\t\t     bf->free_blk, osb->slot_num, real_slot);\n\n\t\tocfs2_set_new_buffer_uptodate(et->et_ci, new_eb_bh[i]);\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t new_eb_bh[i],\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(new_eb_bh[i]->b_data, 0, osb->sb->s_blocksize);\n\t\teb = (struct ocfs2_extent_block *) new_eb_bh[i]->b_data;\n\n\t\t/* We can't guarantee that buffer head is still cached, so\n\t\t * polutlate the extent block again.\n\t\t */\n\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\teb->h_blkno = cpu_to_le64(bf->free_blk);\n\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\teb->h_suballoc_slot = cpu_to_le16(real_slot);\n\t\teb->h_suballoc_loc = cpu_to_le64(bf->free_bg);\n\t\teb->h_suballoc_bit = cpu_to_le16(bf->free_bit);\n\t\teb->h_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t/* We'll also be dirtied by the caller, so\n\t\t * this isn't absolutely necessary.\n\t\t */\n\t\tocfs2_journal_dirty(handle, new_eb_bh[i]);\n\n\t\tif (!fl->f_first) {\n\t\t\tdealloc->c_first_suballocator = fl->f_next_suballocator;\n\t\t\tkfree(fl);\n\t\t}\n\t\tkfree(bf);\n\t}\n\n\t*blk_given = i;\n\nbail:\n\tif (unlikely(status < 0)) {\n\t\tfor (i = 0; i < blk_wanted; i++)\n\t\t\tbrelse(new_eb_bh[i]);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_eb_bh[i]"
          ],
          "line": 6743
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status < 0"
          ],
          "line": 6741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bf"
          ],
          "line": 6735
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "new_eb_bh[i]"
          ],
          "line": 6729
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_eb(osb->sb)"
          ],
          "line": 6724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_eb",
          "args": [
            "osb->sb"
          ],
          "line": 6724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1516-1524",
          "snippet": "static inline int ocfs2_extent_recs_per_eb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_extent_block, h_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n\nstatic inline int ocfs2_extent_recs_per_eb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_extent_block, h_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bf->free_bit"
          ],
          "line": 6722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bf->free_bg"
          ],
          "line": 6721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "real_slot"
          ],
          "line": 6720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "osb->fs_generation"
          ],
          "line": 6719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bf->free_blk"
          ],
          "line": 6718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "eb->h_signature",
            "OCFS2_EXTENT_BLOCK_SIGNATURE"
          ],
          "line": 6717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_eb_bh[i]->b_data",
            "0",
            "osb->sb->s_blocksize"
          ],
          "line": 6711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "et->et_ci",
            "new_eb_bh[i]",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 6703
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "731-735",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "et->et_ci",
            "new_eb_bh[i]"
          ],
          "line": 6701
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Reusing block(%llu) from \"\n\t\t     \"dealloc(local slot:%d, real slot:%d)\\n\"",
            "bf->free_blk",
            "osb->slot_num",
            "real_slot"
          ],
          "line": 6697
        },
        "resolved": true,
        "details": {
          "function_name": "__mlog_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "67-98",
          "snippet": "void __mlog_printk(const u64 *mask, const char *func, int line,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *level;\n\tconst char *prefix = \"\";\n\n\tif (!__mlog_test_u64(*mask, mlog_and_bits) ||\n\t    __mlog_test_u64(*mask, mlog_not_bits))\n\t\treturn;\n\n\tif (*mask & ML_ERROR) {\n\t\tlevel = KERN_ERR;\n\t\tprefix = \"ERROR: \";\n\t} else if (*mask & ML_NOTICE) {\n\t\tlevel = KERN_NOTICE;\n\t} else {\n\t\tlevel = KERN_INFO;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%s(%s,%u,%u):%s:%d %s%pV\",\n\t       level, current->comm, task_pid_nr(current),\n\t       raw_smp_processor_id(), func, line, prefix, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nvoid __mlog_printk(const u64 *mask, const char *func, int line,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *level;\n\tconst char *prefix = \"\";\n\n\tif (!__mlog_test_u64(*mask, mlog_and_bits) ||\n\t    __mlog_test_u64(*mask, mlog_not_bits))\n\t\treturn;\n\n\tif (*mask & ML_ERROR) {\n\t\tlevel = KERN_ERR;\n\t\tprefix = \"ERROR: \";\n\t} else if (*mask & ML_NOTICE) {\n\t\tlevel = KERN_NOTICE;\n\t} else {\n\t\tlevel = KERN_INFO;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%s(%s,%u,%u):%s:%d %s%pV\",\n\t       level, current->comm, task_pid_nr(current),\n\t       raw_smp_processor_id(), func, line, prefix, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "osb->sb",
            "bf->free_blk"
          ],
          "line": 6690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_preferred_free_list",
          "args": [
            "EXTENT_ALLOC_SYSTEM_INODE",
            "osb->slot_num",
            "&real_slot",
            "dealloc"
          ],
          "line": 6676
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_preferred_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6601-6625",
          "snippet": "static struct ocfs2_per_slot_free_list *\nocfs2_find_preferred_free_list(int type,\n\t\t\t       int preferred_slot,\n\t\t\t       int *real_slot,\n\t\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == preferred_slot) {\n\t\t\t*real_slot = fl->f_slot;\n\t\t\treturn fl;\n\t\t}\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\t/* If we can't find any free list matching preferred slot, just use\n\t * the first one.\n\t */\n\tfl = ctxt->c_first_suballocator;\n\t*real_slot = fl->f_slot;\n\n\treturn fl;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_per_slot_free_list *\nocfs2_find_preferred_free_list(int type,\n\t\t\t       int preferred_slot,\n\t\t\t       int *real_slot,\n\t\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == preferred_slot) {\n\t\t\t*real_slot = fl->f_slot;\n\t\t\treturn fl;\n\t\t}\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\t/* If we can't find any free list matching preferred slot, just use\n\t * the first one.\n\t */\n\tfl = ctxt->c_first_suballocator;\n\t*real_slot = fl->f_slot;\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)"
          ],
          "line": 6662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 6662
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given)\n{\n\tint i, status = 0, real_slot;\n\tstruct ocfs2_cached_dealloc_ctxt *dealloc;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *bf;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\t*blk_given = 0;\n\n\t/* If extent tree doesn't have a dealloc, this is not faulty. Just\n\t * tell upper caller dealloc can't provide any block and it should\n\t * ask for alloc to claim more space.\n\t */\n\tdealloc = et->et_dealloc;\n\tif (!dealloc)\n\t\tgoto bail;\n\n\tfor (i = 0; i < blk_wanted; i++) {\n\t\t/* Prefer to use local slot */\n\t\tfl = ocfs2_find_preferred_free_list(EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t\t    osb->slot_num, &real_slot,\n\t\t\t\t\t\t    dealloc);\n\t\t/* If no more block can be reused, we should claim more\n\t\t * from alloc. Just return here normally.\n\t\t */\n\t\tif (!fl) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tbf = fl->f_first;\n\t\tfl->f_first = bf->free_next;\n\n\t\tnew_eb_bh[i] = sb_getblk(osb->sb, bf->free_blk);\n\t\tif (new_eb_bh[i] == NULL) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmlog(0, \"Reusing block(%llu) from \"\n\t\t     \"dealloc(local slot:%d, real slot:%d)\\n\",\n\t\t     bf->free_blk, osb->slot_num, real_slot);\n\n\t\tocfs2_set_new_buffer_uptodate(et->et_ci, new_eb_bh[i]);\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t new_eb_bh[i],\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(new_eb_bh[i]->b_data, 0, osb->sb->s_blocksize);\n\t\teb = (struct ocfs2_extent_block *) new_eb_bh[i]->b_data;\n\n\t\t/* We can't guarantee that buffer head is still cached, so\n\t\t * polutlate the extent block again.\n\t\t */\n\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\teb->h_blkno = cpu_to_le64(bf->free_blk);\n\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\teb->h_suballoc_slot = cpu_to_le16(real_slot);\n\t\teb->h_suballoc_loc = cpu_to_le64(bf->free_bg);\n\t\teb->h_suballoc_bit = cpu_to_le16(bf->free_bit);\n\t\teb->h_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t/* We'll also be dirtied by the caller, so\n\t\t * this isn't absolutely necessary.\n\t\t */\n\t\tocfs2_journal_dirty(handle, new_eb_bh[i]);\n\n\t\tif (!fl->f_first) {\n\t\t\tdealloc->c_first_suballocator = fl->f_next_suballocator;\n\t\t\tkfree(fl);\n\t\t}\n\t\tkfree(bf);\n\t}\n\n\t*blk_given = i;\n\nbail:\n\tif (unlikely(status < 0)) {\n\t\tfor (i = 0; i < blk_wanted; i++)\n\t\t\tbrelse(new_eb_bh[i]);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_is_dealloc_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6628-6643",
    "snippet": "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_per_slot_free_list *fl = NULL;\n\n\tif (!et->et_dealloc)\n\t\treturn 1;\n\n\tfl = et->et_dealloc->c_first_suballocator;\n\tif (!fl)\n\t\treturn 1;\n\n\tif (!fl->f_first)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_per_slot_free_list *fl = NULL;\n\n\tif (!et->et_dealloc)\n\t\treturn 1;\n\n\tfl = et->et_dealloc->c_first_suballocator;\n\tif (!fl)\n\t\treturn 1;\n\n\tif (!fl->f_first)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_find_preferred_free_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6601-6625",
    "snippet": "static struct ocfs2_per_slot_free_list *\nocfs2_find_preferred_free_list(int type,\n\t\t\t       int preferred_slot,\n\t\t\t       int *real_slot,\n\t\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == preferred_slot) {\n\t\t\t*real_slot = fl->f_slot;\n\t\t\treturn fl;\n\t\t}\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\t/* If we can't find any free list matching preferred slot, just use\n\t * the first one.\n\t */\n\tfl = ctxt->c_first_suballocator;\n\t*real_slot = fl->f_slot;\n\n\treturn fl;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_per_slot_free_list *\nocfs2_find_preferred_free_list(int type,\n\t\t\t       int preferred_slot,\n\t\t\t       int *real_slot,\n\t\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == preferred_slot) {\n\t\t\t*real_slot = fl->f_slot;\n\t\t\treturn fl;\n\t\t}\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\t/* If we can't find any free list matching preferred slot, just use\n\t * the first one.\n\t */\n\tfl = ctxt->c_first_suballocator;\n\t*real_slot = fl->f_slot;\n\n\treturn fl;\n}"
  },
  {
    "function_name": "ocfs2_find_per_slot_free_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6575-6599",
    "snippet": "static struct ocfs2_per_slot_free_list *\nocfs2_find_per_slot_free_list(int type,\n\t\t\t      int slot,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == slot)\n\t\t\treturn fl;\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\tfl = kmalloc(sizeof(*fl), GFP_NOFS);\n\tif (fl) {\n\t\tfl->f_inode_type = type;\n\t\tfl->f_slot = slot;\n\t\tfl->f_first = NULL;\n\t\tfl->f_next_suballocator = ctxt->c_first_suballocator;\n\n\t\tctxt->c_first_suballocator = fl;\n\t}\n\treturn fl;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fl)",
            "GFP_NOFS"
          ],
          "line": 6589
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_per_slot_free_list *\nocfs2_find_per_slot_free_list(int type,\n\t\t\t      int slot,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tstruct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;\n\n\twhile (fl) {\n\t\tif (fl->f_inode_type == type && fl->f_slot == slot)\n\t\t\treturn fl;\n\n\t\tfl = fl->f_next_suballocator;\n\t}\n\n\tfl = kmalloc(sizeof(*fl), GFP_NOFS);\n\tif (fl) {\n\t\tfl->f_inode_type = type;\n\t\tfl->f_slot = slot;\n\t\tfl->f_first = NULL;\n\t\tfl->f_next_suballocator = ctxt->c_first_suballocator;\n\n\t\tctxt->c_first_suballocator = fl;\n\t}\n\treturn fl;\n}"
  },
  {
    "function_name": "ocfs2_run_deallocs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6532-6573",
    "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret2"
          ],
          "line": 6565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_cached_clusters",
          "args": [
            "osb",
            "ctxt->c_global_allocator"
          ],
          "line": 6562
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_cached_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6480-6530",
          "snippet": "static int ocfs2_free_cached_clusters(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_cached_block_free *head)\n{\n\tstruct ocfs2_cached_block_free *tmp;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tint ret = 0;\n\n\tinode_lock(tl_inode);\n\n\twhile (head) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_truncate_log_append(osb, handle, head->free_blk,\n\t\t\t\t\t\thead->free_bit);\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinode_unlock(tl_inode);\n\n\twhile (head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_cached_clusters(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_cached_block_free *head)\n{\n\tstruct ocfs2_cached_block_free *tmp;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tint ret = 0;\n\n\tinode_lock(tl_inode);\n\n\twhile (head) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_truncate_log_append(osb, handle, head->free_blk,\n\t\t\t\t\t\thead->free_bit);\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinode_unlock(tl_inode);\n\n\twhile (head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fl"
          ],
          "line": 6558
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret2"
          ],
          "line": 6552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_cached_blocks",
          "args": [
            "osb",
            "fl->f_inode_type",
            "fl->f_slot",
            "fl->f_first"
          ],
          "line": 6547
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_cached_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6385-6455",
          "snippet": "static int ocfs2_free_cached_blocks(struct ocfs2_super *osb,\n\t\t\t\t    int sysfile_type,\n\t\t\t\t    int slot,\n\t\t\t\t    struct ocfs2_cached_block_free *head)\n{\n\tint ret;\n\tu64 bg_blkno;\n\thandle_t *handle;\n\tstruct inode *inode;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_cached_block_free *tmp;\n\n\tinode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(inode);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\twhile (head) {\n\t\tif (head->free_bg)\n\t\t\tbg_blkno = head->free_bg;\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(head->free_blk,\n\t\t\t\t\t\t\t      head->free_bit);\n\t\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttrace_ocfs2_free_cached_blocks(\n\t\t     (unsigned long long)head->free_blk, head->free_bit);\n\n\t\tret = ocfs2_free_suballoc_bits(handle, inode, di_bh,\n\t\t\t\t\t       head->free_bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_commit_trans(osb, handle);\n\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\nout_unlock:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout_mutex:\n\tinode_unlock(inode);\n\tiput(inode);\nout:\n\twhile(head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_cached_blocks(struct ocfs2_super *osb,\n\t\t\t\t    int sysfile_type,\n\t\t\t\t    int slot,\n\t\t\t\t    struct ocfs2_cached_block_free *head)\n{\n\tint ret;\n\tu64 bg_blkno;\n\thandle_t *handle;\n\tstruct inode *inode;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_cached_block_free *tmp;\n\n\tinode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(inode);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\twhile (head) {\n\t\tif (head->free_bg)\n\t\t\tbg_blkno = head->free_bg;\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(head->free_blk,\n\t\t\t\t\t\t\t      head->free_bit);\n\t\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttrace_ocfs2_free_cached_blocks(\n\t\t     (unsigned long long)head->free_blk, head->free_bit);\n\n\t\tret = ocfs2_free_suballoc_bits(handle, inode, di_bh,\n\t\t\t\t\t       head->free_bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_commit_trans(osb, handle);\n\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\nout_unlock:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout_mutex:\n\tinode_unlock(inode);\n\tiput(inode);\nout:\n\twhile(head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_run_deallocs",
          "args": [
            "fl->f_inode_type",
            "fl->f_slot"
          ],
          "line": 6545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_free_cached_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6480-6530",
    "snippet": "static int ocfs2_free_cached_clusters(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_cached_block_free *head)\n{\n\tstruct ocfs2_cached_block_free *tmp;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tint ret = 0;\n\n\tinode_lock(tl_inode);\n\n\twhile (head) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_truncate_log_append(osb, handle, head->free_blk,\n\t\t\t\t\t\thead->free_bit);\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinode_unlock(tl_inode);\n\n\twhile (head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 6526
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "tl_inode"
          ],
          "line": 6520
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6509
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_append",
          "args": [
            "osb",
            "handle",
            "head->free_blk",
            "head->free_bit"
          ],
          "line": 6506
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5853-5927",
          "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_TRUNCATE_LOG_UPDATE"
          ],
          "line": 6499
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6492
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6000-6061",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_needs_flush",
          "args": [
            "osb"
          ],
          "line": 6491
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_needs_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5820-5834",
          "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "tl_inode"
          ],
          "line": 6488
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_cached_clusters(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_cached_block_free *head)\n{\n\tstruct ocfs2_cached_block_free *tmp;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tint ret = 0;\n\n\tinode_lock(tl_inode);\n\n\twhile (head) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_truncate_log_append(osb, handle, head->free_blk,\n\t\t\t\t\t\thead->free_bit);\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinode_unlock(tl_inode);\n\n\twhile (head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_cache_cluster_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6457-6478",
    "snippet": "int ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\tu64 blkno, unsigned int bit)\n{\n\tint ret = 0;\n\tstruct ocfs2_cached_block_free *item;\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\ttrace_ocfs2_cache_cluster_dealloc((unsigned long long)blkno, bit);\n\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = ctxt->c_global_allocator;\n\n\tctxt->c_global_allocator = item;\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_cache_cluster_dealloc",
          "args": [
            "(unsigned long long)blkno",
            "bit"
          ],
          "line": 6470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*item)",
            "GFP_NOFS"
          ],
          "line": 6463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\tu64 blkno, unsigned int bit)\n{\n\tint ret = 0;\n\tstruct ocfs2_cached_block_free *item;\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\ttrace_ocfs2_cache_cluster_dealloc((unsigned long long)blkno, bit);\n\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = ctxt->c_global_allocator;\n\n\tctxt->c_global_allocator = item;\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_free_cached_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6385-6455",
    "snippet": "static int ocfs2_free_cached_blocks(struct ocfs2_super *osb,\n\t\t\t\t    int sysfile_type,\n\t\t\t\t    int slot,\n\t\t\t\t    struct ocfs2_cached_block_free *head)\n{\n\tint ret;\n\tu64 bg_blkno;\n\thandle_t *handle;\n\tstruct inode *inode;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_cached_block_free *tmp;\n\n\tinode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(inode);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\twhile (head) {\n\t\tif (head->free_bg)\n\t\t\tbg_blkno = head->free_bg;\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(head->free_blk,\n\t\t\t\t\t\t\t      head->free_bit);\n\t\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttrace_ocfs2_free_cached_blocks(\n\t\t     (unsigned long long)head->free_blk, head->free_bit);\n\n\t\tret = ocfs2_free_suballoc_bits(handle, inode, di_bh,\n\t\t\t\t\t       head->free_bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_commit_trans(osb, handle);\n\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\nout_unlock:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout_mutex:\n\tinode_unlock(inode);\n\tiput(inode);\nout:\n\twhile(head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 6451
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 6445
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 6444
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 6442
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 6441
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "2589-2603",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_suballoc_bits",
          "args": [
            "handle",
            "inode",
            "di_bh",
            "head->free_bit",
            "bg_blkno",
            "1"
          ],
          "line": 6428
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "2529-2538",
          "snippet": "int ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_free_cached_blocks",
          "args": [
            "(unsigned long long)head->free_blk",
            "head->free_bit"
          ],
          "line": 6425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_SUBALLOC_FREE"
          ],
          "line": 6418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_suballoc_group",
          "args": [
            "head->free_blk",
            "head->free_bit"
          ],
          "line": 6416
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_suballoc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.h",
          "lines": "156-161",
          "snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 6406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 6404
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "sysfile_type",
            "slot"
          ],
          "line": 6397
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/sysfile.c",
          "lines": "139-182",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_free_cached_blocks(struct ocfs2_super *osb,\n\t\t\t\t    int sysfile_type,\n\t\t\t\t    int slot,\n\t\t\t\t    struct ocfs2_cached_block_free *head)\n{\n\tint ret;\n\tu64 bg_blkno;\n\thandle_t *handle;\n\tstruct inode *inode;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_cached_block_free *tmp;\n\n\tinode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(inode);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\twhile (head) {\n\t\tif (head->free_bg)\n\t\t\tbg_blkno = head->free_bg;\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(head->free_blk,\n\t\t\t\t\t\t\t      head->free_bit);\n\t\thandle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttrace_ocfs2_free_cached_blocks(\n\t\t     (unsigned long long)head->free_blk, head->free_bit);\n\n\t\tret = ocfs2_free_suballoc_bits(handle, inode, di_bh,\n\t\t\t\t\t       head->free_bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_commit_trans(osb, handle);\n\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\nout_unlock:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout_mutex:\n\tinode_unlock(inode);\n\tiput(inode);\nout:\n\twhile(head) {\n\t\t/* Premature exit may have left some dangling items. */\n\t\ttmp = head;\n\t\thead = head->free_next;\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6322-6345",
    "snippet": "int ocfs2_truncate_log_init(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\n\tstatus = ocfs2_get_truncate_log_info(osb,\n\t\t\t\t\t     osb->slot_num,\n\t\t\t\t\t     &tl_inode,\n\t\t\t\t\t     &tl_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* ocfs2_truncate_log_shutdown keys on the existence of\n\t * osb->osb_tl_inode so we don't set any of the osb variables\n\t * until we're sure all is well. */\n\tINIT_DELAYED_WORK(&osb->osb_truncate_log_wq,\n\t\t\t  ocfs2_truncate_log_worker);\n\tatomic_set(&osb->osb_tl_disable, 0);\n\tosb->osb_tl_bh    = tl_bh;\n\tosb->osb_tl_inode = tl_inode;\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->osb_tl_disable",
            "0"
          ],
          "line": 6340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&osb->osb_truncate_log_wq",
            "ocfs2_truncate_log_worker"
          ],
          "line": 6338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_truncate_log_info",
          "args": [
            "osb",
            "osb->slot_num",
            "&tl_inode",
            "&tl_bh"
          ],
          "line": 6328
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_truncate_log_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6142-6171",
          "snippet": "static int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_init(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\n\tstatus = ocfs2_get_truncate_log_info(osb,\n\t\t\t\t\t     osb->slot_num,\n\t\t\t\t\t     &tl_inode,\n\t\t\t\t\t     &tl_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* ocfs2_truncate_log_shutdown keys on the existence of\n\t * osb->osb_tl_inode so we don't set any of the osb variables\n\t * until we're sure all is well. */\n\tINIT_DELAYED_WORK(&osb->osb_truncate_log_wq,\n\t\t\t  ocfs2_truncate_log_worker);\n\tatomic_set(&osb->osb_tl_disable, 0);\n\tosb->osb_tl_bh    = tl_bh;\n\tosb->osb_tl_inode = tl_inode;\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6302-6320",
    "snippet": "void ocfs2_truncate_log_shutdown(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tatomic_set(&osb->osb_tl_disable, 1);\n\n\tif (tl_inode) {\n\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\t\tflush_workqueue(osb->ocfs2_wq);\n\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\tbrelse(osb->osb_tl_bh);\n\t\tiput(osb->osb_tl_inode);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "osb->osb_tl_inode"
          ],
          "line": 6318
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "osb->osb_tl_bh"
          ],
          "line": 6317
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6063-6073",
          "snippet": "int ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tinode_lock(tl_inode);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tinode_lock(tl_inode);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "osb->ocfs2_wq"
          ],
          "line": 6311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&osb->osb_truncate_log_wq"
          ],
          "line": 6310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->osb_tl_disable",
            "1"
          ],
          "line": 6307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_truncate_log_shutdown(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tatomic_set(&osb->osb_tl_disable, 1);\n\n\tif (tl_inode) {\n\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\t\tflush_workqueue(osb->ocfs2_wq);\n\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\tbrelse(osb->osb_tl_bh);\n\t\tiput(osb->osb_tl_inode);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_complete_truncate_log_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6244-6300",
    "snippet": "int ocfs2_complete_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t\t struct ocfs2_dinode *tl_copy)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int clusters, num_recs, start_cluster;\n\tu64 start_blk;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_truncate_log *tl;\n\n\tif (OCFS2_I(tl_inode)->ip_blkno == le64_to_cpu(tl_copy->i_blkno)) {\n\t\tmlog(ML_ERROR, \"Asked to recover my own truncate log!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttl = &tl_copy->id2.i_dealloc;\n\tnum_recs = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_complete_truncate_log_recovery(\n\t\t(unsigned long long)le64_to_cpu(tl_copy->i_blkno),\n\t\tnum_recs);\n\n\tinode_lock(tl_inode);\n\tfor(i = 0; i < num_recs; i++) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tstatus = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail_up;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\n\t\tclusters = le32_to_cpu(tl->tl_recs[i].t_clusters);\n\t\tstart_cluster = le32_to_cpu(tl->tl_recs[i].t_start);\n\t\tstart_blk = ocfs2_clusters_to_blocks(osb->sb, start_cluster);\n\n\t\tstatus = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t   start_blk, clusters);\n\t\tocfs2_commit_trans(osb, handle);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\t}\n\nbail_up:\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "tl_inode"
          ],
          "line": 6297
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 6289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_append",
          "args": [
            "osb",
            "handle",
            "start_blk",
            "clusters"
          ],
          "line": 6287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5853-5927",
          "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "start_cluster"
          ],
          "line": 6285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tl->tl_recs[i].t_start"
          ],
          "line": 6284
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 6278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 6277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_TRUNCATE_LOG_UPDATE"
          ],
          "line": 6276
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6269
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6000-6061",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_needs_flush",
          "args": [
            "osb"
          ],
          "line": 6268
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_needs_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5820-5834",
          "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "tl_inode"
          ],
          "line": 6266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_complete_truncate_log_recovery",
          "args": [
            "(unsigned long long)le64_to_cpu(tl_copy->i_blkno)",
            "num_recs"
          ],
          "line": 6262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tl_copy->i_blkno"
          ],
          "line": 6263
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 6261
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Asked to recover my own truncate log!\\n\""
          ],
          "line": 6256
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "tl_inode"
          ],
          "line": 6255
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\n\nint ocfs2_complete_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t\t struct ocfs2_dinode *tl_copy)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int clusters, num_recs, start_cluster;\n\tu64 start_blk;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_truncate_log *tl;\n\n\tif (OCFS2_I(tl_inode)->ip_blkno == le64_to_cpu(tl_copy->i_blkno)) {\n\t\tmlog(ML_ERROR, \"Asked to recover my own truncate log!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttl = &tl_copy->id2.i_dealloc;\n\tnum_recs = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_complete_truncate_log_recovery(\n\t\t(unsigned long long)le64_to_cpu(tl_copy->i_blkno),\n\t\tnum_recs);\n\n\tinode_lock(tl_inode);\n\tfor(i = 0; i < num_recs; i++) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tstatus = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail_up;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\n\t\tclusters = le32_to_cpu(tl->tl_recs[i].t_clusters);\n\t\tstart_cluster = le32_to_cpu(tl->tl_recs[i].t_start);\n\t\tstart_blk = ocfs2_clusters_to_blocks(osb->sb, start_cluster);\n\n\t\tstatus = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t   start_blk, clusters);\n\t\tocfs2_commit_trans(osb, handle);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\t}\n\nbail_up:\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_begin_truncate_log_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6177-6242",
    "snippet": "int ocfs2_begin_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t      int slot_num,\n\t\t\t\t      struct ocfs2_dinode **tl_copy)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\t*tl_copy = NULL;\n\n\ttrace_ocfs2_begin_truncate_log_recovery(slot_num);\n\n\tstatus = ocfs2_get_truncate_log_info(osb, slot_num, &tl_inode, &tl_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_get_truncate_log_info().  It's\n\t * validated by the underlying call to ocfs2_read_inode_block(),\n\t * so any corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tif (le16_to_cpu(tl->tl_used)) {\n\t\ttrace_ocfs2_truncate_log_recovery_num(le16_to_cpu(tl->tl_used));\n\n\t\t*tl_copy = kmalloc(tl_bh->b_size, GFP_KERNEL);\n\t\tif (!(*tl_copy)) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Assuming the write-out below goes well, this copy\n\t\t * will be passed back to recovery for processing. */\n\t\tmemcpy(*tl_copy, tl_bh->b_data, tl_bh->b_size);\n\n\t\t/* All we need to do to clear the truncate log is set\n\t\t * tl_used. */\n\t\ttl->tl_used = 0;\n\n\t\tocfs2_compute_meta_ecc(osb->sb, tl_bh->b_data, &di->i_check);\n\t\tstatus = ocfs2_write_block(osb, tl_bh, INODE_CACHE(tl_inode));\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tiput(tl_inode);\n\tbrelse(tl_bh);\n\n\tif (status < 0) {\n\t\tkfree(*tl_copy);\n\t\t*tl_copy = NULL;\n\t\tmlog_errno(status);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*tl_copy"
          ],
          "line": 6236
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tl_bh"
          ],
          "line": 6233
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tl_inode"
          ],
          "line": 6232
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_block",
          "args": [
            "osb",
            "tl_bh",
            "INODE_CACHE(tl_inode)"
          ],
          "line": 6224
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "54-100",
          "snippet": "int ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(REQ_OP_WRITE, 0, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bio.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bio.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(REQ_OP_WRITE, 0, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "tl_inode"
          ],
          "line": 6224
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "129-132",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_compute_meta_ecc",
          "args": [
            "osb->sb",
            "tl_bh->b_data",
            "&di->i_check"
          ],
          "line": 6223
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_compute_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/blockcheck.c",
          "lines": "606-611",
          "snippet": "void ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*tl_copy",
            "tl_bh->b_data",
            "tl_bh->b_size"
          ],
          "line": 6217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "tl_bh->b_size",
            "GFP_KERNEL"
          ],
          "line": 6208
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_truncate_log_recovery_num",
          "args": [
            "le16_to_cpu(tl->tl_used)"
          ],
          "line": 6206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 6206
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(di)"
          ],
          "line": 6202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "di"
          ],
          "line": 6202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_truncate_log_info",
          "args": [
            "osb",
            "slot_num",
            "&tl_inode",
            "&tl_bh"
          ],
          "line": 6191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_truncate_log_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6142-6171",
          "snippet": "static int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_begin_truncate_log_recovery",
          "args": [
            "slot_num"
          ],
          "line": 6189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_begin_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t      int slot_num,\n\t\t\t\t      struct ocfs2_dinode **tl_copy)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\t*tl_copy = NULL;\n\n\ttrace_ocfs2_begin_truncate_log_recovery(slot_num);\n\n\tstatus = ocfs2_get_truncate_log_info(osb, slot_num, &tl_inode, &tl_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_get_truncate_log_info().  It's\n\t * validated by the underlying call to ocfs2_read_inode_block(),\n\t * so any corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tif (le16_to_cpu(tl->tl_used)) {\n\t\ttrace_ocfs2_truncate_log_recovery_num(le16_to_cpu(tl->tl_used));\n\n\t\t*tl_copy = kmalloc(tl_bh->b_size, GFP_KERNEL);\n\t\tif (!(*tl_copy)) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Assuming the write-out below goes well, this copy\n\t\t * will be passed back to recovery for processing. */\n\t\tmemcpy(*tl_copy, tl_bh->b_data, tl_bh->b_size);\n\n\t\t/* All we need to do to clear the truncate log is set\n\t\t * tl_used. */\n\t\ttl->tl_used = 0;\n\n\t\tocfs2_compute_meta_ecc(osb->sb, tl_bh->b_data, &di->i_check);\n\t\tstatus = ocfs2_write_block(osb, tl_bh, INODE_CACHE(tl_inode));\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tiput(tl_inode);\n\tbrelse(tl_bh);\n\n\tif (status < 0) {\n\t\tkfree(*tl_copy);\n\t\t*tl_copy = NULL;\n\t\tmlog_errno(status);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_get_truncate_log_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6142-6171",
    "snippet": "static int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 6162
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&bh"
          ],
          "line": 6160
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.c",
          "lines": "1619-1622",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"filecheck.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/iversion.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_filecheck_validate_inode_block(struct super_block *sb,\n\t\t\t\t\t\tstruct buffer_head *bh);",
            "static int ocfs2_filecheck_repair_inode_block(struct super_block *sb,\n\t\t\t\t\t      struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"filecheck.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/iversion.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_filecheck_validate_inode_block(struct super_block *sb,\n\t\t\t\t\t\tstruct buffer_head *bh);\nstatic int ocfs2_filecheck_repair_inode_block(struct super_block *sb,\n\t\t\t\t\t      struct buffer_head *bh);\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Could not get load truncate log inode!\\n\""
          ],
          "line": 6156
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "TRUNCATE_LOG_SYSTEM_INODE",
            "slot_num"
          ],
          "line": 6151
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/sysfile.c",
          "lines": "139-182",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_truncate_log_info(struct ocfs2_super *osb,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct inode **tl_inode,\n\t\t\t\t       struct buffer_head **tl_bh)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t   TRUNCATE_LOG_SYSTEM_INODE,\n\t\t\t\t\t   slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get load truncate log inode!\\n\");\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tiput(inode);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*tl_inode = inode;\n\t*tl_bh    = bh;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_try_to_free_truncate_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6110-6140",
    "snippet": "int ocfs2_try_to_free_truncate_log(struct ocfs2_super *osb,\n\t\t\t\t\tunsigned int needed)\n{\n\ttid_t target;\n\tint ret = 0;\n\tunsigned int truncated_clusters;\n\n\tinode_lock(osb->osb_tl_inode);\n\ttruncated_clusters = osb->truncated_clusters;\n\tinode_unlock(osb->osb_tl_inode);\n\n\t/*\n\t * Check whether we can succeed in allocating if we free\n\t * the truncate log.\n\t */\n\tif (truncated_clusters < needed)\n\t\tgoto out;\n\n\tret = ocfs2_flush_truncate_log(osb);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (jbd2_journal_start_commit(osb->journal->j_journal, &target)) {\n\t\tjbd2_log_wait_commit(osb->journal->j_journal, target);\n\t\tret = 1;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_log_wait_commit",
          "args": [
            "osb->journal->j_journal",
            "target"
          ],
          "line": 6135
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/jbd2/journal.c",
          "lines": "695-735",
          "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_PROVE_LOCKING\n\t/*\n\t * Some callers make sure transaction is already committing and in that\n\t * case we cannot block on open handles anymore. So don't warn in that\n\t * case.\n\t */\n\tif (tid_gt(tid, journal->j_commit_sequence) &&\n\t    (!journal->j_committing_transaction ||\n\t     journal->j_committing_transaction->t_tid != tid)) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_might_wait_for_commit(journal);\n\t\tread_lock(&journal->j_state_lock);\n\t}\n#endif\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/sched/mm.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_PROVE_LOCKING\n\t/*\n\t * Some callers make sure transaction is already committing and in that\n\t * case we cannot block on open handles anymore. So don't warn in that\n\t * case.\n\t */\n\tif (tid_gt(tid, journal->j_commit_sequence) &&\n\t    (!journal->j_committing_transaction ||\n\t     journal->j_committing_transaction->t_tid != tid)) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_might_wait_for_commit(journal);\n\t\tread_lock(&journal->j_state_lock);\n\t}\n#endif\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_start_commit",
          "args": [
            "osb->journal->j_journal",
            "&target"
          ],
          "line": 6134
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/jbd2/journal.c",
          "lines": "623-648",
          "snippet": "int jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/sched/mm.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 6130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6063-6073",
          "snippet": "int ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tinode_lock(tl_inode);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tinode_lock(tl_inode);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "osb->osb_tl_inode"
          ],
          "line": 6119
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "osb->osb_tl_inode"
          ],
          "line": 6117
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_try_to_free_truncate_log(struct ocfs2_super *osb,\n\t\t\t\t\tunsigned int needed)\n{\n\ttid_t target;\n\tint ret = 0;\n\tunsigned int truncated_clusters;\n\n\tinode_lock(osb->osb_tl_inode);\n\ttruncated_clusters = osb->truncated_clusters;\n\tinode_unlock(osb->osb_tl_inode);\n\n\t/*\n\t * Check whether we can succeed in allocating if we free\n\t * the truncate log.\n\t */\n\tif (truncated_clusters < needed)\n\t\tgoto out;\n\n\tret = ocfs2_flush_truncate_log(osb);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (jbd2_journal_start_commit(osb->journal->j_journal, &target)) {\n\t\tjbd2_log_wait_commit(osb->journal->j_journal, target);\n\t\tret = 1;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_schedule_truncate_log_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6090-6103",
    "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(osb->ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "osb->ocfs2_wq",
            "&osb->osb_truncate_log_wq",
            "OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL"
          ],
          "line": 6100
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "480-487",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/sched/mm.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&osb->osb_truncate_log_wq"
          ],
          "line": 6098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->osb_tl_disable"
          ],
          "line": 6094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(osb->ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6075-6087",
    "snippet": "static void ocfs2_truncate_log_worker(struct work_struct *work)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tcontainer_of(work, struct ocfs2_super,\n\t\t\t     osb_truncate_log_wq.work);\n\n\tstatus = ocfs2_flush_truncate_log(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_init_steal_slots(osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_init_steal_slots",
          "args": [
            "osb"
          ],
          "line": 6086
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_steal_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "886-890",
          "snippet": "void ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6082
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6063-6073",
          "snippet": "int ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tinode_lock(tl_inode);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tinode_lock(tl_inode);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structocfs2_super",
            "osb_truncate_log_wq.work"
          ],
          "line": 6079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_truncate_log_worker(struct work_struct *work)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tcontainer_of(work, struct ocfs2_super,\n\t\t\t     osb_truncate_log_wq.work);\n\n\tstatus = ocfs2_flush_truncate_log(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_init_steal_slots(osb);\n}"
  },
  {
    "function_name": "ocfs2_flush_truncate_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6063-6073",
    "snippet": "int ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tinode_lock(tl_inode);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "tl_inode"
          ],
          "line": 6070
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 6069
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6000-6061",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "tl_inode"
          ],
          "line": 6068
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tinode_lock(tl_inode);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tinode_unlock(tl_inode);\n\n\treturn status;\n}"
  },
  {
    "function_name": "__ocfs2_flush_truncate_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "6000-6061",
    "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "data_alloc_inode"
          ],
          "line": 6057
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "data_alloc_inode"
          ],
          "line": 6056
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "data_alloc_inode",
            "1"
          ],
          "line": 6053
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "2589-2603",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "data_alloc_bh"
          ],
          "line": 6052
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_replay_truncate_records",
          "args": [
            "osb",
            "data_alloc_inode",
            "data_alloc_bh"
          ],
          "line": 6047
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replay_truncate_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5929-5997",
          "snippet": "static int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\thandle_t *handle;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\thandle_t *handle;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 6043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "data_alloc_inode",
            "&data_alloc_bh",
            "1"
          ],
          "line": 6041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "data_alloc_inode"
          ],
          "line": 6039
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Could not get bitmap inode!\\n\""
          ],
          "line": 6035
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 6030
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/sysfile.c",
          "lines": "139-182",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_flush_truncate_log",
          "args": [
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "num_to_flush"
          ],
          "line": 6022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "tl_inode"
          ],
          "line": 6023
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 6021
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(di)"
          ],
          "line": 6018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "di"
          ],
          "line": 6018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode_trylock(tl_inode)"
          ],
          "line": 6011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_trylock",
          "args": [
            "tl_inode"
          ],
          "line": 6011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_replay_truncate_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5929-5997",
    "snippet": "static int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\thandle_t *handle;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 5989
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_clusters",
          "args": [
            "handle",
            "data_alloc_inode",
            "data_alloc_bh",
            "start_blk",
            "num_clusters"
          ],
          "line": 5980
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "2601-2610",
          "snippet": "int ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_replay_truncate_records",
          "args": [
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "i",
            "le32_to_cpu(rec.t_start)",
            "num_clusters"
          ],
          "line": 5976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec.t_start"
          ],
          "line": 5978
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "tl_inode"
          ],
          "line": 5977
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "data_alloc_inode->i_sb",
            "le32_to_cpu(rec.t_start)"
          ],
          "line": 5969
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "tl_bh"
          ],
          "line": 5966
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "i"
          ],
          "line": 5964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(tl_inode)",
            "tl_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5957
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "725-729",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "tl_inode"
          ],
          "line": 5957
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "129-132",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 5950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC"
          ],
          "line": 5948
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 5946
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\thandle_t *handle;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_commit_trans(osb, handle);\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5853-5927",
    "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "tl_bh"
          ],
          "line": 5922
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "num_clusters"
          ],
          "line": 5920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "index + 1"
          ],
          "line": 5918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "start_cluster"
          ],
          "line": 5917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_truncate_log_append",
          "args": [
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "index",
            "le32_to_cpu(tl->tl_recs[index].t_start)",
            "num_clusters"
          ],
          "line": 5912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tl->tl_recs[index].t_start"
          ],
          "line": 5914
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "tl_inode"
          ],
          "line": 5913
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_can_coalesce",
          "args": [
            "tl",
            "start_cluster"
          ],
          "line": 5904
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_can_coalesce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5836-5851",
          "snippet": "static int ocfs2_truncate_log_can_coalesce(struct ocfs2_truncate_log *tl,\n\t\t\t\t\t   unsigned int new_start)\n{\n\tunsigned int tail_index;\n\tunsigned int current_tail;\n\n\t/* No records, nothing to coalesce */\n\tif (!le16_to_cpu(tl->tl_used))\n\t\treturn 0;\n\n\ttail_index = le16_to_cpu(tl->tl_used) - 1;\n\tcurrent_tail = le32_to_cpu(tl->tl_recs[tail_index].t_start);\n\tcurrent_tail += le32_to_cpu(tl->tl_recs[tail_index].t_clusters);\n\n\treturn current_tail == new_start;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_truncate_log_can_coalesce(struct ocfs2_truncate_log *tl,\n\t\t\t\t\t   unsigned int new_start)\n{\n\tunsigned int tail_index;\n\tunsigned int current_tail;\n\n\t/* No records, nothing to coalesce */\n\tif (!le16_to_cpu(tl->tl_used))\n\t\treturn 0;\n\n\ttail_index = le16_to_cpu(tl->tl_used) - 1;\n\tcurrent_tail = le32_to_cpu(tl->tl_recs[tail_index].t_start);\n\tcurrent_tail += le32_to_cpu(tl->tl_recs[tail_index].t_clusters);\n\n\treturn current_tail == new_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_truncate_log_append",
          "args": [
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "index",
            "start_cluster",
            "num_clusters"
          ],
          "line": 5901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(tl_inode)",
            "tl_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5894
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "725-729",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "tl_inode"
          ],
          "line": 5894
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "129-132",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 5890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 5887
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0",
            "\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\"",
            "(unsigned long long)OCFS2_I(tl_inode)->ip_blkno",
            "ocfs2_truncate_recs_per_inode(osb->sb)",
            "le16_to_cpu(tl->tl_count)"
          ],
          "line": 5878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_recs_per_inode",
          "args": [
            "osb->sb"
          ],
          "line": 5883
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_recs_per_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1566-1574",
          "snippet": "static inline int ocfs2_truncate_recs_per_inode(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_dealloc.tl_recs);\n\n\treturn size / sizeof(struct ocfs2_truncate_rec);\n}",
          "includes": [
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n\nstatic inline int ocfs2_truncate_recs_per_inode(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_dealloc.tl_recs);\n\n\treturn size / sizeof(struct ocfs2_truncate_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(di)"
          ],
          "line": 5874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "di"
          ],
          "line": 5874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "osb->sb",
            "start_blk"
          ],
          "line": 5867
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "748-755",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode_trylock(tl_inode)"
          ],
          "line": 5865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_trylock",
          "args": [
            "tl_inode"
          ],
          "line": 5865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_can_coalesce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5836-5851",
    "snippet": "static int ocfs2_truncate_log_can_coalesce(struct ocfs2_truncate_log *tl,\n\t\t\t\t\t   unsigned int new_start)\n{\n\tunsigned int tail_index;\n\tunsigned int current_tail;\n\n\t/* No records, nothing to coalesce */\n\tif (!le16_to_cpu(tl->tl_used))\n\t\treturn 0;\n\n\ttail_index = le16_to_cpu(tl->tl_used) - 1;\n\tcurrent_tail = le32_to_cpu(tl->tl_recs[tail_index].t_start);\n\tcurrent_tail += le32_to_cpu(tl->tl_recs[tail_index].t_clusters);\n\n\treturn current_tail == new_start;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tl->tl_recs[tail_index].t_clusters"
          ],
          "line": 5848
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_used"
          ],
          "line": 5846
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_truncate_log_can_coalesce(struct ocfs2_truncate_log *tl,\n\t\t\t\t\t   unsigned int new_start)\n{\n\tunsigned int tail_index;\n\tunsigned int current_tail;\n\n\t/* No records, nothing to coalesce */\n\tif (!le16_to_cpu(tl->tl_used))\n\t\treturn 0;\n\n\ttail_index = le16_to_cpu(tl->tl_used) - 1;\n\tcurrent_tail = le32_to_cpu(tl->tl_recs[tail_index].t_start);\n\tcurrent_tail += le32_to_cpu(tl->tl_recs[tail_index].t_clusters);\n\n\treturn current_tail == new_start;\n}"
  },
  {
    "function_name": "ocfs2_truncate_log_needs_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5820-5834",
    "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tl->tl_count"
          ],
          "line": 5833
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count)",
            "\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\"",
            "osb->slot_num",
            "le16_to_cpu(tl->tl_used)",
            "le16_to_cpu(tl->tl_count)"
          ],
          "line": 5829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
  },
  {
    "function_name": "ocfs2_remove_btree_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5707-5818",
    "snippet": "int ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tinode_lock(tl_inode);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tinode_unlock(tl_inode);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 5815
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/refcounttree.c",
          "lines": "524-534",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"file.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"file.h\"\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 5812
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "154-158",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "tl_inode"
          ],
          "line": 5809
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 5807
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_append",
          "args": [
            "osb",
            "handle",
            "phys_blkno",
            "len"
          ],
          "line": 5799
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5853-5927",
          "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_decrease_refcount",
          "args": [
            "inode",
            "handle",
            "ocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno)",
            "len",
            "meta_ac",
            "dealloc",
            "1"
          ],
          "line": 5793
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_decrease_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/refcounttree.c",
          "lines": "2294-2333",
          "snippet": "int ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"file.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"file.h\"\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "osb->sb",
            "phys_blkno"
          ],
          "line": 5794
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "748-755",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et->et_root_bh"
          ],
          "line": 5789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 5787
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_update_clusters",
          "args": [
            "et",
            "-len"
          ],
          "line": 5786
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_update_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "518-522",
          "snippet": "static inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent",
          "args": [
            "handle",
            "et",
            "cpos",
            "len",
            "meta_ac",
            "dealloc"
          ],
          "line": 5780
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5521-5654",
          "snippet": "int ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u trunc len %u, existing record is (%u,%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u trunc len %u, existing record is (%u,%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space_nodirty",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(inode->i_sb, len)"
          ],
          "line": 5777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "inode->i_sb",
            "len"
          ],
          "line": 5778
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "787-791",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 5770
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "538-544",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 5765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_remove_extent_credits(osb->sb) + credits"
          ],
          "line": 5762
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent_credits",
          "args": [
            "osb->sb"
          ],
          "line": 5763
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.h",
          "lines": "412-416",
          "snippet": "static inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS",
            "#define OCFS2_INODE_UPDATE_CREDITS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS\n#define OCFS2_INODE_UPDATE_CREDITS 1\n\nstatic inline int ocfs2_remove_extent_credits(struct super_block *sb)\n{\n\treturn OCFS2_TRUNCATE_LOG_UPDATE + OCFS2_INODE_UPDATE_CREDITS +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 5755
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6000-6061",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(inode_trylock(tl_inode));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tinode_lock(data_alloc_inode);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tinode_unlock(data_alloc_inode);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_needs_flush",
          "args": [
            "osb"
          ],
          "line": 5754
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_needs_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5820-5834",
          "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "tl_inode"
          ],
          "line": 5752
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_blocks_for_rec_trunc",
          "args": [
            "inode",
            "et",
            "1",
            "&meta_ac",
            "extra_blocks"
          ],
          "line": 5745
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_blocks_for_rec_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5665-5705",
          "snippet": "static int ocfs2_reserve_blocks_for_rec_trunc(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 extents_to_split,\n\t\t\t\t\t      struct ocfs2_alloc_context **ac,\n\t\t\t\t\t      int extra_blocks)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*ac = NULL;\n\n\tnum_free_extents = ocfs2_num_free_extents(et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tif (extra_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*ac) {\n\t\t\tocfs2_free_alloc_context(*ac);\n\t\t\t*ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_reserve_blocks_for_rec_trunc(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 extents_to_split,\n\t\t\t\t\t      struct ocfs2_alloc_context **ac,\n\t\t\t\t\t      int extra_blocks)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*ac = NULL;\n\n\tnum_free_extents = ocfs2_num_free_extents(et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tif (extra_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*ac) {\n\t\t\tocfs2_free_alloc_context(*ac);\n\t\t\t*ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_refcount_change_for_del",
          "args": [
            "inode",
            "refcount_loc",
            "phys_blkno",
            "len",
            "&credits",
            "&extra_blocks"
          ],
          "line": 5733
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_refcount_change_for_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/refcounttree.c",
          "lines": "2527-2576",
          "snippet": "int ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tret = ocfs2_error(inode->i_sb, \"Inode %lu want to use refcount tree, but the feature bit is not set in the super block\\n\",\n\t\t\t\t  inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"file.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"file.h\"\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tret = ocfs2_error(inode->i_sb, \"Inode %lu want to use refcount tree, but the feature bit is not set in the super block\\n\",\n\t\t\t\t  inode->i_ino);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "refcount_loc",
            "1",
            "&ref_tree",
            "NULL"
          ],
          "line": 5725
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/refcounttree.c",
          "lines": "451-522",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"file.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"file.h\"\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_refcount_inode(inode)"
          ],
          "line": 5722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_refcount_inode",
          "args": [
            "inode"
          ],
          "line": 5722
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_refcount_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "185-188",
          "snippet": "static inline bool ocfs2_is_refcount_inode(struct inode *inode)\n{\n\treturn (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline bool ocfs2_is_refcount_inode(struct inode *inode)\n{\n\treturn (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "phys_cpos"
          ],
          "line": 5714
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!ocfs2_is_refcount_inode(inode));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tinode_lock(tl_inode);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tinode_unlock(tl_inode);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_reserve_blocks_for_rec_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5665-5705",
    "snippet": "static int ocfs2_reserve_blocks_for_rec_trunc(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 extents_to_split,\n\t\t\t\t\t      struct ocfs2_alloc_context **ac,\n\t\t\t\t\t      int extra_blocks)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*ac = NULL;\n\n\tnum_free_extents = ocfs2_num_free_extents(et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tif (extra_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*ac) {\n\t\t\tocfs2_free_alloc_context(*ac);\n\t\t\t*ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*ac"
          ],
          "line": 5699
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "154-158",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "extra_blocks",
            "ac"
          ],
          "line": 5689
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "971-1031",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "et->et_root_el"
          ],
          "line": 5686
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 5685
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "501-506",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_num_free_extents",
          "args": [
            "et"
          ],
          "line": 5677
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_num_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "964-994",
          "snippet": "int ocfs2_num_free_extents(struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_reserve_blocks_for_rec_trunc(struct inode *inode,\n\t\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 extents_to_split,\n\t\t\t\t\t      struct ocfs2_alloc_context **ac,\n\t\t\t\t\t      int extra_blocks)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*ac = NULL;\n\n\tnum_free_extents = ocfs2_num_free_extents(et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tif (extra_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*ac) {\n\t\t\tocfs2_free_alloc_context(*ac);\n\t\t\t*ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_remove_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5521-5654",
    "snippet": "int ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u trunc len %u, existing record is (%u,%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 5652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_rec",
          "args": [
            "handle",
            "et",
            "path",
            "index",
            "dealloc",
            "cpos",
            "len"
          ],
          "line": 5645
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5357-5519",
          "snippet": "static int ocfs2_truncate_rec(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_path *path, int index,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      u32 cpos, u32 len)\n{\n\tint ret;\n\tu32 left_cpos, rec_range, trunc_range;\n\tint is_rightmost_tree_rec = 0;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_block *eb;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\tif (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&\n\t    path->p_tree_depth) {\n\t\t/*\n\t\t * Check whether this is the rightmost tree record. If\n\t\t * we remove all of this record or part of its right\n\t\t * edge then an update of the record lengths above it\n\t\t * will be required.\n\t\t */\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\t\tif (eb->h_next_leaf_blk == 0)\n\t\t\tis_rightmost_tree_rec = 1;\n\t}\n\n\trec = &el->l_recs[index];\n\tif (index == 0 && path->p_tree_depth &&\n\t    le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/*\n\t\t * Changing the leftmost offset (via partial or whole\n\t\t * record truncate) of an interior (or rightmost) path\n\t\t * means we have to update the subtree that is formed\n\t\t * by this leaf and the one to it's left.\n\t\t *\n\t\t * There are two cases we can skip:\n\t\t *   1) Path is the leftmost one in our btree.\n\t\t *   2) The leaf is rightmost and will be empty after\n\t\t *      we remove the extent record - the rotate code\n\t\t *      knows how to update the newly formed edge.\n\t\t */\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {\n\t\tint next_free;\n\n\t\tmemset(rec, 0, sizeof(*rec));\n\t\tocfs2_cleanup_merge(el, index);\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (is_rightmost_tree_rec && next_free > 1) {\n\t\t\t/*\n\t\t\t * We skip the edge update if this path will\n\t\t\t * be deleted by the rotate code.\n\t\t\t */\n\t\t\trec = &el->l_recs[next_free - 1];\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path,\n\t\t\t\t\t\t       rec);\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/* Remove leftmost portion of the record. */\n\t\tle32_add_cpu(&rec->e_cpos, len);\n\t\tle64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t} else if (rec_range == trunc_range) {\n\t\t/* Remove rightmost portion of the record */\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t\tif (is_rightmost_tree_rec)\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\t} else {\n\t\t/* Caller should have trapped this. */\n\t\tmlog(ML_ERROR, \"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     le32_to_cpu(rec->e_cpos),\n\t\t     le16_to_cpu(rec->e_leaf_clusters), cpos, len);\n\t\tBUG();\n\t}\n\n\tif (left_path) {\n\t\tint subtree_index;\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\t\tocfs2_complete_edge_insert(handle, left_path, path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\n\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_truncate_rec(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_path *path, int index,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      u32 cpos, u32 len)\n{\n\tint ret;\n\tu32 left_cpos, rec_range, trunc_range;\n\tint is_rightmost_tree_rec = 0;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_block *eb;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\tif (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&\n\t    path->p_tree_depth) {\n\t\t/*\n\t\t * Check whether this is the rightmost tree record. If\n\t\t * we remove all of this record or part of its right\n\t\t * edge then an update of the record lengths above it\n\t\t * will be required.\n\t\t */\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\t\tif (eb->h_next_leaf_blk == 0)\n\t\t\tis_rightmost_tree_rec = 1;\n\t}\n\n\trec = &el->l_recs[index];\n\tif (index == 0 && path->p_tree_depth &&\n\t    le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/*\n\t\t * Changing the leftmost offset (via partial or whole\n\t\t * record truncate) of an interior (or rightmost) path\n\t\t * means we have to update the subtree that is formed\n\t\t * by this leaf and the one to it's left.\n\t\t *\n\t\t * There are two cases we can skip:\n\t\t *   1) Path is the leftmost one in our btree.\n\t\t *   2) The leaf is rightmost and will be empty after\n\t\t *      we remove the extent record - the rotate code\n\t\t *      knows how to update the newly formed edge.\n\t\t */\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {\n\t\tint next_free;\n\n\t\tmemset(rec, 0, sizeof(*rec));\n\t\tocfs2_cleanup_merge(el, index);\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (is_rightmost_tree_rec && next_free > 1) {\n\t\t\t/*\n\t\t\t * We skip the edge update if this path will\n\t\t\t * be deleted by the rotate code.\n\t\t\t */\n\t\t\trec = &el->l_recs[next_free - 1];\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path,\n\t\t\t\t\t\t       rec);\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/* Remove leftmost portion of the record. */\n\t\tle32_add_cpu(&rec->e_cpos, len);\n\t\tle64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t} else if (rec_range == trunc_range) {\n\t\t/* Remove rightmost portion of the record */\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t\tif (is_rightmost_tree_rec)\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\t} else {\n\t\t/* Caller should have trapped this. */\n\t\tmlog(ML_ERROR, \"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     le32_to_cpu(rec->e_cpos),\n\t\t     le16_to_cpu(rec->e_leaf_clusters), cpos, len);\n\t\tBUG();\n\t}\n\n\tif (left_path) {\n\t\tint subtree_index;\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\t\tocfs2_complete_edge_insert(handle, left_path, path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\n\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu: error after split at cpos %u trunc len %u, existing record is (%u,%u)\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos",
            "len",
            "le32_to_cpu(rec->e_cpos)",
            "ocfs2_rec_clusters(el, rec)"
          ],
          "line": 5636
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 5640
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 5639
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 5638
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 5636
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 5618
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "782-804",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "path",
            "cpos"
          ],
          "line": 5611
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "path",
            "1"
          ],
          "line": 5609
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "589-616",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_tree",
          "args": [
            "handle",
            "et",
            "path",
            "index",
            "trunc_range",
            "meta_ac"
          ],
          "line": 5598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5288-5355",
          "snippet": "static int ocfs2_split_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *path,\n\t\t\t    int index, u32 new_range,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, depth, credits;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *rightmost_el, *el;\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_insert_type insert;\n\n\t/*\n\t * Setup the record to split before we grow the tree.\n\t */\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[index];\n\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t   &split_rec, new_range, rec);\n\n\tdepth = path->p_tree_depth;\n\tif (depth > 0) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_leaf_el(path);\n\n\tcredits = path->p_tree_depth +\n\t\t  ocfs2_extend_meta_needed(et->et_root_el);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et, &depth, &last_eb_bh,\n\t\t\t\t      meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_split = SPLIT_RIGHT;\n\tinsert.ins_tree_depth = depth;\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_split_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *path,\n\t\t\t    int index, u32 new_range,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, depth, credits;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *rightmost_el, *el;\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_insert_type insert;\n\n\t/*\n\t * Setup the record to split before we grow the tree.\n\t */\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[index];\n\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t   &split_rec, new_range, rec);\n\n\tdepth = path->p_tree_depth;\n\tif (depth > 0) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_leaf_el(path);\n\n\tcredits = path->p_tree_depth +\n\t\t  ocfs2_extend_meta_needed(et->et_root_el);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et, &depth, &last_eb_bh,\n\t\t\t\t      meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_split = SPLIT_RIGHT;\n\tinsert.ins_tree_depth = depth;\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_remove_extent",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos",
            "len",
            "index",
            "le32_to_cpu(rec->e_cpos)",
            "ocfs2_rec_clusters(el, rec)"
          ],
          "line": 5585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range"
          ],
          "line": 5583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 5539
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "722-726",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_map_truncate",
          "args": [
            "et",
            "0"
          ],
          "line": 5537
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_map_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "531-536",
          "snippet": "static inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u trunc len %u, existing record is (%u,%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_truncate_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5357-5519",
    "snippet": "static int ocfs2_truncate_rec(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_path *path, int index,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      u32 cpos, u32 len)\n{\n\tint ret;\n\tu32 left_cpos, rec_range, trunc_range;\n\tint is_rightmost_tree_rec = 0;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_block *eb;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\tif (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&\n\t    path->p_tree_depth) {\n\t\t/*\n\t\t * Check whether this is the rightmost tree record. If\n\t\t * we remove all of this record or part of its right\n\t\t * edge then an update of the record lengths above it\n\t\t * will be required.\n\t\t */\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\t\tif (eb->h_next_leaf_blk == 0)\n\t\t\tis_rightmost_tree_rec = 1;\n\t}\n\n\trec = &el->l_recs[index];\n\tif (index == 0 && path->p_tree_depth &&\n\t    le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/*\n\t\t * Changing the leftmost offset (via partial or whole\n\t\t * record truncate) of an interior (or rightmost) path\n\t\t * means we have to update the subtree that is formed\n\t\t * by this leaf and the one to it's left.\n\t\t *\n\t\t * There are two cases we can skip:\n\t\t *   1) Path is the leftmost one in our btree.\n\t\t *   2) The leaf is rightmost and will be empty after\n\t\t *      we remove the extent record - the rotate code\n\t\t *      knows how to update the newly formed edge.\n\t\t */\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {\n\t\tint next_free;\n\n\t\tmemset(rec, 0, sizeof(*rec));\n\t\tocfs2_cleanup_merge(el, index);\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (is_rightmost_tree_rec && next_free > 1) {\n\t\t\t/*\n\t\t\t * We skip the edge update if this path will\n\t\t\t * be deleted by the rotate code.\n\t\t\t */\n\t\t\trec = &el->l_recs[next_free - 1];\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path,\n\t\t\t\t\t\t       rec);\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/* Remove leftmost portion of the record. */\n\t\tle32_add_cpu(&rec->e_cpos, len);\n\t\tle64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t} else if (rec_range == trunc_range) {\n\t\t/* Remove rightmost portion of the record */\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t\tif (is_rightmost_tree_rec)\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\t} else {\n\t\t/* Caller should have trapped this. */\n\t\tmlog(ML_ERROR, \"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     le32_to_cpu(rec->e_cpos),\n\t\t     le16_to_cpu(rec->e_leaf_clusters), cpos, len);\n\t\tBUG();\n\t}\n\n\tif (left_path) {\n\t\tint subtree_index;\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\t\tocfs2_complete_edge_insert(handle, left_path, path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\n\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 5517
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_tree_left",
          "args": [
            "handle",
            "et",
            "path",
            "dealloc"
          ],
          "line": 5512
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_tree_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3160-3269",
          "snippet": "static int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent block at %llu\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent block at %llu\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(path)"
          ],
          "line": 5510
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 5510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "path",
            "subtree_index"
          ],
          "line": 5506
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2052-2120",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "path"
          ],
          "line": 5505
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1764-1792",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 5499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "le32_to_cpu(rec->e_cpos)",
            "le16_to_cpu(rec->e_leaf_clusters)",
            "cpos",
            "len"
          ],
          "line": 5494
        },
        "resolved": true,
        "details": {
          "function_name": "__mlog_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "67-98",
          "snippet": "void __mlog_printk(const u64 *mask, const char *func, int line,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *level;\n\tconst char *prefix = \"\";\n\n\tif (!__mlog_test_u64(*mask, mlog_and_bits) ||\n\t    __mlog_test_u64(*mask, mlog_not_bits))\n\t\treturn;\n\n\tif (*mask & ML_ERROR) {\n\t\tlevel = KERN_ERR;\n\t\tprefix = \"ERROR: \";\n\t} else if (*mask & ML_NOTICE) {\n\t\tlevel = KERN_NOTICE;\n\t} else {\n\t\tlevel = KERN_INFO;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%s(%s,%u,%u):%s:%d %s%pV\",\n\t       level, current->comm, task_pid_nr(current),\n\t       raw_smp_processor_id(), func, line, prefix, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nvoid __mlog_printk(const u64 *mask, const char *func, int line,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *level;\n\tconst char *prefix = \"\";\n\n\tif (!__mlog_test_u64(*mask, mlog_and_bits) ||\n\t    __mlog_test_u64(*mask, mlog_not_bits))\n\t\treturn;\n\n\tif (*mask & ML_ERROR) {\n\t\tlevel = KERN_ERR;\n\t\tprefix = \"ERROR: \";\n\t} else if (*mask & ML_NOTICE) {\n\t\tlevel = KERN_NOTICE;\n\t} else {\n\t\tlevel = KERN_INFO;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%s(%s,%u,%u):%s:%d %s%pV\",\n\t       level, current->comm, task_pid_nr(current),\n\t       raw_smp_processor_id(), func, line, prefix, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 5498
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 5497
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 5496
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_rightmost_records",
          "args": [
            "handle",
            "et",
            "path",
            "rec"
          ],
          "line": 5491
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_rightmost_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3964-3999",
          "snippet": "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "-len"
          ],
          "line": 5489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "-len"
          ],
          "line": 5486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&rec->e_blkno",
            "ocfs2_clusters_to_blocks(sb, len)"
          ],
          "line": 5485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "len"
          ],
          "line": 5485
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_cpos",
            "len"
          ],
          "line": 5484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cleanup_merge",
          "args": [
            "el",
            "index"
          ],
          "line": 5470
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cleanup_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3271-3301",
          "snippet": "static void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rec",
            "0",
            "sizeof(*rec)"
          ],
          "line": 5469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 5463
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "left_path"
          ],
          "line": 5457
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "755-774",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "0",
            "handle->h_buffer_credits",
            "path"
          ],
          "line": 5443
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2298-2310",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "left_cpos"
          ],
          "line": 5434
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "path"
          ],
          "line": 5427
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "716-720",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "sb",
            "path",
            "&left_cpos"
          ],
          "line": 5420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2225-2291",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 5399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 5372
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 5366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_truncate_rec(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_path *path, int index,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      u32 cpos, u32 len)\n{\n\tint ret;\n\tu32 left_cpos, rec_range, trunc_range;\n\tint is_rightmost_tree_rec = 0;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_block *eb;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tindex--;\n\t}\n\n\tif (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&\n\t    path->p_tree_depth) {\n\t\t/*\n\t\t * Check whether this is the rightmost tree record. If\n\t\t * we remove all of this record or part of its right\n\t\t * edge then an update of the record lengths above it\n\t\t * will be required.\n\t\t */\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\t\tif (eb->h_next_leaf_blk == 0)\n\t\t\tis_rightmost_tree_rec = 1;\n\t}\n\n\trec = &el->l_recs[index];\n\tif (index == 0 && path->p_tree_depth &&\n\t    le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/*\n\t\t * Changing the leftmost offset (via partial or whole\n\t\t * record truncate) of an interior (or rightmost) path\n\t\t * means we have to update the subtree that is formed\n\t\t * by this leaf and the one to it's left.\n\t\t *\n\t\t * There are two cases we can skip:\n\t\t *   1) Path is the leftmost one in our btree.\n\t\t *   2) The leaf is rightmost and will be empty after\n\t\t *      we remove the extent record - the rotate code\n\t\t *      knows how to update the newly formed edge.\n\t\t */\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t      path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {\n\t\tint next_free;\n\n\t\tmemset(rec, 0, sizeof(*rec));\n\t\tocfs2_cleanup_merge(el, index);\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (is_rightmost_tree_rec && next_free > 1) {\n\t\t\t/*\n\t\t\t * We skip the edge update if this path will\n\t\t\t * be deleted by the rotate code.\n\t\t\t */\n\t\t\trec = &el->l_recs[next_free - 1];\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path,\n\t\t\t\t\t\t       rec);\n\t\t}\n\t} else if (le32_to_cpu(rec->e_cpos) == cpos) {\n\t\t/* Remove leftmost portion of the record. */\n\t\tle32_add_cpu(&rec->e_cpos, len);\n\t\tle64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t} else if (rec_range == trunc_range) {\n\t\t/* Remove rightmost portion of the record */\n\t\tle16_add_cpu(&rec->e_leaf_clusters, -len);\n\t\tif (is_rightmost_tree_rec)\n\t\t\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\t} else {\n\t\t/* Caller should have trapped this. */\n\t\tmlog(ML_ERROR, \"Owner %llu: Invalid record truncate: (%u, %u) \"\n\t\t     \"(%u, %u)\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     le32_to_cpu(rec->e_cpos),\n\t\t     le16_to_cpu(rec->e_leaf_clusters), cpos, len);\n\t\tBUG();\n\t}\n\n\tif (left_path) {\n\t\tint subtree_index;\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\t\tocfs2_complete_edge_insert(handle, left_path, path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\n\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_split_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5288-5355",
    "snippet": "static int ocfs2_split_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *path,\n\t\t\t    int index, u32 new_range,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, depth, credits;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *rightmost_el, *el;\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_insert_type insert;\n\n\t/*\n\t * Setup the record to split before we grow the tree.\n\t */\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[index];\n\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t   &split_rec, new_range, rec);\n\n\tdepth = path->p_tree_depth;\n\tif (depth > 0) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_leaf_el(path);\n\n\tcredits = path->p_tree_depth +\n\t\t  ocfs2_extend_meta_needed(et->et_root_el);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et, &depth, &last_eb_bh,\n\t\t\t\t      meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_split = SPLIT_RIGHT;\n\tinsert.ins_tree_depth = depth;\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "last_eb_bh"
          ],
          "line": 5353
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_do_insert_extent",
          "args": [
            "handle",
            "et",
            "&split_rec",
            "&insert"
          ],
          "line": 5348
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4253-4363",
          "snippet": "static int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&insert",
            "0",
            "sizeof(struct ocfs2_insert_type)"
          ],
          "line": 5342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grow_tree",
          "args": [
            "handle",
            "et",
            "&depth",
            "&last_eb_bh",
            "meta_ac"
          ],
          "line": 5334
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grow_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1539-1605",
          "snippet": "static int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL && ocfs2_is_dealloc_empty(et));\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL && ocfs2_is_dealloc_empty(et));\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rightmost_el->l_count"
          ],
          "line": 5333
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "credits"
          ],
          "line": 5326
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "et->et_root_el"
          ],
          "line": 5325
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "ocfs2_et_get_last_eb_blk(et)",
            "&last_eb_bh"
          ],
          "line": 5311
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "944-958",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 5312
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_get_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "513-516",
          "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_make_right_split_rec",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "&split_rec",
            "new_range",
            "rec"
          ],
          "line": 5306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_make_right_split_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4898-4916",
          "snippet": "static void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 5306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_split_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *path,\n\t\t\t    int index, u32 new_range,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, depth, credits;\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *rightmost_el, *el;\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_insert_type insert;\n\n\t/*\n\t * Setup the record to split before we grow the tree.\n\t */\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[index];\n\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t   &split_rec, new_range, rec);\n\n\tdepth = path->p_tree_depth;\n\tif (depth > 0) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_leaf_el(path);\n\n\tcredits = path->p_tree_depth +\n\t\t  ocfs2_extend_meta_needed(et->et_root_el);\n\tret = ocfs2_extend_trans(handle, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et, &depth, &last_eb_bh,\n\t\t\t\t      meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_split = SPLIT_RIGHT;\n\tinsert.ins_tree_depth = depth;\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_mark_extent_written",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5253-5286",
    "snippet": "int ocfs2_mark_extent_written(struct inode *inode,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      handle_t *handle, u32 cpos, u32 len, u32 phys,\n\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_written(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tcpos, len, phys);\n\n\tif (!ocfs2_writes_unwritten_extents(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu has unwritten extents that are being written to, but the feature bit is not set in the super block\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * XXX: This should be fixed up so that we just re-insert the\n\t * next extent records.\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       0, OCFS2_EXT_UNWRITTEN);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_change_extent_flag",
          "args": [
            "handle",
            "et",
            "cpos",
            "len",
            "phys",
            "meta_ac",
            "dealloc",
            "0",
            "OCFS2_EXT_UNWRITTEN"
          ],
          "line": 5278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_change_extent_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5165-5242",
          "snippet": "int ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_map_truncate",
          "args": [
            "et",
            "0"
          ],
          "line": 5276
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_map_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "531-536",
          "snippet": "static inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %llu has unwritten extents that are being written to, but the feature bit is not set in the super block\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 5266
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 5267
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_writes_unwritten_extents",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 5265
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_writes_unwritten_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "508-519",
          "snippet": "static inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)\n{\n\t/*\n\t * Support for sparse files is a pre-requisite\n\t */\n\tif (!ocfs2_sparse_alloc(osb))\n\t\treturn 0;\n\n\tif (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)\n{\n\t/*\n\t * Support for sparse files is a pre-requisite\n\t */\n\tif (!ocfs2_sparse_alloc(osb))\n\t\treturn 0;\n\n\tif (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 5265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mark_extent_written",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "cpos",
            "len",
            "phys"
          ],
          "line": 5261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_mark_extent_written(struct inode *inode,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      handle_t *handle, u32 cpos, u32 len, u32 phys,\n\t\t\t      struct ocfs2_alloc_context *meta_ac,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_written(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tcpos, len, phys);\n\n\tif (!ocfs2_writes_unwritten_extents(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu has unwritten extents that are being written to, but the feature bit is not set in the super block\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * XXX: This should be fixed up so that we just re-insert the\n\t * next extent records.\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       0, OCFS2_EXT_UNWRITTEN);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_change_extent_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5165-5242",
    "snippet": "int ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 5239
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_extent",
          "args": [
            "handle",
            "et",
            "left_path",
            "index",
            "&split_rec",
            "meta_ac",
            "dealloc"
          ],
          "line": 5232
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5072-5151",
          "snippet": "int ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t     split_index,\n\t\t\t\t\t     split_rec,\n\t\t\t\t\t     &ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t     split_index,\n\t\t\t\t\t     split_rec,\n\t\t\t\t\t     &ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "start_blkno"
          ],
          "line": 5225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cpos"
          ],
          "line": 5223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&split_rec",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 5222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "clear_flags"
          ],
          "line": 5215
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "149-155",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 5217
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Owner %llu has an extent at cpos %u which can no longer be found\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos"
          ],
          "line": 5196
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 5194
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "782-804",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 5192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "cpos"
          ],
          "line": 5187
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 5180
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "722-726",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "phys"
          ],
          "line": 5174
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 5173
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "ocfs2_split_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5072-5151",
    "snippet": "int ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t     split_index,\n\t\t\t\t\t     split_rec,\n\t\t\t\t\t     &ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "last_eb_bh"
          ],
          "line": 5149
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_try_to_merge_extent",
          "args": [
            "handle",
            "et",
            "path",
            "split_index",
            "split_rec",
            "dealloc",
            "&ctxt"
          ],
          "line": 5141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_try_to_merge_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3669-3838",
          "snippet": "static int ocfs2_try_to_merge_extent(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path,\n\t\t\t\t     int split_index,\n\t\t\t\t     struct ocfs2_extent_rec *split_rec,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     struct ocfs2_merge_ctxt *ctxt)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\n\tBUG_ON(ctxt->c_contig_type == CONTIG_NONE);\n\n\tif (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * The merge code will need to create an empty\n\t\t * extent to take the place of the newly\n\t\t * emptied slot. Remove any pre-existing empty\n\t\t * extents - having more than one in a leaf is\n\t\t * illegal.\n\t\t */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tsplit_index--;\n\t\trec = &el->l_recs[split_index];\n\t}\n\n\tif (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {\n\t\t/*\n\t\t * Left-right contig implies this.\n\t\t */\n\t\tBUG_ON(!ctxt->c_split_covers_rec);\n\n\t\t/*\n\t\t * Since the leftright insert always covers the entire\n\t\t * extent, this call will delete the insert record\n\t\t * entirely, resulting in an empty extent record added to\n\t\t * the extent block.\n\t\t *\n\t\t * Since the adding of an empty extent shifts\n\t\t * everything back to the right, there's no need to\n\t\t * update split_index here.\n\t\t *\n\t\t * When the split_index is zero, we need to merge it to the\n\t\t * prevoius extent block. It is more efficient and easier\n\t\t * if we do merge_right first and merge_left later.\n\t\t */\n\t\tret = ocfs2_merge_rec_right(path, handle, et, split_rec,\n\t\t\t\t\t    split_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We can only get this from logic error above.\n\t\t */\n\t\tBUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The merge left us with an empty extent, remove it. */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trec = &el->l_recs[split_index];\n\n\t\t/*\n\t\t * Note that we don't pass split_rec here on purpose -\n\t\t * we've merged it into the rec already.\n\t\t */\n\t\tret = ocfs2_merge_rec_left(path, handle, et, rec,\n\t\t\t\t\t   dealloc, split_index);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\t/*\n\t\t * Error from this last rotate is not critical, so\n\t\t * print but don't bubble it up.\n\t\t */\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * Merge a record to the left or right.\n\t\t *\n\t\t * 'contig_type' is relative to the existing record,\n\t\t * so for example, if we're \"right contig\", it's to\n\t\t * the record on the left (hence the left merge).\n\t\t */\n\t\tif (ctxt->c_contig_type == CONTIG_RIGHT) {\n\t\t\tret = ocfs2_merge_rec_left(path, handle, et,\n\t\t\t\t\t\t   split_rec, dealloc,\n\t\t\t\t\t\t   split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ocfs2_merge_rec_right(path, handle,\n\t\t\t\t\t\t    et, split_rec,\n\t\t\t\t\t\t    split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ctxt->c_split_covers_rec) {\n\t\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tpath);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The merge may have left an empty extent in\n\t\t\t * our leaf. Try to rotate it away.\n\t\t\t */\n\t\t\tret = ocfs2_rotate_tree_left(handle, et, path,\n\t\t\t\t\t\t     dealloc);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_try_to_merge_extent(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path,\n\t\t\t\t     int split_index,\n\t\t\t\t     struct ocfs2_extent_rec *split_rec,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     struct ocfs2_merge_ctxt *ctxt)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\n\tBUG_ON(ctxt->c_contig_type == CONTIG_NONE);\n\n\tif (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * The merge code will need to create an empty\n\t\t * extent to take the place of the newly\n\t\t * emptied slot. Remove any pre-existing empty\n\t\t * extents - having more than one in a leaf is\n\t\t * illegal.\n\t\t */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tsplit_index--;\n\t\trec = &el->l_recs[split_index];\n\t}\n\n\tif (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {\n\t\t/*\n\t\t * Left-right contig implies this.\n\t\t */\n\t\tBUG_ON(!ctxt->c_split_covers_rec);\n\n\t\t/*\n\t\t * Since the leftright insert always covers the entire\n\t\t * extent, this call will delete the insert record\n\t\t * entirely, resulting in an empty extent record added to\n\t\t * the extent block.\n\t\t *\n\t\t * Since the adding of an empty extent shifts\n\t\t * everything back to the right, there's no need to\n\t\t * update split_index here.\n\t\t *\n\t\t * When the split_index is zero, we need to merge it to the\n\t\t * prevoius extent block. It is more efficient and easier\n\t\t * if we do merge_right first and merge_left later.\n\t\t */\n\t\tret = ocfs2_merge_rec_right(path, handle, et, split_rec,\n\t\t\t\t\t    split_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We can only get this from logic error above.\n\t\t */\n\t\tBUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The merge left us with an empty extent, remove it. */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trec = &el->l_recs[split_index];\n\n\t\t/*\n\t\t * Note that we don't pass split_rec here on purpose -\n\t\t * we've merged it into the rec already.\n\t\t */\n\t\tret = ocfs2_merge_rec_left(path, handle, et, rec,\n\t\t\t\t\t   dealloc, split_index);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\t/*\n\t\t * Error from this last rotate is not critical, so\n\t\t * print but don't bubble it up.\n\t\t */\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * Merge a record to the left or right.\n\t\t *\n\t\t * 'contig_type' is relative to the existing record,\n\t\t * so for example, if we're \"right contig\", it's to\n\t\t * the record on the left (hence the left merge).\n\t\t */\n\t\tif (ctxt->c_contig_type == CONTIG_RIGHT) {\n\t\t\tret = ocfs2_merge_rec_left(path, handle, et,\n\t\t\t\t\t\t   split_rec, dealloc,\n\t\t\t\t\t\t   split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ocfs2_merge_rec_right(path, handle,\n\t\t\t\t\t\t    et, split_rec,\n\t\t\t\t\t\t    split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ctxt->c_split_covers_rec) {\n\t\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tpath);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The merge may have left an empty extent in\n\t\t\t * our leaf. Try to rotate it away.\n\t\t\t */\n\t\t\tret = ocfs2_rotate_tree_left(handle, et, path,\n\t\t\t\t\t\t     dealloc);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_and_insert",
          "args": [
            "handle",
            "et",
            "path",
            "&last_eb_bh",
            "split_index",
            "split_rec",
            "meta_ac"
          ],
          "line": 5135
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_and_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4918-5028",
          "snippet": "static int ocfs2_split_and_insert(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct buffer_head **last_eb_bh,\n\t\t\t\t  int split_index,\n\t\t\t\t  struct ocfs2_extent_rec *orig_split_rec,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret = 0, depth;\n\tunsigned int insert_range, rec_range, do_leftright = 0;\n\tstruct ocfs2_extent_rec tmprec;\n\tstruct ocfs2_extent_list *rightmost_el;\n\tstruct ocfs2_extent_rec rec;\n\tstruct ocfs2_extent_rec split_rec = *orig_split_rec;\n\tstruct ocfs2_insert_type insert;\n\tstruct ocfs2_extent_block *eb;\n\nleftright:\n\t/*\n\t * Store a copy of the record on the stack - it might move\n\t * around as the tree is manipulated below.\n\t */\n\trec = path_leaf_el(path)->l_recs[split_index];\n\n\trightmost_el = et->et_root_el;\n\n\tdepth = le16_to_cpu(rightmost_el->l_tree_depth);\n\tif (depth) {\n\t\tBUG_ON(!(*last_eb_bh));\n\t\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\t\trightmost_el = &eb->h_list;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et,\n\t\t\t\t      &depth, last_eb_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_tree_depth = depth;\n\n\tinsert_range = le32_to_cpu(split_rec.e_cpos) +\n\t\tle16_to_cpu(split_rec.e_leaf_clusters);\n\trec_range = le32_to_cpu(rec.e_cpos) +\n\t\tle16_to_cpu(rec.e_leaf_clusters);\n\n\tif (split_rec.e_cpos == rec.e_cpos) {\n\t\tinsert.ins_split = SPLIT_LEFT;\n\t} else if (insert_range == rec_range) {\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\t} else {\n\t\t/*\n\t\t * Left/right split. We fake this as a right split\n\t\t * first and then make a second pass as a left split.\n\t\t */\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\n\t\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t   &tmprec, insert_range, &rec);\n\n\t\tsplit_rec = tmprec;\n\n\t\tBUG_ON(do_leftright);\n\t\tdo_leftright = 1;\n\t}\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (do_leftright == 1) {\n\t\tu32 cpos;\n\t\tstruct ocfs2_extent_list *el;\n\n\t\tdo_leftright++;\n\t\tsplit_rec = *orig_split_rec;\n\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tcpos = le32_to_cpu(split_rec.e_cpos);\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tsplit_index = ocfs2_search_extent_list(el, cpos);\n\t\tif (split_index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto leftright;\n\t}\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_split_and_insert(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct buffer_head **last_eb_bh,\n\t\t\t\t  int split_index,\n\t\t\t\t  struct ocfs2_extent_rec *orig_split_rec,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret = 0, depth;\n\tunsigned int insert_range, rec_range, do_leftright = 0;\n\tstruct ocfs2_extent_rec tmprec;\n\tstruct ocfs2_extent_list *rightmost_el;\n\tstruct ocfs2_extent_rec rec;\n\tstruct ocfs2_extent_rec split_rec = *orig_split_rec;\n\tstruct ocfs2_insert_type insert;\n\tstruct ocfs2_extent_block *eb;\n\nleftright:\n\t/*\n\t * Store a copy of the record on the stack - it might move\n\t * around as the tree is manipulated below.\n\t */\n\trec = path_leaf_el(path)->l_recs[split_index];\n\n\trightmost_el = et->et_root_el;\n\n\tdepth = le16_to_cpu(rightmost_el->l_tree_depth);\n\tif (depth) {\n\t\tBUG_ON(!(*last_eb_bh));\n\t\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\t\trightmost_el = &eb->h_list;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et,\n\t\t\t\t      &depth, last_eb_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_tree_depth = depth;\n\n\tinsert_range = le32_to_cpu(split_rec.e_cpos) +\n\t\tle16_to_cpu(split_rec.e_leaf_clusters);\n\trec_range = le32_to_cpu(rec.e_cpos) +\n\t\tle16_to_cpu(rec.e_leaf_clusters);\n\n\tif (split_rec.e_cpos == rec.e_cpos) {\n\t\tinsert.ins_split = SPLIT_LEFT;\n\t} else if (insert_range == rec_range) {\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\t} else {\n\t\t/*\n\t\t * Left/right split. We fake this as a right split\n\t\t * first and then make a second pass as a left split.\n\t\t */\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\n\t\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t   &tmprec, insert_range, &rec);\n\n\t\tsplit_rec = tmprec;\n\n\t\tBUG_ON(do_leftright);\n\t\tdo_leftright = 1;\n\t}\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (do_leftright == 1) {\n\t\tu32 cpos;\n\t\tstruct ocfs2_extent_list *el;\n\n\t\tdo_leftright++;\n\t\tsplit_rec = *orig_split_rec;\n\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tcpos = le32_to_cpu(split_rec.e_cpos);\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tsplit_index = ocfs2_search_extent_list(el, cpos);\n\t\tif (split_index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto leftright;\n\t}\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_replace_extent_rec",
          "args": [
            "handle",
            "et",
            "path",
            "el",
            "split_index",
            "split_rec"
          ],
          "line": 5132
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replace_extent_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "5030-5051",
          "snippet": "static int ocfs2_replace_extent_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_extent_list *el,\n\t\t\t\t    int split_index,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tint ret;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel->l_recs[split_index] = *split_rec;\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_replace_extent_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_extent_list *el,\n\t\t\t\t    int split_index,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tint ret;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel->l_recs[split_index] = *split_rec;\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_split_extent",
          "args": [
            "split_index",
            "ctxt.c_contig_type",
            "ctxt.c_has_empty_extent",
            "ctxt.c_split_covers_rec"
          ],
          "line": 5126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 5124
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "ocfs2_et_get_last_eb_blk(et)",
            "&last_eb_bh"
          ],
          "line": 5109
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "944-958",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_get_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "513-516",
          "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_merge_contig_type",
          "args": [
            "et",
            "path",
            "el",
            "split_index",
            "split_rec",
            "&ctxt"
          ],
          "line": 5094
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_merge_contig_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4365-4491",
          "snippet": "static int ocfs2_figure_merge_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *path,\n\t\t\t       struct ocfs2_extent_list *el, int index,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       struct ocfs2_merge_ctxt *ctxt)\n{\n\tint status = 0;\n\tenum ocfs2_contig_type ret = CONTIG_NONE;\n\tu32 left_cpos, right_cpos;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_list *new_el;\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_block *eb;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (index > 0) {\n\t\trec = &el->l_recs[index - 1];\n\t} else if (path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (status)\n\t\t\tgoto exit;\n\n\t\tif (left_cpos != 0) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tstatus = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t\t left_cpos);\n\t\t\tif (status)\n\t\t\t\tgoto free_left_path;\n\n\t\t\tnew_el = path_leaf_el(left_path);\n\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) !=\n\t\t\t    le16_to_cpu(new_el->l_count)) {\n\t\t\t\tbh = path_leaf_bh(left_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d.  It should have matched the l_count of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_count));\n\t\t\t\tgoto free_left_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[\n\t\t\t\tle16_to_cpu(new_el->l_next_free_rec) - 1];\n\t\t}\n\t}\n\n\t/*\n\t * We're careful to check for an empty extent record here -\n\t * the merge code will know what to do if it sees one.\n\t */\n\tif (rec) {\n\t\tif (index == 1 && ocfs2_is_empty_extent(rec)) {\n\t\t\tif (split_rec->e_cpos == el->l_recs[index].e_cpos)\n\t\t\t\tret = CONTIG_RIGHT;\n\t\t} else {\n\t\t\tret = ocfs2_et_extent_contig(et, rec, split_rec);\n\t\t}\n\t}\n\n\trec = NULL;\n\tif (index < (le16_to_cpu(el->l_next_free_rec) - 1))\n\t\trec = &el->l_recs[index + 1];\n\telse if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&\n\t\t path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\t\tif (status)\n\t\t\tgoto free_left_path;\n\n\t\tif (right_cpos == 0)\n\t\t\tgoto free_left_path;\n\n\t\tright_path = ocfs2_new_path_from_path(path);\n\t\tif (!right_path) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto free_left_path;\n\t\t}\n\n\t\tstatus = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (status)\n\t\t\tgoto free_right_path;\n\n\t\tnew_el = path_leaf_el(right_path);\n\t\trec = &new_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) <= 1) {\n\t\t\t\tbh = path_leaf_bh(right_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec));\n\t\t\t\tgoto free_right_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[1];\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tenum ocfs2_contig_type contig_type;\n\n\t\tcontig_type = ocfs2_et_extent_contig(et, rec, split_rec);\n\n\t\tif (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)\n\t\t\tret = CONTIG_LEFTRIGHT;\n\t\telse if (ret == CONTIG_NONE)\n\t\t\tret = contig_type;\n\t}\n\nfree_right_path:\n\tocfs2_free_path(right_path);\nfree_left_path:\n\tocfs2_free_path(left_path);\nexit:\n\tif (status == 0)\n\t\tctxt->c_contig_type = ret;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_figure_merge_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *path,\n\t\t\t       struct ocfs2_extent_list *el, int index,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       struct ocfs2_merge_ctxt *ctxt)\n{\n\tint status = 0;\n\tenum ocfs2_contig_type ret = CONTIG_NONE;\n\tu32 left_cpos, right_cpos;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_list *new_el;\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_block *eb;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (index > 0) {\n\t\trec = &el->l_recs[index - 1];\n\t} else if (path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (status)\n\t\t\tgoto exit;\n\n\t\tif (left_cpos != 0) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tstatus = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t\t left_cpos);\n\t\t\tif (status)\n\t\t\t\tgoto free_left_path;\n\n\t\t\tnew_el = path_leaf_el(left_path);\n\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) !=\n\t\t\t    le16_to_cpu(new_el->l_count)) {\n\t\t\t\tbh = path_leaf_bh(left_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d.  It should have matched the l_count of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_count));\n\t\t\t\tgoto free_left_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[\n\t\t\t\tle16_to_cpu(new_el->l_next_free_rec) - 1];\n\t\t}\n\t}\n\n\t/*\n\t * We're careful to check for an empty extent record here -\n\t * the merge code will know what to do if it sees one.\n\t */\n\tif (rec) {\n\t\tif (index == 1 && ocfs2_is_empty_extent(rec)) {\n\t\t\tif (split_rec->e_cpos == el->l_recs[index].e_cpos)\n\t\t\t\tret = CONTIG_RIGHT;\n\t\t} else {\n\t\t\tret = ocfs2_et_extent_contig(et, rec, split_rec);\n\t\t}\n\t}\n\n\trec = NULL;\n\tif (index < (le16_to_cpu(el->l_next_free_rec) - 1))\n\t\trec = &el->l_recs[index + 1];\n\telse if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&\n\t\t path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\t\tif (status)\n\t\t\tgoto free_left_path;\n\n\t\tif (right_cpos == 0)\n\t\t\tgoto free_left_path;\n\n\t\tright_path = ocfs2_new_path_from_path(path);\n\t\tif (!right_path) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto free_left_path;\n\t\t}\n\n\t\tstatus = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (status)\n\t\t\tgoto free_right_path;\n\n\t\tnew_el = path_leaf_el(right_path);\n\t\trec = &new_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) <= 1) {\n\t\t\t\tbh = path_leaf_bh(right_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec));\n\t\t\t\tgoto free_right_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[1];\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tenum ocfs2_contig_type contig_type;\n\n\t\tcontig_type = ocfs2_et_extent_contig(et, rec, split_rec);\n\n\t\tif (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)\n\t\t\tret = CONTIG_LEFTRIGHT;\n\t\telse if (ret == CONTIG_NONE)\n\t\t\tret = contig_type;\n\t}\n\nfree_right_path:\n\tocfs2_free_path(right_path);\nfree_left_path:\n\tocfs2_free_path(left_path);\nexit:\n\tif (status == 0)\n\t\tctxt->c_contig_type = ret;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "split_rec->e_leaf_clusters"
          ],
          "line": 5088
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "split_rec->e_cpos"
          ],
          "line": 5088
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t     split_index,\n\t\t\t\t\t     split_rec,\n\t\t\t\t\t     &ctxt);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_replace_extent_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "5030-5051",
    "snippet": "static int ocfs2_replace_extent_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_extent_list *el,\n\t\t\t\t    int split_index,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tint ret;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel->l_recs[split_index] = *split_rec;\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(path)"
          ],
          "line": 5048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "path",
            "path_num_items(path) - 1"
          ],
          "line": 5039
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "735-750",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 5040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_replace_extent_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_extent_list *el,\n\t\t\t\t    int split_index,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tint ret;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel->l_recs[split_index] = *split_rec;\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_split_and_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4918-5028",
    "snippet": "static int ocfs2_split_and_insert(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct buffer_head **last_eb_bh,\n\t\t\t\t  int split_index,\n\t\t\t\t  struct ocfs2_extent_rec *orig_split_rec,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret = 0, depth;\n\tunsigned int insert_range, rec_range, do_leftright = 0;\n\tstruct ocfs2_extent_rec tmprec;\n\tstruct ocfs2_extent_list *rightmost_el;\n\tstruct ocfs2_extent_rec rec;\n\tstruct ocfs2_extent_rec split_rec = *orig_split_rec;\n\tstruct ocfs2_insert_type insert;\n\tstruct ocfs2_extent_block *eb;\n\nleftright:\n\t/*\n\t * Store a copy of the record on the stack - it might move\n\t * around as the tree is manipulated below.\n\t */\n\trec = path_leaf_el(path)->l_recs[split_index];\n\n\trightmost_el = et->et_root_el;\n\n\tdepth = le16_to_cpu(rightmost_el->l_tree_depth);\n\tif (depth) {\n\t\tBUG_ON(!(*last_eb_bh));\n\t\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\t\trightmost_el = &eb->h_list;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et,\n\t\t\t\t      &depth, last_eb_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_tree_depth = depth;\n\n\tinsert_range = le32_to_cpu(split_rec.e_cpos) +\n\t\tle16_to_cpu(split_rec.e_leaf_clusters);\n\trec_range = le32_to_cpu(rec.e_cpos) +\n\t\tle16_to_cpu(rec.e_leaf_clusters);\n\n\tif (split_rec.e_cpos == rec.e_cpos) {\n\t\tinsert.ins_split = SPLIT_LEFT;\n\t} else if (insert_range == rec_range) {\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\t} else {\n\t\t/*\n\t\t * Left/right split. We fake this as a right split\n\t\t * first and then make a second pass as a left split.\n\t\t */\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\n\t\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t   &tmprec, insert_range, &rec);\n\n\t\tsplit_rec = tmprec;\n\n\t\tBUG_ON(do_leftright);\n\t\tdo_leftright = 1;\n\t}\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (do_leftright == 1) {\n\t\tu32 cpos;\n\t\tstruct ocfs2_extent_list *el;\n\n\t\tdo_leftright++;\n\t\tsplit_rec = *orig_split_rec;\n\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tcpos = le32_to_cpu(split_rec.e_cpos);\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tsplit_index = ocfs2_search_extent_list(el, cpos);\n\t\tif (split_index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto leftright;\n\t}\nout:\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu has an extent at cpos %u which can no longer be found\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 5018
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 5014
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "782-804",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 5013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 5009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "path",
            "cpos"
          ],
          "line": 5007
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "split_rec.e_cpos"
          ],
          "line": 5006
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "path",
            "1"
          ],
          "line": 5004
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "589-616",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_do_insert_extent",
          "args": [
            "handle",
            "et",
            "&split_rec",
            "&insert"
          ],
          "line": 4991
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4253-4363",
          "snippet": "static int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "do_leftright"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_make_right_split_rec",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "&tmprec",
            "insert_range",
            "&rec"
          ],
          "line": 4982
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_make_right_split_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4898-4916",
          "snippet": "static void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec.e_leaf_clusters"
          ],
          "line": 4969
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&insert",
            "0",
            "sizeof(struct ocfs2_insert_type)"
          ],
          "line": 4961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grow_tree",
          "args": [
            "handle",
            "et",
            "&depth",
            "last_eb_bh",
            "meta_ac"
          ],
          "line": 4953
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grow_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1539-1605",
          "snippet": "static int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL && ocfs2_is_dealloc_empty(et));\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL && ocfs2_is_dealloc_empty(et));\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(*last_eb_bh)"
          ],
          "line": 4946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 4940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_split_and_insert(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct buffer_head **last_eb_bh,\n\t\t\t\t  int split_index,\n\t\t\t\t  struct ocfs2_extent_rec *orig_split_rec,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret = 0, depth;\n\tunsigned int insert_range, rec_range, do_leftright = 0;\n\tstruct ocfs2_extent_rec tmprec;\n\tstruct ocfs2_extent_list *rightmost_el;\n\tstruct ocfs2_extent_rec rec;\n\tstruct ocfs2_extent_rec split_rec = *orig_split_rec;\n\tstruct ocfs2_insert_type insert;\n\tstruct ocfs2_extent_block *eb;\n\nleftright:\n\t/*\n\t * Store a copy of the record on the stack - it might move\n\t * around as the tree is manipulated below.\n\t */\n\trec = path_leaf_el(path)->l_recs[split_index];\n\n\trightmost_el = et->et_root_el;\n\n\tdepth = le16_to_cpu(rightmost_el->l_tree_depth);\n\tif (depth) {\n\t\tBUG_ON(!(*last_eb_bh));\n\t\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\t\trightmost_el = &eb->h_list;\n\t}\n\n\tif (le16_to_cpu(rightmost_el->l_next_free_rec) ==\n\t    le16_to_cpu(rightmost_el->l_count)) {\n\t\tret = ocfs2_grow_tree(handle, et,\n\t\t\t\t      &depth, last_eb_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(&insert, 0, sizeof(struct ocfs2_insert_type));\n\tinsert.ins_appending = APPEND_NONE;\n\tinsert.ins_contig = CONTIG_NONE;\n\tinsert.ins_tree_depth = depth;\n\n\tinsert_range = le32_to_cpu(split_rec.e_cpos) +\n\t\tle16_to_cpu(split_rec.e_leaf_clusters);\n\trec_range = le32_to_cpu(rec.e_cpos) +\n\t\tle16_to_cpu(rec.e_leaf_clusters);\n\n\tif (split_rec.e_cpos == rec.e_cpos) {\n\t\tinsert.ins_split = SPLIT_LEFT;\n\t} else if (insert_range == rec_range) {\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\t} else {\n\t\t/*\n\t\t * Left/right split. We fake this as a right split\n\t\t * first and then make a second pass as a left split.\n\t\t */\n\t\tinsert.ins_split = SPLIT_RIGHT;\n\n\t\tocfs2_make_right_split_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t   &tmprec, insert_range, &rec);\n\n\t\tsplit_rec = tmprec;\n\n\t\tBUG_ON(do_leftright);\n\t\tdo_leftright = 1;\n\t}\n\n\tret = ocfs2_do_insert_extent(handle, et, &split_rec, &insert);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (do_leftright == 1) {\n\t\tu32 cpos;\n\t\tstruct ocfs2_extent_list *el;\n\n\t\tdo_leftright++;\n\t\tsplit_rec = *orig_split_rec;\n\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tcpos = le32_to_cpu(split_rec.e_cpos);\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tsplit_index = ocfs2_search_extent_list(el, cpos);\n\t\tif (split_index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has an extent at cpos %u which can no longer be found\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto leftright;\n\t}\nout:\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_make_right_split_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4898-4916",
    "snippet": "static void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&split_rec->e_blkno",
            "ocfs2_clusters_to_blocks(sb, cpos - rec_cpos)"
          ],
          "line": 4912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "cpos - rec_cpos"
          ],
          "line": 4913
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "rec_range - cpos"
          ],
          "line": 4909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cpos"
          ],
          "line": 4908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "split_rec",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 4906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 4904
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 4903
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_make_right_split_rec(struct super_block *sb,\n\t\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t\t       u32 cpos,\n\t\t\t\t       struct ocfs2_extent_rec *rec)\n{\n\tu32 rec_cpos = le32_to_cpu(rec->e_cpos);\n\tu32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);\n\n\tmemset(split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\n\tsplit_rec->e_cpos = cpu_to_le32(cpos);\n\tsplit_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);\n\n\tsplit_rec->e_blkno = rec->e_blkno;\n\tle64_add_cpu(&split_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));\n\n\tsplit_rec->e_flags = rec->e_flags;\n}"
  },
  {
    "function_name": "ocfs2_add_clusters_in_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4786-4896",
    "snippet": "int ocfs2_add_clusters_in_btree(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tu32 *logical_offset,\n\t\t\t\tu32 clusters_to_add,\n\t\t\t\tint mark_unwritten,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tenum ocfs2_alloc_restarted *reason_ret)\n{\n\tint status = 0, err = 0;\n\tint need_free = 0;\n\tint free_extents;\n\tenum ocfs2_alloc_restarted reason = RESTART_NONE;\n\tu32 bit_off, num_bits;\n\tu64 block;\n\tu8 flags = 0;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\tBUG_ON(!clusters_to_add);\n\n\tif (mark_unwritten)\n\t\tflags = OCFS2_EXT_UNWRITTEN;\n\n\tfree_extents = ocfs2_num_free_extents(et);\n\tif (free_extents < 0) {\n\t\tstatus = free_extents;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* there are two cases which could cause us to EAGAIN in the\n\t * we-need-more-metadata case:\n\t * 1) we haven't reserved *any*\n\t * 2) we are so fragmented, we've needed to add metadata too\n\t *    many times. */\n\tif (!free_extents && !meta_ac) {\n\t\terr = -1;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t} else if ((!free_extents)\n\t\t   && (ocfs2_alloc_context_bits_left(meta_ac)\n\t\t       < ocfs2_extend_meta_needed(et->et_root_el))) {\n\t\terr = -2;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t}\n\n\tstatus = __ocfs2_claim_clusters(handle, data_ac, 1,\n\t\t\t\t\tclusters_to_add, &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\t/* reserve our write early -- insert_extent may update the tree root */\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_clusters_in_btree(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t     bit_off, num_bits);\n\tstatus = ocfs2_insert_extent(handle, et, *logical_offset, block,\n\t\t\t\t     num_bits, flags, meta_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tclusters_to_add -= num_bits;\n\t*logical_offset += num_bits;\n\n\tif (clusters_to_add) {\n\t\terr = clusters_to_add;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_TRANS;\n\t}\n\nbail:\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num_bits);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum_bits);\n\t}\n\nleave:\n\tif (reason_ret)\n\t\t*reason_ret = reason;\n\ttrace_ocfs2_add_clusters_in_btree_ret(status, reason, err);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_add_clusters_in_btree_ret",
          "args": [
            "status",
            "reason",
            "err"
          ],
          "line": 4894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_clusters",
          "args": [
            "handle",
            "data_ac->ac_inode",
            "data_ac->ac_bh",
            "ocfs2_clusters_to_blocks(osb->sb, bit_off)",
            "num_bits"
          ],
          "line": 4884
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "2601-2610",
          "snippet": "int ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_clusters(handle_t *handle,\n\t\t\tstruct inode *bitmap_inode,\n\t\t\tstruct buffer_head *bitmap_bh,\n\t\t\tu64 start_blk,\n\t\t\tunsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_set_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "bit_off"
          ],
          "line": 4887
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_local_alloc_bits",
          "args": [
            "osb",
            "handle",
            "data_ac",
            "bit_off",
            "num_bits"
          ],
          "line": 4881
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_local_alloc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/localalloc.c",
          "lines": "780-820",
          "snippet": "int ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
            "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nint ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et->et_root_bh"
          ],
          "line": 4867
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "et",
            "*logical_offset",
            "block",
            "num_bits",
            "flags",
            "meta_ac"
          ],
          "line": 4859
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4716-4777",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_add_clusters_in_btree",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "bit_off",
            "num_bits"
          ],
          "line": 4856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 4857
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4847
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "538-544",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_bits > clusters_to_add"
          ],
          "line": 4844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_claim_clusters",
          "args": [
            "handle",
            "data_ac",
            "1",
            "clusters_to_add",
            "&bit_off",
            "&num_bits"
          ],
          "line": 4836
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "2309-2378",
          "snippet": "int __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "et->et_root_el"
          ],
          "line": 4829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_alloc_context_bits_left",
          "args": [
            "meta_ac"
          ],
          "line": 4828
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_alloc_context_bits_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.h",
          "lines": "67-70",
          "snippet": "static inline int ocfs2_alloc_context_bits_left(struct ocfs2_alloc_context *ac)\n{\n\treturn ac->ac_bits_wanted - ac->ac_bits_given;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_alloc_context_bits_left(struct ocfs2_alloc_context *ac)\n{\n\treturn ac->ac_bits_wanted - ac->ac_bits_given;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_num_free_extents",
          "args": [
            "et"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_num_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "964-994",
          "snippet": "int ocfs2_num_free_extents(struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!clusters_to_add"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 4803
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_add_clusters_in_btree(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tu32 *logical_offset,\n\t\t\t\tu32 clusters_to_add,\n\t\t\t\tint mark_unwritten,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tenum ocfs2_alloc_restarted *reason_ret)\n{\n\tint status = 0, err = 0;\n\tint need_free = 0;\n\tint free_extents;\n\tenum ocfs2_alloc_restarted reason = RESTART_NONE;\n\tu32 bit_off, num_bits;\n\tu64 block;\n\tu8 flags = 0;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\tBUG_ON(!clusters_to_add);\n\n\tif (mark_unwritten)\n\t\tflags = OCFS2_EXT_UNWRITTEN;\n\n\tfree_extents = ocfs2_num_free_extents(et);\n\tif (free_extents < 0) {\n\t\tstatus = free_extents;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* there are two cases which could cause us to EAGAIN in the\n\t * we-need-more-metadata case:\n\t * 1) we haven't reserved *any*\n\t * 2) we are so fragmented, we've needed to add metadata too\n\t *    many times. */\n\tif (!free_extents && !meta_ac) {\n\t\terr = -1;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t} else if ((!free_extents)\n\t\t   && (ocfs2_alloc_context_bits_left(meta_ac)\n\t\t       < ocfs2_extend_meta_needed(et->et_root_el))) {\n\t\terr = -2;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t}\n\n\tstatus = __ocfs2_claim_clusters(handle, data_ac, 1,\n\t\t\t\t\tclusters_to_add, &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\t/* reserve our write early -- insert_extent may update the tree root */\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_clusters_in_btree(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t     bit_off, num_bits);\n\tstatus = ocfs2_insert_extent(handle, et, *logical_offset, block,\n\t\t\t\t     num_bits, flags, meta_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tclusters_to_add -= num_bits;\n\t*logical_offset += num_bits;\n\n\tif (clusters_to_add) {\n\t\terr = clusters_to_add;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_TRANS;\n\t}\n\nbail:\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num_bits);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum_bits);\n\t}\n\nleave:\n\tif (reason_ret)\n\t\t*reason_ret = reason;\n\ttrace_ocfs2_add_clusters_in_btree_ret(status, reason, err);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_insert_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4716-4777",
    "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "last_eb_bh"
          ],
          "line": 4774
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_map_insert",
          "args": [
            "et",
            "&rec"
          ],
          "line": 4771
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_map_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "524-529",
          "snippet": "static inline void ocfs2_et_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\tif (et->et_ops->eo_extent_map_insert)\n\t\tet->et_ops->eo_extent_map_insert(et, rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\tif (et->et_ops->eo_extent_map_insert)\n\t\tet->et_ops->eo_extent_map_insert(et, rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_do_insert_extent",
          "args": [
            "handle",
            "et",
            "&rec",
            "&insert"
          ],
          "line": 4767
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4253-4363",
          "snippet": "static int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_grow_tree",
          "args": [
            "handle",
            "et",
            "&insert.ins_tree_depth",
            "&last_eb_bh",
            "meta_ac"
          ],
          "line": 4757
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_grow_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1539-1605",
          "snippet": "static int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL && ocfs2_is_dealloc_empty(et));\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL && ocfs2_is_dealloc_empty(et));\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_insert_extent",
          "args": [
            "insert.ins_appending",
            "insert.ins_contig",
            "insert.ins_contig_index",
            "free_records",
            "insert.ins_tree_depth"
          ],
          "line": 4752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_insert_type",
          "args": [
            "et",
            "&last_eb_bh",
            "&rec",
            "&free_records",
            "&insert"
          ],
          "line": 4745
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_insert_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4586-4709",
          "snippet": "static int ocfs2_figure_insert_type(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    int *free_records,\n\t\t\t\t    struct ocfs2_insert_type *insert)\n{\n\tint ret;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinsert->ins_split = SPLIT_NONE;\n\n\tel = et->et_root_el;\n\tinsert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);\n\n\tif (el->l_tree_depth) {\n\t\t/*\n\t\t * If we have tree depth, we read in the\n\t\t * rightmost extent block ahead of time as\n\t\t * ocfs2_figure_insert_type() and ocfs2_add_branch()\n\t\t * may want it later.\n\t\t */\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\t/*\n\t * Unless we have a contiguous insert, we'll need to know if\n\t * there is room left in our allocation tree for another\n\t * extent record.\n\t *\n\t * XXX: This test is simplistic, we can search for empty\n\t * extent records too.\n\t */\n\t*free_records = le16_to_cpu(el->l_count) -\n\t\tle16_to_cpu(el->l_next_free_rec);\n\n\tif (!insert->ins_tree_depth) {\n\t\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t\treturn 0;\n\t}\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * In the case that we're inserting past what the tree\n\t * currently accounts for, ocfs2_find_path() will return for\n\t * us the rightmost tree path. This is accounted for below in\n\t * the appending code.\n\t */\n\tret = ocfs2_find_path(et->et_ci, path, le32_to_cpu(insert_rec->e_cpos));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\t/*\n\t * Now that we have the path, there's two things we want to determine:\n\t * 1) Contiguousness (also set contig_index if this is so)\n\t *\n\t * 2) Are we doing an append? We can trivially break this up\n         *     into two types of appends: simple record append, or a\n         *     rotate inside the tail leaf.\n\t */\n\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\n\t/*\n\t * The insert code isn't quite ready to deal with all cases of\n\t * left contiguousness. Specifically, if it's an insert into\n\t * the 1st record in a leaf, it will require the adjustment of\n\t * cluster count on the last record of the path directly to it's\n\t * left. For now, just catch that case and fool the layers\n\t * above us. This works just fine for tree_depth == 0, which\n\t * is why we allow that above.\n\t */\n\tif (insert->ins_contig == CONTIG_LEFT &&\n\t    insert->ins_contig_index == 0)\n\t\tinsert->ins_contig = CONTIG_NONE;\n\n\t/*\n\t * Ok, so we can simply compare against last_eb to figure out\n\t * whether the path doesn't exist. This will only happen in\n\t * the case that we're doing a tail append, so maybe we can\n\t * take advantage of that information somehow.\n\t */\n\tif (ocfs2_et_get_last_eb_blk(et) ==\n\t    path_leaf_bh(path)->b_blocknr) {\n\t\t/*\n\t\t * Ok, ocfs2_find_path() returned us the rightmost\n\t\t * tree path. This might be an appending insert. There are\n\t\t * two cases:\n\t\t *    1) We're doing a true append at the tail:\n\t\t *\t-This might even be off the end of the leaf\n\t\t *    2) We're \"appending\" by rotating in the tail\n\t\t */\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\n\tif (ret == 0)\n\t\t*last_eb_bh = bh;\n\telse\n\t\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_figure_insert_type(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    int *free_records,\n\t\t\t\t    struct ocfs2_insert_type *insert)\n{\n\tint ret;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinsert->ins_split = SPLIT_NONE;\n\n\tel = et->et_root_el;\n\tinsert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);\n\n\tif (el->l_tree_depth) {\n\t\t/*\n\t\t * If we have tree depth, we read in the\n\t\t * rightmost extent block ahead of time as\n\t\t * ocfs2_figure_insert_type() and ocfs2_add_branch()\n\t\t * may want it later.\n\t\t */\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\t/*\n\t * Unless we have a contiguous insert, we'll need to know if\n\t * there is room left in our allocation tree for another\n\t * extent record.\n\t *\n\t * XXX: This test is simplistic, we can search for empty\n\t * extent records too.\n\t */\n\t*free_records = le16_to_cpu(el->l_count) -\n\t\tle16_to_cpu(el->l_next_free_rec);\n\n\tif (!insert->ins_tree_depth) {\n\t\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t\treturn 0;\n\t}\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * In the case that we're inserting past what the tree\n\t * currently accounts for, ocfs2_find_path() will return for\n\t * us the rightmost tree path. This is accounted for below in\n\t * the appending code.\n\t */\n\tret = ocfs2_find_path(et->et_ci, path, le32_to_cpu(insert_rec->e_cpos));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\t/*\n\t * Now that we have the path, there's two things we want to determine:\n\t * 1) Contiguousness (also set contig_index if this is so)\n\t *\n\t * 2) Are we doing an append? We can trivially break this up\n         *     into two types of appends: simple record append, or a\n         *     rotate inside the tail leaf.\n\t */\n\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\n\t/*\n\t * The insert code isn't quite ready to deal with all cases of\n\t * left contiguousness. Specifically, if it's an insert into\n\t * the 1st record in a leaf, it will require the adjustment of\n\t * cluster count on the last record of the path directly to it's\n\t * left. For now, just catch that case and fool the layers\n\t * above us. This works just fine for tree_depth == 0, which\n\t * is why we allow that above.\n\t */\n\tif (insert->ins_contig == CONTIG_LEFT &&\n\t    insert->ins_contig_index == 0)\n\t\tinsert->ins_contig = CONTIG_NONE;\n\n\t/*\n\t * Ok, so we can simply compare against last_eb to figure out\n\t * whether the path doesn't exist. This will only happen in\n\t * the case that we're doing a tail append, so maybe we can\n\t * take advantage of that information somehow.\n\t */\n\tif (ocfs2_et_get_last_eb_blk(et) ==\n\t    path_leaf_bh(path)->b_blocknr) {\n\t\t/*\n\t\t * Ok, ocfs2_find_path() returned us the rightmost\n\t\t * tree path. This might be an appending insert. There are\n\t\t * two cases:\n\t\t *    1) We're doing a true append at the tail:\n\t\t *\t-This might even be off the end of the leaf\n\t\t *    2) We're \"appending\" by rotating in the tail\n\t\t */\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\n\tif (ret == 0)\n\t\t*last_eb_bh = bh;\n\telse\n\t\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_insert_check",
          "args": [
            "et",
            "&rec"
          ],
          "line": 4739
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_insert_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "559-567",
          "snippet": "static inline int ocfs2_et_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_extent_rec *rec)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_insert_check)\n\t\tret = et->et_ops->eo_insert_check(et, rec);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_extent_rec *rec)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_insert_check)\n\t\tret = et->et_ops->eo_insert_check(et, rec);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "new_clusters"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "start_blk"
          ],
          "line": 4736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cpos"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rec",
            "0",
            "sizeof(rec)"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_insert_extent_start",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "cpos",
            "new_clusters"
          ],
          "line": 4730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 4731
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_figure_insert_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4586-4709",
    "snippet": "static int ocfs2_figure_insert_type(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    int *free_records,\n\t\t\t\t    struct ocfs2_insert_type *insert)\n{\n\tint ret;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinsert->ins_split = SPLIT_NONE;\n\n\tel = et->et_root_el;\n\tinsert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);\n\n\tif (el->l_tree_depth) {\n\t\t/*\n\t\t * If we have tree depth, we read in the\n\t\t * rightmost extent block ahead of time as\n\t\t * ocfs2_figure_insert_type() and ocfs2_add_branch()\n\t\t * may want it later.\n\t\t */\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\t/*\n\t * Unless we have a contiguous insert, we'll need to know if\n\t * there is room left in our allocation tree for another\n\t * extent record.\n\t *\n\t * XXX: This test is simplistic, we can search for empty\n\t * extent records too.\n\t */\n\t*free_records = le16_to_cpu(el->l_count) -\n\t\tle16_to_cpu(el->l_next_free_rec);\n\n\tif (!insert->ins_tree_depth) {\n\t\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t\treturn 0;\n\t}\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * In the case that we're inserting past what the tree\n\t * currently accounts for, ocfs2_find_path() will return for\n\t * us the rightmost tree path. This is accounted for below in\n\t * the appending code.\n\t */\n\tret = ocfs2_find_path(et->et_ci, path, le32_to_cpu(insert_rec->e_cpos));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\t/*\n\t * Now that we have the path, there's two things we want to determine:\n\t * 1) Contiguousness (also set contig_index if this is so)\n\t *\n\t * 2) Are we doing an append? We can trivially break this up\n         *     into two types of appends: simple record append, or a\n         *     rotate inside the tail leaf.\n\t */\n\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\n\t/*\n\t * The insert code isn't quite ready to deal with all cases of\n\t * left contiguousness. Specifically, if it's an insert into\n\t * the 1st record in a leaf, it will require the adjustment of\n\t * cluster count on the last record of the path directly to it's\n\t * left. For now, just catch that case and fool the layers\n\t * above us. This works just fine for tree_depth == 0, which\n\t * is why we allow that above.\n\t */\n\tif (insert->ins_contig == CONTIG_LEFT &&\n\t    insert->ins_contig_index == 0)\n\t\tinsert->ins_contig = CONTIG_NONE;\n\n\t/*\n\t * Ok, so we can simply compare against last_eb to figure out\n\t * whether the path doesn't exist. This will only happen in\n\t * the case that we're doing a tail append, so maybe we can\n\t * take advantage of that information somehow.\n\t */\n\tif (ocfs2_et_get_last_eb_blk(et) ==\n\t    path_leaf_bh(path)->b_blocknr) {\n\t\t/*\n\t\t * Ok, ocfs2_find_path() returned us the rightmost\n\t\t * tree path. This might be an appending insert. There are\n\t\t * two cases:\n\t\t *    1) We're doing a true append at the tail:\n\t\t *\t-This might even be off the end of the leaf\n\t\t *    2) We're \"appending\" by rotating in the tail\n\t\t */\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\n\tif (ret == 0)\n\t\t*last_eb_bh = bh;\n\telse\n\t\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 4707
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 4702
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_appending_type",
          "args": [
            "insert",
            "el",
            "insert_rec"
          ],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_appending_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4539-4571",
          "snippet": "static void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\n\t\t\t\t\tstruct ocfs2_extent_list *el,\n\t\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tu32 cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tinsert->ins_appending = APPEND_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (!el->l_next_free_rec)\n\t\tgoto set_tail_append;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\t/* Were all records empty? */\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 1)\n\t\t\tgoto set_tail_append;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\n\tif (cpos >=\n\t    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))\n\t\tgoto set_tail_append;\n\n\treturn;\n\nset_tail_append:\n\tinsert->ins_appending = APPEND_TAIL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\n\t\t\t\t\tstruct ocfs2_extent_list *el,\n\t\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tu32 cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tinsert->ins_appending = APPEND_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (!el->l_next_free_rec)\n\t\tgoto set_tail_append;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\t/* Were all records empty? */\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 1)\n\t\t\tgoto set_tail_append;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\n\tif (cpos >=\n\t    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))\n\t\tgoto set_tail_append;\n\n\treturn;\n\nset_tail_append:\n\tinsert->ins_appending = APPEND_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 4688
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_get_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "513-516",
          "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_figure_contig_type",
          "args": [
            "et",
            "insert",
            "el",
            "insert_rec"
          ],
          "line": 4667
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_figure_contig_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4493-4527",
          "snippet": "static void ocfs2_figure_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_insert_type *insert,\n\t\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t\t     struct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tenum ocfs2_contig_type contig_type = CONTIG_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\tcontig_type = ocfs2_et_extent_contig(et, &el->l_recs[i],\n\t\t\t\t\t\t     insert_rec);\n\t\tif (contig_type != CONTIG_NONE) {\n\t\t\tinsert->ins_contig_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinsert->ins_contig = contig_type;\n\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\tstruct ocfs2_extent_rec *rec =\n\t\t\t\t&el->l_recs[insert->ins_contig_index];\n\t\tunsigned int len = le16_to_cpu(rec->e_leaf_clusters) +\n\t\t\t\t   le16_to_cpu(insert_rec->e_leaf_clusters);\n\n\t\t/*\n\t\t * Caller might want us to limit the size of extents, don't\n\t\t * calculate contiguousness if we might exceed that limit.\n\t\t */\n\t\tif (et->et_max_leaf_clusters &&\n\t\t    (len > et->et_max_leaf_clusters))\n\t\t\tinsert->ins_contig = CONTIG_NONE;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_figure_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_insert_type *insert,\n\t\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t\t     struct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tenum ocfs2_contig_type contig_type = CONTIG_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\tcontig_type = ocfs2_et_extent_contig(et, &el->l_recs[i],\n\t\t\t\t\t\t     insert_rec);\n\t\tif (contig_type != CONTIG_NONE) {\n\t\t\tinsert->ins_contig_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinsert->ins_contig = contig_type;\n\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\tstruct ocfs2_extent_rec *rec =\n\t\t\t\t&el->l_recs[insert->ins_contig_index];\n\t\tunsigned int len = le16_to_cpu(rec->e_leaf_clusters) +\n\t\t\t\t   le16_to_cpu(insert_rec->e_leaf_clusters);\n\n\t\t/*\n\t\t * Caller might want us to limit the size of extents, don't\n\t\t * calculate contiguousness if we might exceed that limit.\n\t\t */\n\t\tif (et->et_max_leaf_clusters &&\n\t\t    (len > et->et_max_leaf_clusters))\n\t\t\tinsert->ins_contig = CONTIG_NONE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 4657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "path",
            "le32_to_cpu(insert_rec->e_cpos)"
          ],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "insert_rec->e_cpos"
          ],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 4638
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "722-726",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 4630
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "ocfs2_et_get_last_eb_blk(et)",
            "&bh"
          ],
          "line": 4610
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "944-958",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_figure_insert_type(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    int *free_records,\n\t\t\t\t    struct ocfs2_insert_type *insert)\n{\n\tint ret;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\tstruct buffer_head *bh = NULL;\n\n\tinsert->ins_split = SPLIT_NONE;\n\n\tel = et->et_root_el;\n\tinsert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);\n\n\tif (el->l_tree_depth) {\n\t\t/*\n\t\t * If we have tree depth, we read in the\n\t\t * rightmost extent block ahead of time as\n\t\t * ocfs2_figure_insert_type() and ocfs2_add_branch()\n\t\t * may want it later.\n\t\t */\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\t/*\n\t * Unless we have a contiguous insert, we'll need to know if\n\t * there is room left in our allocation tree for another\n\t * extent record.\n\t *\n\t * XXX: This test is simplistic, we can search for empty\n\t * extent records too.\n\t */\n\t*free_records = le16_to_cpu(el->l_count) -\n\t\tle16_to_cpu(el->l_next_free_rec);\n\n\tif (!insert->ins_tree_depth) {\n\t\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t\treturn 0;\n\t}\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * In the case that we're inserting past what the tree\n\t * currently accounts for, ocfs2_find_path() will return for\n\t * us the rightmost tree path. This is accounted for below in\n\t * the appending code.\n\t */\n\tret = ocfs2_find_path(et->et_ci, path, le32_to_cpu(insert_rec->e_cpos));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\t/*\n\t * Now that we have the path, there's two things we want to determine:\n\t * 1) Contiguousness (also set contig_index if this is so)\n\t *\n\t * 2) Are we doing an append? We can trivially break this up\n         *     into two types of appends: simple record append, or a\n         *     rotate inside the tail leaf.\n\t */\n\tocfs2_figure_contig_type(et, insert, el, insert_rec);\n\n\t/*\n\t * The insert code isn't quite ready to deal with all cases of\n\t * left contiguousness. Specifically, if it's an insert into\n\t * the 1st record in a leaf, it will require the adjustment of\n\t * cluster count on the last record of the path directly to it's\n\t * left. For now, just catch that case and fool the layers\n\t * above us. This works just fine for tree_depth == 0, which\n\t * is why we allow that above.\n\t */\n\tif (insert->ins_contig == CONTIG_LEFT &&\n\t    insert->ins_contig_index == 0)\n\t\tinsert->ins_contig = CONTIG_NONE;\n\n\t/*\n\t * Ok, so we can simply compare against last_eb to figure out\n\t * whether the path doesn't exist. This will only happen in\n\t * the case that we're doing a tail append, so maybe we can\n\t * take advantage of that information somehow.\n\t */\n\tif (ocfs2_et_get_last_eb_blk(et) ==\n\t    path_leaf_bh(path)->b_blocknr) {\n\t\t/*\n\t\t * Ok, ocfs2_find_path() returned us the rightmost\n\t\t * tree path. This might be an appending insert. There are\n\t\t * two cases:\n\t\t *    1) We're doing a true append at the tail:\n\t\t *\t-This might even be off the end of the leaf\n\t\t *    2) We're \"appending\" by rotating in the tail\n\t\t */\n\t\tocfs2_figure_appending_type(insert, el, insert_rec);\n\t}\n\nout:\n\tocfs2_free_path(path);\n\n\tif (ret == 0)\n\t\t*last_eb_bh = bh;\n\telse\n\t\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_figure_appending_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4539-4571",
    "snippet": "static void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\n\t\t\t\t\tstruct ocfs2_extent_list *el,\n\t\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tu32 cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tinsert->ins_appending = APPEND_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (!el->l_next_free_rec)\n\t\tgoto set_tail_append;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\t/* Were all records empty? */\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 1)\n\t\t\tgoto set_tail_append;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\n\tif (cpos >=\n\t    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))\n\t\tgoto set_tail_append;\n\n\treturn;\n\nset_tail_append:\n\tinsert->ins_appending = APPEND_TAIL;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 4564
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 4564
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 4554
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_tree_depth) != 0"
          ],
          "line": 4549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\n\t\t\t\t\tstruct ocfs2_extent_list *el,\n\t\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tu32 cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tinsert->ins_appending = APPEND_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (!el->l_next_free_rec)\n\t\tgoto set_tail_append;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\t/* Were all records empty? */\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 1)\n\t\t\tgoto set_tail_append;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\n\tif (cpos >=\n\t    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))\n\t\tgoto set_tail_append;\n\n\treturn;\n\nset_tail_append:\n\tinsert->ins_appending = APPEND_TAIL;\n}"
  },
  {
    "function_name": "ocfs2_figure_contig_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4493-4527",
    "snippet": "static void ocfs2_figure_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_insert_type *insert,\n\t\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t\t     struct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tenum ocfs2_contig_type contig_type = CONTIG_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\tcontig_type = ocfs2_et_extent_contig(et, &el->l_recs[i],\n\t\t\t\t\t\t     insert_rec);\n\t\tif (contig_type != CONTIG_NONE) {\n\t\t\tinsert->ins_contig_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinsert->ins_contig = contig_type;\n\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\tstruct ocfs2_extent_rec *rec =\n\t\t\t\t&el->l_recs[insert->ins_contig_index];\n\t\tunsigned int len = le16_to_cpu(rec->e_leaf_clusters) +\n\t\t\t\t   le16_to_cpu(insert_rec->e_leaf_clusters);\n\n\t\t/*\n\t\t * Caller might want us to limit the size of extents, don't\n\t\t * calculate contiguousness if we might exceed that limit.\n\t\t */\n\t\tif (et->et_max_leaf_clusters &&\n\t\t    (len > et->et_max_leaf_clusters))\n\t\t\tinsert->ins_contig = CONTIG_NONE;\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "insert_rec->e_leaf_clusters"
          ],
          "line": 4517
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_contig",
          "args": [
            "et",
            "&el->l_recs[i]",
            "insert_rec"
          ],
          "line": 4504
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "546-557",
          "snippet": "static inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_tree_depth) != 0"
          ],
          "line": 4501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_figure_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_insert_type *insert,\n\t\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t\t     struct ocfs2_extent_rec *insert_rec)\n{\n\tint i;\n\tenum ocfs2_contig_type contig_type = CONTIG_NONE;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\tcontig_type = ocfs2_et_extent_contig(et, &el->l_recs[i],\n\t\t\t\t\t\t     insert_rec);\n\t\tif (contig_type != CONTIG_NONE) {\n\t\t\tinsert->ins_contig_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinsert->ins_contig = contig_type;\n\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\tstruct ocfs2_extent_rec *rec =\n\t\t\t\t&el->l_recs[insert->ins_contig_index];\n\t\tunsigned int len = le16_to_cpu(rec->e_leaf_clusters) +\n\t\t\t\t   le16_to_cpu(insert_rec->e_leaf_clusters);\n\n\t\t/*\n\t\t * Caller might want us to limit the size of extents, don't\n\t\t * calculate contiguousness if we might exceed that limit.\n\t\t */\n\t\tif (et->et_max_leaf_clusters &&\n\t\t    (len > et->et_max_leaf_clusters))\n\t\t\tinsert->ins_contig = CONTIG_NONE;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_figure_merge_contig_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4365-4491",
    "snippet": "static int ocfs2_figure_merge_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *path,\n\t\t\t       struct ocfs2_extent_list *el, int index,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       struct ocfs2_merge_ctxt *ctxt)\n{\n\tint status = 0;\n\tenum ocfs2_contig_type ret = CONTIG_NONE;\n\tu32 left_cpos, right_cpos;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_list *new_el;\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_block *eb;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (index > 0) {\n\t\trec = &el->l_recs[index - 1];\n\t} else if (path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (status)\n\t\t\tgoto exit;\n\n\t\tif (left_cpos != 0) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tstatus = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t\t left_cpos);\n\t\t\tif (status)\n\t\t\t\tgoto free_left_path;\n\n\t\t\tnew_el = path_leaf_el(left_path);\n\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) !=\n\t\t\t    le16_to_cpu(new_el->l_count)) {\n\t\t\t\tbh = path_leaf_bh(left_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d.  It should have matched the l_count of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_count));\n\t\t\t\tgoto free_left_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[\n\t\t\t\tle16_to_cpu(new_el->l_next_free_rec) - 1];\n\t\t}\n\t}\n\n\t/*\n\t * We're careful to check for an empty extent record here -\n\t * the merge code will know what to do if it sees one.\n\t */\n\tif (rec) {\n\t\tif (index == 1 && ocfs2_is_empty_extent(rec)) {\n\t\t\tif (split_rec->e_cpos == el->l_recs[index].e_cpos)\n\t\t\t\tret = CONTIG_RIGHT;\n\t\t} else {\n\t\t\tret = ocfs2_et_extent_contig(et, rec, split_rec);\n\t\t}\n\t}\n\n\trec = NULL;\n\tif (index < (le16_to_cpu(el->l_next_free_rec) - 1))\n\t\trec = &el->l_recs[index + 1];\n\telse if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&\n\t\t path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\t\tif (status)\n\t\t\tgoto free_left_path;\n\n\t\tif (right_cpos == 0)\n\t\t\tgoto free_left_path;\n\n\t\tright_path = ocfs2_new_path_from_path(path);\n\t\tif (!right_path) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto free_left_path;\n\t\t}\n\n\t\tstatus = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (status)\n\t\t\tgoto free_right_path;\n\n\t\tnew_el = path_leaf_el(right_path);\n\t\trec = &new_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) <= 1) {\n\t\t\t\tbh = path_leaf_bh(right_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec));\n\t\t\t\tgoto free_right_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[1];\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tenum ocfs2_contig_type contig_type;\n\n\t\tcontig_type = ocfs2_et_extent_contig(et, rec, split_rec);\n\n\t\tif (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)\n\t\t\tret = CONTIG_LEFTRIGHT;\n\t\telse if (ret == CONTIG_NONE)\n\t\t\tret = contig_type;\n\t}\n\nfree_right_path:\n\tocfs2_free_path(right_path);\nfree_left_path:\n\tocfs2_free_path(left_path);\nexit:\n\tif (status == 0)\n\t\tctxt->c_contig_type = ret;\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 4485
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_extent_contig",
          "args": [
            "et",
            "rec",
            "split_rec"
          ],
          "line": 4474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_extent_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "546-557",
          "snippet": "static inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Extent block #%llu has an invalid l_next_free_rec of %d\\n\"",
            "(unsigned long long)le64_to_cpu(eb->h_blkno)",
            "le16_to_cpu(new_el->l_next_free_rec)"
          ],
          "line": 4461
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "new_el->l_next_free_rec"
          ],
          "line": 4464
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 4463
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 4459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "rec"
          ],
          "line": 4457
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 4455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "right_path",
            "right_cpos"
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "path"
          ],
          "line": 4444
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "716-720",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_right_leaf",
          "args": [
            "sb",
            "path",
            "&right_cpos"
          ],
          "line": 4437
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_right_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2820-2887",
          "snippet": "int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 4405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "sb",
            "path",
            "&left_cpos"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2225-2291",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 4379
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_figure_merge_contig_type(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *path,\n\t\t\t       struct ocfs2_extent_list *el, int index,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       struct ocfs2_merge_ctxt *ctxt)\n{\n\tint status = 0;\n\tenum ocfs2_contig_type ret = CONTIG_NONE;\n\tu32 left_cpos, right_cpos;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_list *new_el;\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_block *eb;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (index > 0) {\n\t\trec = &el->l_recs[index - 1];\n\t} else if (path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_left_leaf(sb, path, &left_cpos);\n\t\tif (status)\n\t\t\tgoto exit;\n\n\t\tif (left_cpos != 0) {\n\t\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\t\tif (!left_path) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tstatus = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t\t left_cpos);\n\t\t\tif (status)\n\t\t\t\tgoto free_left_path;\n\n\t\t\tnew_el = path_leaf_el(left_path);\n\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) !=\n\t\t\t    le16_to_cpu(new_el->l_count)) {\n\t\t\t\tbh = path_leaf_bh(left_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d.  It should have matched the l_count of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_count));\n\t\t\t\tgoto free_left_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[\n\t\t\t\tle16_to_cpu(new_el->l_next_free_rec) - 1];\n\t\t}\n\t}\n\n\t/*\n\t * We're careful to check for an empty extent record here -\n\t * the merge code will know what to do if it sees one.\n\t */\n\tif (rec) {\n\t\tif (index == 1 && ocfs2_is_empty_extent(rec)) {\n\t\t\tif (split_rec->e_cpos == el->l_recs[index].e_cpos)\n\t\t\t\tret = CONTIG_RIGHT;\n\t\t} else {\n\t\t\tret = ocfs2_et_extent_contig(et, rec, split_rec);\n\t\t}\n\t}\n\n\trec = NULL;\n\tif (index < (le16_to_cpu(el->l_next_free_rec) - 1))\n\t\trec = &el->l_recs[index + 1];\n\telse if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&\n\t\t path->p_tree_depth > 0) {\n\t\tstatus = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\t\tif (status)\n\t\t\tgoto free_left_path;\n\n\t\tif (right_cpos == 0)\n\t\t\tgoto free_left_path;\n\n\t\tright_path = ocfs2_new_path_from_path(path);\n\t\tif (!right_path) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto free_left_path;\n\t\t}\n\n\t\tstatus = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (status)\n\t\t\tgoto free_right_path;\n\n\t\tnew_el = path_leaf_el(right_path);\n\t\trec = &new_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tif (le16_to_cpu(new_el->l_next_free_rec) <= 1) {\n\t\t\t\tbh = path_leaf_bh(right_path);\n\t\t\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t\t\tstatus = ocfs2_error(sb,\n\t\t\t\t\t\t\"Extent block #%llu has an invalid l_next_free_rec of %d\\n\",\n\t\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t\tle16_to_cpu(new_el->l_next_free_rec));\n\t\t\t\tgoto free_right_path;\n\t\t\t}\n\t\t\trec = &new_el->l_recs[1];\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tenum ocfs2_contig_type contig_type;\n\n\t\tcontig_type = ocfs2_et_extent_contig(et, rec, split_rec);\n\n\t\tif (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)\n\t\t\tret = CONTIG_LEFTRIGHT;\n\t\telse if (ret == CONTIG_NONE)\n\t\t\tret = contig_type;\n\t}\n\nfree_right_path:\n\tocfs2_free_path(right_path);\nfree_left_path:\n\tocfs2_free_path(left_path);\nexit:\n\tif (status == 0)\n\t\tctxt->c_contig_type = ret;\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_do_insert_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4253-4363",
    "snippet": "static int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "right_path"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et->et_root_bh"
          ],
          "line": 4356
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_update_clusters",
          "args": [
            "et",
            "le16_to_cpu(insert_rec->e_leaf_clusters)"
          ],
          "line": 4353
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_update_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "518-522",
          "snippet": "static inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "insert_rec->e_leaf_clusters"
          ],
          "line": 4354
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_path",
          "args": [
            "handle",
            "et",
            "left_path",
            "right_path",
            "insert_rec",
            "type"
          ],
          "line": 4344
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4172-4251",
          "snippet": "static int ocfs2_insert_path(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     struct ocfs2_path *left_path,\n\t\t\t     struct ocfs2_path *right_path,\n\t\t\t     struct ocfs2_extent_rec *insert_rec,\n\t\t\t     struct ocfs2_insert_type *insert)\n{\n\tint ret, subtree_index;\n\tstruct buffer_head *leaf_bh = path_leaf_bh(right_path);\n\n\tif (left_path) {\n\t\t/*\n\t\t * There's a chance that left_path got passed back to\n\t\t * us without being accounted for in the\n\t\t * journal. Extend our transaction here to be sure we\n\t\t * can change those blocks.\n\t\t */\n\t\tret = ocfs2_extend_trans(handle, left_path->p_tree_depth);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Pass both paths to the journal. The majority of inserts\n\t * will be touching all components anyway.\n\t */\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\t/*\n\t\t * We could call ocfs2_insert_at_leaf() for some types\n\t\t * of splits, but it's easier to just let one separate\n\t\t * function sort it all out.\n\t\t */\n\t\tocfs2_split_record(et, left_path, right_path,\n\t\t\t\t   insert_rec, insert->ins_split);\n\n\t\t/*\n\t\t * Split might have modified either leaf and we don't\n\t\t * have a guarantee that the later edge insert will\n\t\t * dirty this for us.\n\t\t */\n\t\tif (left_path)\n\t\t\tocfs2_journal_dirty(handle,\n\t\t\t\t\t    path_leaf_bh(left_path));\n\t} else\n\t\tocfs2_insert_at_leaf(et, insert_rec, path_leaf_el(right_path),\n\t\t\t\t     insert);\n\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tif (left_path) {\n\t\t/*\n\t\t * The rotate code has indicated that we need to fix\n\t\t * up portions of the tree after the insert.\n\t\t *\n\t\t * XXX: Should we extend the transaction here?\n\t\t */\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_insert_path(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     struct ocfs2_path *left_path,\n\t\t\t     struct ocfs2_path *right_path,\n\t\t\t     struct ocfs2_extent_rec *insert_rec,\n\t\t\t     struct ocfs2_insert_type *insert)\n{\n\tint ret, subtree_index;\n\tstruct buffer_head *leaf_bh = path_leaf_bh(right_path);\n\n\tif (left_path) {\n\t\t/*\n\t\t * There's a chance that left_path got passed back to\n\t\t * us without being accounted for in the\n\t\t * journal. Extend our transaction here to be sure we\n\t\t * can change those blocks.\n\t\t */\n\t\tret = ocfs2_extend_trans(handle, left_path->p_tree_depth);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Pass both paths to the journal. The majority of inserts\n\t * will be touching all components anyway.\n\t */\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\t/*\n\t\t * We could call ocfs2_insert_at_leaf() for some types\n\t\t * of splits, but it's easier to just let one separate\n\t\t * function sort it all out.\n\t\t */\n\t\tocfs2_split_record(et, left_path, right_path,\n\t\t\t\t   insert_rec, insert->ins_split);\n\n\t\t/*\n\t\t * Split might have modified either leaf and we don't\n\t\t * have a guarantee that the later edge insert will\n\t\t * dirty this for us.\n\t\t */\n\t\tif (left_path)\n\t\t\tocfs2_journal_dirty(handle,\n\t\t\t\t\t    path_leaf_bh(left_path));\n\t} else\n\t\tocfs2_insert_at_leaf(et, insert_rec, path_leaf_el(right_path),\n\t\t\t\t     insert);\n\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tif (left_path) {\n\t\t/*\n\t\t * The rotate code has indicated that we need to fix\n\t\t * up portions of the tree after the insert.\n\t\t *\n\t\t * XXX: Should we extend the transaction here?\n\t\t */\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_append_rec_to_path",
          "args": [
            "handle",
            "et",
            "insert_rec",
            "right_path",
            "&left_path"
          ],
          "line": 4336
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_append_rec_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4001-4084",
          "snippet": "static int ocfs2_append_rec_to_path(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    struct ocfs2_path *right_path,\n\t\t\t\t    struct ocfs2_path **ret_left_path)\n{\n\tint ret, next_free;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/*\n\t * This shouldn't happen for non-trees. The extent rec cluster\n\t * count manipulation below only works for interior nodes.\n\t */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\t/*\n\t * If our appending insert is at the leftmost edge of a leaf,\n\t * then we might need to update the rightmost records of the\n\t * neighboring path.\n\t */\n\tel = path_leaf_el(right_path);\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tu32 left_cpos;\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\t    right_path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_ocfs2_append_rec_to_path(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\tleft_cpos);\n\n\t\t/*\n\t\t * No need to worry if the append is already in the\n\t\t * leftmost leaf.\n\t\t */\n\t\tif (left_cpos) {\n\t\t\tleft_path = ocfs2_new_path_from_path(right_path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ocfs2_insert_path() will pass the left_path to the\n\t\t\t * journal for us.\n\t\t\t */\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_adjust_rightmost_records(handle, et, right_path, insert_rec);\n\n\t*ret_left_path = left_path;\n\tret = 0;\nout:\n\tif (ret != 0)\n\t\tocfs2_free_path(left_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_append_rec_to_path(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    struct ocfs2_path *right_path,\n\t\t\t\t    struct ocfs2_path **ret_left_path)\n{\n\tint ret, next_free;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/*\n\t * This shouldn't happen for non-trees. The extent rec cluster\n\t * count manipulation below only works for interior nodes.\n\t */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\t/*\n\t * If our appending insert is at the leftmost edge of a leaf,\n\t * then we might need to update the rightmost records of the\n\t * neighboring path.\n\t */\n\tel = path_leaf_el(right_path);\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tu32 left_cpos;\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\t    right_path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_ocfs2_append_rec_to_path(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\tleft_cpos);\n\n\t\t/*\n\t\t * No need to worry if the append is already in the\n\t\t * leftmost leaf.\n\t\t */\n\t\tif (left_cpos) {\n\t\t\tleft_path = ocfs2_new_path_from_path(right_path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ocfs2_insert_path() will pass the left_path to the\n\t\t\t * journal for us.\n\t\t\t */\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_adjust_rightmost_records(handle, et, right_path, insert_rec);\n\n\t*ret_left_path = left_path;\n\tret = 0;\nout:\n\tif (ret != 0)\n\t\tocfs2_free_path(left_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4328
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "538-544",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_tree_right",
          "args": [
            "handle",
            "et",
            "type->ins_split",
            "le32_to_cpu(insert_rec->e_cpos)",
            "right_path",
            "&left_path"
          ],
          "line": 4316
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_tree_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2377-2536",
          "snippet": "static int ocfs2_rotate_tree_right(handle_t *handle,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   enum ocfs2_split_type split,\n\t\t\t\t   u32 insert_cpos,\n\t\t\t\t   struct ocfs2_path *right_path,\n\t\t\t\t   struct ocfs2_path **ret_left_path)\n{\n\tint ret, start, orig_credits = handle->h_buffer_credits;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\t*ret_left_path = NULL;\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_rotate_tree_right(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tinsert_cpos, cpos);\n\n\t/*\n\t * What we want to do here is:\n\t *\n\t * 1) Start with the rightmost path.\n\t *\n\t * 2) Determine a path to the leaf block directly to the left\n\t *    of that leaf.\n\t *\n\t * 3) Determine the 'subtree root' - the lowest level tree node\n\t *    which contains a path to both leaves.\n\t *\n\t * 4) Rotate the subtree.\n\t *\n\t * 5) Find the next subtree by considering the left path to be\n\t *    the new right path.\n\t *\n\t * The check at the top of this while loop also accepts\n\t * insert_cpos == cpos because cpos is only a _theoretical_\n\t * value to get us the left path - insert_cpos might very well\n\t * be filling that hole.\n\t *\n\t * Stop at a cpos of '0' because we either started at the\n\t * leftmost branch (i.e., a tree with one branch and a\n\t * rotation inside of it), or we've gone as far as we can in\n\t * rotating subtrees.\n\t */\n\twhile (cpos && insert_cpos <= cpos) {\n\t\ttrace_ocfs2_rotate_tree_right(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tinsert_cpos, cpos);\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlog_bug_on_msg(path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path),\n\t\t\t\t\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tinsert_cpos, cpos,\n\t\t\t\t(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr);\n\n\t\tif (split == SPLIT_NONE &&\n\t\t    ocfs2_rotate_requires_path_adjustment(left_path,\n\t\t\t\t\t\t\t  insert_cpos)) {\n\n\t\t\t/*\n\t\t\t * We've rotated the tree as much as we\n\t\t\t * should. The rest is up to\n\t\t\t * ocfs2_insert_path() to complete, after the\n\t\t\t * record insertion. We indicate this\n\t\t\t * situation by returning the left path.\n\t\t\t *\n\t\t\t * The reason we don't adjust the records here\n\t\t\t * before the record insert is that an error\n\t\t\t * later might break the rule where a parent\n\t\t\t * record e_cpos will reflect the actual\n\t\t\t * e_cpos of the 1st nonempty record of the\n\t\t\t * child list.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\tstart = ocfs2_find_subtree_root(et, left_path, right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(start,\n\t\t\t(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr,\n\t\t\tright_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, start,\n\t\t\t\t\t\t      orig_credits, right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_right(handle, et, left_path,\n\t\t\t\t\t\t right_path, start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split != SPLIT_NONE &&\n\t\t    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),\n\t\t\t\t\t\tinsert_cpos)) {\n\t\t\t/*\n\t\t\t * A rotate moves the rightmost left leaf\n\t\t\t * record over to the leftmost right leaf\n\t\t\t * slot. If we're doing an extent split\n\t\t\t * instead of a real insert, then we have to\n\t\t\t * check that the extent to be split wasn't\n\t\t\t * just moved over. If it was, then we can\n\t\t\t * exit here, passing left_path back -\n\t\t\t * ocfs2_split_extent() is smart enough to\n\t\t\t * search both leaves.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to re-read the next right path\n\t\t * as we know that it'll be our current left\n\t\t * path. Optimize by copying values instead.\n\t\t */\n\t\tocfs2_mv_path(right_path, left_path);\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\nout_ret_path:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_tree_right(handle_t *handle,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   enum ocfs2_split_type split,\n\t\t\t\t   u32 insert_cpos,\n\t\t\t\t   struct ocfs2_path *right_path,\n\t\t\t\t   struct ocfs2_path **ret_left_path)\n{\n\tint ret, start, orig_credits = handle->h_buffer_credits;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\t*ret_left_path = NULL;\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_rotate_tree_right(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tinsert_cpos, cpos);\n\n\t/*\n\t * What we want to do here is:\n\t *\n\t * 1) Start with the rightmost path.\n\t *\n\t * 2) Determine a path to the leaf block directly to the left\n\t *    of that leaf.\n\t *\n\t * 3) Determine the 'subtree root' - the lowest level tree node\n\t *    which contains a path to both leaves.\n\t *\n\t * 4) Rotate the subtree.\n\t *\n\t * 5) Find the next subtree by considering the left path to be\n\t *    the new right path.\n\t *\n\t * The check at the top of this while loop also accepts\n\t * insert_cpos == cpos because cpos is only a _theoretical_\n\t * value to get us the left path - insert_cpos might very well\n\t * be filling that hole.\n\t *\n\t * Stop at a cpos of '0' because we either started at the\n\t * leftmost branch (i.e., a tree with one branch and a\n\t * rotation inside of it), or we've gone as far as we can in\n\t * rotating subtrees.\n\t */\n\twhile (cpos && insert_cpos <= cpos) {\n\t\ttrace_ocfs2_rotate_tree_right(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tinsert_cpos, cpos);\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlog_bug_on_msg(path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path),\n\t\t\t\t\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tinsert_cpos, cpos,\n\t\t\t\t(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr);\n\n\t\tif (split == SPLIT_NONE &&\n\t\t    ocfs2_rotate_requires_path_adjustment(left_path,\n\t\t\t\t\t\t\t  insert_cpos)) {\n\n\t\t\t/*\n\t\t\t * We've rotated the tree as much as we\n\t\t\t * should. The rest is up to\n\t\t\t * ocfs2_insert_path() to complete, after the\n\t\t\t * record insertion. We indicate this\n\t\t\t * situation by returning the left path.\n\t\t\t *\n\t\t\t * The reason we don't adjust the records here\n\t\t\t * before the record insert is that an error\n\t\t\t * later might break the rule where a parent\n\t\t\t * record e_cpos will reflect the actual\n\t\t\t * e_cpos of the 1st nonempty record of the\n\t\t\t * child list.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\tstart = ocfs2_find_subtree_root(et, left_path, right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(start,\n\t\t\t(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr,\n\t\t\tright_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, start,\n\t\t\t\t\t\t      orig_credits, right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_right(handle, et, left_path,\n\t\t\t\t\t\t right_path, start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split != SPLIT_NONE &&\n\t\t    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),\n\t\t\t\t\t\tinsert_cpos)) {\n\t\t\t/*\n\t\t\t * A rotate moves the rightmost left leaf\n\t\t\t * record over to the leftmost right leaf\n\t\t\t * slot. If we're doing an extent split\n\t\t\t * instead of a real insert, then we have to\n\t\t\t * check that the extent to be split wasn't\n\t\t\t * just moved over. If it was, then we can\n\t\t\t * exit here, passing left_path back -\n\t\t\t * ocfs2_split_extent() is smart enough to\n\t\t\t * search both leaves.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to re-read the next right path\n\t\t * as we know that it'll be our current left\n\t\t * path. Optimize by copying values instead.\n\t\t */\n\t\tocfs2_mv_path(right_path, left_path);\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\nout_ret_path:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "insert_rec->e_cpos"
          ],
          "line": 4317
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "right_path",
            "cpos"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "722-726",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_at_leaf",
          "args": [
            "et",
            "insert_rec",
            "el",
            "type"
          ],
          "line": 4274
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_at_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3875-3962",
          "snippet": "static void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_do_insert_extent(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t  struct ocfs2_insert_type *type)\n{\n\tint ret, rotate = 0;\n\tu32 cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\n\tel = et->et_root_el;\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tocfs2_insert_at_leaf(et, insert_rec, el, type);\n\t\tgoto out_update_clusters;\n\t}\n\n\tright_path = ocfs2_new_path_from_et(et);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Determine the path to start with. Rotations need the\n\t * rightmost path, everything else can go directly to the\n\t * target leaf.\n\t */\n\tcpos = le32_to_cpu(insert_rec->e_cpos);\n\tif (type->ins_appending == APPEND_NONE &&\n\t    type->ins_contig == CONTIG_NONE) {\n\t\trotate = 1;\n\t\tcpos = UINT_MAX;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Rotations and appends need special treatment - they modify\n\t * parts of the tree's above them.\n\t *\n\t * Both might pass back a path immediate to the left of the\n\t * one being inserted to. This will be cause\n\t * ocfs2_insert_path() to modify the rightmost records of\n\t * left_path to account for an edge insert.\n\t *\n\t * XXX: When modifying this code, keep in mind that an insert\n\t * can wind up skipping both of these two special cases...\n\t */\n\tif (rotate) {\n\t\tret = ocfs2_rotate_tree_right(handle, et, type->ins_split,\n\t\t\t\t\t      le32_to_cpu(insert_rec->e_cpos),\n\t\t\t\t\t      right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * ocfs2_rotate_tree_right() might have extended the\n\t\t * transaction without re-journaling our tree root.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (type->ins_appending == APPEND_TAIL\n\t\t   && type->ins_contig != CONTIG_LEFT) {\n\t\tret = ocfs2_append_rec_to_path(handle, et, insert_rec,\n\t\t\t\t\t       right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_insert_path(handle, et, left_path, right_path,\n\t\t\t\tinsert_rec, type);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_clusters:\n\tif (type->ins_split == SPLIT_NONE)\n\t\tocfs2_et_update_clusters(et,\n\t\t\t\t\t le16_to_cpu(insert_rec->e_leaf_clusters));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_insert_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4172-4251",
    "snippet": "static int ocfs2_insert_path(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     struct ocfs2_path *left_path,\n\t\t\t     struct ocfs2_path *right_path,\n\t\t\t     struct ocfs2_extent_rec *insert_rec,\n\t\t\t     struct ocfs2_insert_type *insert)\n{\n\tint ret, subtree_index;\n\tstruct buffer_head *leaf_bh = path_leaf_bh(right_path);\n\n\tif (left_path) {\n\t\t/*\n\t\t * There's a chance that left_path got passed back to\n\t\t * us without being accounted for in the\n\t\t * journal. Extend our transaction here to be sure we\n\t\t * can change those blocks.\n\t\t */\n\t\tret = ocfs2_extend_trans(handle, left_path->p_tree_depth);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Pass both paths to the journal. The majority of inserts\n\t * will be touching all components anyway.\n\t */\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\t/*\n\t\t * We could call ocfs2_insert_at_leaf() for some types\n\t\t * of splits, but it's easier to just let one separate\n\t\t * function sort it all out.\n\t\t */\n\t\tocfs2_split_record(et, left_path, right_path,\n\t\t\t\t   insert_rec, insert->ins_split);\n\n\t\t/*\n\t\t * Split might have modified either leaf and we don't\n\t\t * have a guarantee that the later edge insert will\n\t\t * dirty this for us.\n\t\t */\n\t\tif (left_path)\n\t\t\tocfs2_journal_dirty(handle,\n\t\t\t\t\t    path_leaf_bh(left_path));\n\t} else\n\t\tocfs2_insert_at_leaf(et, insert_rec, path_leaf_el(right_path),\n\t\t\t\t     insert);\n\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tif (left_path) {\n\t\t/*\n\t\t * The rotate code has indicated that we need to fix\n\t\t * up portions of the tree after the insert.\n\t\t *\n\t\t * XXX: Should we extend the transaction here?\n\t\t */\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 4244
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2052-2120",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 4242
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1764-1792",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "leaf_bh"
          ],
          "line": 4233
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_at_leaf",
          "args": [
            "et",
            "insert_rec",
            "path_leaf_el(right_path)",
            "insert"
          ],
          "line": 4230
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_at_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3875-3962",
          "snippet": "static void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 4230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_record",
          "args": [
            "et",
            "left_path",
            "right_path",
            "insert_rec",
            "insert->ins_split"
          ],
          "line": 4218
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "4086-4162",
          "snippet": "static void ocfs2_split_record(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *left_path,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       enum ocfs2_split_type split)\n{\n\tint index;\n\tu32 cpos = le32_to_cpu(split_rec->e_cpos);\n\tstruct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;\n\tstruct ocfs2_extent_rec *rec, *tmprec;\n\n\tright_el = path_leaf_el(right_path);\n\tif (left_path)\n\t\tleft_el = path_leaf_el(left_path);\n\n\tel = right_el;\n\tinsert_el = right_el;\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index != -1) {\n\t\tif (index == 0 && left_path) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t\t/*\n\t\t\t * This typically means that the record\n\t\t\t * started in the left path but moved to the\n\t\t\t * right as a result of rotation. We either\n\t\t\t * move the existing record to the left, or we\n\t\t\t * do the later insert there.\n\t\t\t *\n\t\t\t * In this case, the left path should always\n\t\t\t * exist as the rotate code will have passed\n\t\t\t * it back for a post-insert update.\n\t\t\t */\n\n\t\t\tif (split == SPLIT_LEFT) {\n\t\t\t\t/*\n\t\t\t\t * It's a left split. Since we know\n\t\t\t\t * that the rotate code gave us an\n\t\t\t\t * empty extent in the left path, we\n\t\t\t\t * can just do the insert there.\n\t\t\t\t */\n\t\t\t\tinsert_el = left_el;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Right split - we have to move the\n\t\t\t\t * existing record over to the left\n\t\t\t\t * leaf. The insert will be into the\n\t\t\t\t * newly created empty extent in the\n\t\t\t\t * right leaf.\n\t\t\t\t */\n\t\t\t\ttmprec = &right_el->l_recs[index];\n\t\t\t\tocfs2_rotate_leaf(left_el, tmprec);\n\t\t\t\tel = left_el;\n\n\t\t\t\tmemset(tmprec, 0, sizeof(*tmprec));\n\t\t\t\tindex = ocfs2_search_extent_list(left_el, cpos);\n\t\t\t\tBUG_ON(index == -1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG_ON(!left_path);\n\t\tBUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));\n\t\t/*\n\t\t * Left path is easy - we can just allow the insert to\n\t\t * happen.\n\t\t */\n\t\tel = left_el;\n\t\tinsert_el = left_el;\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tBUG_ON(index == -1);\n\t}\n\n\trec = &el->l_recs[index];\n\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\tsplit, rec, split_rec);\n\tocfs2_rotate_leaf(insert_el, split_rec);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_split_record(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *left_path,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       enum ocfs2_split_type split)\n{\n\tint index;\n\tu32 cpos = le32_to_cpu(split_rec->e_cpos);\n\tstruct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;\n\tstruct ocfs2_extent_rec *rec, *tmprec;\n\n\tright_el = path_leaf_el(right_path);\n\tif (left_path)\n\t\tleft_el = path_leaf_el(left_path);\n\n\tel = right_el;\n\tinsert_el = right_el;\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index != -1) {\n\t\tif (index == 0 && left_path) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t\t/*\n\t\t\t * This typically means that the record\n\t\t\t * started in the left path but moved to the\n\t\t\t * right as a result of rotation. We either\n\t\t\t * move the existing record to the left, or we\n\t\t\t * do the later insert there.\n\t\t\t *\n\t\t\t * In this case, the left path should always\n\t\t\t * exist as the rotate code will have passed\n\t\t\t * it back for a post-insert update.\n\t\t\t */\n\n\t\t\tif (split == SPLIT_LEFT) {\n\t\t\t\t/*\n\t\t\t\t * It's a left split. Since we know\n\t\t\t\t * that the rotate code gave us an\n\t\t\t\t * empty extent in the left path, we\n\t\t\t\t * can just do the insert there.\n\t\t\t\t */\n\t\t\t\tinsert_el = left_el;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Right split - we have to move the\n\t\t\t\t * existing record over to the left\n\t\t\t\t * leaf. The insert will be into the\n\t\t\t\t * newly created empty extent in the\n\t\t\t\t * right leaf.\n\t\t\t\t */\n\t\t\t\ttmprec = &right_el->l_recs[index];\n\t\t\t\tocfs2_rotate_leaf(left_el, tmprec);\n\t\t\t\tel = left_el;\n\n\t\t\t\tmemset(tmprec, 0, sizeof(*tmprec));\n\t\t\t\tindex = ocfs2_search_extent_list(left_el, cpos);\n\t\t\t\tBUG_ON(index == -1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG_ON(!left_path);\n\t\tBUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));\n\t\t/*\n\t\t * Left path is easy - we can just allow the insert to\n\t\t * happen.\n\t\t */\n\t\tel = left_el;\n\t\tinsert_el = left_el;\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tBUG_ON(index == -1);\n\t}\n\n\trec = &el->l_recs[index];\n\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\tsplit, rec, split_rec);\n\tocfs2_rotate_leaf(insert_el, split_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "right_path"
          ],
          "line": 4206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "755-774",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "left_path->p_tree_depth"
          ],
          "line": 4189
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_insert_path(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     struct ocfs2_path *left_path,\n\t\t\t     struct ocfs2_path *right_path,\n\t\t\t     struct ocfs2_extent_rec *insert_rec,\n\t\t\t     struct ocfs2_insert_type *insert)\n{\n\tint ret, subtree_index;\n\tstruct buffer_head *leaf_bh = path_leaf_bh(right_path);\n\n\tif (left_path) {\n\t\t/*\n\t\t * There's a chance that left_path got passed back to\n\t\t * us without being accounted for in the\n\t\t * journal. Extend our transaction here to be sure we\n\t\t * can change those blocks.\n\t\t */\n\t\tret = ocfs2_extend_trans(handle, left_path->p_tree_depth);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Pass both paths to the journal. The majority of inserts\n\t * will be touching all components anyway.\n\t */\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\t/*\n\t\t * We could call ocfs2_insert_at_leaf() for some types\n\t\t * of splits, but it's easier to just let one separate\n\t\t * function sort it all out.\n\t\t */\n\t\tocfs2_split_record(et, left_path, right_path,\n\t\t\t\t   insert_rec, insert->ins_split);\n\n\t\t/*\n\t\t * Split might have modified either leaf and we don't\n\t\t * have a guarantee that the later edge insert will\n\t\t * dirty this for us.\n\t\t */\n\t\tif (left_path)\n\t\t\tocfs2_journal_dirty(handle,\n\t\t\t\t\t    path_leaf_bh(left_path));\n\t} else\n\t\tocfs2_insert_at_leaf(et, insert_rec, path_leaf_el(right_path),\n\t\t\t\t     insert);\n\n\tocfs2_journal_dirty(handle, leaf_bh);\n\n\tif (left_path) {\n\t\t/*\n\t\t * The rotate code has indicated that we need to fix\n\t\t * up portions of the tree after the insert.\n\t\t *\n\t\t * XXX: Should we extend the transaction here?\n\t\t */\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_split_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4086-4162",
    "snippet": "static void ocfs2_split_record(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *left_path,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       enum ocfs2_split_type split)\n{\n\tint index;\n\tu32 cpos = le32_to_cpu(split_rec->e_cpos);\n\tstruct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;\n\tstruct ocfs2_extent_rec *rec, *tmprec;\n\n\tright_el = path_leaf_el(right_path);\n\tif (left_path)\n\t\tleft_el = path_leaf_el(left_path);\n\n\tel = right_el;\n\tinsert_el = right_el;\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index != -1) {\n\t\tif (index == 0 && left_path) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t\t/*\n\t\t\t * This typically means that the record\n\t\t\t * started in the left path but moved to the\n\t\t\t * right as a result of rotation. We either\n\t\t\t * move the existing record to the left, or we\n\t\t\t * do the later insert there.\n\t\t\t *\n\t\t\t * In this case, the left path should always\n\t\t\t * exist as the rotate code will have passed\n\t\t\t * it back for a post-insert update.\n\t\t\t */\n\n\t\t\tif (split == SPLIT_LEFT) {\n\t\t\t\t/*\n\t\t\t\t * It's a left split. Since we know\n\t\t\t\t * that the rotate code gave us an\n\t\t\t\t * empty extent in the left path, we\n\t\t\t\t * can just do the insert there.\n\t\t\t\t */\n\t\t\t\tinsert_el = left_el;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Right split - we have to move the\n\t\t\t\t * existing record over to the left\n\t\t\t\t * leaf. The insert will be into the\n\t\t\t\t * newly created empty extent in the\n\t\t\t\t * right leaf.\n\t\t\t\t */\n\t\t\t\ttmprec = &right_el->l_recs[index];\n\t\t\t\tocfs2_rotate_leaf(left_el, tmprec);\n\t\t\t\tel = left_el;\n\n\t\t\t\tmemset(tmprec, 0, sizeof(*tmprec));\n\t\t\t\tindex = ocfs2_search_extent_list(left_el, cpos);\n\t\t\t\tBUG_ON(index == -1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG_ON(!left_path);\n\t\tBUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));\n\t\t/*\n\t\t * Left path is easy - we can just allow the insert to\n\t\t * happen.\n\t\t */\n\t\tel = left_el;\n\t\tinsert_el = left_el;\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tBUG_ON(index == -1);\n\t}\n\n\trec = &el->l_recs[index];\n\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\tsplit, rec, split_rec);\n\tocfs2_rotate_leaf(insert_el, split_rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rotate_leaf",
          "args": [
            "insert_el",
            "split_rec"
          ],
          "line": 4161
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1625-1702",
          "snippet": "static void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_subtract_from_rec",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "split",
            "rec",
            "split_rec"
          ],
          "line": 4159
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_subtract_from_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3840-3868",
          "snippet": "static void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 4159
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index == -1"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 4154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "782-804",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_empty_extent(&left_el->l_recs[0])"
          ],
          "line": 4147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&left_el->l_recs[0]"
          ],
          "line": 4147
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!left_path"
          ],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index == -1"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmprec",
            "0",
            "sizeof(*tmprec)"
          ],
          "line": 4140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_is_empty_extent(&el->l_recs[0])"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "split_rec->e_cpos"
          ],
          "line": 4093
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_split_record(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *left_path,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t\t       enum ocfs2_split_type split)\n{\n\tint index;\n\tu32 cpos = le32_to_cpu(split_rec->e_cpos);\n\tstruct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;\n\tstruct ocfs2_extent_rec *rec, *tmprec;\n\n\tright_el = path_leaf_el(right_path);\n\tif (left_path)\n\t\tleft_el = path_leaf_el(left_path);\n\n\tel = right_el;\n\tinsert_el = right_el;\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index != -1) {\n\t\tif (index == 0 && left_path) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t\t/*\n\t\t\t * This typically means that the record\n\t\t\t * started in the left path but moved to the\n\t\t\t * right as a result of rotation. We either\n\t\t\t * move the existing record to the left, or we\n\t\t\t * do the later insert there.\n\t\t\t *\n\t\t\t * In this case, the left path should always\n\t\t\t * exist as the rotate code will have passed\n\t\t\t * it back for a post-insert update.\n\t\t\t */\n\n\t\t\tif (split == SPLIT_LEFT) {\n\t\t\t\t/*\n\t\t\t\t * It's a left split. Since we know\n\t\t\t\t * that the rotate code gave us an\n\t\t\t\t * empty extent in the left path, we\n\t\t\t\t * can just do the insert there.\n\t\t\t\t */\n\t\t\t\tinsert_el = left_el;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Right split - we have to move the\n\t\t\t\t * existing record over to the left\n\t\t\t\t * leaf. The insert will be into the\n\t\t\t\t * newly created empty extent in the\n\t\t\t\t * right leaf.\n\t\t\t\t */\n\t\t\t\ttmprec = &right_el->l_recs[index];\n\t\t\t\tocfs2_rotate_leaf(left_el, tmprec);\n\t\t\t\tel = left_el;\n\n\t\t\t\tmemset(tmprec, 0, sizeof(*tmprec));\n\t\t\t\tindex = ocfs2_search_extent_list(left_el, cpos);\n\t\t\t\tBUG_ON(index == -1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBUG_ON(!left_path);\n\t\tBUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));\n\t\t/*\n\t\t * Left path is easy - we can just allow the insert to\n\t\t * happen.\n\t\t */\n\t\tel = left_el;\n\t\tinsert_el = left_el;\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tBUG_ON(index == -1);\n\t}\n\n\trec = &el->l_recs[index];\n\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\tsplit, rec, split_rec);\n\tocfs2_rotate_leaf(insert_el, split_rec);\n}"
  },
  {
    "function_name": "ocfs2_append_rec_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "4001-4084",
    "snippet": "static int ocfs2_append_rec_to_path(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    struct ocfs2_path *right_path,\n\t\t\t\t    struct ocfs2_path **ret_left_path)\n{\n\tint ret, next_free;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/*\n\t * This shouldn't happen for non-trees. The extent rec cluster\n\t * count manipulation below only works for interior nodes.\n\t */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\t/*\n\t * If our appending insert is at the leftmost edge of a leaf,\n\t * then we might need to update the rightmost records of the\n\t * neighboring path.\n\t */\n\tel = path_leaf_el(right_path);\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tu32 left_cpos;\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\t    right_path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_ocfs2_append_rec_to_path(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\tleft_cpos);\n\n\t\t/*\n\t\t * No need to worry if the append is already in the\n\t\t * leftmost leaf.\n\t\t */\n\t\tif (left_cpos) {\n\t\t\tleft_path = ocfs2_new_path_from_path(right_path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ocfs2_insert_path() will pass the left_path to the\n\t\t\t * journal for us.\n\t\t\t */\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_adjust_rightmost_records(handle, et, right_path, insert_rec);\n\n\t*ret_left_path = left_path;\n\tret = 0;\nout:\n\tif (ret != 0)\n\t\tocfs2_free_path(left_path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_rightmost_records",
          "args": [
            "handle",
            "et",
            "right_path",
            "insert_rec"
          ],
          "line": 4075
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_rightmost_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3964-3999",
          "snippet": "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "right_path"
          ],
          "line": 4069
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "755-774",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "left_cpos"
          ],
          "line": 4055
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "right_path"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "716-720",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_append_rec_to_path",
          "args": [
            "(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci)",
            "le32_to_cpu(insert_rec->e_cpos)",
            "left_cpos"
          ],
          "line": 4037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "insert_rec->e_cpos"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "right_path",
            "&left_cpos"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2225-2291",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 4027
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 4025
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_path->p_tree_depth == 0"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic int ocfs2_append_rec_to_path(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t    struct ocfs2_path *right_path,\n\t\t\t\t    struct ocfs2_path **ret_left_path)\n{\n\tint ret, next_free;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/*\n\t * This shouldn't happen for non-trees. The extent rec cluster\n\t * count manipulation below only works for interior nodes.\n\t */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\t/*\n\t * If our appending insert is at the leftmost edge of a leaf,\n\t * then we might need to update the rightmost records of the\n\t * neighboring path.\n\t */\n\tel = path_leaf_el(right_path);\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\tif (next_free == 0 ||\n\t    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tu32 left_cpos;\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\t    right_path, &left_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_ocfs2_append_rec_to_path(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\tleft_cpos);\n\n\t\t/*\n\t\t * No need to worry if the append is already in the\n\t\t * leftmost leaf.\n\t\t */\n\t\tif (left_cpos) {\n\t\t\tleft_path = ocfs2_new_path_from_path(right_path);\n\t\t\tif (!left_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_find_path(et->et_ci, left_path,\n\t\t\t\t\t      left_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ocfs2_insert_path() will pass the left_path to the\n\t\t\t * journal for us.\n\t\t\t */\n\t\t}\n\t}\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, right_path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_adjust_rightmost_records(handle, et, right_path, insert_rec);\n\n\t*ret_left_path = left_path;\n\tret = 0;\nout:\n\tif (ret != 0)\n\t\tocfs2_free_path(left_path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_adjust_rightmost_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3964-3999",
    "snippet": "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 3997
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_int_clusters",
            "-le32_to_cpu(rec->e_cpos)"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 3995
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_int_clusters",
            "le16_to_cpu(insert_rec->e_leaf_clusters)"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "insert_rec->e_leaf_clusters"
          ],
          "line": 3993
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu has a bad extent list\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)"
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 3985
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_insert_at_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3875-3962",
    "snippet": "static void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rotate_leaf",
          "args": [
            "el",
            "insert_rec"
          ],
          "line": 3961
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1625-1702",
          "snippet": "static void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&el->l_next_free_rec",
            "1"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count)",
            "\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\"",
            "ocfs2_metadata_cache_owner(et->et_ci)",
            "le16_to_cpu(el->l_tree_depth)",
            "le16_to_cpu(el->l_count)",
            "le16_to_cpu(el->l_next_free_rec)",
            "le32_to_cpu(el->l_recs[i].e_cpos)",
            "le16_to_cpu(el->l_recs[i].e_leaf_clusters)",
            "le32_to_cpu(insert_rec->e_cpos)",
            "le16_to_cpu(insert_rec->e_leaf_clusters)"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "insert_rec->e_leaf_clusters"
          ],
          "line": 3943
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "insert_rec->e_cpos"
          ],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(insert_rec->e_cpos) < range"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3915
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "le16_to_cpu(insert_rec->e_leaf_clusters)"
          ],
          "line": 3905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_subtract_from_rec",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "insert->ins_split",
            "rec",
            "insert_rec"
          ],
          "line": 3890
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_subtract_from_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3840-3868",
          "snippet": "static void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3890
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i == -1"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "le32_to_cpu(insert_rec->e_cpos)"
          ],
          "line": 3887
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "782-804",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_tree_depth) != 0"
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_insert_at_leaf(struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *insert_rec,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_insert_type *insert)\n{\n\tint i = insert->ins_contig_index;\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (insert->ins_split != SPLIT_NONE) {\n\t\ti = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));\n\t\tBUG_ON(i == -1);\n\t\trec = &el->l_recs[i];\n\t\tocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\tinsert->ins_split, rec,\n\t\t\t\t\tinsert_rec);\n\t\tgoto rotate;\n\t}\n\n\t/*\n\t * Contiguous insert - either left or right.\n\t */\n\tif (insert->ins_contig != CONTIG_NONE) {\n\t\trec = &el->l_recs[i];\n\t\tif (insert->ins_contig == CONTIG_LEFT) {\n\t\t\trec->e_blkno = insert_rec->e_blkno;\n\t\t\trec->e_cpos = insert_rec->e_cpos;\n\t\t}\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\treturn;\n\t}\n\n\t/*\n\t * Handle insert into an empty leaf.\n\t */\n\tif (le16_to_cpu(el->l_next_free_rec) == 0 ||\n\t    ((le16_to_cpu(el->l_next_free_rec) == 1) &&\n\t     ocfs2_is_empty_extent(&el->l_recs[0]))) {\n\t\tel->l_recs[0] = *insert_rec;\n\t\tel->l_next_free_rec = cpu_to_le16(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Appending insert.\n\t */\n\tif (insert->ins_appending == APPEND_TAIL) {\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[i];\n\t\trange = le32_to_cpu(rec->e_cpos)\n\t\t\t+ le16_to_cpu(rec->e_leaf_clusters);\n\t\tBUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);\n\n\t\tmlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\t\"owner %llu, depth %u, count %u, next free %u, \"\n\t\t\t\t\"rec.cpos %u, rec.clusters %u, \"\n\t\t\t\t\"insert.cpos %u, insert.clusters %u\\n\",\n\t\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tle16_to_cpu(el->l_tree_depth),\n\t\t\t\tle16_to_cpu(el->l_count),\n\t\t\t\tle16_to_cpu(el->l_next_free_rec),\n\t\t\t\tle32_to_cpu(el->l_recs[i].e_cpos),\n\t\t\t\tle16_to_cpu(el->l_recs[i].e_leaf_clusters),\n\t\t\t\tle32_to_cpu(insert_rec->e_cpos),\n\t\t\t\tle16_to_cpu(insert_rec->e_leaf_clusters));\n\t\ti++;\n\t\tel->l_recs[i] = *insert_rec;\n\t\tle16_add_cpu(&el->l_next_free_rec, 1);\n\t\treturn;\n\t}\n\nrotate:\n\t/*\n\t * Ok, we have to rotate.\n\t *\n\t * At this point, it is safe to assume that inserting into an\n\t * empty leaf and appending to a leaf have both been handled\n\t * above.\n\t *\n\t * This leaf needs to have space, either by the empty 1st\n\t * extent record, or by virtue of an l_next_rec < l_count.\n\t */\n\tocfs2_rotate_leaf(el, insert_rec);\n}"
  },
  {
    "function_name": "ocfs2_subtract_from_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3840-3868",
    "snippet": "static void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "-le16_to_cpu(split_rec->e_leaf_clusters)"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "split_rec->e_leaf_clusters"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rec->e_leaf_clusters",
            "-le16_to_cpu(split_rec->e_leaf_clusters)"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&rec->e_blkno",
            "len_blocks"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_cpos",
            "le16_to_cpu(split_rec->e_leaf_clusters)"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "le16_to_cpu(split_rec->e_leaf_clusters)"
          ],
          "line": 3847
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_subtract_from_rec(struct super_block *sb,\n\t\t\t\t    enum ocfs2_split_type split,\n\t\t\t\t    struct ocfs2_extent_rec *rec,\n\t\t\t\t    struct ocfs2_extent_rec *split_rec)\n{\n\tu64 len_blocks;\n\n\tlen_blocks = ocfs2_clusters_to_blocks(sb,\n\t\t\t\tle16_to_cpu(split_rec->e_leaf_clusters));\n\n\tif (split == SPLIT_LEFT) {\n\t\t/*\n\t\t * Region is on the left edge of the existing\n\t\t * record.\n\t\t */\n\t\tle32_add_cpu(&rec->e_cpos,\n\t\t\t     le16_to_cpu(split_rec->e_leaf_clusters));\n\t\tle64_add_cpu(&rec->e_blkno, len_blocks);\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t} else {\n\t\t/*\n\t\t * Region is on the right edge of the existing\n\t\t * record.\n\t\t */\n\t\tle16_add_cpu(&rec->e_leaf_clusters,\n\t\t\t     -le16_to_cpu(split_rec->e_leaf_clusters));\n\t}\n}"
  },
  {
    "function_name": "ocfs2_try_to_merge_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3669-3838",
    "snippet": "static int ocfs2_try_to_merge_extent(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path,\n\t\t\t\t     int split_index,\n\t\t\t\t     struct ocfs2_extent_rec *split_rec,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     struct ocfs2_merge_ctxt *ctxt)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\n\tBUG_ON(ctxt->c_contig_type == CONTIG_NONE);\n\n\tif (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * The merge code will need to create an empty\n\t\t * extent to take the place of the newly\n\t\t * emptied slot. Remove any pre-existing empty\n\t\t * extents - having more than one in a leaf is\n\t\t * illegal.\n\t\t */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tsplit_index--;\n\t\trec = &el->l_recs[split_index];\n\t}\n\n\tif (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {\n\t\t/*\n\t\t * Left-right contig implies this.\n\t\t */\n\t\tBUG_ON(!ctxt->c_split_covers_rec);\n\n\t\t/*\n\t\t * Since the leftright insert always covers the entire\n\t\t * extent, this call will delete the insert record\n\t\t * entirely, resulting in an empty extent record added to\n\t\t * the extent block.\n\t\t *\n\t\t * Since the adding of an empty extent shifts\n\t\t * everything back to the right, there's no need to\n\t\t * update split_index here.\n\t\t *\n\t\t * When the split_index is zero, we need to merge it to the\n\t\t * prevoius extent block. It is more efficient and easier\n\t\t * if we do merge_right first and merge_left later.\n\t\t */\n\t\tret = ocfs2_merge_rec_right(path, handle, et, split_rec,\n\t\t\t\t\t    split_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We can only get this from logic error above.\n\t\t */\n\t\tBUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The merge left us with an empty extent, remove it. */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trec = &el->l_recs[split_index];\n\n\t\t/*\n\t\t * Note that we don't pass split_rec here on purpose -\n\t\t * we've merged it into the rec already.\n\t\t */\n\t\tret = ocfs2_merge_rec_left(path, handle, et, rec,\n\t\t\t\t\t   dealloc, split_index);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\t/*\n\t\t * Error from this last rotate is not critical, so\n\t\t * print but don't bubble it up.\n\t\t */\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * Merge a record to the left or right.\n\t\t *\n\t\t * 'contig_type' is relative to the existing record,\n\t\t * so for example, if we're \"right contig\", it's to\n\t\t * the record on the left (hence the left merge).\n\t\t */\n\t\tif (ctxt->c_contig_type == CONTIG_RIGHT) {\n\t\t\tret = ocfs2_merge_rec_left(path, handle, et,\n\t\t\t\t\t\t   split_rec, dealloc,\n\t\t\t\t\t\t   split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ocfs2_merge_rec_right(path, handle,\n\t\t\t\t\t\t    et, split_rec,\n\t\t\t\t\t\t    split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ctxt->c_split_covers_rec) {\n\t\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tpath);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The merge may have left an empty extent in\n\t\t\t * our leaf. Try to rotate it away.\n\t\t\t */\n\t\t\tret = ocfs2_rotate_tree_left(handle, et, path,\n\t\t\t\t\t\t     dealloc);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_tree_left",
          "args": [
            "handle",
            "et",
            "path",
            "dealloc"
          ],
          "line": 3828
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_tree_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3160-3269",
          "snippet": "static int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent block at %llu\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent block at %llu\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "0",
            "handle->h_buffer_credits",
            "path"
          ],
          "line": 3815
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2298-2310",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_merge_rec_right",
          "args": [
            "path",
            "handle",
            "et",
            "split_rec",
            "split_index"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_merge_rec_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3357-3468",
          "snippet": "static int ocfs2_merge_rec_right(struct ocfs2_path *left_path,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *split_rec,\n\t\t\t\t int index)\n{\n\tint ret, next_free, i;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *right_el;\n\tstruct ocfs2_path *right_path = NULL;\n\tint subtree_index = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(left_path);\n\tstruct buffer_head *bh = path_leaf_bh(left_path);\n\tstruct buffer_head *root_bh = NULL;\n\n\tBUG_ON(index >= le16_to_cpu(el->l_next_free_rec));\n\tleft_rec = &el->l_recs[index];\n\n\tif (index == le16_to_cpu(el->l_next_free_rec) - 1 &&\n\t    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_right_path(et, left_path, &right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tright_el = path_leaf_el(right_path);\n\t\tnext_free = le16_to_cpu(right_el->l_next_free_rec);\n\t\tBUG_ON(next_free <= 0);\n\t\tright_rec = &right_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(right_rec)) {\n\t\t\tBUG_ON(next_free <= 1);\n\t\t\tright_rec = &right_el->l_recs[1];\n\t\t}\n\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tBUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);\n\t\tright_rec = &el->l_recs[index + 1];\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, left_path,\n\t\t\t\t\t   path_num_items(left_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, -split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     -ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (right_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\nout:\n\tocfs2_free_path(right_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_merge_rec_right(struct ocfs2_path *left_path,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *split_rec,\n\t\t\t\t int index)\n{\n\tint ret, next_free, i;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *right_el;\n\tstruct ocfs2_path *right_path = NULL;\n\tint subtree_index = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(left_path);\n\tstruct buffer_head *bh = path_leaf_bh(left_path);\n\tstruct buffer_head *root_bh = NULL;\n\n\tBUG_ON(index >= le16_to_cpu(el->l_next_free_rec));\n\tleft_rec = &el->l_recs[index];\n\n\tif (index == le16_to_cpu(el->l_next_free_rec) - 1 &&\n\t    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_right_path(et, left_path, &right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tright_el = path_leaf_el(right_path);\n\t\tnext_free = le16_to_cpu(right_el->l_next_free_rec);\n\t\tBUG_ON(next_free <= 0);\n\t\tright_rec = &right_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(right_rec)) {\n\t\t\tBUG_ON(next_free <= 1);\n\t\t\tright_rec = &right_el->l_recs[1];\n\t\t}\n\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tBUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);\n\t\tright_rec = &el->l_recs[index + 1];\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, left_path,\n\t\t\t\t\t   path_num_items(left_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, -split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     -ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (right_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\nout:\n\tocfs2_free_path(right_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_merge_rec_left",
          "args": [
            "path",
            "handle",
            "et",
            "split_rec",
            "dealloc",
            "split_index"
          ],
          "line": 3796
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_merge_rec_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3523-3667",
          "snippet": "static int ocfs2_merge_rec_left(struct ocfs2_path *right_path,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_extent_rec *split_rec,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tint index)\n{\n\tint ret, i, subtree_index = 0, has_empty_extent = 0;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *el = path_leaf_el(right_path);\n\tstruct buffer_head *bh = path_leaf_bh(right_path);\n\tstruct buffer_head *root_bh = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\tBUG_ON(index < 0);\n\n\tright_rec = &el->l_recs[index];\n\tif (index == 0) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_left_path(et, right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tleft_el = path_leaf_el(left_path);\n\t\tBUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count));\n\n\t\tleft_rec = &left_el->l_recs[\n\t\t\t\tle16_to_cpu(left_el->l_next_free_rec) - 1];\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tleft_rec = &el->l_recs[index - 1];\n\t\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\t\thas_empty_extent = 1;\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   path_num_items(right_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (has_empty_extent && index == 1) {\n\t\t/*\n\t\t * The easy case - we can just plop the record right in.\n\t\t */\n\t\t*left_rec = *split_rec;\n\t} else\n\t\tle16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (left_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\t\t/*\n\t\t * In the situation that the right_rec is empty and the extent\n\t\t * block is empty also,  ocfs2_complete_edge_insert can't handle\n\t\t * it and we need to delete the right extent block.\n\t\t */\n\t\tif (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&\n\t\t    le16_to_cpu(el->l_next_free_rec) == 1) {\n\t\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tright_path);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_remove_rightmost_path(handle, et,\n\t\t\t\t\t\t\t  right_path,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Now the rightmost extent block has been deleted.\n\t\t\t * So we use the new rightmost path.\n\t\t\t */\n\t\t\tocfs2_mv_path(right_path, left_path);\n\t\t\tleft_path = NULL;\n\t\t} else\n\t\t\tocfs2_complete_edge_insert(handle, left_path,\n\t\t\t\t\t\t   right_path, subtree_index);\n\t}\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_merge_rec_left(struct ocfs2_path *right_path,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_extent_rec *split_rec,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tint index)\n{\n\tint ret, i, subtree_index = 0, has_empty_extent = 0;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *el = path_leaf_el(right_path);\n\tstruct buffer_head *bh = path_leaf_bh(right_path);\n\tstruct buffer_head *root_bh = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\tBUG_ON(index < 0);\n\n\tright_rec = &el->l_recs[index];\n\tif (index == 0) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_left_path(et, right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tleft_el = path_leaf_el(left_path);\n\t\tBUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count));\n\n\t\tleft_rec = &left_el->l_recs[\n\t\t\t\tle16_to_cpu(left_el->l_next_free_rec) - 1];\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tleft_rec = &el->l_recs[index - 1];\n\t\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\t\thas_empty_extent = 1;\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   path_num_items(right_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (has_empty_extent && index == 1) {\n\t\t/*\n\t\t * The easy case - we can just plop the record right in.\n\t\t */\n\t\t*left_rec = *split_rec;\n\t} else\n\t\tle16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (left_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\t\t/*\n\t\t * In the situation that the right_rec is empty and the extent\n\t\t * block is empty also,  ocfs2_complete_edge_insert can't handle\n\t\t * it and we need to delete the right extent block.\n\t\t */\n\t\tif (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&\n\t\t    le16_to_cpu(el->l_next_free_rec) == 1) {\n\t\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tright_path);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_remove_rightmost_path(handle, et,\n\t\t\t\t\t\t\t  right_path,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Now the rightmost extent block has been deleted.\n\t\t\t * So we use the new rightmost path.\n\t\t\t */\n\t\t\tocfs2_mv_path(right_path, left_path);\n\t\t\tleft_path = NULL;\n\t\t} else\n\t\t\tocfs2_complete_edge_insert(handle, left_path,\n\t\t\t\t\t\t   right_path, subtree_index);\n\t}\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ocfs2_is_empty_extent(&el->l_recs[0])"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3738
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ctxt->c_split_covers_rec"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ctxt->c_contig_type == CONTIG_NONE"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_try_to_merge_extent(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path,\n\t\t\t\t     int split_index,\n\t\t\t\t     struct ocfs2_extent_rec *split_rec,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     struct ocfs2_merge_ctxt *ctxt)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\n\tBUG_ON(ctxt->c_contig_type == CONTIG_NONE);\n\n\tif (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * The merge code will need to create an empty\n\t\t * extent to take the place of the newly\n\t\t * emptied slot. Remove any pre-existing empty\n\t\t * extents - having more than one in a leaf is\n\t\t * illegal.\n\t\t */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tsplit_index--;\n\t\trec = &el->l_recs[split_index];\n\t}\n\n\tif (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {\n\t\t/*\n\t\t * Left-right contig implies this.\n\t\t */\n\t\tBUG_ON(!ctxt->c_split_covers_rec);\n\n\t\t/*\n\t\t * Since the leftright insert always covers the entire\n\t\t * extent, this call will delete the insert record\n\t\t * entirely, resulting in an empty extent record added to\n\t\t * the extent block.\n\t\t *\n\t\t * Since the adding of an empty extent shifts\n\t\t * everything back to the right, there's no need to\n\t\t * update split_index here.\n\t\t *\n\t\t * When the split_index is zero, we need to merge it to the\n\t\t * prevoius extent block. It is more efficient and easier\n\t\t * if we do merge_right first and merge_left later.\n\t\t */\n\t\tret = ocfs2_merge_rec_right(path, handle, et, split_rec,\n\t\t\t\t\t    split_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We can only get this from logic error above.\n\t\t */\n\t\tBUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));\n\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The merge left us with an empty extent, remove it. */\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trec = &el->l_recs[split_index];\n\n\t\t/*\n\t\t * Note that we don't pass split_rec here on purpose -\n\t\t * we've merged it into the rec already.\n\t\t */\n\t\tret = ocfs2_merge_rec_left(path, handle, et, rec,\n\t\t\t\t\t   dealloc, split_index);\n\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\thandle->h_buffer_credits,\n\t\t\t\tpath);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_tree_left(handle, et, path, dealloc);\n\t\t/*\n\t\t * Error from this last rotate is not critical, so\n\t\t * print but don't bubble it up.\n\t\t */\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * Merge a record to the left or right.\n\t\t *\n\t\t * 'contig_type' is relative to the existing record,\n\t\t * so for example, if we're \"right contig\", it's to\n\t\t * the record on the left (hence the left merge).\n\t\t */\n\t\tif (ctxt->c_contig_type == CONTIG_RIGHT) {\n\t\t\tret = ocfs2_merge_rec_left(path, handle, et,\n\t\t\t\t\t\t   split_rec, dealloc,\n\t\t\t\t\t\t   split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ocfs2_merge_rec_right(path, handle,\n\t\t\t\t\t\t    et, split_rec,\n\t\t\t\t\t\t    split_index);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ctxt->c_split_covers_rec) {\n\t\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tpath);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The merge may have left an empty extent in\n\t\t\t * our leaf. Try to rotate it away.\n\t\t\t */\n\t\t\tret = ocfs2_rotate_tree_left(handle, et, path,\n\t\t\t\t\t\t     dealloc);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_merge_rec_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3523-3667",
    "snippet": "static int ocfs2_merge_rec_left(struct ocfs2_path *right_path,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_extent_rec *split_rec,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tint index)\n{\n\tint ret, i, subtree_index = 0, has_empty_extent = 0;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *el = path_leaf_el(right_path);\n\tstruct buffer_head *bh = path_leaf_bh(right_path);\n\tstruct buffer_head *root_bh = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\tBUG_ON(index < 0);\n\n\tright_rec = &el->l_recs[index];\n\tif (index == 0) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_left_path(et, right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tleft_el = path_leaf_el(left_path);\n\t\tBUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count));\n\n\t\tleft_rec = &left_el->l_recs[\n\t\t\t\tle16_to_cpu(left_el->l_next_free_rec) - 1];\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tleft_rec = &el->l_recs[index - 1];\n\t\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\t\thas_empty_extent = 1;\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   path_num_items(right_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (has_empty_extent && index == 1) {\n\t\t/*\n\t\t * The easy case - we can just plop the record right in.\n\t\t */\n\t\t*left_rec = *split_rec;\n\t} else\n\t\tle16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (left_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\t\t/*\n\t\t * In the situation that the right_rec is empty and the extent\n\t\t * block is empty also,  ocfs2_complete_edge_insert can't handle\n\t\t * it and we need to delete the right extent block.\n\t\t */\n\t\tif (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&\n\t\t    le16_to_cpu(el->l_next_free_rec) == 1) {\n\t\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tright_path);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_remove_rightmost_path(handle, et,\n\t\t\t\t\t\t\t  right_path,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Now the rightmost extent block has been deleted.\n\t\t\t * So we use the new rightmost path.\n\t\t\t */\n\t\t\tocfs2_mv_path(right_path, left_path);\n\t\t\tleft_path = NULL;\n\t\t} else\n\t\t\tocfs2_complete_edge_insert(handle, left_path,\n\t\t\t\t\t\t   right_path, subtree_index);\n\t}\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2052-2120",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_path",
          "args": [
            "right_path",
            "left_path"
          ],
          "line": 3658
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "656-672",
          "snippet": "static void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_rightmost_path",
          "args": [
            "handle",
            "et",
            "right_path",
            "dealloc"
          ],
          "line": 3647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_rightmost_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3031-3118",
          "snippet": "static int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "0",
            "handle->h_buffer_credits",
            "right_path"
          ],
          "line": 3639
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2298-2310",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 3637
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(left_path)"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cleanup_merge",
          "args": [
            "el",
            "index"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cleanup_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3271-3301",
          "snippet": "static void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&right_rec->e_leaf_clusters",
            "-split_clusters"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&right_rec->e_blkno",
            "ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters)"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "split_clusters"
          ],
          "line": 3621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&right_rec->e_cpos",
            "split_clusters"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&left_rec->e_leaf_clusters",
            "split_clusters"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "right_path",
            "path_num_items(right_path) - 1"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "735-750",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3600
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root_bh != right_path->p_node[subtree_index].bh"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1764-1792",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos)"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "split_rec->e_cpos"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count)"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_left_path",
          "args": [
            "et",
            "right_path",
            "&left_path"
          ],
          "line": 3545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_left_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3470-3511",
          "snippet": "static int ocfs2_get_left_path(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_path **ret_left_path)\n{\n\tint ret;\n\tu32 left_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    right_path, &left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the leftmost leaf. */\n\tBUG_ON(left_cpos == 0);\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_left_path = left_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_get_left_path(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_path **ret_left_path)\n{\n\tint ret;\n\tu32 left_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    right_path, &left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the leftmost leaf. */\n\tBUG_ON(left_cpos == 0);\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_left_path = left_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index < 0"
          ],
          "line": 3540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_merge_rec_left(struct ocfs2_path *right_path,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_extent_rec *split_rec,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\tint index)\n{\n\tint ret, i, subtree_index = 0, has_empty_extent = 0;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *el = path_leaf_el(right_path);\n\tstruct buffer_head *bh = path_leaf_bh(right_path);\n\tstruct buffer_head *root_bh = NULL;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\tBUG_ON(index < 0);\n\n\tright_rec = &el->l_recs[index];\n\tif (index == 0) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_left_path(et, right_path, &left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tleft_el = path_leaf_el(left_path);\n\t\tBUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=\n\t\t       le16_to_cpu(left_el->l_count));\n\n\t\tleft_rec = &left_el->l_recs[\n\t\t\t\tle16_to_cpu(left_el->l_next_free_rec) - 1];\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(split_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tleft_rec = &el->l_recs[index - 1];\n\t\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\t\thas_empty_extent = 1;\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   path_num_items(right_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (has_empty_extent && index == 1) {\n\t\t/*\n\t\t * The easy case - we can just plop the record right in.\n\t\t */\n\t\t*left_rec = *split_rec;\n\t} else\n\t\tle16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t      split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (left_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\t\t/*\n\t\t * In the situation that the right_rec is empty and the extent\n\t\t * block is empty also,  ocfs2_complete_edge_insert can't handle\n\t\t * it and we need to delete the right extent block.\n\t\t */\n\t\tif (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&\n\t\t    le16_to_cpu(el->l_next_free_rec) == 1) {\n\t\t\t/* extend credit for ocfs2_remove_rightmost_path */\n\t\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\thandle->h_buffer_credits,\n\t\t\t\t\tright_path);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_remove_rightmost_path(handle, et,\n\t\t\t\t\t\t\t  right_path,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Now the rightmost extent block has been deleted.\n\t\t\t * So we use the new rightmost path.\n\t\t\t */\n\t\t\tocfs2_mv_path(right_path, left_path);\n\t\t\tleft_path = NULL;\n\t\t} else\n\t\t\tocfs2_complete_edge_insert(handle, left_path,\n\t\t\t\t\t\t   right_path, subtree_index);\n\t}\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_left_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3470-3511",
    "snippet": "static int ocfs2_get_left_path(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_path **ret_left_path)\n{\n\tint ret;\n\tu32 left_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    right_path, &left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the leftmost leaf. */\n\tBUG_ON(left_cpos == 0);\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_left_path = left_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 3509
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "left_cpos"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "right_path"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "716-720",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "left_cpos == 0"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "right_path",
            "&left_cpos"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2225-2291",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_path->p_tree_depth == 0"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_get_left_path(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_path *right_path,\n\t\t\t       struct ocfs2_path **ret_left_path)\n{\n\tint ret;\n\tu32 left_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\n\t*ret_left_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(right_path->p_tree_depth == 0);\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    right_path, &left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the leftmost leaf. */\n\tBUG_ON(left_cpos == 0);\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, left_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_left_path = left_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(left_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_merge_rec_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3357-3468",
    "snippet": "static int ocfs2_merge_rec_right(struct ocfs2_path *left_path,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *split_rec,\n\t\t\t\t int index)\n{\n\tint ret, next_free, i;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *right_el;\n\tstruct ocfs2_path *right_path = NULL;\n\tint subtree_index = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(left_path);\n\tstruct buffer_head *bh = path_leaf_bh(left_path);\n\tstruct buffer_head *root_bh = NULL;\n\n\tBUG_ON(index >= le16_to_cpu(el->l_next_free_rec));\n\tleft_rec = &el->l_recs[index];\n\n\tif (index == le16_to_cpu(el->l_next_free_rec) - 1 &&\n\t    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_right_path(et, left_path, &right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tright_el = path_leaf_el(right_path);\n\t\tnext_free = le16_to_cpu(right_el->l_next_free_rec);\n\t\tBUG_ON(next_free <= 0);\n\t\tright_rec = &right_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(right_rec)) {\n\t\t\tBUG_ON(next_free <= 1);\n\t\t\tright_rec = &right_el->l_recs[1];\n\t\t}\n\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tBUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);\n\t\tright_rec = &el->l_recs[index + 1];\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, left_path,\n\t\t\t\t\t   path_num_items(left_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, -split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     -ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (right_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\nout:\n\tocfs2_free_path(right_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "right_path"
          ],
          "line": 3466
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2052-2120",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(right_path)"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cleanup_merge",
          "args": [
            "el",
            "index"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cleanup_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3271-3301",
          "snippet": "static void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&right_rec->e_leaf_clusters",
            "split_clusters"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&right_rec->e_blkno",
            "-ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters)"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "split_clusters"
          ],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&right_rec->e_cpos",
            "-split_clusters"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&left_rec->e_leaf_clusters",
            "-split_clusters"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "left_path",
            "path_num_items(left_path) - 1"
          ],
          "line": 3442
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "735-750",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "left_path"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index == le16_to_cpu(el->l_next_free_rec) - 1"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root_bh != right_path->p_node[subtree_index].bh"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "subtree_index",
            "handle->h_buffer_credits",
            "right_path"
          ],
          "line": 3402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2298-2310",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1764-1792",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos)"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "right_rec->e_cpos"
          ],
          "line": 3397
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next_free <= 1"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "right_rec"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next_free <= 0"
          ],
          "line": 3388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_right_path",
          "args": [
            "et",
            "left_path",
            "&right_path"
          ],
          "line": 3380
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_right_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3303-3348",
          "snippet": "static int ocfs2_get_right_path(struct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *left_path,\n\t\t\t\tstruct ocfs2_path **ret_right_path)\n{\n\tint ret;\n\tu32 right_cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\t*ret_right_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(left_path->p_tree_depth == 0);\n\n\tleft_el = path_leaf_el(left_path);\n\tBUG_ON(left_el->l_next_free_rec != left_el->l_count);\n\n\tret = ocfs2_find_cpos_for_right_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t     left_path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the rightmost leaf. */\n\tBUG_ON(right_cpos == 0);\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_right_path = right_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_get_right_path(struct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *left_path,\n\t\t\t\tstruct ocfs2_path **ret_right_path)\n{\n\tint ret;\n\tu32 right_cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\t*ret_right_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(left_path->p_tree_depth == 0);\n\n\tleft_el = path_leaf_el(left_path);\n\tBUG_ON(left_el->l_next_free_rec != left_el->l_count);\n\n\tret = ocfs2_find_cpos_for_right_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t     left_path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the rightmost leaf. */\n\tBUG_ON(right_cpos == 0);\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_right_path = right_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index >= le16_to_cpu(el->l_next_free_rec)"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 3370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_merge_rec_right(struct ocfs2_path *left_path,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_extent_rec *split_rec,\n\t\t\t\t int index)\n{\n\tint ret, next_free, i;\n\tunsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);\n\tstruct ocfs2_extent_rec *left_rec;\n\tstruct ocfs2_extent_rec *right_rec;\n\tstruct ocfs2_extent_list *right_el;\n\tstruct ocfs2_path *right_path = NULL;\n\tint subtree_index = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(left_path);\n\tstruct buffer_head *bh = path_leaf_bh(left_path);\n\tstruct buffer_head *root_bh = NULL;\n\n\tBUG_ON(index >= le16_to_cpu(el->l_next_free_rec));\n\tleft_rec = &el->l_recs[index];\n\n\tif (index == le16_to_cpu(el->l_next_free_rec) - 1 &&\n\t    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {\n\t\t/* we meet with a cross extent block merge. */\n\t\tret = ocfs2_get_right_path(et, left_path, &right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tright_el = path_leaf_el(right_path);\n\t\tnext_free = le16_to_cpu(right_el->l_next_free_rec);\n\t\tBUG_ON(next_free <= 0);\n\t\tright_rec = &right_el->l_recs[0];\n\t\tif (ocfs2_is_empty_extent(right_rec)) {\n\t\t\tBUG_ON(next_free <= 1);\n\t\t\tright_rec = &right_el->l_recs[1];\n\t\t}\n\n\t\tBUG_ON(le32_to_cpu(left_rec->e_cpos) +\n\t\t       le16_to_cpu(left_rec->e_leaf_clusters) !=\n\t\t       le32_to_cpu(right_rec->e_cpos));\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t\tright_path);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, subtree_index,\n\t\t\t\t\t\t      handle->h_buffer_credits,\n\t\t\t\t\t\t      right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\troot_bh = left_path->p_node[subtree_index].bh;\n\t\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t\t   subtree_index);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = subtree_index + 1;\n\t\t     i < path_num_items(right_path); i++) {\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   right_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t\t   left_path, i);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tBUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);\n\t\tright_rec = &el->l_recs[index + 1];\n\t}\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, left_path,\n\t\t\t\t\t   path_num_items(left_path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tle16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);\n\n\tle32_add_cpu(&right_rec->e_cpos, -split_clusters);\n\tle64_add_cpu(&right_rec->e_blkno,\n\t\t     -ocfs2_clusters_to_blocks(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t       split_clusters));\n\tle16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);\n\n\tocfs2_cleanup_merge(el, index);\n\n\tocfs2_journal_dirty(handle, bh);\n\tif (right_path) {\n\t\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\t}\nout:\n\tocfs2_free_path(right_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_right_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3303-3348",
    "snippet": "static int ocfs2_get_right_path(struct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *left_path,\n\t\t\t\tstruct ocfs2_path **ret_right_path)\n{\n\tint ret;\n\tu32 right_cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\t*ret_right_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(left_path->p_tree_depth == 0);\n\n\tleft_el = path_leaf_el(left_path);\n\tBUG_ON(left_el->l_next_free_rec != left_el->l_count);\n\n\tret = ocfs2_find_cpos_for_right_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t     left_path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the rightmost leaf. */\n\tBUG_ON(right_cpos == 0);\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_right_path = right_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "right_path"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "right_path",
            "right_cpos"
          ],
          "line": 3337
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "left_path"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "716-720",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_cpos == 0"
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_right_leaf",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "left_path",
            "&right_cpos"
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_right_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2820-2887",
          "snippet": "int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "left_el->l_next_free_rec != left_el->l_count"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "left_path->p_tree_depth == 0"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_get_right_path(struct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *left_path,\n\t\t\t\tstruct ocfs2_path **ret_right_path)\n{\n\tint ret;\n\tu32 right_cpos;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct ocfs2_extent_list *left_el;\n\n\t*ret_right_path = NULL;\n\n\t/* This function shouldn't be called for non-trees. */\n\tBUG_ON(left_path->p_tree_depth == 0);\n\n\tleft_el = path_leaf_el(left_path);\n\tBUG_ON(left_el->l_next_free_rec != left_el->l_count);\n\n\tret = ocfs2_find_cpos_for_right_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t     left_path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* This function shouldn't be called for the rightmost leaf. */\n\tBUG_ON(right_cpos == 0);\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*ret_right_path = right_path;\nout:\n\tif (ret)\n\t\tocfs2_free_path(right_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_cleanup_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3271-3301",
    "snippet": "static void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 3299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&el->l_recs[1]",
            "&el->l_recs[0]",
            "size"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ocfs2_is_empty_extent(&el->l_recs[0])"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,\n\t\t\t\tint index)\n{\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[index];\n\tunsigned int size;\n\n\tif (rec->e_leaf_clusters == 0) {\n\t\t/*\n\t\t * We consumed all of the merged-from record. An empty\n\t\t * extent cannot exist anywhere but the 1st array\n\t\t * position, so move things over if the merged-from\n\t\t * record doesn't occupy that position.\n\t\t *\n\t\t * This creates a new empty extent so the caller\n\t\t * should be smart enough to have removed any existing\n\t\t * ones.\n\t\t */\n\t\tif (index > 0) {\n\t\t\tBUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));\n\t\t\tsize = index * sizeof(struct ocfs2_extent_rec);\n\t\t\tmemmove(&el->l_recs[1], &el->l_recs[0], size);\n\t\t}\n\n\t\t/*\n\t\t * Always memset - the caller doesn't check whether it\n\t\t * created an empty extent, so there could be junk in\n\t\t * the other fields.\n\t\t */\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\t}\n}"
  },
  {
    "function_name": "ocfs2_rotate_tree_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3160-3269",
    "snippet": "static int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent block at %llu\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "restart_path"
          ],
          "line": 3267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_rotate_tree_left",
          "args": [
            "handle",
            "et",
            "orig_credits",
            "tmp_path",
            "dealloc",
            "&restart_path"
          ],
          "line": 3250
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_rotate_tree_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2914-3029",
          "snippet": "static int __ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    int orig_credits,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t    struct ocfs2_path **empty_extent_path)\n{\n\tint ret, subtree_root, deleted;\n\tu32 right_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])))\n\t\treturn 0;\n\n\t*empty_extent_path = NULL;\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tleft_path = ocfs2_new_path_from_path(path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_path(left_path, path);\n\n\tright_path = ocfs2_new_path_from_path(path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (right_cpos) {\n\t\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_root = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t       right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(subtree_root,\n\t\t     (unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr,\n\t\t     right_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t\t      orig_credits, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Caller might still want to make changes to the\n\t\t * tree root, so re-add it to the journal here.\n\t\t */\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_left(handle, et, left_path,\n\t\t\t\t\t\tright_path, subtree_root,\n\t\t\t\t\t\tdealloc, &deleted);\n\t\tif (ret == -EAGAIN) {\n\t\t\t/*\n\t\t\t * The rotation has to temporarily stop due to\n\t\t\t * the right subtree having an empty\n\t\t\t * extent. Pass it back to the caller for a\n\t\t\t * fixup.\n\t\t\t */\n\t\t\t*empty_extent_path = right_path;\n\t\t\tright_path = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The subtree rotate might have removed records on\n\t\t * the rightmost edge. If so, then rotation is\n\t\t * complete.\n\t\t */\n\t\tif (deleted)\n\t\t\tbreak;\n\n\t\tocfs2_mv_path(left_path, right_path);\n\n\t\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path,\n\t\t\t\t\t\t     &right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(right_path);\n\tocfs2_free_path(left_path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int __ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    int orig_credits,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t    struct ocfs2_path **empty_extent_path)\n{\n\tint ret, subtree_root, deleted;\n\tu32 right_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])))\n\t\treturn 0;\n\n\t*empty_extent_path = NULL;\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tleft_path = ocfs2_new_path_from_path(path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_path(left_path, path);\n\n\tright_path = ocfs2_new_path_from_path(path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (right_cpos) {\n\t\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_root = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t       right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(subtree_root,\n\t\t     (unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr,\n\t\t     right_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t\t      orig_credits, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Caller might still want to make changes to the\n\t\t * tree root, so re-add it to the journal here.\n\t\t */\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_left(handle, et, left_path,\n\t\t\t\t\t\tright_path, subtree_root,\n\t\t\t\t\t\tdealloc, &deleted);\n\t\tif (ret == -EAGAIN) {\n\t\t\t/*\n\t\t\t * The rotation has to temporarily stop due to\n\t\t\t * the right subtree having an empty\n\t\t\t * extent. Pass it back to the caller for a\n\t\t\t * fixup.\n\t\t\t */\n\t\t\t*empty_extent_path = right_path;\n\t\t\tright_path = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The subtree rotate might have removed records on\n\t\t * the rightmost edge. If so, then rotation is\n\t\t * complete.\n\t\t */\n\t\tif (deleted)\n\t\t\tbreak;\n\n\t\tocfs2_mv_path(left_path, right_path);\n\n\t\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path,\n\t\t\t\t\t\t     &right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(right_path);\n\tocfs2_free_path(left_path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_rightmost_path",
          "args": [
            "handle",
            "et",
            "path",
            "dealloc"
          ],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_rightmost_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3031-3118",
          "snippet": "static int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu has empty extent block at %llu\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "(unsigned long long)le64_to_cpu(eb->h_blkno)"
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 3213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_rightmost_leaf_left",
          "args": [
            "handle",
            "et",
            "path"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_rightmost_leaf_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2889-2912",
          "snippet": "static int ocfs2_rotate_rightmost_leaf_left(handle_t *handle,\n\t\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t\t    struct ocfs2_path *path)\n{\n\tint ret;\n\tstruct buffer_head *bh = path_leaf_bh(path);\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_empty_extent(el);\n\tocfs2_journal_dirty(handle, bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_rightmost_leaf_left(handle_t *handle,\n\t\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t\t    struct ocfs2_path *path)\n{\n\tint ret;\n\tstruct buffer_head *bh = path_leaf_bh(path);\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_empty_extent(el);\n\tocfs2_journal_dirty(handle, bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_path *path,\n\t\t\t\t  struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, orig_credits = handle->h_buffer_credits;\n\tstruct ocfs2_path *tmp_path = NULL, *restart_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tel = path_leaf_el(path);\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tif (path->p_tree_depth == 0) {\nrightmost_no_delete:\n\t\t/*\n\t\t * Inline extents. This is trivially handled, so do\n\t\t * it up front.\n\t\t */\n\t\tret = ocfs2_rotate_rightmost_leaf_left(handle, et, path);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle rightmost branch now. There's several cases:\n\t *  1) simple rotation leaving records in there. That's trivial.\n\t *  2) rotation requiring a branch delete - there's no more\n\t *     records left. Two cases of this:\n\t *     a) There are branches to the left.\n\t *     b) This is also the leftmost (the only) branch.\n\t *\n\t *  1) is handled via ocfs2_rotate_rightmost_leaf_left()\n\t *  2a) we need the left branch so that we can update it with the unlink\n\t *  2b) we need to bring the root back to inline extents.\n\t */\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tel = &eb->h_list;\n\tif (eb->h_next_leaf_blk == 0) {\n\t\t/*\n\t\t * This gets a bit tricky if we're going to delete the\n\t\t * rightmost path. Get the other cases out of the way\n\t\t * 1st.\n\t\t */\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1)\n\t\t\tgoto rightmost_no_delete;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tret = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent block at %llu\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * XXX: The caller can not trust \"path\" any more after\n\t\t * this as it will have been deleted. What do we do?\n\t\t *\n\t\t * In theory the rotate-for-merge code will never get\n\t\t * here because it'll always ask for a rotate in a\n\t\t * nonempty list.\n\t\t */\n\n\t\tret = ocfs2_remove_rightmost_path(handle, et, path,\n\t\t\t\t\t\t  dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now we can loop, remembering the path we get from -EAGAIN\n\t * and restarting from there.\n\t */\ntry_rotate:\n\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits, path,\n\t\t\t\t       dealloc, &restart_path);\n\tif (ret && ret != -EAGAIN) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (ret == -EAGAIN) {\n\t\ttmp_path = restart_path;\n\t\trestart_path = NULL;\n\n\t\tret = __ocfs2_rotate_tree_left(handle, et, orig_credits,\n\t\t\t\t\t       tmp_path, dealloc,\n\t\t\t\t\t       &restart_path);\n\t\tif (ret && ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_free_path(tmp_path);\n\t\ttmp_path = NULL;\n\n\t\tif (ret == 0)\n\t\t\tgoto try_rotate;\n\t}\n\nout:\n\tocfs2_free_path(tmp_path);\n\tocfs2_free_path(restart_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_remove_rightmost_empty_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3120-3142",
    "snippet": "static int ocfs2_remove_rightmost_empty_extent(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\thandle_t *handle;\n\tint ret;\n\tint credits = path->p_tree_depth * 2 + 1;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_remove_rightmost_path(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_rightmost_path",
          "args": [
            "handle",
            "et",
            "path",
            "dealloc"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_rightmost_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3031-3118",
          "snippet": "static int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_remove_rightmost_empty_extent(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\thandle_t *handle;\n\tint ret;\n\tint credits = path->p_tree_depth * 2 + 1;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_remove_rightmost_path(handle, et, path, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tocfs2_commit_trans(osb, handle);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_remove_rightmost_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "3031-3118",
    "snippet": "static int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_root_bh(path)"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "path"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_set_last_eb_blk",
          "args": [
            "et",
            "0"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_set_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "507-511",
          "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_unlink_path",
          "args": [
            "handle",
            "et",
            "dealloc",
            "path",
            "1"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlink_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2578-2621",
          "snippet": "static void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_edge_lengths",
          "args": [
            "handle",
            "et",
            "left_path"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_edge_lengths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2538-2576",
          "snippet": "static int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlink_subtree",
          "args": [
            "handle",
            "et",
            "left_path",
            "path",
            "subtree_index",
            "dealloc"
          ],
          "line": 3085
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlink_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2623-2654",
          "snippet": "static void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_block *eb;\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_block *eb;\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "path"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1764-1792",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "left_path"
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "755-774",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "cpos"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "path"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "716-720",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "path",
            "&cpos"
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2225-2291",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_sanity_check",
          "args": [
            "et"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_sanity_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "569-576",
          "snippet": "static inline int ocfs2_et_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_sanity_check)\n\t\tret = et->et_ops->eo_sanity_check(et);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_sanity_check)\n\t\tret = et->et_ops->eo_sanity_check(et);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_remove_rightmost_path(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tstruct ocfs2_path *path,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, subtree_index;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\n\tret = ocfs2_et_sanity_check(et);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t    path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (cpos) {\n\t\t/*\n\t\t * We have a path to the left of this one - it needs\n\t\t * an update too.\n\t\t */\n\t\tleft_path = ocfs2_new_path_from_path(path);\n\t\tif (!left_path) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_journal_access_path(et->et_ci, handle, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_index = ocfs2_find_subtree_root(et, left_path, path);\n\n\t\tocfs2_unlink_subtree(handle, et, left_path, path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\t} else {\n\t\t/*\n\t\t * 'path' is also the leftmost path which\n\t\t * means it must be the only one. This gets\n\t\t * handled differently because we want to\n\t\t * revert the root back to having extents\n\t\t * in-line.\n\t\t */\n\t\tocfs2_unlink_path(handle, et, dealloc, path, 1);\n\n\t\tel = et->et_root_el;\n\t\tel->l_tree_depth = 0;\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_et_set_last_eb_blk(et, 0);\n\t}\n\n\tocfs2_journal_dirty(handle, path_root_bh(path));\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_rotate_tree_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2914-3029",
    "snippet": "static int __ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    int orig_credits,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t    struct ocfs2_path **empty_extent_path)\n{\n\tint ret, subtree_root, deleted;\n\tu32 right_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])))\n\t\treturn 0;\n\n\t*empty_extent_path = NULL;\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tleft_path = ocfs2_new_path_from_path(path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_path(left_path, path);\n\n\tright_path = ocfs2_new_path_from_path(path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (right_cpos) {\n\t\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_root = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t       right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(subtree_root,\n\t\t     (unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr,\n\t\t     right_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t\t      orig_credits, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Caller might still want to make changes to the\n\t\t * tree root, so re-add it to the journal here.\n\t\t */\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_left(handle, et, left_path,\n\t\t\t\t\t\tright_path, subtree_root,\n\t\t\t\t\t\tdealloc, &deleted);\n\t\tif (ret == -EAGAIN) {\n\t\t\t/*\n\t\t\t * The rotation has to temporarily stop due to\n\t\t\t * the right subtree having an empty\n\t\t\t * extent. Pass it back to the caller for a\n\t\t\t * fixup.\n\t\t\t */\n\t\t\t*empty_extent_path = right_path;\n\t\t\tright_path = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The subtree rotate might have removed records on\n\t\t * the rightmost edge. If so, then rotation is\n\t\t * complete.\n\t\t */\n\t\tif (deleted)\n\t\t\tbreak;\n\n\t\tocfs2_mv_path(left_path, right_path);\n\n\t\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path,\n\t\t\t\t\t\t     &right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(right_path);\n\tocfs2_free_path(left_path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_right_leaf",
          "args": [
            "sb",
            "left_path",
            "&right_cpos"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_right_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2820-2887",
          "snippet": "int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_path",
          "args": [
            "left_path",
            "right_path"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "656-672",
          "snippet": "static void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_subtree_left",
          "args": [
            "handle",
            "et",
            "left_path",
            "right_path",
            "subtree_root",
            "dealloc",
            "&deleted"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_subtree_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2656-2809",
          "snippet": "static int ocfs2_rotate_subtree_left(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *left_path,\n\t\t\t\t     struct ocfs2_path *right_path,\n\t\t\t\t     int subtree_index,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int *deleted)\n{\n\tint ret, i, del_right_subtree = 0, right_has_empty = 0;\n\tstruct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);\n\tstruct ocfs2_extent_list *right_leaf_el, *left_leaf_el;\n\tstruct ocfs2_extent_block *eb;\n\n\t*deleted = 0;\n\n\tright_leaf_el = path_leaf_el(right_path);\n\tleft_leaf_el = path_leaf_el(left_path);\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tif (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))\n\t\treturn 0;\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;\n\tif (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {\n\t\t/*\n\t\t * It's legal for us to proceed if the right leaf is\n\t\t * the rightmost one and it has an empty extent. There\n\t\t * are two cases to handle - whether the leaf will be\n\t\t * empty after removal or not. If the leaf isn't empty\n\t\t * then just remove the empty extent up front. The\n\t\t * next block will handle empty leaves by flagging\n\t\t * them for unlink.\n\t\t *\n\t\t * Non rightmost leaves will throw -EAGAIN and the\n\t\t * caller can manually move the subtree and retry.\n\t\t */\n\n\t\tif (eb->h_next_leaf_blk != 0ULL)\n\t\t\treturn -EAGAIN;\n\n\t\tif (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {\n\t\t\tret = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t      path_leaf_bh(right_path),\n\t\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t\t} else\n\t\t\tright_has_empty = 1;\n\t}\n\n\tif (eb->h_next_leaf_blk == 0ULL &&\n\t    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {\n\t\t/*\n\t\t * We have to update i_last_eb_blk during the meta\n\t\t * data delete.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdel_right_subtree = 1;\n\t}\n\n\t/*\n\t * Getting here with an empty extent in the right path implies\n\t * that it's the rightmost path and will be deleted.\n\t */\n\tBUG_ON(right_has_empty && !del_right_subtree);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!right_has_empty) {\n\t\t/*\n\t\t * Only do this if we're moving a real\n\t\t * record. Otherwise, the action is delayed until\n\t\t * after removal of the right path in which case we\n\t\t * can do a simple shift to remove the empty extent.\n\t\t */\n\t\tocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);\n\t\tmemset(&right_leaf_el->l_recs[0], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t}\n\tif (eb->h_next_leaf_blk == 0ULL) {\n\t\t/*\n\t\t * Move recs over to get rid of empty extent, decrease\n\t\t * next_free. This is allowed to remove the last\n\t\t * extent in our leaf (setting l_next_free_rec to\n\t\t * zero) - the delete code below won't care.\n\t\t */\n\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\n\tif (del_right_subtree) {\n\t\tocfs2_unlink_subtree(handle, et, left_path, right_path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\t\t/*\n\t\t * Removal of the extent in the left leaf was skipped\n\t\t * above so we could delete the right path\n\t\t * 1st.\n\t\t */\n\t\tif (right_has_empty)\n\t\t\tocfs2_remove_empty_extent(left_leaf_el);\n\n\t\tocfs2_journal_dirty(handle, et_root_bh);\n\n\t\t*deleted = 1;\n\t} else\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_subtree_left(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *left_path,\n\t\t\t\t     struct ocfs2_path *right_path,\n\t\t\t\t     int subtree_index,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int *deleted)\n{\n\tint ret, i, del_right_subtree = 0, right_has_empty = 0;\n\tstruct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);\n\tstruct ocfs2_extent_list *right_leaf_el, *left_leaf_el;\n\tstruct ocfs2_extent_block *eb;\n\n\t*deleted = 0;\n\n\tright_leaf_el = path_leaf_el(right_path);\n\tleft_leaf_el = path_leaf_el(left_path);\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tif (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))\n\t\treturn 0;\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;\n\tif (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {\n\t\t/*\n\t\t * It's legal for us to proceed if the right leaf is\n\t\t * the rightmost one and it has an empty extent. There\n\t\t * are two cases to handle - whether the leaf will be\n\t\t * empty after removal or not. If the leaf isn't empty\n\t\t * then just remove the empty extent up front. The\n\t\t * next block will handle empty leaves by flagging\n\t\t * them for unlink.\n\t\t *\n\t\t * Non rightmost leaves will throw -EAGAIN and the\n\t\t * caller can manually move the subtree and retry.\n\t\t */\n\n\t\tif (eb->h_next_leaf_blk != 0ULL)\n\t\t\treturn -EAGAIN;\n\n\t\tif (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {\n\t\t\tret = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t      path_leaf_bh(right_path),\n\t\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t\t} else\n\t\t\tright_has_empty = 1;\n\t}\n\n\tif (eb->h_next_leaf_blk == 0ULL &&\n\t    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {\n\t\t/*\n\t\t * We have to update i_last_eb_blk during the meta\n\t\t * data delete.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdel_right_subtree = 1;\n\t}\n\n\t/*\n\t * Getting here with an empty extent in the right path implies\n\t * that it's the rightmost path and will be deleted.\n\t */\n\tBUG_ON(right_has_empty && !del_right_subtree);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!right_has_empty) {\n\t\t/*\n\t\t * Only do this if we're moving a real\n\t\t * record. Otherwise, the action is delayed until\n\t\t * after removal of the right path in which case we\n\t\t * can do a simple shift to remove the empty extent.\n\t\t */\n\t\tocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);\n\t\tmemset(&right_leaf_el->l_recs[0], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t}\n\tif (eb->h_next_leaf_blk == 0ULL) {\n\t\t/*\n\t\t * Move recs over to get rid of empty extent, decrease\n\t\t * next_free. This is allowed to remove the last\n\t\t * extent in our leaf (setting l_next_free_rec to\n\t\t * zero) - the delete code below won't care.\n\t\t */\n\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\n\tif (del_right_subtree) {\n\t\tocfs2_unlink_subtree(handle, et, left_path, right_path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\t\t/*\n\t\t * Removal of the extent in the left leaf was skipped\n\t\t * above so we could delete the right path\n\t\t * 1st.\n\t\t */\n\t\tif (right_has_empty)\n\t\t\tocfs2_remove_empty_extent(left_leaf_el);\n\n\t\tocfs2_journal_dirty(handle, et_root_bh);\n\n\t\t*deleted = 1;\n\t} else\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "left_path",
            "0"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "735-750",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "0",
            "orig_credits",
            "left_path"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2298-2310",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_subtree",
          "args": [
            "subtree_root",
            "(unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr",
            "right_path->p_tree_depth"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1764-1792",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "right_path",
            "right_cpos"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "path"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "716-720",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cp_path",
          "args": [
            "left_path",
            "path"
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cp_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "633-650",
          "snippet": "static void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_el(dest) != path_root_el(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tocfs2_reinit_path(dest, 1);\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tif (dest->p_node[i].bh)\n\t\t\tget_bh(dest->p_node[i].bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_el(dest) != path_root_el(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tocfs2_reinit_path(dest, 1);\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tif (dest->p_node[i].bh)\n\t\t\tget_bh(dest->p_node[i].bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&(path_leaf_el(path)->l_recs[0])"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int __ocfs2_rotate_tree_left(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    int orig_credits,\n\t\t\t\t    struct ocfs2_path *path,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t    struct ocfs2_path **empty_extent_path)\n{\n\tint ret, subtree_root, deleted;\n\tu32 right_cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_path *right_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\tif (!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])))\n\t\treturn 0;\n\n\t*empty_extent_path = NULL;\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, path, &right_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tleft_path = ocfs2_new_path_from_path(path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_cp_path(left_path, path);\n\n\tright_path = ocfs2_new_path_from_path(path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (right_cpos) {\n\t\tret = ocfs2_find_path(et->et_ci, right_path, right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsubtree_root = ocfs2_find_subtree_root(et, left_path,\n\t\t\t\t\t\t       right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(subtree_root,\n\t\t     (unsigned long long)\n\t\t     right_path->p_node[subtree_root].bh->b_blocknr,\n\t\t     right_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, 0,\n\t\t\t\t\t\t      orig_credits, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Caller might still want to make changes to the\n\t\t * tree root, so re-add it to the journal here.\n\t\t */\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_left(handle, et, left_path,\n\t\t\t\t\t\tright_path, subtree_root,\n\t\t\t\t\t\tdealloc, &deleted);\n\t\tif (ret == -EAGAIN) {\n\t\t\t/*\n\t\t\t * The rotation has to temporarily stop due to\n\t\t\t * the right subtree having an empty\n\t\t\t * extent. Pass it back to the caller for a\n\t\t\t * fixup.\n\t\t\t */\n\t\t\t*empty_extent_path = right_path;\n\t\t\tright_path = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The subtree rotate might have removed records on\n\t\t * the rightmost edge. If so, then rotation is\n\t\t * complete.\n\t\t */\n\t\tif (deleted)\n\t\t\tbreak;\n\n\t\tocfs2_mv_path(left_path, right_path);\n\n\t\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path,\n\t\t\t\t\t\t     &right_cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(right_path);\n\tocfs2_free_path(left_path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_rotate_rightmost_leaf_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2889-2912",
    "snippet": "static int ocfs2_rotate_rightmost_leaf_left(handle_t *handle,\n\t\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t\t    struct ocfs2_path *path)\n{\n\tint ret;\n\tstruct buffer_head *bh = path_leaf_bh(path);\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_empty_extent(el);\n\tocfs2_journal_dirty(handle, bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_empty_extent",
          "args": [
            "el"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1704-1718",
          "snippet": "static void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "path",
            "path_num_items(path) - 1"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "735-750",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_rightmost_leaf_left(handle_t *handle,\n\t\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t\t    struct ocfs2_path *path)\n{\n\tint ret;\n\tstruct buffer_head *bh = path_leaf_bh(path);\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\n\tif (!ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn 0;\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, path,\n\t\t\t\t\t   path_num_items(path) - 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_empty_extent(el);\n\tocfs2_journal_dirty(handle, bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_cpos_for_right_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2820-2887",
    "snippet": "int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Invalid extent tree at extent block %llu\\n\"",
            "(unsigned long long)blkno"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "el->l_recs[j + 1].e_cpos"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "el->l_recs[j].e_blkno"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_rotate_subtree_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2656-2809",
    "snippet": "static int ocfs2_rotate_subtree_left(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *left_path,\n\t\t\t\t     struct ocfs2_path *right_path,\n\t\t\t\t     int subtree_index,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int *deleted)\n{\n\tint ret, i, del_right_subtree = 0, right_has_empty = 0;\n\tstruct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);\n\tstruct ocfs2_extent_list *right_leaf_el, *left_leaf_el;\n\tstruct ocfs2_extent_block *eb;\n\n\t*deleted = 0;\n\n\tright_leaf_el = path_leaf_el(right_path);\n\tleft_leaf_el = path_leaf_el(left_path);\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tif (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))\n\t\treturn 0;\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;\n\tif (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {\n\t\t/*\n\t\t * It's legal for us to proceed if the right leaf is\n\t\t * the rightmost one and it has an empty extent. There\n\t\t * are two cases to handle - whether the leaf will be\n\t\t * empty after removal or not. If the leaf isn't empty\n\t\t * then just remove the empty extent up front. The\n\t\t * next block will handle empty leaves by flagging\n\t\t * them for unlink.\n\t\t *\n\t\t * Non rightmost leaves will throw -EAGAIN and the\n\t\t * caller can manually move the subtree and retry.\n\t\t */\n\n\t\tif (eb->h_next_leaf_blk != 0ULL)\n\t\t\treturn -EAGAIN;\n\n\t\tif (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {\n\t\t\tret = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t      path_leaf_bh(right_path),\n\t\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t\t} else\n\t\t\tright_has_empty = 1;\n\t}\n\n\tif (eb->h_next_leaf_blk == 0ULL &&\n\t    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {\n\t\t/*\n\t\t * We have to update i_last_eb_blk during the meta\n\t\t * data delete.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdel_right_subtree = 1;\n\t}\n\n\t/*\n\t * Getting here with an empty extent in the right path implies\n\t * that it's the rightmost path and will be deleted.\n\t */\n\tBUG_ON(right_has_empty && !del_right_subtree);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!right_has_empty) {\n\t\t/*\n\t\t * Only do this if we're moving a real\n\t\t * record. Otherwise, the action is delayed until\n\t\t * after removal of the right path in which case we\n\t\t * can do a simple shift to remove the empty extent.\n\t\t */\n\t\tocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);\n\t\tmemset(&right_leaf_el->l_recs[0], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t}\n\tif (eb->h_next_leaf_blk == 0ULL) {\n\t\t/*\n\t\t * Move recs over to get rid of empty extent, decrease\n\t\t * next_free. This is allowed to remove the last\n\t\t * extent in our leaf (setting l_next_free_rec to\n\t\t * zero) - the delete code below won't care.\n\t\t */\n\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\n\tif (del_right_subtree) {\n\t\tocfs2_unlink_subtree(handle, et, left_path, right_path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\t\t/*\n\t\t * Removal of the extent in the left leaf was skipped\n\t\t * above so we could delete the right path\n\t\t * 1st.\n\t\t */\n\t\tif (right_has_empty)\n\t\t\tocfs2_remove_empty_extent(left_leaf_el);\n\n\t\tocfs2_journal_dirty(handle, et_root_bh);\n\n\t\t*deleted = 1;\n\t} else\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2052-2120",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et_root_bh"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_empty_extent",
          "args": [
            "left_leaf_el"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1704-1718",
          "snippet": "static void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_set_last_eb_blk",
          "args": [
            "et",
            "le64_to_cpu(eb->h_blkno)"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_set_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "507-511",
          "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_edge_lengths",
          "args": [
            "handle",
            "et",
            "left_path"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_edge_lengths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2538-2576",
          "snippet": "static int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlink_subtree",
          "args": [
            "handle",
            "et",
            "left_path",
            "right_path",
            "subtree_index",
            "dealloc"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlink_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2623-2654",
          "snippet": "static void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_block *eb;\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_block *eb;\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&right_leaf_el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_leaf",
          "args": [
            "left_leaf_el",
            "&right_leaf_el->l_recs[0]"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1625-1702",
          "snippet": "static void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "left_path",
            "i"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "735-750",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_has_empty && !del_right_subtree"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "538-544",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "right_leaf_el->l_next_free_rec"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "et->et_ci",
            "path_leaf_bh(right_path)",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "731-735",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&right_leaf_el->l_recs[0]"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root_bh != right_path->p_node[subtree_index].bh"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "right_path"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_rotate_subtree_left(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *left_path,\n\t\t\t\t     struct ocfs2_path *right_path,\n\t\t\t\t     int subtree_index,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int *deleted)\n{\n\tint ret, i, del_right_subtree = 0, right_has_empty = 0;\n\tstruct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);\n\tstruct ocfs2_extent_list *right_leaf_el, *left_leaf_el;\n\tstruct ocfs2_extent_block *eb;\n\n\t*deleted = 0;\n\n\tright_leaf_el = path_leaf_el(right_path);\n\tleft_leaf_el = path_leaf_el(left_path);\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tif (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))\n\t\treturn 0;\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;\n\tif (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {\n\t\t/*\n\t\t * It's legal for us to proceed if the right leaf is\n\t\t * the rightmost one and it has an empty extent. There\n\t\t * are two cases to handle - whether the leaf will be\n\t\t * empty after removal or not. If the leaf isn't empty\n\t\t * then just remove the empty extent up front. The\n\t\t * next block will handle empty leaves by flagging\n\t\t * them for unlink.\n\t\t *\n\t\t * Non rightmost leaves will throw -EAGAIN and the\n\t\t * caller can manually move the subtree and retry.\n\t\t */\n\n\t\tif (eb->h_next_leaf_blk != 0ULL)\n\t\t\treturn -EAGAIN;\n\n\t\tif (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {\n\t\t\tret = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t      path_leaf_bh(right_path),\n\t\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t\t} else\n\t\t\tright_has_empty = 1;\n\t}\n\n\tif (eb->h_next_leaf_blk == 0ULL &&\n\t    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {\n\t\t/*\n\t\t * We have to update i_last_eb_blk during the meta\n\t\t * data delete.\n\t\t */\n\t\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdel_right_subtree = 1;\n\t}\n\n\t/*\n\t * Getting here with an empty extent in the right path implies\n\t * that it's the rightmost path and will be deleted.\n\t */\n\tBUG_ON(right_has_empty && !del_right_subtree);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!right_has_empty) {\n\t\t/*\n\t\t * Only do this if we're moving a real\n\t\t * record. Otherwise, the action is delayed until\n\t\t * after removal of the right path in which case we\n\t\t * can do a simple shift to remove the empty extent.\n\t\t */\n\t\tocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);\n\t\tmemset(&right_leaf_el->l_recs[0], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t}\n\tif (eb->h_next_leaf_blk == 0ULL) {\n\t\t/*\n\t\t * Move recs over to get rid of empty extent, decrease\n\t\t * next_free. This is allowed to remove the last\n\t\t * extent in our leaf (setting l_next_free_rec to\n\t\t * zero) - the delete code below won't care.\n\t\t */\n\t\tocfs2_remove_empty_extent(right_leaf_el);\n\t}\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\tocfs2_journal_dirty(handle, path_leaf_bh(right_path));\n\n\tif (del_right_subtree) {\n\t\tocfs2_unlink_subtree(handle, et, left_path, right_path,\n\t\t\t\t     subtree_index, dealloc);\n\t\tret = ocfs2_update_edge_lengths(handle, et, left_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\t\t/*\n\t\t * Removal of the extent in the left leaf was skipped\n\t\t * above so we could delete the right path\n\t\t * 1st.\n\t\t */\n\t\tif (right_has_empty)\n\t\t\tocfs2_remove_empty_extent(left_leaf_el);\n\n\t\tocfs2_journal_dirty(handle, et_root_bh);\n\n\t\t*deleted = 1;\n\t} else\n\t\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_unlink_subtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2623-2654",
    "snippet": "static void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_block *eb;\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlink_path",
          "args": [
            "handle",
            "et",
            "dealloc",
            "right_path",
            "subtree_index + 1"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlink_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2578-2621",
          "snippet": "static void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path_leaf_bh(left_path)"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&root_el->l_next_free_rec",
            "-1"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root_el->l_recs[i]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i >= le16_to_cpu(root_el->l_next_free_rec)"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_next_free_rec"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_subtree(handle_t *handle,\n\t\t\t\t struct ocfs2_extent_tree *et,\n\t\t\t\t struct ocfs2_path *left_path,\n\t\t\t\t struct ocfs2_path *right_path,\n\t\t\t\t int subtree_index,\n\t\t\t\t struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint i;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\tstruct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;\n\tstruct ocfs2_extent_block *eb;\n\n\teb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;\n\n\tfor(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tif (root_el->l_recs[i].e_blkno == eb->h_blkno)\n\t\t\tbreak;\n\n\tBUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));\n\n\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&root_el->l_next_free_rec, -1);\n\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;\n\teb->h_next_leaf_blk = 0;\n\n\tocfs2_journal_dirty(handle, root_bh);\n\tocfs2_journal_dirty(handle, path_leaf_bh(left_path));\n\n\tocfs2_unlink_path(handle, et, dealloc, right_path,\n\t\t\t  subtree_index + 1);\n}"
  },
  {
    "function_name": "ocfs2_unlink_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2578-2621",
    "snippet": "static void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_remove_from_cache",
          "args": [
            "et->et_ci",
            "bh"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "603-609",
          "snippet": "void ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cache_extent_block_free",
          "args": [
            "dealloc",
            "eb"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cache_extent_block_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6787-6795",
          "snippet": "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb)\n{\n\treturn ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_slot),\n\t\t\t\t\t le64_to_cpu(eb->h_suballoc_loc),\n\t\t\t\t\t le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_bit));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb)\n{\n\treturn ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_slot),\n\t\t\t\t\t le64_to_cpu(eb->h_suballoc_loc),\n\t\t\t\t\t le64_to_cpu(eb->h_blkno),\n\t\t\t\t\t le16_to_cpu(eb->h_suballoc_bit));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "(unsigned long long)le64_to_cpu(eb->h_blkno)",
            "le16_to_cpu(el->l_next_free_rec)"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "__mlog_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "67-98",
          "snippet": "void __mlog_printk(const u64 *mask, const char *func, int line,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *level;\n\tconst char *prefix = \"\";\n\n\tif (!__mlog_test_u64(*mask, mlog_and_bits) ||\n\t    __mlog_test_u64(*mask, mlog_not_bits))\n\t\treturn;\n\n\tif (*mask & ML_ERROR) {\n\t\tlevel = KERN_ERR;\n\t\tprefix = \"ERROR: \";\n\t} else if (*mask & ML_NOTICE) {\n\t\tlevel = KERN_NOTICE;\n\t} else {\n\t\tlevel = KERN_INFO;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%s(%s,%u,%u):%s:%d %s%pV\",\n\t       level, current->comm, task_pid_nr(current),\n\t       raw_smp_processor_id(), func, line, prefix, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nvoid __mlog_printk(const u64 *mask, const char *func, int line,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *level;\n\tconst char *prefix = \"\";\n\n\tif (!__mlog_test_u64(*mask, mlog_and_bits) ||\n\t    __mlog_test_u64(*mask, mlog_not_bits))\n\t\treturn;\n\n\tif (*mask & ML_ERROR) {\n\t\tlevel = KERN_ERR;\n\t\tprefix = \"ERROR: \";\n\t} else if (*mask & ML_NOTICE) {\n\t\tlevel = KERN_NOTICE;\n\t} else {\n\t\tlevel = KERN_INFO;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%s(%s,%u,%u):%s:%d %s%pV\",\n\t       level, current->comm, task_pid_nr(current),\n\t       raw_smp_processor_id(), func, line, prefix, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void ocfs2_unlink_path(handle_t *handle,\n\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t      struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t      struct ocfs2_path *path, int unlink_start)\n{\n\tint ret, i;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct buffer_head *bh;\n\n\tfor(i = unlink_start; i < path_num_items(path); i++) {\n\t\tbh = path->p_node[i].bh;\n\n\t\teb = (struct ocfs2_extent_block *)bh->b_data;\n\t\t/*\n\t\t * Not all nodes might have had their final count\n\t\t * decremented by the caller - handle this here.\n\t\t */\n\t\tel = &eb->h_list;\n\t\tif (le16_to_cpu(el->l_next_free_rec) > 1) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode %llu, attempted to remove extent block \"\n\t\t\t     \"%llu with %u records\\n\",\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t     (unsigned long long)le64_to_cpu(eb->h_blkno),\n\t\t\t     le16_to_cpu(el->l_next_free_rec));\n\n\t\t\tocfs2_journal_dirty(handle, bh);\n\t\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tel->l_next_free_rec = 0;\n\t\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\n\t\tret = ocfs2_cache_extent_block_free(dealloc, eb);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t\tocfs2_remove_from_cache(et->et_ci, bh);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_update_edge_lengths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2538-2576",
    "snippet": "static int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "path->p_node[i].bh"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->e_int_clusters",
            "-le32_to_cpu(rec->e_cpos)"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "range"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_next_free_rec) == 0"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "eb->h_next_leaf_blk != 0ULL"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "path"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "755-774",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_update_edge_lengths(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_path *path)\n{\n\tint i, idx, ret;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_block *eb;\n\tu32 range;\n\n\tret = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Path should always be rightmost. */\n\teb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;\n\tBUG_ON(eb->h_next_leaf_blk != 0ULL);\n\n\tel = &eb->h_list;\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);\n\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[idx];\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tel = path->p_node[i].el;\n\t\tidx = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\trec = &el->l_recs[idx];\n\n\t\trec->e_int_clusters = cpu_to_le32(range);\n\t\tle32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, path->p_node[i].bh);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_rotate_tree_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2377-2536",
    "snippet": "static int ocfs2_rotate_tree_right(handle_t *handle,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   enum ocfs2_split_type split,\n\t\t\t\t   u32 insert_cpos,\n\t\t\t\t   struct ocfs2_path *right_path,\n\t\t\t\t   struct ocfs2_path **ret_left_path)\n{\n\tint ret, start, orig_credits = handle->h_buffer_credits;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\t*ret_left_path = NULL;\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_rotate_tree_right(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tinsert_cpos, cpos);\n\n\t/*\n\t * What we want to do here is:\n\t *\n\t * 1) Start with the rightmost path.\n\t *\n\t * 2) Determine a path to the leaf block directly to the left\n\t *    of that leaf.\n\t *\n\t * 3) Determine the 'subtree root' - the lowest level tree node\n\t *    which contains a path to both leaves.\n\t *\n\t * 4) Rotate the subtree.\n\t *\n\t * 5) Find the next subtree by considering the left path to be\n\t *    the new right path.\n\t *\n\t * The check at the top of this while loop also accepts\n\t * insert_cpos == cpos because cpos is only a _theoretical_\n\t * value to get us the left path - insert_cpos might very well\n\t * be filling that hole.\n\t *\n\t * Stop at a cpos of '0' because we either started at the\n\t * leftmost branch (i.e., a tree with one branch and a\n\t * rotation inside of it), or we've gone as far as we can in\n\t * rotating subtrees.\n\t */\n\twhile (cpos && insert_cpos <= cpos) {\n\t\ttrace_ocfs2_rotate_tree_right(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tinsert_cpos, cpos);\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlog_bug_on_msg(path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path),\n\t\t\t\t\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tinsert_cpos, cpos,\n\t\t\t\t(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr);\n\n\t\tif (split == SPLIT_NONE &&\n\t\t    ocfs2_rotate_requires_path_adjustment(left_path,\n\t\t\t\t\t\t\t  insert_cpos)) {\n\n\t\t\t/*\n\t\t\t * We've rotated the tree as much as we\n\t\t\t * should. The rest is up to\n\t\t\t * ocfs2_insert_path() to complete, after the\n\t\t\t * record insertion. We indicate this\n\t\t\t * situation by returning the left path.\n\t\t\t *\n\t\t\t * The reason we don't adjust the records here\n\t\t\t * before the record insert is that an error\n\t\t\t * later might break the rule where a parent\n\t\t\t * record e_cpos will reflect the actual\n\t\t\t * e_cpos of the 1st nonempty record of the\n\t\t\t * child list.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\tstart = ocfs2_find_subtree_root(et, left_path, right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(start,\n\t\t\t(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr,\n\t\t\tright_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, start,\n\t\t\t\t\t\t      orig_credits, right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_right(handle, et, left_path,\n\t\t\t\t\t\t right_path, start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split != SPLIT_NONE &&\n\t\t    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),\n\t\t\t\t\t\tinsert_cpos)) {\n\t\t\t/*\n\t\t\t * A rotate moves the rightmost left leaf\n\t\t\t * record over to the leftmost right leaf\n\t\t\t * slot. If we're doing an extent split\n\t\t\t * instead of a real insert, then we have to\n\t\t\t * check that the extent to be split wasn't\n\t\t\t * just moved over. If it was, then we can\n\t\t\t * exit here, passing left_path back -\n\t\t\t * ocfs2_split_extent() is smart enough to\n\t\t\t * search both leaves.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to re-read the next right path\n\t\t * as we know that it'll be our current left\n\t\t * path. Optimize by copying values instead.\n\t\t */\n\t\tocfs2_mv_path(right_path, left_path);\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\nout_ret_path:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "left_path"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "sb",
            "right_path",
            "&cpos"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2225-2291",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_path",
          "args": [
            "right_path",
            "left_path"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "656-672",
          "snippet": "static void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_leftmost_rec_contains",
          "args": [
            "path_leaf_el(right_path)",
            "insert_cpos"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leftmost_rec_contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2338-2359",
          "snippet": "static int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (next_free == 0)\n\t\treturn 0;\n\n\trec = &el->l_recs[0];\n\tif (ocfs2_is_empty_extent(rec)) {\n\t\t/* Empty list. */\n\t\tif (next_free == 1)\n\t\t\treturn 0;\n\t\trec = &el->l_recs[1];\n\t}\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (next_free == 0)\n\t\treturn 0;\n\n\trec = &el->l_recs[0];\n\tif (ocfs2_is_empty_extent(rec)) {\n\t\t/* Empty list. */\n\t\tif (next_free == 1)\n\t\t\treturn 0;\n\t\trec = &el->l_recs[1];\n\t}\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_subtree_right",
          "args": [
            "handle",
            "et",
            "left_path",
            "right_path",
            "start"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_subtree_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2122-2217",
          "snippet": "static int ocfs2_rotate_subtree_right(handle_t *handle,\n\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t      struct ocfs2_path *left_path,\n\t\t\t\t      struct ocfs2_path *right_path,\n\t\t\t\t      int subtree_index)\n{\n\tint ret, i;\n\tstruct buffer_head *right_leaf_bh;\n\tstruct buffer_head *left_leaf_bh = NULL;\n\tstruct buffer_head *root_bh;\n\tstruct ocfs2_extent_list *right_el, *left_el;\n\tstruct ocfs2_extent_rec move_rec;\n\n\tleft_leaf_bh = path_leaf_bh(left_path);\n\tleft_el = path_leaf_el(left_path);\n\n\tif (left_el->l_next_free_rec != left_el->l_count) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Inode %llu has non-full interior leaf node %llu (next free = %u)\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    (unsigned long long)left_leaf_bh->b_blocknr,\n\t\t\t    le16_to_cpu(left_el->l_next_free_rec));\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * This extent block may already have an empty record, so we\n\t * return early if so.\n\t */\n\tif (ocfs2_is_empty_extent(&left_el->l_recs[0]))\n\t\treturn 0;\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tright_leaf_bh = path_leaf_bh(right_path);\n\tright_el = path_leaf_el(right_path);\n\n\t/* This is a code error, not a disk corruption. */\n\tmlog_bug_on_msg(!right_el->l_next_free_rec, \"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t(unsigned long long)right_leaf_bh->b_blocknr);\n\n\tocfs2_create_empty_extent(right_el);\n\n\tocfs2_journal_dirty(handle, right_leaf_bh);\n\n\t/* Do the copy now. */\n\ti = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\tmove_rec = left_el->l_recs[i];\n\tright_el->l_recs[0] = move_rec;\n\n\t/*\n\t * Clear out the record we just copied and shift everything\n\t * over, leaving an empty extent in the left leaf.\n\t *\n\t * We temporarily subtract from next_free_rec so that the\n\t * shift will lose the tail record (which is now defunct).\n\t */\n\tle16_add_cpu(&left_el->l_next_free_rec, -1);\n\tocfs2_shift_records_right(left_el);\n\tmemset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&left_el->l_next_free_rec, 1);\n\n\tocfs2_journal_dirty(handle, left_leaf_bh);\n\n\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_subtree_right(handle_t *handle,\n\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t      struct ocfs2_path *left_path,\n\t\t\t\t      struct ocfs2_path *right_path,\n\t\t\t\t      int subtree_index)\n{\n\tint ret, i;\n\tstruct buffer_head *right_leaf_bh;\n\tstruct buffer_head *left_leaf_bh = NULL;\n\tstruct buffer_head *root_bh;\n\tstruct ocfs2_extent_list *right_el, *left_el;\n\tstruct ocfs2_extent_rec move_rec;\n\n\tleft_leaf_bh = path_leaf_bh(left_path);\n\tleft_el = path_leaf_el(left_path);\n\n\tif (left_el->l_next_free_rec != left_el->l_count) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Inode %llu has non-full interior leaf node %llu (next free = %u)\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    (unsigned long long)left_leaf_bh->b_blocknr,\n\t\t\t    le16_to_cpu(left_el->l_next_free_rec));\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * This extent block may already have an empty record, so we\n\t * return early if so.\n\t */\n\tif (ocfs2_is_empty_extent(&left_el->l_recs[0]))\n\t\treturn 0;\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tright_leaf_bh = path_leaf_bh(right_path);\n\tright_el = path_leaf_el(right_path);\n\n\t/* This is a code error, not a disk corruption. */\n\tmlog_bug_on_msg(!right_el->l_next_free_rec, \"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t(unsigned long long)right_leaf_bh->b_blocknr);\n\n\tocfs2_create_empty_extent(right_el);\n\n\tocfs2_journal_dirty(handle, right_leaf_bh);\n\n\t/* Do the copy now. */\n\ti = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\tmove_rec = left_el->l_recs[i];\n\tright_el->l_recs[0] = move_rec;\n\n\t/*\n\t * Clear out the record we just copied and shift everything\n\t * over, leaving an empty extent in the left leaf.\n\t *\n\t * We temporarily subtract from next_free_rec so that the\n\t * shift will lose the tail record (which is now defunct).\n\t */\n\tle16_add_cpu(&left_el->l_next_free_rec, -1);\n\tocfs2_shift_records_right(left_el);\n\tmemset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&left_el->l_next_free_rec, 1);\n\n\tocfs2_journal_dirty(handle, left_leaf_bh);\n\n\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_rotate_transaction",
          "args": [
            "handle",
            "start",
            "orig_credits",
            "right_path"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_rotate_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2298-2310",
          "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_subtree",
          "args": [
            "start",
            "(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr",
            "right_path->p_tree_depth"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "et",
            "left_path",
            "right_path"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1764-1792",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rotate_requires_path_adjustment",
          "args": [
            "left_path",
            "insert_cpos"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_requires_path_adjustment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2322-2336",
          "snippet": "static int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,\n\t\t\t\t\t\t u32 insert_cpos)\n{\n\tstruct ocfs2_extent_list *left_el;\n\tstruct ocfs2_extent_rec *rec;\n\tint next_free;\n\n\tleft_el = path_leaf_el(left_path);\n\tnext_free = le16_to_cpu(left_el->l_next_free_rec);\n\trec = &left_el->l_recs[next_free - 1];\n\n\tif (insert_cpos > le32_to_cpu(rec->e_cpos))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,\n\t\t\t\t\t\t u32 insert_cpos)\n{\n\tstruct ocfs2_extent_list *left_el;\n\tstruct ocfs2_extent_rec *rec;\n\tint next_free;\n\n\tleft_el = path_leaf_el(left_path);\n\tnext_free = le16_to_cpu(left_el->l_next_free_rec);\n\trec = &left_el->l_recs[next_free - 1];\n\n\tif (insert_cpos > le32_to_cpu(rec->e_cpos))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path)",
            "\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "insert_cpos",
            "cpos",
            "(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "left_path",
            "cpos"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_tree_right",
          "args": [
            "(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci)",
            "insert_cpos",
            "cpos"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_tree_right",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "insert_cpos",
            "cpos"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "right_path"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "716-720",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_tree_right(handle_t *handle,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   enum ocfs2_split_type split,\n\t\t\t\t   u32 insert_cpos,\n\t\t\t\t   struct ocfs2_path *right_path,\n\t\t\t\t   struct ocfs2_path **ret_left_path)\n{\n\tint ret, start, orig_credits = handle->h_buffer_credits;\n\tu32 cpos;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\n\t*ret_left_path = NULL;\n\n\tleft_path = ocfs2_new_path_from_path(right_path);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_rotate_tree_right(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tinsert_cpos, cpos);\n\n\t/*\n\t * What we want to do here is:\n\t *\n\t * 1) Start with the rightmost path.\n\t *\n\t * 2) Determine a path to the leaf block directly to the left\n\t *    of that leaf.\n\t *\n\t * 3) Determine the 'subtree root' - the lowest level tree node\n\t *    which contains a path to both leaves.\n\t *\n\t * 4) Rotate the subtree.\n\t *\n\t * 5) Find the next subtree by considering the left path to be\n\t *    the new right path.\n\t *\n\t * The check at the top of this while loop also accepts\n\t * insert_cpos == cpos because cpos is only a _theoretical_\n\t * value to get us the left path - insert_cpos might very well\n\t * be filling that hole.\n\t *\n\t * Stop at a cpos of '0' because we either started at the\n\t * leftmost branch (i.e., a tree with one branch and a\n\t * rotation inside of it), or we've gone as far as we can in\n\t * rotating subtrees.\n\t */\n\twhile (cpos && insert_cpos <= cpos) {\n\t\ttrace_ocfs2_rotate_tree_right(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tinsert_cpos, cpos);\n\n\t\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlog_bug_on_msg(path_leaf_bh(left_path) ==\n\t\t\t\tpath_leaf_bh(right_path),\n\t\t\t\t\"Owner %llu: error during insert of %u \"\n\t\t\t\t\"(left path cpos %u) results in two identical \"\n\t\t\t\t\"paths ending at %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tinsert_cpos, cpos,\n\t\t\t\t(unsigned long long)\n\t\t\t\tpath_leaf_bh(left_path)->b_blocknr);\n\n\t\tif (split == SPLIT_NONE &&\n\t\t    ocfs2_rotate_requires_path_adjustment(left_path,\n\t\t\t\t\t\t\t  insert_cpos)) {\n\n\t\t\t/*\n\t\t\t * We've rotated the tree as much as we\n\t\t\t * should. The rest is up to\n\t\t\t * ocfs2_insert_path() to complete, after the\n\t\t\t * record insertion. We indicate this\n\t\t\t * situation by returning the left path.\n\t\t\t *\n\t\t\t * The reason we don't adjust the records here\n\t\t\t * before the record insert is that an error\n\t\t\t * later might break the rule where a parent\n\t\t\t * record e_cpos will reflect the actual\n\t\t\t * e_cpos of the 1st nonempty record of the\n\t\t\t * child list.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\tstart = ocfs2_find_subtree_root(et, left_path, right_path);\n\n\t\ttrace_ocfs2_rotate_subtree(start,\n\t\t\t(unsigned long long)\n\t\t\tright_path->p_node[start].bh->b_blocknr,\n\t\t\tright_path->p_tree_depth);\n\n\t\tret = ocfs2_extend_rotate_transaction(handle, start,\n\t\t\t\t\t\t      orig_credits, right_path);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_rotate_subtree_right(handle, et, left_path,\n\t\t\t\t\t\t right_path, start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (split != SPLIT_NONE &&\n\t\t    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),\n\t\t\t\t\t\tinsert_cpos)) {\n\t\t\t/*\n\t\t\t * A rotate moves the rightmost left leaf\n\t\t\t * record over to the leftmost right leaf\n\t\t\t * slot. If we're doing an extent split\n\t\t\t * instead of a real insert, then we have to\n\t\t\t * check that the extent to be split wasn't\n\t\t\t * just moved over. If it was, then we can\n\t\t\t * exit here, passing left_path back -\n\t\t\t * ocfs2_split_extent() is smart enough to\n\t\t\t * search both leaves.\n\t\t\t */\n\t\t\t*ret_left_path = left_path;\n\t\t\tgoto out_ret_path;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to re-read the next right path\n\t\t * as we know that it'll be our current left\n\t\t * path. Optimize by copying values instead.\n\t\t */\n\t\tocfs2_mv_path(right_path, left_path);\n\n\t\tret = ocfs2_find_cpos_for_left_leaf(sb, right_path, &cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(left_path);\n\nout_ret_path:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_leftmost_rec_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2338-2359",
    "snippet": "static int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (next_free == 0)\n\t\treturn 0;\n\n\trec = &el->l_recs[0];\n\tif (ocfs2_is_empty_extent(rec)) {\n\t\t/* Empty list. */\n\t\tif (next_free == 1)\n\t\t\treturn 0;\n\t\trec = &el->l_recs[1];\n\t}\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "rec"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tunsigned int range;\n\tstruct ocfs2_extent_rec *rec;\n\n\tif (next_free == 0)\n\t\treturn 0;\n\n\trec = &el->l_recs[0];\n\tif (ocfs2_is_empty_extent(rec)) {\n\t\t/* Empty list. */\n\t\tif (next_free == 1)\n\t\t\treturn 0;\n\t\trec = &el->l_recs[1];\n\t}\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_rotate_requires_path_adjustment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2322-2336",
    "snippet": "static int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,\n\t\t\t\t\t\t u32 insert_cpos)\n{\n\tstruct ocfs2_extent_list *left_el;\n\tstruct ocfs2_extent_rec *rec;\n\tint next_free;\n\n\tleft_el = path_leaf_el(left_path);\n\tnext_free = le16_to_cpu(left_el->l_next_free_rec);\n\trec = &left_el->l_recs[next_free - 1];\n\n\tif (insert_cpos > le32_to_cpu(rec->e_cpos))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "left_el->l_next_free_rec"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,\n\t\t\t\t\t\t u32 insert_cpos)\n{\n\tstruct ocfs2_extent_list *left_el;\n\tstruct ocfs2_extent_rec *rec;\n\tint next_free;\n\n\tleft_el = path_leaf_el(left_path);\n\tnext_free = le16_to_cpu(left_el->l_next_free_rec);\n\trec = &left_el->l_recs[next_free - 1];\n\n\tif (insert_cpos > le32_to_cpu(rec->e_cpos))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_extend_rotate_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2298-2310",
    "snippet": "static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "credits - handle->h_buffer_credits"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,\n\t\t\t\t\t   int op_credits,\n\t\t\t\t\t   struct ocfs2_path *path)\n{\n\tint ret = 0;\n\tint credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;\n\n\tif (handle->h_buffer_credits < credits)\n\t\tret = ocfs2_extend_trans(handle,\n\t\t\t\t\t credits - handle->h_buffer_credits);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_cpos_for_left_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2225-2291",
    "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Invalid extent tree at extent block %llu\\n\"",
            "(unsigned long long)blkno"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "&el->l_recs[j - 1]"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "el->l_recs[j - 1].e_cpos"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "el->l_recs[j].e_blkno"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path->p_tree_depth == 0"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb, \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_rotate_subtree_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2122-2217",
    "snippet": "static int ocfs2_rotate_subtree_right(handle_t *handle,\n\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t      struct ocfs2_path *left_path,\n\t\t\t\t      struct ocfs2_path *right_path,\n\t\t\t\t      int subtree_index)\n{\n\tint ret, i;\n\tstruct buffer_head *right_leaf_bh;\n\tstruct buffer_head *left_leaf_bh = NULL;\n\tstruct buffer_head *root_bh;\n\tstruct ocfs2_extent_list *right_el, *left_el;\n\tstruct ocfs2_extent_rec move_rec;\n\n\tleft_leaf_bh = path_leaf_bh(left_path);\n\tleft_el = path_leaf_el(left_path);\n\n\tif (left_el->l_next_free_rec != left_el->l_count) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Inode %llu has non-full interior leaf node %llu (next free = %u)\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    (unsigned long long)left_leaf_bh->b_blocknr,\n\t\t\t    le16_to_cpu(left_el->l_next_free_rec));\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * This extent block may already have an empty record, so we\n\t * return early if so.\n\t */\n\tif (ocfs2_is_empty_extent(&left_el->l_recs[0]))\n\t\treturn 0;\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tright_leaf_bh = path_leaf_bh(right_path);\n\tright_el = path_leaf_el(right_path);\n\n\t/* This is a code error, not a disk corruption. */\n\tmlog_bug_on_msg(!right_el->l_next_free_rec, \"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t(unsigned long long)right_leaf_bh->b_blocknr);\n\n\tocfs2_create_empty_extent(right_el);\n\n\tocfs2_journal_dirty(handle, right_leaf_bh);\n\n\t/* Do the copy now. */\n\ti = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\tmove_rec = left_el->l_recs[i];\n\tright_el->l_recs[0] = move_rec;\n\n\t/*\n\t * Clear out the record we just copied and shift everything\n\t * over, leaving an empty extent in the left leaf.\n\t *\n\t * We temporarily subtract from next_free_rec so that the\n\t * shift will lose the tail record (which is now defunct).\n\t */\n\tle16_add_cpu(&left_el->l_next_free_rec, -1);\n\tocfs2_shift_records_right(left_el);\n\tmemset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&left_el->l_next_free_rec, 1);\n\n\tocfs2_journal_dirty(handle, left_leaf_bh);\n\n\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_complete_edge_insert",
          "args": [
            "handle",
            "left_path",
            "right_path",
            "subtree_index"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_edge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2052-2120",
          "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "left_leaf_bh"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&left_el->l_next_free_rec",
            "1"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&left_el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_shift_records_right",
          "args": [
            "left_el"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_shift_records_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1610-1623",
          "snippet": "static void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&left_el->l_next_free_rec",
            "-1"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "left_el->l_next_free_rec"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_create_empty_extent",
          "args": [
            "right_el"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1727-1750",
          "snippet": "static void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (next_free == 0)\n\t\tgoto set_and_inc;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn;\n\n\tmlog_bug_on_msg(el->l_count == el->l_next_free_rec,\n\t\t\t\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\",\n\t\t\tle16_to_cpu(el->l_count),\n\t\t\tle16_to_cpu(el->l_tree_depth));\n\n\tocfs2_shift_records_right(el);\n\nset_and_inc:\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (next_free == 0)\n\t\tgoto set_and_inc;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn;\n\n\tmlog_bug_on_msg(el->l_count == el->l_next_free_rec,\n\t\t\t\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\",\n\t\t\tle16_to_cpu(el->l_count),\n\t\t\tle16_to_cpu(el->l_tree_depth));\n\n\tocfs2_shift_records_right(el);\n\nset_and_inc:\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!right_el->l_next_free_rec",
            "\"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "(unsigned long long)right_leaf_bh->b_blocknr"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right_path"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "left_path",
            "i"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "735-750",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "right_path"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root_bh != right_path->p_node[subtree_index].bh"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&left_el->l_recs[0]"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Inode %llu has non-full interior leaf node %llu (next free = %u)\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "(unsigned long long)left_leaf_bh->b_blocknr",
            "le16_to_cpu(left_el->l_next_free_rec)"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left_path"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_rotate_subtree_right(handle_t *handle,\n\t\t\t\t      struct ocfs2_extent_tree *et,\n\t\t\t\t      struct ocfs2_path *left_path,\n\t\t\t\t      struct ocfs2_path *right_path,\n\t\t\t\t      int subtree_index)\n{\n\tint ret, i;\n\tstruct buffer_head *right_leaf_bh;\n\tstruct buffer_head *left_leaf_bh = NULL;\n\tstruct buffer_head *root_bh;\n\tstruct ocfs2_extent_list *right_el, *left_el;\n\tstruct ocfs2_extent_rec move_rec;\n\n\tleft_leaf_bh = path_leaf_bh(left_path);\n\tleft_el = path_leaf_el(left_path);\n\n\tif (left_el->l_next_free_rec != left_el->l_count) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Inode %llu has non-full interior leaf node %llu (next free = %u)\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    (unsigned long long)left_leaf_bh->b_blocknr,\n\t\t\t    le16_to_cpu(left_el->l_next_free_rec));\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * This extent block may already have an empty record, so we\n\t * return early if so.\n\t */\n\tif (ocfs2_is_empty_extent(&left_el->l_recs[0]))\n\t\treturn 0;\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\tBUG_ON(root_bh != right_path->p_node[subtree_index].bh);\n\n\tret = ocfs2_path_bh_journal_access(handle, et->et_ci, right_path,\n\t\t\t\t\t   subtree_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tfor(i = subtree_index + 1; i < path_num_items(right_path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   right_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_path_bh_journal_access(handle, et->et_ci,\n\t\t\t\t\t\t   left_path, i);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tright_leaf_bh = path_leaf_bh(right_path);\n\tright_el = path_leaf_el(right_path);\n\n\t/* This is a code error, not a disk corruption. */\n\tmlog_bug_on_msg(!right_el->l_next_free_rec, \"Inode %llu: Rotate fails \"\n\t\t\t\"because rightmost leaf block %llu is empty\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t(unsigned long long)right_leaf_bh->b_blocknr);\n\n\tocfs2_create_empty_extent(right_el);\n\n\tocfs2_journal_dirty(handle, right_leaf_bh);\n\n\t/* Do the copy now. */\n\ti = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\tmove_rec = left_el->l_recs[i];\n\tright_el->l_recs[0] = move_rec;\n\n\t/*\n\t * Clear out the record we just copied and shift everything\n\t * over, leaving an empty extent in the left leaf.\n\t *\n\t * We temporarily subtract from next_free_rec so that the\n\t * shift will lose the tail record (which is now defunct).\n\t */\n\tle16_add_cpu(&left_el->l_next_free_rec, -1);\n\tocfs2_shift_records_right(left_el);\n\tmemset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n\tle16_add_cpu(&left_el->l_next_free_rec, 1);\n\n\tocfs2_journal_dirty(handle, left_leaf_bh);\n\n\tocfs2_complete_edge_insert(handle, left_path, right_path,\n\t\t\t\t   subtree_index);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_complete_edge_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2052-2120",
    "snippet": "static void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "root_bh"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_root_records",
          "args": [
            "el",
            "left_el",
            "right_el",
            "left_path->p_node[subtree_index + 1].bh->b_blocknr"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_root_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "2014-2037",
          "snippet": "static void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,\n\t\t\t\t      struct ocfs2_extent_list *left_el,\n\t\t\t\t      struct ocfs2_extent_list *right_el,\n\t\t\t\t      u64 left_el_blkno)\n{\n\tint i;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth));\n\n\tfor(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {\n\t\tif (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The path walking code should have never returned a root and\n\t * two paths which are not adjacent.\n\t */\n\tBUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));\n\n\tocfs2_adjust_adjacent_records(&root_el->l_recs[i],\n\t\t\t\t      &root_el->l_recs[i + 1], right_el);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,\n\t\t\t\t      struct ocfs2_extent_list *left_el,\n\t\t\t\t      struct ocfs2_extent_list *right_el,\n\t\t\t\t      u64 left_el_blkno)\n{\n\tint i;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth));\n\n\tfor(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {\n\t\tif (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The path walking code should have never returned a root and\n\t * two paths which are not adjacent.\n\t */\n\tBUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));\n\n\tocfs2_adjust_adjacent_records(&root_el->l_recs[i],\n\t\t\t\t      &root_el->l_recs[i + 1], right_el);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_adjacent_records",
          "args": [
            "left_rec",
            "right_rec",
            "right_el"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_adjacent_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1972-2007",
          "snippet": "static void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\n\nstatic void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "left_el->l_next_free_rec"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_complete_edge_insert",
          "args": [
            "i"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "right_path"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "left_path"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_complete_edge_insert(handle_t *handle,\n\t\t\t\t       struct ocfs2_path *left_path,\n\t\t\t\t       struct ocfs2_path *right_path,\n\t\t\t\t       int subtree_index)\n{\n\tint i, idx;\n\tstruct ocfs2_extent_list *el, *left_el, *right_el;\n\tstruct ocfs2_extent_rec *left_rec, *right_rec;\n\tstruct buffer_head *root_bh = left_path->p_node[subtree_index].bh;\n\n\t/*\n\t * Update the counts and position values within all the\n\t * interior nodes to reflect the leaf rotation we just did.\n\t *\n\t * The root node is handled below the loop.\n\t *\n\t * We begin the loop with right_el and left_el pointing to the\n\t * leaf lists and work our way up.\n\t *\n\t * NOTE: within this loop, left_el and right_el always refer\n\t * to the *child* lists.\n\t */\n\tleft_el = path_leaf_el(left_path);\n\tright_el = path_leaf_el(right_path);\n\tfor(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {\n\t\ttrace_ocfs2_complete_edge_insert(i);\n\n\t\t/*\n\t\t * One nice property of knowing that all of these\n\t\t * nodes are below the root is that we only deal with\n\t\t * the leftmost right node record and the rightmost\n\t\t * left node record.\n\t\t */\n\t\tel = left_path->p_node[i].el;\n\t\tidx = le16_to_cpu(left_el->l_next_free_rec) - 1;\n\t\tleft_rec = &el->l_recs[idx];\n\n\t\tel = right_path->p_node[i].el;\n\t\tright_rec = &el->l_recs[0];\n\n\t\tocfs2_adjust_adjacent_records(left_rec, right_rec, right_el);\n\n\t\tocfs2_journal_dirty(handle, left_path->p_node[i].bh);\n\t\tocfs2_journal_dirty(handle, right_path->p_node[i].bh);\n\n\t\t/*\n\t\t * Setup our list pointers now so that the current\n\t\t * parents become children in the next iteration.\n\t\t */\n\t\tleft_el = left_path->p_node[i].el;\n\t\tright_el = right_path->p_node[i].el;\n\t}\n\n\t/*\n\t * At the root node, adjust the two adjacent records which\n\t * begin our path to the leaves.\n\t */\n\n\tel = left_path->p_node[subtree_index].el;\n\tleft_el = left_path->p_node[subtree_index + 1].el;\n\tright_el = right_path->p_node[subtree_index + 1].el;\n\n\tocfs2_adjust_root_records(el, left_el, right_el,\n\t\t\t\t  left_path->p_node[subtree_index + 1].bh->b_blocknr);\n\n\troot_bh = left_path->p_node[subtree_index].bh;\n\n\tocfs2_journal_dirty(handle, root_bh);\n}"
  },
  {
    "function_name": "ocfs2_adjust_root_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "2014-2037",
    "snippet": "static void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,\n\t\t\t\t      struct ocfs2_extent_list *left_el,\n\t\t\t\t      struct ocfs2_extent_list *right_el,\n\t\t\t\t      u64 left_el_blkno)\n{\n\tint i;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth));\n\n\tfor(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {\n\t\tif (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The path walking code should have never returned a root and\n\t * two paths which are not adjacent.\n\t */\n\tBUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));\n\n\tocfs2_adjust_adjacent_records(&root_el->l_recs[i],\n\t\t\t\t      &root_el->l_recs[i + 1], right_el);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_adjust_adjacent_records",
          "args": [
            "&root_el->l_recs[i]",
            "&root_el->l_recs[i + 1]",
            "right_el"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_adjacent_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1972-2007",
          "snippet": "static void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\n\nstatic void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i >= (le16_to_cpu(root_el->l_next_free_rec) - 1)"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_next_free_rec"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "root_el->l_recs[i].e_blkno"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth)"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,\n\t\t\t\t      struct ocfs2_extent_list *left_el,\n\t\t\t\t      struct ocfs2_extent_list *right_el,\n\t\t\t\t      u64 left_el_blkno)\n{\n\tint i;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) <=\n\t       le16_to_cpu(left_el->l_tree_depth));\n\n\tfor(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {\n\t\tif (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * The path walking code should have never returned a root and\n\t * two paths which are not adjacent.\n\t */\n\tBUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));\n\n\tocfs2_adjust_adjacent_records(&root_el->l_recs[i],\n\t\t\t\t      &root_el->l_recs[i + 1], right_el);\n}"
  },
  {
    "function_name": "ocfs2_adjust_adjacent_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1972-2007",
    "snippet": "static void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "right_end"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "right_rec->e_cpos"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&right_rec->e_cpos",
            "left_clusters"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "left_clusters"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(right_child_el->l_next_free_rec) <= 1"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "right_child_el->l_next_free_rec"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "right_child_el->l_tree_depth"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "right_child_el",
            "&right_child_el->l_recs[0]"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\n\nstatic void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,\n\t\t\t\t  struct ocfs2_extent_rec *right_rec,\n\t\t\t\t  struct ocfs2_extent_list *right_child_el)\n{\n\tu32 left_clusters, right_end;\n\n\t/*\n\t * Interior nodes never have holes. Their cpos is the cpos of\n\t * the leftmost record in their child list. Their cluster\n\t * count covers the full theoretical range of their child list\n\t * - the range between their cpos and the cpos of the record\n\t * immediately to their right.\n\t */\n\tleft_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);\n\tif (!ocfs2_rec_clusters(right_child_el, &right_child_el->l_recs[0])) {\n\t\tBUG_ON(right_child_el->l_tree_depth);\n\t\tBUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);\n\t\tleft_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);\n\t}\n\tleft_clusters -= le32_to_cpu(left_rec->e_cpos);\n\tleft_rec->e_int_clusters = cpu_to_le32(left_clusters);\n\n\t/*\n\t * Calculate the rightmost cluster count boundary before\n\t * moving cpos - we will need to adjust clusters after\n\t * updating e_cpos to keep the same highest cluster count.\n\t */\n\tright_end = le32_to_cpu(right_rec->e_cpos);\n\tright_end += le32_to_cpu(right_rec->e_int_clusters);\n\n\tright_rec->e_cpos = left_rec->e_cpos;\n\tle32_add_cpu(&right_rec->e_cpos, left_clusters);\n\n\tright_end -= le32_to_cpu(right_rec->e_cpos);\n\tright_rec->e_int_clusters = cpu_to_le32(right_end);\n}"
  },
  {
    "function_name": "ocfs2_find_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1941-1957",
    "snippet": "int ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_find_path",
          "args": [
            "ci",
            "root_el",
            "cpos",
            "find_leaf_ins",
            "&bh"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1802-1884",
          "snippet": "static int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "find_leaf_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1920-1931",
    "snippet": "static void find_leaf_ins(void *data, struct buffer_head *bh)\n{\n\tstruct ocfs2_extent_block *eb =(struct ocfs2_extent_block *)bh->b_data;\n\tstruct ocfs2_extent_list *el = &eb->h_list;\n\tstruct buffer_head **ret = data;\n\n\t/* We want to retain only the leaf block. */\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tget_bh(bh);\n\t\t*ret = bh;\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_tree_depth"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic void find_leaf_ins(void *data, struct buffer_head *bh)\n{\n\tstruct ocfs2_extent_block *eb =(struct ocfs2_extent_block *)bh->b_data;\n\tstruct ocfs2_extent_list *el = &eb->h_list;\n\tstruct buffer_head **ret = data;\n\n\t/* We want to retain only the leaf block. */\n\tif (le16_to_cpu(el->l_tree_depth) == 0) {\n\t\tget_bh(bh);\n\t\t*ret = bh;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_find_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1909-1918",
    "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_find_path",
          "args": [
            "ci",
            "path_root_el(path)",
            "cpos",
            "find_path_ins",
            "&data"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1802-1884",
          "snippet": "static int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "path"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
  },
  {
    "function_name": "find_path_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1901-1908",
    "snippet": "static void find_path_ins(void *data, struct buffer_head *bh)\n{\n\tstruct find_path_data *fp = data;\n\n\tget_bh(bh);\n\tocfs2_path_insert_eb(fp->path, fp->index, bh);\n\tfp->index++;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_path_insert_eb",
          "args": [
            "fp->path",
            "fp->index",
            "bh"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_insert_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "679-694",
          "snippet": "static inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,\n\t\t\t\t\tstruct buffer_head *eb_bh)\n{\n\tstruct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t/*\n\t * Right now, no root bh is an extent block, so this helps\n\t * catch code errors with dinode trees. The assertion can be\n\t * safely removed if we ever need to insert extent block\n\t * structures at the root.\n\t */\n\tBUG_ON(index == 0);\n\n\tpath->p_node[index].bh = eb_bh;\n\tpath->p_node[index].el = &eb->h_list;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,\n\t\t\t\t\tstruct buffer_head *eb_bh)\n{\n\tstruct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t/*\n\t * Right now, no root bh is an extent block, so this helps\n\t * catch code errors with dinode trees. The assertion can be\n\t * safely removed if we ever need to insert extent block\n\t * structures at the root.\n\t */\n\tBUG_ON(index == 0);\n\n\tpath->p_node[index].bh = eb_bh;\n\tpath->p_node[index].el = &eb->h_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void find_path_ins(void *data, struct buffer_head *bh)\n{\n\tstruct find_path_data *fp = data;\n\n\tget_bh(bh);\n\tocfs2_path_insert_eb(fp->path, fp->index, bh);\n\tfp->index++;\n}"
  },
  {
    "function_name": "__ocfs2_find_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1802-1884",
    "snippet": "static int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "data",
            "bh"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6797-6802",
          "snippet": "static int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(ci)",
            "\"Owner %llu has bad count in extent list at block %llu (next free=%u, count=%u)\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(ci)",
            "(unsigned long long)bh->b_blocknr",
            "le16_to_cpu(el->l_next_free_rec)",
            "le16_to_cpu(el->l_count)"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_count"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "ci",
            "blkno",
            "&bh"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "944-958",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "el->l_recs[i].e_blkno"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int __ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t\t     struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t\t     path_insert_t *func, void *data)\n{\n\tint i, ret = 0;\n\tu32 range;\n\tu64 blkno;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tel = root_el;\n\twhile (el->l_tree_depth) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has empty extent list at depth %u\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {\n\t\t\trec = &el->l_recs[i];\n\n\t\t\t/*\n\t\t\t * In the case that cpos is off the allocation\n\t\t\t * tree, this should just wind up returning the\n\t\t\t * rightmost record.\n\t\t\t */\n\t\t\trange = le32_to_cpu(rec->e_cpos) +\n\t\t\t\tocfs2_rec_clusters(el, rec);\n\t\t\tif (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)\n\t\t\t    break;\n\t\t}\n\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (blkno == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad blkno in extent list at depth %u (index %d)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    le16_to_cpu(el->l_tree_depth), i);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\tret = ocfs2_read_extent_block(ci, blkno, &bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) >\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(ci),\n\t\t\t\t    \"Owner %llu has bad count in extent list at block %llu (next free=%u, count=%u)\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t\t    le16_to_cpu(el->l_next_free_rec),\n\t\t\t\t    le16_to_cpu(el->l_count));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (func)\n\t\t\tfunc(data, bh);\n\t}\n\nout:\n\t/*\n\t * Catch any trailing bh that the loop didn't handle.\n\t */\n\tbrelse(bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_subtree_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1764-1792",
    "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "i > left->p_tree_depth",
            "\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "left->p_tree_depth",
            "right->p_tree_depth",
            "(unsigned long long)path_leaf_bh(left)->b_blocknr",
            "(unsigned long long)path_leaf_bh(right)->b_blocknr"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "right"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "left"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_bh(left) != path_root_bh(right)"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "right"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "left"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
  },
  {
    "function_name": "ocfs2_create_empty_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1727-1750",
    "snippet": "static void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (next_free == 0)\n\t\tgoto set_and_inc;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn;\n\n\tmlog_bug_on_msg(el->l_count == el->l_next_free_rec,\n\t\t\t\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\",\n\t\t\tle16_to_cpu(el->l_count),\n\t\t\tle16_to_cpu(el->l_tree_depth));\n\n\tocfs2_shift_records_right(el);\n\nset_and_inc:\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[0]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&el->l_next_free_rec",
            "1"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_shift_records_right",
          "args": [
            "el"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_shift_records_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1610-1623",
          "snippet": "static void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "el->l_count == el->l_next_free_rec",
            "\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\"",
            "le16_to_cpu(el->l_count)",
            "le16_to_cpu(el->l_tree_depth)"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_tree_depth"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_tree_depth) != 0"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(le16_to_cpu(el->l_tree_depth) != 0);\n\n\tif (next_free == 0)\n\t\tgoto set_and_inc;\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0]))\n\t\treturn;\n\n\tmlog_bug_on_msg(el->l_count == el->l_next_free_rec,\n\t\t\t\"Asked to create an empty extent in a full list:\\n\"\n\t\t\t\"count = %u, tree depth = %u\",\n\t\t\tle16_to_cpu(el->l_count),\n\t\t\tle16_to_cpu(el->l_tree_depth));\n\n\tocfs2_shift_records_right(el);\n\nset_and_inc:\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\tmemset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));\n}"
  },
  {
    "function_name": "ocfs2_remove_empty_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1704-1718",
    "snippet": "static void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_recs"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&el->l_recs[num_recs]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&el->l_recs[0]",
            "&el->l_recs[1]",
            "size"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_recs == 0"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)\n{\n\tint size, num_recs = le16_to_cpu(el->l_next_free_rec);\n\n\tBUG_ON(num_recs == 0);\n\n\tif (ocfs2_is_empty_extent(&el->l_recs[0])) {\n\t\tnum_recs--;\n\t\tsize = num_recs * sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[0], &el->l_recs[1], size);\n\t\tmemset(&el->l_recs[num_recs], 0,\n\t\t       sizeof(struct ocfs2_extent_rec));\n\t\tel->l_next_free_rec = cpu_to_le16(num_recs);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_rotate_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1625-1702",
    "snippet": "static void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count)"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_count"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "next_free"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&el->l_recs[insert_index + 1]",
            "&el->l_recs[insert_index]",
            "num_bytes"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next_free >= le16_to_cpu(el->l_count)"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "insert_index > next_free"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "insert_index >= le16_to_cpu(el->l_count)"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "insert_index < 0"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_rotate_leaf",
          "args": [
            "insert_cpos",
            "insert_index",
            "has_empty",
            "next_free",
            "le16_to_cpu(el->l_count)"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "el->l_next_free_rec == el->l_count && !has_empty"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!next_free"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "&el->l_recs[0]"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "268-271",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,\n\t\t\t      struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, insert_index, next_free, has_empty, num_bytes;\n\tu32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);\n\tstruct ocfs2_extent_rec *rec;\n\n\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\thas_empty = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\tBUG_ON(!next_free);\n\n\t/* The tree code before us didn't allow enough room in the leaf. */\n\tBUG_ON(el->l_next_free_rec == el->l_count && !has_empty);\n\n\t/*\n\t * The easiest way to approach this is to just remove the\n\t * empty extent and temporarily decrement next_free.\n\t */\n\tif (has_empty) {\n\t\t/*\n\t\t * If next_free was 1 (only an empty extent), this\n\t\t * loop won't execute, which is fine. We still want\n\t\t * the decrement above to happen.\n\t\t */\n\t\tfor(i = 0; i < (next_free - 1); i++)\n\t\t\tel->l_recs[i] = el->l_recs[i+1];\n\n\t\tnext_free--;\n\t}\n\n\t/*\n\t * Figure out what the new record index should be.\n\t */\n\tfor(i = 0; i < next_free; i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (insert_cpos < le32_to_cpu(rec->e_cpos))\n\t\t\tbreak;\n\t}\n\tinsert_index = i;\n\n\ttrace_ocfs2_rotate_leaf(insert_cpos, insert_index,\n\t\t\t\thas_empty, next_free,\n\t\t\t\tle16_to_cpu(el->l_count));\n\n\tBUG_ON(insert_index < 0);\n\tBUG_ON(insert_index >= le16_to_cpu(el->l_count));\n\tBUG_ON(insert_index > next_free);\n\n\t/*\n\t * No need to memmove if we're just adding to the tail.\n\t */\n\tif (insert_index != next_free) {\n\t\tBUG_ON(next_free >= le16_to_cpu(el->l_count));\n\n\t\tnum_bytes = next_free - insert_index;\n\t\tnum_bytes *= sizeof(struct ocfs2_extent_rec);\n\t\tmemmove(&el->l_recs[insert_index + 1],\n\t\t\t&el->l_recs[insert_index],\n\t\t\tnum_bytes);\n\t}\n\n\t/*\n\t * Either we had an empty extent, and need to re-increment or\n\t * there was no empty extent on a non full rightmost leaf node,\n\t * in which case we still need to increment.\n\t */\n\tnext_free++;\n\tel->l_next_free_rec = cpu_to_le16(next_free);\n\t/*\n\t * Make sure none of the math above just messed up our tree.\n\t */\n\tBUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));\n\n\tel->l_recs[insert_index] = *insert_rec;\n\n}"
  },
  {
    "function_name": "ocfs2_shift_records_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1610-1623",
    "snippet": "static void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&el->l_recs[1]",
            "&el->l_recs[0]",
            "num_bytes"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next_free >= count"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!next_free"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_count"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_shift_records_right(struct ocfs2_extent_list *el)\n{\n\tint next_free = le16_to_cpu(el->l_next_free_rec);\n\tint count = le16_to_cpu(el->l_count);\n\tunsigned int num_bytes;\n\n\tBUG_ON(!next_free);\n\t/* This will cause us to go off the end of our extent list. */\n\tBUG_ON(next_free >= count);\n\n\tnum_bytes = sizeof(struct ocfs2_extent_rec) * next_free;\n\n\tmemmove(&el->l_recs[1], &el->l_recs[0], num_bytes);\n}"
  },
  {
    "function_name": "ocfs2_grow_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1539-1605",
    "snippet": "static int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL && ocfs2_is_dealloc_empty(et));\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_branch",
          "args": [
            "handle",
            "et",
            "bh",
            "last_eb_bh",
            "meta_ac"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1161-1357",
          "snippet": "static int ocfs2_add_branch(handle_t *handle,\n\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t    struct buffer_head *eb_bh,\n\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint status, new_blocks, i, block_given = 0;\n\tu64 next_blkno, new_last_eb_blk;\n\tstruct buffer_head *bh;\n\tstruct buffer_head **new_eb_bhs = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *eb_el;\n\tstruct ocfs2_extent_list  *el;\n\tu32 new_cpos, root_end;\n\n\tBUG_ON(!last_eb_bh || !*last_eb_bh);\n\n\tif (eb_bh) {\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t} else\n\t\tel = et->et_root_el;\n\n\t/* we never add a branch to a leaf. */\n\tBUG_ON(!el->l_tree_depth);\n\n\tnew_blocks = le16_to_cpu(el->l_tree_depth);\n\n\teb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;\n\tnew_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);\n\troot_end = ocfs2_sum_rightmost_rec(et->et_root_el);\n\n\t/*\n\t * If there is a gap before the root end and the real end\n\t * of the righmost leaf block, we need to remove the gap\n\t * between new_cpos and root_end first so that the tree\n\t * is consistent after we add a new branch(it will start\n\t * from new_cpos).\n\t */\n\tif (root_end > new_cpos) {\n\t\ttrace_ocfs2_adjust_rightmost_branch(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\troot_end, new_cpos);\n\n\t\tstatus = ocfs2_adjust_rightmost_branch(handle, et);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* allocate the number of new eb blocks we need */\n\tnew_eb_bhs = kcalloc(new_blocks, sizeof(struct buffer_head *),\n\t\t\t     GFP_KERNEL);\n\tif (!new_eb_bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Firstyly, try to reuse dealloc since we have already estimated how\n\t * many extent blocks we may use.\n\t */\n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      new_eb_bhs, new_blocks,\n\t\t\t\t\t\t      &block_given);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tBUG_ON(block_given > new_blocks);\n\n\tif (block_given < new_blocks) {\n\t\tBUG_ON(!meta_ac);\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et,\n\t\t\t\t\t\t   new_blocks - block_given,\n\t\t\t\t\t\t   meta_ac,\n\t\t\t\t\t\t   &new_eb_bhs[block_given]);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Note: new_eb_bhs[new_blocks - 1] is the guy which will be\n\t * linked with the rest of the tree.\n\t * conversly, new_eb_bhs[0] is the new bottommost leaf.\n\t *\n\t * when we leave the loop, new_last_eb_blk will point to the\n\t * newest leaf, and next_blkno will point to the topmost extent\n\t * block. */\n\tnext_blkno = new_last_eb_blk = 0;\n\tfor(i = 0; i < new_blocks; i++) {\n\t\tbh = new_eb_bhs[i];\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\t\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\t\teb_el = &eb->h_list;\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb->h_next_leaf_blk = 0;\n\t\teb_el->l_tree_depth = cpu_to_le16(i);\n\t\teb_el->l_next_free_rec = cpu_to_le16(1);\n\t\t/*\n\t\t * This actually counts as an empty extent as\n\t\t * c_clusters == 0\n\t\t */\n\t\teb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);\n\t\teb_el->l_recs[0].e_blkno = cpu_to_le64(next_blkno);\n\t\t/*\n\t\t * eb_el isn't always an interior node, but even leaf\n\t\t * nodes want a zero'd flags and reserved field so\n\t\t * this gets the whole 32 bits regardless of use.\n\t\t */\n\t\teb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);\n\t\tif (!eb_el->l_tree_depth)\n\t\t\tnew_last_eb_blk = le64_to_cpu(eb->h_blkno);\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t\tnext_blkno = le64_to_cpu(eb->h_blkno);\n\t}\n\n\t/* This is a bit hairy. We want to update up to three blocks\n\t * here without leaving any of them in an inconsistent state\n\t * in case of error. We don't have to worry about\n\t * journal_dirty erroring as it won't unless we've aborted the\n\t * handle (in which case we would never be here) so reserving\n\t * the write with journal_access is all we need to do. */\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, *last_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (eb_bh) {\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, eb_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Link the new branch into the rest of the tree (el will\n\t * either be on the root_bh, or the extent block passed in. */\n\ti = le16_to_cpu(el->l_next_free_rec);\n\tel->l_recs[i].e_blkno = cpu_to_le64(next_blkno);\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\tel->l_recs[i].e_int_clusters = 0;\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\n\t/* fe needs a new last extent block pointer, as does the\n\t * next_leaf on the previously last-extent-block. */\n\tocfs2_et_set_last_eb_blk(et, new_last_eb_blk);\n\n\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\teb->h_next_leaf_blk = cpu_to_le64(new_last_eb_blk);\n\n\tocfs2_journal_dirty(handle, *last_eb_bh);\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\tif (eb_bh)\n\t\tocfs2_journal_dirty(handle, eb_bh);\n\n\t/*\n\t * Some callers want to track the rightmost leaf so pass it\n\t * back here.\n\t */\n\tbrelse(*last_eb_bh);\n\tget_bh(new_eb_bhs[0]);\n\t*last_eb_bh = new_eb_bhs[0];\n\n\tstatus = 0;\nbail:\n\tif (new_eb_bhs) {\n\t\tfor (i = 0; i < new_blocks; i++)\n\t\t\tbrelse(new_eb_bhs[i]);\n\t\tkfree(new_eb_bhs);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_add_branch(handle_t *handle,\n\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t    struct buffer_head *eb_bh,\n\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint status, new_blocks, i, block_given = 0;\n\tu64 next_blkno, new_last_eb_blk;\n\tstruct buffer_head *bh;\n\tstruct buffer_head **new_eb_bhs = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *eb_el;\n\tstruct ocfs2_extent_list  *el;\n\tu32 new_cpos, root_end;\n\n\tBUG_ON(!last_eb_bh || !*last_eb_bh);\n\n\tif (eb_bh) {\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t} else\n\t\tel = et->et_root_el;\n\n\t/* we never add a branch to a leaf. */\n\tBUG_ON(!el->l_tree_depth);\n\n\tnew_blocks = le16_to_cpu(el->l_tree_depth);\n\n\teb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;\n\tnew_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);\n\troot_end = ocfs2_sum_rightmost_rec(et->et_root_el);\n\n\t/*\n\t * If there is a gap before the root end and the real end\n\t * of the righmost leaf block, we need to remove the gap\n\t * between new_cpos and root_end first so that the tree\n\t * is consistent after we add a new branch(it will start\n\t * from new_cpos).\n\t */\n\tif (root_end > new_cpos) {\n\t\ttrace_ocfs2_adjust_rightmost_branch(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\troot_end, new_cpos);\n\n\t\tstatus = ocfs2_adjust_rightmost_branch(handle, et);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* allocate the number of new eb blocks we need */\n\tnew_eb_bhs = kcalloc(new_blocks, sizeof(struct buffer_head *),\n\t\t\t     GFP_KERNEL);\n\tif (!new_eb_bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Firstyly, try to reuse dealloc since we have already estimated how\n\t * many extent blocks we may use.\n\t */\n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      new_eb_bhs, new_blocks,\n\t\t\t\t\t\t      &block_given);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tBUG_ON(block_given > new_blocks);\n\n\tif (block_given < new_blocks) {\n\t\tBUG_ON(!meta_ac);\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et,\n\t\t\t\t\t\t   new_blocks - block_given,\n\t\t\t\t\t\t   meta_ac,\n\t\t\t\t\t\t   &new_eb_bhs[block_given]);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Note: new_eb_bhs[new_blocks - 1] is the guy which will be\n\t * linked with the rest of the tree.\n\t * conversly, new_eb_bhs[0] is the new bottommost leaf.\n\t *\n\t * when we leave the loop, new_last_eb_blk will point to the\n\t * newest leaf, and next_blkno will point to the topmost extent\n\t * block. */\n\tnext_blkno = new_last_eb_blk = 0;\n\tfor(i = 0; i < new_blocks; i++) {\n\t\tbh = new_eb_bhs[i];\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\t\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\t\teb_el = &eb->h_list;\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb->h_next_leaf_blk = 0;\n\t\teb_el->l_tree_depth = cpu_to_le16(i);\n\t\teb_el->l_next_free_rec = cpu_to_le16(1);\n\t\t/*\n\t\t * This actually counts as an empty extent as\n\t\t * c_clusters == 0\n\t\t */\n\t\teb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);\n\t\teb_el->l_recs[0].e_blkno = cpu_to_le64(next_blkno);\n\t\t/*\n\t\t * eb_el isn't always an interior node, but even leaf\n\t\t * nodes want a zero'd flags and reserved field so\n\t\t * this gets the whole 32 bits regardless of use.\n\t\t */\n\t\teb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);\n\t\tif (!eb_el->l_tree_depth)\n\t\t\tnew_last_eb_blk = le64_to_cpu(eb->h_blkno);\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t\tnext_blkno = le64_to_cpu(eb->h_blkno);\n\t}\n\n\t/* This is a bit hairy. We want to update up to three blocks\n\t * here without leaving any of them in an inconsistent state\n\t * in case of error. We don't have to worry about\n\t * journal_dirty erroring as it won't unless we've aborted the\n\t * handle (in which case we would never be here) so reserving\n\t * the write with journal_access is all we need to do. */\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, *last_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (eb_bh) {\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, eb_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Link the new branch into the rest of the tree (el will\n\t * either be on the root_bh, or the extent block passed in. */\n\ti = le16_to_cpu(el->l_next_free_rec);\n\tel->l_recs[i].e_blkno = cpu_to_le64(next_blkno);\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\tel->l_recs[i].e_int_clusters = 0;\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\n\t/* fe needs a new last extent block pointer, as does the\n\t * next_leaf on the previously last-extent-block. */\n\tocfs2_et_set_last_eb_blk(et, new_last_eb_blk);\n\n\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\teb->h_next_leaf_blk = cpu_to_le64(new_last_eb_blk);\n\n\tocfs2_journal_dirty(handle, *last_eb_bh);\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\tif (eb_bh)\n\t\tocfs2_journal_dirty(handle, eb_bh);\n\n\t/*\n\t * Some callers want to track the rightmost leaf so pass it\n\t * back here.\n\t */\n\tbrelse(*last_eb_bh);\n\tget_bh(new_eb_bhs[0]);\n\t*last_eb_bh = new_eb_bhs[0];\n\n\tstatus = 0;\nbail:\n\tif (new_eb_bhs) {\n\t\tfor (i = 0; i < new_blocks; i++)\n\t\t\tbrelse(new_eb_bhs[i]);\n\t\tkfree(new_eb_bhs);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*last_eb_bh"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_shift_tree_depth",
          "args": [
            "handle",
            "et",
            "meta_ac",
            "&bh"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_shift_tree_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1364-1447",
          "snippet": "static int ocfs2_shift_tree_depth(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t  struct buffer_head **ret_new_eb_bh)\n{\n\tint status, i, block_given = 0;\n\tu32 new_clusters;\n\tstruct buffer_head *new_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *root_el;\n\tstruct ocfs2_extent_list  *eb_el;\n\n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      &new_eb_bh, 1,\n\t\t\t\t\t\t      &block_given);\n\t} else if (meta_ac) {\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et, 1, meta_ac,\n\t\t\t\t\t\t   &new_eb_bh);\n\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\teb = (struct ocfs2_extent_block *) new_eb_bh->b_data;\n\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\n\teb_el = &eb->h_list;\n\troot_el = et->et_root_el;\n\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, new_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* copy the root extent list data into the new extent block */\n\teb_el->l_tree_depth = root_el->l_tree_depth;\n\teb_el->l_next_free_rec = root_el->l_next_free_rec;\n\tfor (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\teb_el->l_recs[i] = root_el->l_recs[i];\n\n\tocfs2_journal_dirty(handle, new_eb_bh);\n\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tnew_clusters = ocfs2_sum_rightmost_rec(eb_el);\n\n\t/* update root_bh now */\n\tle16_add_cpu(&root_el->l_tree_depth, 1);\n\troot_el->l_recs[0].e_cpos = 0;\n\troot_el->l_recs[0].e_blkno = eb->h_blkno;\n\troot_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);\n\tfor (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\troot_el->l_next_free_rec = cpu_to_le16(1);\n\n\t/* If this is our 1st tree depth shift, then last_eb_blk\n\t * becomes the allocated extent block */\n\tif (root_el->l_tree_depth == cpu_to_le16(1))\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\t*ret_new_eb_bh = new_eb_bh;\n\tnew_eb_bh = NULL;\n\tstatus = 0;\nbail:\n\tbrelse(new_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_shift_tree_depth(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t  struct buffer_head **ret_new_eb_bh)\n{\n\tint status, i, block_given = 0;\n\tu32 new_clusters;\n\tstruct buffer_head *new_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *root_el;\n\tstruct ocfs2_extent_list  *eb_el;\n\n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      &new_eb_bh, 1,\n\t\t\t\t\t\t      &block_given);\n\t} else if (meta_ac) {\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et, 1, meta_ac,\n\t\t\t\t\t\t   &new_eb_bh);\n\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\teb = (struct ocfs2_extent_block *) new_eb_bh->b_data;\n\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\n\teb_el = &eb->h_list;\n\troot_el = et->et_root_el;\n\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, new_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* copy the root extent list data into the new extent block */\n\teb_el->l_tree_depth = root_el->l_tree_depth;\n\teb_el->l_next_free_rec = root_el->l_next_free_rec;\n\tfor (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\teb_el->l_recs[i] = root_el->l_recs[i];\n\n\tocfs2_journal_dirty(handle, new_eb_bh);\n\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tnew_clusters = ocfs2_sum_rightmost_rec(eb_el);\n\n\t/* update root_bh now */\n\tle16_add_cpu(&root_el->l_tree_depth, 1);\n\troot_el->l_recs[0].e_cpos = 0;\n\troot_el->l_recs[0].e_blkno = eb->h_blkno;\n\troot_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);\n\tfor (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\troot_el->l_next_free_rec = cpu_to_le16(1);\n\n\t/* If this is our 1st tree depth shift, then last_eb_blk\n\t * becomes the allocated extent block */\n\tif (root_el->l_tree_depth == cpu_to_le16(1))\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\t*ret_new_eb_bh = new_eb_bh;\n\tnew_eb_bh = NULL;\n\tstatus = 0;\nbail:\n\tbrelse(new_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_grow_tree",
          "args": [
            "(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci)",
            "depth"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bh"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_branch_target",
          "args": [
            "et",
            "&bh"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_branch_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1466-1527",
          "snippet": "static int ocfs2_find_branch_target(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **target_bh)\n{\n\tint status = 0, i;\n\tu64 blkno;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *el;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *lowest_bh = NULL;\n\n\t*target_bh = NULL;\n\n\tel = et->et_root_el;\n\n\twhile(le16_to_cpu(el->l_tree_depth) > 1) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent list (next_free_rec == 0)\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tgoto bail;\n\t\t}\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (!blkno) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has extent list where extent # %d has no physical block start\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci), i);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tstatus = ocfs2_read_extent_block(et->et_ci, blkno, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) <\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tbrelse(lowest_bh);\n\t\t\tlowest_bh = bh;\n\t\t\tget_bh(lowest_bh);\n\t\t}\n\t}\n\n\t/* If we didn't find one and the fe doesn't have any room,\n\t * then return '1' */\n\tel = et->et_root_el;\n\tif (!lowest_bh && (el->l_next_free_rec == el->l_count))\n\t\tstatus = 1;\n\n\t*target_bh = lowest_bh;\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_find_branch_target(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **target_bh)\n{\n\tint status = 0, i;\n\tu64 blkno;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *el;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *lowest_bh = NULL;\n\n\t*target_bh = NULL;\n\n\tel = et->et_root_el;\n\n\twhile(le16_to_cpu(el->l_tree_depth) > 1) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent list (next_free_rec == 0)\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tgoto bail;\n\t\t}\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (!blkno) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has extent list where extent # %d has no physical block start\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci), i);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tstatus = ocfs2_read_extent_block(et->et_ci, blkno, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) <\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tbrelse(lowest_bh);\n\t\t\tlowest_bh = bh;\n\t\t\tget_bh(lowest_bh);\n\t\t}\n\t}\n\n\t/* If we didn't find one and the fe doesn't have any room,\n\t * then return '1' */\n\tel = et->et_root_el;\n\tif (!lowest_bh && (el->l_next_free_rec == el->l_count))\n\t\tstatus = 1;\n\n\t*target_bh = lowest_bh;\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "meta_ac == NULL && ocfs2_is_dealloc_empty(et)"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_dealloc_empty",
          "args": [
            "et"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_dealloc_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6628-6643",
          "snippet": "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_per_slot_free_list *fl = NULL;\n\n\tif (!et->et_dealloc)\n\t\treturn 1;\n\n\tfl = et->et_dealloc->c_first_suballocator;\n\tif (!fl)\n\t\treturn 1;\n\n\tif (!fl->f_first)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_per_slot_free_list *fl = NULL;\n\n\tif (!et->et_dealloc)\n\t\treturn 1;\n\n\tfl = et->et_dealloc->c_first_suballocator;\n\tif (!fl)\n\t\treturn 1;\n\n\tif (!fl->f_first)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_tree_depth"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_grow_tree(handle_t *handle, struct ocfs2_extent_tree *et,\n\t\t\t   int *final_depth, struct buffer_head **last_eb_bh,\n\t\t\t   struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret, shift;\n\tstruct ocfs2_extent_list *el = et->et_root_el;\n\tint depth = le16_to_cpu(el->l_tree_depth);\n\tstruct buffer_head *bh = NULL;\n\n\tBUG_ON(meta_ac == NULL && ocfs2_is_dealloc_empty(et));\n\n\tshift = ocfs2_find_branch_target(et, &bh);\n\tif (shift < 0) {\n\t\tret = shift;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* We traveled all the way to the bottom of the allocation tree\n\t * and didn't find room for any more extents - we need to add\n\t * another tree level */\n\tif (shift) {\n\t\tBUG_ON(bh);\n\t\ttrace_ocfs2_grow_tree(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\tdepth);\n\n\t\t/* ocfs2_shift_tree_depth will return us a buffer with\n\t\t * the new extent block (so we can pass that to\n\t\t * ocfs2_add_branch). */\n\t\tret = ocfs2_shift_tree_depth(handle, et, meta_ac, &bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdepth++;\n\t\tif (depth == 1) {\n\t\t\t/*\n\t\t\t * Special case: we have room now if we shifted from\n\t\t\t * tree_depth 0, so no more work needs to be done.\n\t\t\t *\n\t\t\t * We won't be calling add_branch, so pass\n\t\t\t * back *last_eb_bh as the new leaf. At depth\n\t\t\t * zero, it should always be null so there's\n\t\t\t * no reason to brelse.\n\t\t\t */\n\t\t\tBUG_ON(*last_eb_bh);\n\t\t\tget_bh(bh);\n\t\t\t*last_eb_bh = bh;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* call ocfs2_add_branch to add the final part of the tree with\n\t * the new data. */\n\tret = ocfs2_add_branch(handle, et, bh, last_eb_bh,\n\t\t\t       meta_ac);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\tif (final_depth)\n\t\t*final_depth = depth;\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_branch_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1466-1527",
    "snippet": "static int ocfs2_find_branch_target(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **target_bh)\n{\n\tint status = 0, i;\n\tu64 blkno;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *el;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *lowest_bh = NULL;\n\n\t*target_bh = NULL;\n\n\tel = et->et_root_el;\n\n\twhile(le16_to_cpu(el->l_tree_depth) > 1) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent list (next_free_rec == 0)\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tgoto bail;\n\t\t}\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (!blkno) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has extent list where extent # %d has no physical block start\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci), i);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tstatus = ocfs2_read_extent_block(et->et_ci, blkno, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) <\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tbrelse(lowest_bh);\n\t\t\tlowest_bh = bh;\n\t\t\tget_bh(lowest_bh);\n\t\t}\n\t}\n\n\t/* If we didn't find one and the fe doesn't have any room,\n\t * then return '1' */\n\tel = et->et_root_el;\n\tif (!lowest_bh && (el->l_next_free_rec == el->l_count))\n\t\tstatus = 1;\n\n\t*target_bh = lowest_bh;\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "lowest_bh"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_count"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "blkno",
            "&bh"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "944-958",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "\"Owner %llu has extent list where extent # %d has no physical block start\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci)",
            "i"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "el->l_recs[i].e_blkno"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_find_branch_target(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct buffer_head **target_bh)\n{\n\tint status = 0, i;\n\tu64 blkno;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *el;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *lowest_bh = NULL;\n\n\t*target_bh = NULL;\n\n\tel = et->et_root_el;\n\n\twhile(le16_to_cpu(el->l_tree_depth) > 1) {\n\t\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has empty extent list (next_free_rec == 0)\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\tgoto bail;\n\t\t}\n\t\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\t\tblkno = le64_to_cpu(el->l_recs[i].e_blkno);\n\t\tif (!blkno) {\n\t\t\tstatus = ocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t\t\"Owner %llu has extent list where extent # %d has no physical block start\\n\",\n\t\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci), i);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tstatus = ocfs2_read_extent_block(et->et_ci, blkno, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (le16_to_cpu(el->l_next_free_rec) <\n\t\t    le16_to_cpu(el->l_count)) {\n\t\t\tbrelse(lowest_bh);\n\t\t\tlowest_bh = bh;\n\t\t\tget_bh(lowest_bh);\n\t\t}\n\t}\n\n\t/* If we didn't find one and the fe doesn't have any room,\n\t * then return '1' */\n\tel = et->et_root_el;\n\tif (!lowest_bh && (el->l_next_free_rec == el->l_count))\n\t\tstatus = 1;\n\n\t*target_bh = lowest_bh;\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_shift_tree_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1364-1447",
    "snippet": "static int ocfs2_shift_tree_depth(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t  struct buffer_head **ret_new_eb_bh)\n{\n\tint status, i, block_given = 0;\n\tu32 new_clusters;\n\tstruct buffer_head *new_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *root_el;\n\tstruct ocfs2_extent_list  *eb_el;\n\n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      &new_eb_bh, 1,\n\t\t\t\t\t\t      &block_given);\n\t} else if (meta_ac) {\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et, 1, meta_ac,\n\t\t\t\t\t\t   &new_eb_bh);\n\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\teb = (struct ocfs2_extent_block *) new_eb_bh->b_data;\n\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\n\teb_el = &eb->h_list;\n\troot_el = et->et_root_el;\n\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, new_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* copy the root extent list data into the new extent block */\n\teb_el->l_tree_depth = root_el->l_tree_depth;\n\teb_el->l_next_free_rec = root_el->l_next_free_rec;\n\tfor (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\teb_el->l_recs[i] = root_el->l_recs[i];\n\n\tocfs2_journal_dirty(handle, new_eb_bh);\n\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tnew_clusters = ocfs2_sum_rightmost_rec(eb_el);\n\n\t/* update root_bh now */\n\tle16_add_cpu(&root_el->l_tree_depth, 1);\n\troot_el->l_recs[0].e_cpos = 0;\n\troot_el->l_recs[0].e_blkno = eb->h_blkno;\n\troot_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);\n\tfor (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\troot_el->l_next_free_rec = cpu_to_le16(1);\n\n\t/* If this is our 1st tree depth shift, then last_eb_blk\n\t * becomes the allocated extent block */\n\tif (root_el->l_tree_depth == cpu_to_le16(1))\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\t*ret_new_eb_bh = new_eb_bh;\n\tnew_eb_bh = NULL;\n\tstatus = 0;\nbail:\n\tbrelse(new_eb_bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_eb_bh"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "et->et_root_bh"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_set_last_eb_blk",
          "args": [
            "et",
            "le64_to_cpu(eb->h_blkno)"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_set_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "507-511",
          "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root_el->l_recs[i]",
            "0",
            "sizeof(struct ocfs2_extent_rec)"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_next_free_rec"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_clusters"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&root_el->l_tree_depth",
            "1"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sum_rightmost_rec",
          "args": [
            "eb_el"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sum_rightmost_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1094-1102",
          "snippet": "static inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "538-544",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "et->et_ci",
            "new_eb_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "731-735",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_EXTENT_BLOCK(eb)"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_EXTENT_BLOCK",
          "args": [
            "eb"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_new_meta_bhs",
          "args": [
            "handle",
            "et",
            "1",
            "meta_ac",
            "&new_eb_bh"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_new_meta_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1001-1080",
          "snippet": "static int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reuse_blk_from_dealloc",
          "args": [
            "handle",
            "et",
            "&new_eb_bh",
            "1",
            "&block_given"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reuse_blk_from_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6651-6747",
          "snippet": "static int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given)\n{\n\tint i, status = 0, real_slot;\n\tstruct ocfs2_cached_dealloc_ctxt *dealloc;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *bf;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\t*blk_given = 0;\n\n\t/* If extent tree doesn't have a dealloc, this is not faulty. Just\n\t * tell upper caller dealloc can't provide any block and it should\n\t * ask for alloc to claim more space.\n\t */\n\tdealloc = et->et_dealloc;\n\tif (!dealloc)\n\t\tgoto bail;\n\n\tfor (i = 0; i < blk_wanted; i++) {\n\t\t/* Prefer to use local slot */\n\t\tfl = ocfs2_find_preferred_free_list(EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t\t    osb->slot_num, &real_slot,\n\t\t\t\t\t\t    dealloc);\n\t\t/* If no more block can be reused, we should claim more\n\t\t * from alloc. Just return here normally.\n\t\t */\n\t\tif (!fl) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tbf = fl->f_first;\n\t\tfl->f_first = bf->free_next;\n\n\t\tnew_eb_bh[i] = sb_getblk(osb->sb, bf->free_blk);\n\t\tif (new_eb_bh[i] == NULL) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmlog(0, \"Reusing block(%llu) from \"\n\t\t     \"dealloc(local slot:%d, real slot:%d)\\n\",\n\t\t     bf->free_blk, osb->slot_num, real_slot);\n\n\t\tocfs2_set_new_buffer_uptodate(et->et_ci, new_eb_bh[i]);\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t new_eb_bh[i],\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(new_eb_bh[i]->b_data, 0, osb->sb->s_blocksize);\n\t\teb = (struct ocfs2_extent_block *) new_eb_bh[i]->b_data;\n\n\t\t/* We can't guarantee that buffer head is still cached, so\n\t\t * polutlate the extent block again.\n\t\t */\n\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\teb->h_blkno = cpu_to_le64(bf->free_blk);\n\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\teb->h_suballoc_slot = cpu_to_le16(real_slot);\n\t\teb->h_suballoc_loc = cpu_to_le64(bf->free_bg);\n\t\teb->h_suballoc_bit = cpu_to_le16(bf->free_bit);\n\t\teb->h_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t/* We'll also be dirtied by the caller, so\n\t\t * this isn't absolutely necessary.\n\t\t */\n\t\tocfs2_journal_dirty(handle, new_eb_bh[i]);\n\n\t\tif (!fl->f_first) {\n\t\t\tdealloc->c_first_suballocator = fl->f_next_suballocator;\n\t\t\tkfree(fl);\n\t\t}\n\t\tkfree(bf);\n\t}\n\n\t*blk_given = i;\n\nbail:\n\tif (unlikely(status < 0)) {\n\t\tfor (i = 0; i < blk_wanted; i++)\n\t\t\tbrelse(new_eb_bh[i]);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given)\n{\n\tint i, status = 0, real_slot;\n\tstruct ocfs2_cached_dealloc_ctxt *dealloc;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *bf;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\t*blk_given = 0;\n\n\t/* If extent tree doesn't have a dealloc, this is not faulty. Just\n\t * tell upper caller dealloc can't provide any block and it should\n\t * ask for alloc to claim more space.\n\t */\n\tdealloc = et->et_dealloc;\n\tif (!dealloc)\n\t\tgoto bail;\n\n\tfor (i = 0; i < blk_wanted; i++) {\n\t\t/* Prefer to use local slot */\n\t\tfl = ocfs2_find_preferred_free_list(EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t\t    osb->slot_num, &real_slot,\n\t\t\t\t\t\t    dealloc);\n\t\t/* If no more block can be reused, we should claim more\n\t\t * from alloc. Just return here normally.\n\t\t */\n\t\tif (!fl) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tbf = fl->f_first;\n\t\tfl->f_first = bf->free_next;\n\n\t\tnew_eb_bh[i] = sb_getblk(osb->sb, bf->free_blk);\n\t\tif (new_eb_bh[i] == NULL) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmlog(0, \"Reusing block(%llu) from \"\n\t\t     \"dealloc(local slot:%d, real slot:%d)\\n\",\n\t\t     bf->free_blk, osb->slot_num, real_slot);\n\n\t\tocfs2_set_new_buffer_uptodate(et->et_ci, new_eb_bh[i]);\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t new_eb_bh[i],\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(new_eb_bh[i]->b_data, 0, osb->sb->s_blocksize);\n\t\teb = (struct ocfs2_extent_block *) new_eb_bh[i]->b_data;\n\n\t\t/* We can't guarantee that buffer head is still cached, so\n\t\t * polutlate the extent block again.\n\t\t */\n\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\teb->h_blkno = cpu_to_le64(bf->free_blk);\n\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\teb->h_suballoc_slot = cpu_to_le16(real_slot);\n\t\teb->h_suballoc_loc = cpu_to_le64(bf->free_bg);\n\t\teb->h_suballoc_bit = cpu_to_le16(bf->free_bit);\n\t\teb->h_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t/* We'll also be dirtied by the caller, so\n\t\t * this isn't absolutely necessary.\n\t\t */\n\t\tocfs2_journal_dirty(handle, new_eb_bh[i]);\n\n\t\tif (!fl->f_first) {\n\t\t\tdealloc->c_first_suballocator = fl->f_next_suballocator;\n\t\t\tkfree(fl);\n\t\t}\n\t\tkfree(bf);\n\t}\n\n\t*blk_given = i;\n\nbail:\n\tif (unlikely(status < 0)) {\n\t\tfor (i = 0; i < blk_wanted; i++)\n\t\t\tbrelse(new_eb_bh[i]);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_dealloc_empty",
          "args": [
            "et"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_dealloc_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6628-6643",
          "snippet": "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_per_slot_free_list *fl = NULL;\n\n\tif (!et->et_dealloc)\n\t\treturn 1;\n\n\tfl = et->et_dealloc->c_first_suballocator;\n\tif (!fl)\n\t\treturn 1;\n\n\tif (!fl->f_first)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_per_slot_free_list *fl = NULL;\n\n\tif (!et->et_dealloc)\n\t\treturn 1;\n\n\tfl = et->et_dealloc->c_first_suballocator;\n\tif (!fl)\n\t\treturn 1;\n\n\tif (!fl->f_first)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_shift_tree_depth(handle_t *handle,\n\t\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t  struct buffer_head **ret_new_eb_bh)\n{\n\tint status, i, block_given = 0;\n\tu32 new_clusters;\n\tstruct buffer_head *new_eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *root_el;\n\tstruct ocfs2_extent_list  *eb_el;\n\n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      &new_eb_bh, 1,\n\t\t\t\t\t\t      &block_given);\n\t} else if (meta_ac) {\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et, 1, meta_ac,\n\t\t\t\t\t\t   &new_eb_bh);\n\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\teb = (struct ocfs2_extent_block *) new_eb_bh->b_data;\n\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\n\teb_el = &eb->h_list;\n\troot_el = et->et_root_el;\n\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, new_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* copy the root extent list data into the new extent block */\n\teb_el->l_tree_depth = root_el->l_tree_depth;\n\teb_el->l_next_free_rec = root_el->l_next_free_rec;\n\tfor (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\teb_el->l_recs[i] = root_el->l_recs[i];\n\n\tocfs2_journal_dirty(handle, new_eb_bh);\n\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tnew_clusters = ocfs2_sum_rightmost_rec(eb_el);\n\n\t/* update root_bh now */\n\tle16_add_cpu(&root_el->l_tree_depth, 1);\n\troot_el->l_recs[0].e_cpos = 0;\n\troot_el->l_recs[0].e_blkno = eb->h_blkno;\n\troot_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);\n\tfor (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)\n\t\tmemset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));\n\troot_el->l_next_free_rec = cpu_to_le16(1);\n\n\t/* If this is our 1st tree depth shift, then last_eb_blk\n\t * becomes the allocated extent block */\n\tif (root_el->l_tree_depth == cpu_to_le16(1))\n\t\tocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\t*ret_new_eb_bh = new_eb_bh;\n\tnew_eb_bh = NULL;\n\tstatus = 0;\nbail:\n\tbrelse(new_eb_bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_add_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1161-1357",
    "snippet": "static int ocfs2_add_branch(handle_t *handle,\n\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t    struct buffer_head *eb_bh,\n\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint status, new_blocks, i, block_given = 0;\n\tu64 next_blkno, new_last_eb_blk;\n\tstruct buffer_head *bh;\n\tstruct buffer_head **new_eb_bhs = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *eb_el;\n\tstruct ocfs2_extent_list  *el;\n\tu32 new_cpos, root_end;\n\n\tBUG_ON(!last_eb_bh || !*last_eb_bh);\n\n\tif (eb_bh) {\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t} else\n\t\tel = et->et_root_el;\n\n\t/* we never add a branch to a leaf. */\n\tBUG_ON(!el->l_tree_depth);\n\n\tnew_blocks = le16_to_cpu(el->l_tree_depth);\n\n\teb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;\n\tnew_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);\n\troot_end = ocfs2_sum_rightmost_rec(et->et_root_el);\n\n\t/*\n\t * If there is a gap before the root end and the real end\n\t * of the righmost leaf block, we need to remove the gap\n\t * between new_cpos and root_end first so that the tree\n\t * is consistent after we add a new branch(it will start\n\t * from new_cpos).\n\t */\n\tif (root_end > new_cpos) {\n\t\ttrace_ocfs2_adjust_rightmost_branch(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\troot_end, new_cpos);\n\n\t\tstatus = ocfs2_adjust_rightmost_branch(handle, et);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* allocate the number of new eb blocks we need */\n\tnew_eb_bhs = kcalloc(new_blocks, sizeof(struct buffer_head *),\n\t\t\t     GFP_KERNEL);\n\tif (!new_eb_bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Firstyly, try to reuse dealloc since we have already estimated how\n\t * many extent blocks we may use.\n\t */\n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      new_eb_bhs, new_blocks,\n\t\t\t\t\t\t      &block_given);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tBUG_ON(block_given > new_blocks);\n\n\tif (block_given < new_blocks) {\n\t\tBUG_ON(!meta_ac);\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et,\n\t\t\t\t\t\t   new_blocks - block_given,\n\t\t\t\t\t\t   meta_ac,\n\t\t\t\t\t\t   &new_eb_bhs[block_given]);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Note: new_eb_bhs[new_blocks - 1] is the guy which will be\n\t * linked with the rest of the tree.\n\t * conversly, new_eb_bhs[0] is the new bottommost leaf.\n\t *\n\t * when we leave the loop, new_last_eb_blk will point to the\n\t * newest leaf, and next_blkno will point to the topmost extent\n\t * block. */\n\tnext_blkno = new_last_eb_blk = 0;\n\tfor(i = 0; i < new_blocks; i++) {\n\t\tbh = new_eb_bhs[i];\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\t\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\t\teb_el = &eb->h_list;\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb->h_next_leaf_blk = 0;\n\t\teb_el->l_tree_depth = cpu_to_le16(i);\n\t\teb_el->l_next_free_rec = cpu_to_le16(1);\n\t\t/*\n\t\t * This actually counts as an empty extent as\n\t\t * c_clusters == 0\n\t\t */\n\t\teb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);\n\t\teb_el->l_recs[0].e_blkno = cpu_to_le64(next_blkno);\n\t\t/*\n\t\t * eb_el isn't always an interior node, but even leaf\n\t\t * nodes want a zero'd flags and reserved field so\n\t\t * this gets the whole 32 bits regardless of use.\n\t\t */\n\t\teb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);\n\t\tif (!eb_el->l_tree_depth)\n\t\t\tnew_last_eb_blk = le64_to_cpu(eb->h_blkno);\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t\tnext_blkno = le64_to_cpu(eb->h_blkno);\n\t}\n\n\t/* This is a bit hairy. We want to update up to three blocks\n\t * here without leaving any of them in an inconsistent state\n\t * in case of error. We don't have to worry about\n\t * journal_dirty erroring as it won't unless we've aborted the\n\t * handle (in which case we would never be here) so reserving\n\t * the write with journal_access is all we need to do. */\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, *last_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (eb_bh) {\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, eb_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Link the new branch into the rest of the tree (el will\n\t * either be on the root_bh, or the extent block passed in. */\n\ti = le16_to_cpu(el->l_next_free_rec);\n\tel->l_recs[i].e_blkno = cpu_to_le64(next_blkno);\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\tel->l_recs[i].e_int_clusters = 0;\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\n\t/* fe needs a new last extent block pointer, as does the\n\t * next_leaf on the previously last-extent-block. */\n\tocfs2_et_set_last_eb_blk(et, new_last_eb_blk);\n\n\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\teb->h_next_leaf_blk = cpu_to_le64(new_last_eb_blk);\n\n\tocfs2_journal_dirty(handle, *last_eb_bh);\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\tif (eb_bh)\n\t\tocfs2_journal_dirty(handle, eb_bh);\n\n\t/*\n\t * Some callers want to track the rightmost leaf so pass it\n\t * back here.\n\t */\n\tbrelse(*last_eb_bh);\n\tget_bh(new_eb_bhs[0]);\n\t*last_eb_bh = new_eb_bhs[0];\n\n\tstatus = 0;\nbail:\n\tif (new_eb_bhs) {\n\t\tfor (i = 0; i < new_blocks; i++)\n\t\t\tbrelse(new_eb_bhs[i]);\n\t\tkfree(new_eb_bhs);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_eb_bhs"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_eb_bhs[i]"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "new_eb_bhs[0]"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "eb_bh"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "new_last_eb_blk"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_set_last_eb_blk",
          "args": [
            "et",
            "new_last_eb_blk"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_set_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "507-511",
          "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&el->l_next_free_rec",
            "1"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_cpos"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "next_blkno"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "et->et_ci",
            "eb_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "731-735",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_et_root_journal_access",
          "args": [
            "handle",
            "et",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_root_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "538-544",
          "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "next_blkno"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_cpos"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "i"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_EXTENT_BLOCK(eb)"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_EXTENT_BLOCK",
          "args": [
            "eb"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_new_meta_bhs",
          "args": [
            "handle",
            "et",
            "new_blocks - block_given",
            "meta_ac",
            "&new_eb_bhs[block_given]"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_new_meta_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1001-1080",
          "snippet": "static int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!meta_ac"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block_given > new_blocks"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reuse_blk_from_dealloc",
          "args": [
            "handle",
            "et",
            "new_eb_bhs",
            "new_blocks",
            "&block_given"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reuse_blk_from_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6651-6747",
          "snippet": "static int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given)\n{\n\tint i, status = 0, real_slot;\n\tstruct ocfs2_cached_dealloc_ctxt *dealloc;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *bf;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\t*blk_given = 0;\n\n\t/* If extent tree doesn't have a dealloc, this is not faulty. Just\n\t * tell upper caller dealloc can't provide any block and it should\n\t * ask for alloc to claim more space.\n\t */\n\tdealloc = et->et_dealloc;\n\tif (!dealloc)\n\t\tgoto bail;\n\n\tfor (i = 0; i < blk_wanted; i++) {\n\t\t/* Prefer to use local slot */\n\t\tfl = ocfs2_find_preferred_free_list(EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t\t    osb->slot_num, &real_slot,\n\t\t\t\t\t\t    dealloc);\n\t\t/* If no more block can be reused, we should claim more\n\t\t * from alloc. Just return here normally.\n\t\t */\n\t\tif (!fl) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tbf = fl->f_first;\n\t\tfl->f_first = bf->free_next;\n\n\t\tnew_eb_bh[i] = sb_getblk(osb->sb, bf->free_blk);\n\t\tif (new_eb_bh[i] == NULL) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmlog(0, \"Reusing block(%llu) from \"\n\t\t     \"dealloc(local slot:%d, real slot:%d)\\n\",\n\t\t     bf->free_blk, osb->slot_num, real_slot);\n\n\t\tocfs2_set_new_buffer_uptodate(et->et_ci, new_eb_bh[i]);\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t new_eb_bh[i],\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(new_eb_bh[i]->b_data, 0, osb->sb->s_blocksize);\n\t\teb = (struct ocfs2_extent_block *) new_eb_bh[i]->b_data;\n\n\t\t/* We can't guarantee that buffer head is still cached, so\n\t\t * polutlate the extent block again.\n\t\t */\n\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\teb->h_blkno = cpu_to_le64(bf->free_blk);\n\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\teb->h_suballoc_slot = cpu_to_le16(real_slot);\n\t\teb->h_suballoc_loc = cpu_to_le64(bf->free_bg);\n\t\teb->h_suballoc_bit = cpu_to_le16(bf->free_bit);\n\t\teb->h_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t/* We'll also be dirtied by the caller, so\n\t\t * this isn't absolutely necessary.\n\t\t */\n\t\tocfs2_journal_dirty(handle, new_eb_bh[i]);\n\n\t\tif (!fl->f_first) {\n\t\t\tdealloc->c_first_suballocator = fl->f_next_suballocator;\n\t\t\tkfree(fl);\n\t\t}\n\t\tkfree(bf);\n\t}\n\n\t*blk_given = i;\n\nbail:\n\tif (unlikely(status < 0)) {\n\t\tfor (i = 0; i < blk_wanted; i++)\n\t\t\tbrelse(new_eb_bh[i]);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_reuse_blk_from_dealloc(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct buffer_head **new_eb_bh,\n\t\t\t\t\tint blk_wanted, int *blk_given)\n{\n\tint i, status = 0, real_slot;\n\tstruct ocfs2_cached_dealloc_ctxt *dealloc;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *bf;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\t*blk_given = 0;\n\n\t/* If extent tree doesn't have a dealloc, this is not faulty. Just\n\t * tell upper caller dealloc can't provide any block and it should\n\t * ask for alloc to claim more space.\n\t */\n\tdealloc = et->et_dealloc;\n\tif (!dealloc)\n\t\tgoto bail;\n\n\tfor (i = 0; i < blk_wanted; i++) {\n\t\t/* Prefer to use local slot */\n\t\tfl = ocfs2_find_preferred_free_list(EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t\t    osb->slot_num, &real_slot,\n\t\t\t\t\t\t    dealloc);\n\t\t/* If no more block can be reused, we should claim more\n\t\t * from alloc. Just return here normally.\n\t\t */\n\t\tif (!fl) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tbf = fl->f_first;\n\t\tfl->f_first = bf->free_next;\n\n\t\tnew_eb_bh[i] = sb_getblk(osb->sb, bf->free_blk);\n\t\tif (new_eb_bh[i] == NULL) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmlog(0, \"Reusing block(%llu) from \"\n\t\t     \"dealloc(local slot:%d, real slot:%d)\\n\",\n\t\t     bf->free_blk, osb->slot_num, real_slot);\n\n\t\tocfs2_set_new_buffer_uptodate(et->et_ci, new_eb_bh[i]);\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t new_eb_bh[i],\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tmemset(new_eb_bh[i]->b_data, 0, osb->sb->s_blocksize);\n\t\teb = (struct ocfs2_extent_block *) new_eb_bh[i]->b_data;\n\n\t\t/* We can't guarantee that buffer head is still cached, so\n\t\t * polutlate the extent block again.\n\t\t */\n\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\teb->h_blkno = cpu_to_le64(bf->free_blk);\n\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\teb->h_suballoc_slot = cpu_to_le16(real_slot);\n\t\teb->h_suballoc_loc = cpu_to_le64(bf->free_bg);\n\t\teb->h_suballoc_bit = cpu_to_le16(bf->free_bit);\n\t\teb->h_list.l_count =\n\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t/* We'll also be dirtied by the caller, so\n\t\t * this isn't absolutely necessary.\n\t\t */\n\t\tocfs2_journal_dirty(handle, new_eb_bh[i]);\n\n\t\tif (!fl->f_first) {\n\t\t\tdealloc->c_first_suballocator = fl->f_next_suballocator;\n\t\t\tkfree(fl);\n\t\t}\n\t\tkfree(bf);\n\t}\n\n\t*blk_given = i;\n\nbail:\n\tif (unlikely(status < 0)) {\n\t\tfor (i = 0; i < blk_wanted; i++)\n\t\t\tbrelse(new_eb_bh[i]);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_dealloc_empty",
          "args": [
            "et"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_dealloc_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6628-6643",
          "snippet": "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_per_slot_free_list *fl = NULL;\n\n\tif (!et->et_dealloc)\n\t\treturn 1;\n\n\tfl = et->et_dealloc->c_first_suballocator;\n\tif (!fl)\n\t\treturn 1;\n\n\tif (!fl->f_first)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_per_slot_free_list *fl = NULL;\n\n\tif (!et->et_dealloc)\n\t\treturn 1;\n\n\tfl = et->et_dealloc->c_first_suballocator;\n\tif (!fl)\n\t\treturn 1;\n\n\tif (!fl->f_first)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "new_blocks",
            "sizeof(struct buffer_head *)",
            "GFP_KERNEL"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_rightmost_branch",
          "args": [
            "handle",
            "et"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_rightmost_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1108-1148",
          "snippet": "static int ocfs2_adjust_rightmost_branch(handle_t *handle,\n\t\t\t\t\t struct ocfs2_extent_tree *et)\n{\n\tint status;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_path(et->et_ci, path, UINT_MAX);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle, path_num_items(path));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec) - 1];\n\n\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\nout:\n\tocfs2_free_path(path);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_adjust_rightmost_branch(handle_t *handle,\n\t\t\t\t\t struct ocfs2_extent_tree *et)\n{\n\tint status;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_path(et->et_ci, path, UINT_MAX);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle, path_num_items(path));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec) - 1];\n\n\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\nout:\n\tocfs2_free_path(path);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_adjust_rightmost_branch",
          "args": [
            "(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci)",
            "root_end",
            "new_cpos"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sum_rightmost_rec",
          "args": [
            "et->et_root_el"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sum_rightmost_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1094-1102",
          "snippet": "static inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!el->l_tree_depth"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!last_eb_bh || !*last_eb_bh"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_add_branch(handle_t *handle,\n\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t    struct buffer_head *eb_bh,\n\t\t\t    struct buffer_head **last_eb_bh,\n\t\t\t    struct ocfs2_alloc_context *meta_ac)\n{\n\tint status, new_blocks, i, block_given = 0;\n\tu64 next_blkno, new_last_eb_blk;\n\tstruct buffer_head *bh;\n\tstruct buffer_head **new_eb_bhs = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_list  *eb_el;\n\tstruct ocfs2_extent_list  *el;\n\tu32 new_cpos, root_end;\n\n\tBUG_ON(!last_eb_bh || !*last_eb_bh);\n\n\tif (eb_bh) {\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t} else\n\t\tel = et->et_root_el;\n\n\t/* we never add a branch to a leaf. */\n\tBUG_ON(!el->l_tree_depth);\n\n\tnew_blocks = le16_to_cpu(el->l_tree_depth);\n\n\teb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;\n\tnew_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);\n\troot_end = ocfs2_sum_rightmost_rec(et->et_root_el);\n\n\t/*\n\t * If there is a gap before the root end and the real end\n\t * of the righmost leaf block, we need to remove the gap\n\t * between new_cpos and root_end first so that the tree\n\t * is consistent after we add a new branch(it will start\n\t * from new_cpos).\n\t */\n\tif (root_end > new_cpos) {\n\t\ttrace_ocfs2_adjust_rightmost_branch(\n\t\t\t(unsigned long long)\n\t\t\tocfs2_metadata_cache_owner(et->et_ci),\n\t\t\troot_end, new_cpos);\n\n\t\tstatus = ocfs2_adjust_rightmost_branch(handle, et);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* allocate the number of new eb blocks we need */\n\tnew_eb_bhs = kcalloc(new_blocks, sizeof(struct buffer_head *),\n\t\t\t     GFP_KERNEL);\n\tif (!new_eb_bhs) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* Firstyly, try to reuse dealloc since we have already estimated how\n\t * many extent blocks we may use.\n\t */\n\tif (!ocfs2_is_dealloc_empty(et)) {\n\t\tstatus = ocfs2_reuse_blk_from_dealloc(handle, et,\n\t\t\t\t\t\t      new_eb_bhs, new_blocks,\n\t\t\t\t\t\t      &block_given);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tBUG_ON(block_given > new_blocks);\n\n\tif (block_given < new_blocks) {\n\t\tBUG_ON(!meta_ac);\n\t\tstatus = ocfs2_create_new_meta_bhs(handle, et,\n\t\t\t\t\t\t   new_blocks - block_given,\n\t\t\t\t\t\t   meta_ac,\n\t\t\t\t\t\t   &new_eb_bhs[block_given]);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Note: new_eb_bhs[new_blocks - 1] is the guy which will be\n\t * linked with the rest of the tree.\n\t * conversly, new_eb_bhs[0] is the new bottommost leaf.\n\t *\n\t * when we leave the loop, new_last_eb_blk will point to the\n\t * newest leaf, and next_blkno will point to the topmost extent\n\t * block. */\n\tnext_blkno = new_last_eb_blk = 0;\n\tfor(i = 0; i < new_blocks; i++) {\n\t\tbh = new_eb_bhs[i];\n\t\teb = (struct ocfs2_extent_block *) bh->b_data;\n\t\t/* ocfs2_create_new_meta_bhs() should create it right! */\n\t\tBUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));\n\t\teb_el = &eb->h_list;\n\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\teb->h_next_leaf_blk = 0;\n\t\teb_el->l_tree_depth = cpu_to_le16(i);\n\t\teb_el->l_next_free_rec = cpu_to_le16(1);\n\t\t/*\n\t\t * This actually counts as an empty extent as\n\t\t * c_clusters == 0\n\t\t */\n\t\teb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);\n\t\teb_el->l_recs[0].e_blkno = cpu_to_le64(next_blkno);\n\t\t/*\n\t\t * eb_el isn't always an interior node, but even leaf\n\t\t * nodes want a zero'd flags and reserved field so\n\t\t * this gets the whole 32 bits regardless of use.\n\t\t */\n\t\teb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);\n\t\tif (!eb_el->l_tree_depth)\n\t\t\tnew_last_eb_blk = le64_to_cpu(eb->h_blkno);\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t\tnext_blkno = le64_to_cpu(eb->h_blkno);\n\t}\n\n\t/* This is a bit hairy. We want to update up to three blocks\n\t * here without leaving any of them in an inconsistent state\n\t * in case of error. We don't have to worry about\n\t * journal_dirty erroring as it won't unless we've aborted the\n\t * handle (in which case we would never be here) so reserving\n\t * the write with journal_access is all we need to do. */\n\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, *last_eb_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (eb_bh) {\n\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci, eb_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Link the new branch into the rest of the tree (el will\n\t * either be on the root_bh, or the extent block passed in. */\n\ti = le16_to_cpu(el->l_next_free_rec);\n\tel->l_recs[i].e_blkno = cpu_to_le64(next_blkno);\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\tel->l_recs[i].e_int_clusters = 0;\n\tle16_add_cpu(&el->l_next_free_rec, 1);\n\n\t/* fe needs a new last extent block pointer, as does the\n\t * next_leaf on the previously last-extent-block. */\n\tocfs2_et_set_last_eb_blk(et, new_last_eb_blk);\n\n\teb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;\n\teb->h_next_leaf_blk = cpu_to_le64(new_last_eb_blk);\n\n\tocfs2_journal_dirty(handle, *last_eb_bh);\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\tif (eb_bh)\n\t\tocfs2_journal_dirty(handle, eb_bh);\n\n\t/*\n\t * Some callers want to track the rightmost leaf so pass it\n\t * back here.\n\t */\n\tbrelse(*last_eb_bh);\n\tget_bh(new_eb_bhs[0]);\n\t*last_eb_bh = new_eb_bhs[0];\n\n\tstatus = 0;\nbail:\n\tif (new_eb_bhs) {\n\t\tfor (i = 0; i < new_blocks; i++)\n\t\t\tbrelse(new_eb_bhs[i]);\n\t\tkfree(new_eb_bhs);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_adjust_rightmost_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1108-1148",
    "snippet": "static int ocfs2_adjust_rightmost_branch(handle_t *handle,\n\t\t\t\t\t struct ocfs2_extent_tree *et)\n{\n\tint status;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_path(et->et_ci, path, UINT_MAX);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle, path_num_items(path));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec) - 1];\n\n\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\nout:\n\tocfs2_free_path(path);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "618-624",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_rightmost_records",
          "args": [
            "handle",
            "et",
            "path",
            "rec"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_rightmost_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "3964-3999",
          "snippet": "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec)\n{\n\tint i, next_free;\n\tstruct buffer_head *bh;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\t/*\n\t * Update everything except the leaf block.\n\t */\n\tfor (i = 0; i < path->p_tree_depth; i++) {\n\t\tbh = path->p_node[i].bh;\n\t\tel = path->p_node[i].el;\n\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tif (next_free == 0) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu has a bad extent list\\n\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci));\n\t\t\treturn;\n\t\t}\n\n\t\trec = &el->l_recs[next_free - 1];\n\n\t\trec->e_int_clusters = insert_rec->e_cpos;\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     le16_to_cpu(insert_rec->e_leaf_clusters));\n\t\tle32_add_cpu(&rec->e_int_clusters,\n\t\t\t     -le32_to_cpu(rec->e_cpos));\n\n\t\tocfs2_journal_dirty(handle, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_path",
          "args": [
            "et->et_ci",
            "handle",
            "path"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "755-774",
          "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "path_num_items(path)"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "path",
            "UINT_MAX"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "1909-1918",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "722-726",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_adjust_rightmost_branch(handle_t *handle,\n\t\t\t\t\t struct ocfs2_extent_tree *et)\n{\n\tint status;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_find_path(et->et_ci, path, UINT_MAX);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_extend_trans(handle, path_num_items(path));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_path(et->et_ci, handle, path);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\trec = &el->l_recs[le16_to_cpu(el->l_next_free_rec) - 1];\n\n\tocfs2_adjust_rightmost_records(handle, et, path, rec);\n\nout:\n\tocfs2_free_path(path);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_sum_rightmost_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1094-1102",
    "snippet": "static inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "&el->l_recs[i]"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "el->l_recs[i].e_cpos"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)\n{\n\tint i;\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\n\treturn le32_to_cpu(el->l_recs[i].e_cpos) +\n\t\tocfs2_rec_clusters(el, &el->l_recs[i]);\n}"
  },
  {
    "function_name": "ocfs2_create_new_meta_bhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "1001-1080",
    "snippet": "static int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[i]"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bhs[i]"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "786-807",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\t\t\tstruct super_block *sb = bh->b_bdev->bd_super;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed. \"\n\t\t\t\t\t\"Aborting transaction and journal.\\n\");\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t\tocfs2_abort(sb, \"Journal already aborted.\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_eb(osb->sb)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_eb",
          "args": [
            "osb->sb"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1516-1524",
          "snippet": "static inline int ocfs2_extent_recs_per_eb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_extent_block, h_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n\nstatic inline int ocfs2_extent_recs_per_eb(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_extent_block, h_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "suballoc_bit_start"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "suballoc_loc"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "meta_ac->ac_alloc_slot"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "osb->fs_generation"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "first_blkno"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "eb->h_signature",
            "OCFS2_EXTENT_BLOCK_SIGNATURE"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bhs[i]->b_data",
            "0",
            "osb->sb->s_blocksize"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "et->et_ci",
            "bhs[i]",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "731-735",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "et->et_ci",
            "bhs[i]"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "osb->sb",
            "first_blkno"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_metadata",
          "args": [
            "handle",
            "meta_ac",
            "wanted - count",
            "&suballoc_loc",
            "&suballoc_bit_start",
            "&num_got",
            "&first_blkno"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "2000-2036",
          "snippet": "int ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_create_new_meta_bhs(handle_t *handle,\n\t\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t\t     int wanted,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct buffer_head *bhs[])\n{\n\tint count, status, i;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\tstruct ocfs2_extent_block *eb;\n\n\tcount = 0;\n\twhile (count < wanted) {\n\t\tstatus = ocfs2_claim_metadata(handle,\n\t\t\t\t\t      meta_ac,\n\t\t\t\t\t      wanted - count,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit_start,\n\t\t\t\t\t      &num_got,\n\t\t\t\t\t      &first_blkno);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = count;  i < (num_got + count); i++) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, first_blkno);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tocfs2_set_new_buffer_uptodate(et->et_ci, bhs[i]);\n\n\t\t\tstatus = ocfs2_journal_access_eb(handle, et->et_ci,\n\t\t\t\t\t\t\t bhs[i],\n\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tmemset(bhs[i]->b_data, 0, osb->sb->s_blocksize);\n\t\t\teb = (struct ocfs2_extent_block *) bhs[i]->b_data;\n\t\t\t/* Ok, setup the minimal stuff here. */\n\t\t\tstrcpy(eb->h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE);\n\t\t\teb->h_blkno = cpu_to_le64(first_blkno);\n\t\t\teb->h_fs_generation = cpu_to_le32(osb->fs_generation);\n\t\t\teb->h_suballoc_slot =\n\t\t\t\tcpu_to_le16(meta_ac->ac_alloc_slot);\n\t\t\teb->h_suballoc_loc = cpu_to_le64(suballoc_loc);\n\t\t\teb->h_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\t\t\teb->h_list.l_count =\n\t\t\t\tcpu_to_le16(ocfs2_extent_recs_per_eb(osb->sb));\n\n\t\t\tsuballoc_bit_start++;\n\t\t\tfirst_blkno++;\n\n\t\t\t/* We'll also be dirtied by the caller, so\n\t\t\t * this isn't absolutely necessary. */\n\t\t\tocfs2_journal_dirty(handle, bhs[i]);\n\t\t}\n\n\t\tcount += num_got;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tfor(i = 0; i < wanted; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\t\tmlog_errno(status);\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_num_free_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "964-994",
    "snippet": "int ocfs2_num_free_extents(struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_num_free_extents",
          "args": [
            "retval"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "eb_bh"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "el->l_tree_depth != 0"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "retval"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "et->et_ci",
            "last_eb_blk",
            "&eb_bh"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "944-958",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_et_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_et_get_last_eb_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "513-516",
          "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
  },
  {
    "function_name": "ocfs2_read_extent_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "944-958",
    "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "ci",
            "eb_blkno",
            "&tmp",
            "ocfs2_validate_extent_block"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "105-205",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\t/* Don't put buffer head and re-assign it to NULL if it is allocated\n\t * outside since the caller can't be aware of this alternation!\n\t */\n\tnew_bh = (bhs[0] == NULL);\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n#else\n\t\t\tunlock_buffer(bh);\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\nread_failure:\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\tif (unlikely(status)) {\n\t\t\tif (new_bh && bh) {\n\t\t\t\t/* If middle bh fails, let previous bh\n\t\t\t\t * finish its read and then put it to\n\t\t\t\t * aovoid bh leak\n\t\t\t\t */\n\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i - 1] = NULL;\n\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tgoto read_failure;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bio.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bio.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\t/* Don't put buffer head and re-assign it to NULL if it is allocated\n\t * outside since the caller can't be aware of this alternation!\n\t */\n\tnew_bh = (bhs[0] == NULL);\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n#else\n\t\t\tunlock_buffer(bh);\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\nread_failure:\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\tif (unlikely(status)) {\n\t\t\tif (new_bh && bh) {\n\t\t\t\t/* If middle bh fails, let previous bh\n\t\t\t\t * finish its read and then put it to\n\t\t\t\t * aovoid bh leak\n\t\t\t\t */\n\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i - 1] = NULL;\n\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tgoto read_failure;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_validate_extent_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "892-942",
    "snippet": "static int ocfs2_validate_extent_block(struct super_block *sb,\n\t\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_extent_block *eb =\n\t\t(struct ocfs2_extent_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_extent_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &eb->h_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for extent block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\tif (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Extent block #%llu has bad signature %.*s\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t\t eb->h_signature);\n\t\tgoto bail;\n\t}\n\n\tif (le64_to_cpu(eb->h_blkno) != bh->b_blocknr) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Extent block #%llu has an invalid h_blkno of %llu\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(eb->h_fs_generation) != OCFS2_SB(sb)->fs_generation)\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Extent block #%llu has an invalid h_fs_generation of #%u\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t le32_to_cpu(eb->h_fs_generation));\nbail:\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Extent block #%llu has an invalid h_fs_generation of #%u\\n\"",
            "(unsigned long long)bh->b_blocknr",
            "le32_to_cpu(eb->h_fs_generation)"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "2594-2612",
          "snippet": "int __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nint __ocfs2_error(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %pV\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\treturn ocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "eb->h_fs_generation"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_blkno"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_EXTENT_BLOCK",
          "args": [
            "eb"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Checksum failed for extent block %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "141-147",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&eb->h_check"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_validate_extent_block",
          "args": [
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic int ocfs2_validate_extent_block(struct super_block *sb,\n\t\t\t\t       struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_extent_block *eb =\n\t\t(struct ocfs2_extent_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_extent_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &eb->h_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for extent block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Errors after here are fatal.\n\t */\n\n\tif (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Extent block #%llu has bad signature %.*s\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr, 7,\n\t\t\t\t eb->h_signature);\n\t\tgoto bail;\n\t}\n\n\tif (le64_to_cpu(eb->h_blkno) != bh->b_blocknr) {\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Extent block #%llu has an invalid h_blkno of %llu\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t (unsigned long long)le64_to_cpu(eb->h_blkno));\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(eb->h_fs_generation) != OCFS2_SB(sb)->fs_generation)\n\t\trc = ocfs2_error(sb,\n\t\t\t\t \"Extent block #%llu has an invalid h_fs_generation of #%u\\n\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t le32_to_cpu(eb->h_fs_generation));\nbail:\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_extent_rec_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "833-858",
    "snippet": "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tu64 blkno = le64_to_cpu(insert_rec->e_blkno);\n\n\t/*\n\t * Refuse to coalesce extent records with different flag\n\t * fields - we don't want to mix unwritten extents with user\n\t * data.\n\t */\n\tif (ext->e_flags != insert_rec->e_flags)\n\t\treturn CONTIG_NONE;\n\n\tif (ocfs2_extents_adjacent(ext, insert_rec) &&\n\t    ocfs2_block_extent_contig(sb, ext, blkno))\n\t\t\treturn CONTIG_RIGHT;\n\n\tblkno = le64_to_cpu(ext->e_blkno);\n\tif (ocfs2_extents_adjacent(insert_rec, ext) &&\n\t    ocfs2_block_extent_contig(sb, insert_rec, blkno))\n\t\treturn CONTIG_LEFT;\n\n\treturn CONTIG_NONE;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_block_extent_contig",
          "args": [
            "sb",
            "insert_rec",
            "blkno"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_extent_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "810-820",
          "snippet": "static int ocfs2_block_extent_contig(struct super_block *sb,\n\t\t\t\t     struct ocfs2_extent_rec *ext,\n\t\t\t\t     u64 blkno)\n{\n\tu64 blk_end = le64_to_cpu(ext->e_blkno);\n\n\tblk_end += ocfs2_clusters_to_blocks(sb,\n\t\t\t\t    le16_to_cpu(ext->e_leaf_clusters));\n\n\treturn blkno == blk_end;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nstatic int ocfs2_block_extent_contig(struct super_block *sb,\n\t\t\t\t     struct ocfs2_extent_rec *ext,\n\t\t\t\t     u64 blkno)\n{\n\tu64 blk_end = le64_to_cpu(ext->e_blkno);\n\n\tblk_end += ocfs2_clusters_to_blocks(sb,\n\t\t\t\t    le16_to_cpu(ext->e_leaf_clusters));\n\n\treturn blkno == blk_end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extents_adjacent",
          "args": [
            "insert_rec",
            "ext"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extents_adjacent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "822-831",
          "snippet": "static int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,\n\t\t\t\t  struct ocfs2_extent_rec *right)\n{\n\tu32 left_range;\n\n\tleft_range = le32_to_cpu(left->e_cpos) +\n\t\tle16_to_cpu(left->e_leaf_clusters);\n\n\treturn (left_range == le32_to_cpu(right->e_cpos));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,\n\t\t\t\t  struct ocfs2_extent_rec *right)\n{\n\tu32 left_range;\n\n\tleft_range = le32_to_cpu(left->e_cpos) +\n\t\tle16_to_cpu(left->e_leaf_clusters);\n\n\treturn (left_range == le32_to_cpu(right->e_cpos));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "ext->e_blkno"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tu64 blkno = le64_to_cpu(insert_rec->e_blkno);\n\n\t/*\n\t * Refuse to coalesce extent records with different flag\n\t * fields - we don't want to mix unwritten extents with user\n\t * data.\n\t */\n\tif (ext->e_flags != insert_rec->e_flags)\n\t\treturn CONTIG_NONE;\n\n\tif (ocfs2_extents_adjacent(ext, insert_rec) &&\n\t    ocfs2_block_extent_contig(sb, ext, blkno))\n\t\t\treturn CONTIG_RIGHT;\n\n\tblkno = le64_to_cpu(ext->e_blkno);\n\tif (ocfs2_extents_adjacent(insert_rec, ext) &&\n\t    ocfs2_block_extent_contig(sb, insert_rec, blkno))\n\t\treturn CONTIG_LEFT;\n\n\treturn CONTIG_NONE;\n}"
  },
  {
    "function_name": "ocfs2_extents_adjacent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "822-831",
    "snippet": "static int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,\n\t\t\t\t  struct ocfs2_extent_rec *right)\n{\n\tu32 left_range;\n\n\tleft_range = le32_to_cpu(left->e_cpos) +\n\t\tle16_to_cpu(left->e_leaf_clusters);\n\n\treturn (left_range == le32_to_cpu(right->e_cpos));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "right->e_cpos"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "left->e_leaf_clusters"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,\n\t\t\t\t  struct ocfs2_extent_rec *right)\n{\n\tu32 left_range;\n\n\tleft_range = le32_to_cpu(left->e_cpos) +\n\t\tle16_to_cpu(left->e_leaf_clusters);\n\n\treturn (left_range == le32_to_cpu(right->e_cpos));\n}"
  },
  {
    "function_name": "ocfs2_block_extent_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "810-820",
    "snippet": "static int ocfs2_block_extent_contig(struct super_block *sb,\n\t\t\t\t     struct ocfs2_extent_rec *ext,\n\t\t\t\t     u64 blkno)\n{\n\tu64 blk_end = le64_to_cpu(ext->e_blkno);\n\n\tblk_end += ocfs2_clusters_to_blocks(sb,\n\t\t\t\t    le16_to_cpu(ext->e_leaf_clusters));\n\n\treturn blkno == blk_end;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "le16_to_cpu(ext->e_leaf_clusters)"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-736",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ext->e_leaf_clusters"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "ext->e_blkno"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nstatic int ocfs2_block_extent_contig(struct super_block *sb,\n\t\t\t\t     struct ocfs2_extent_rec *ext,\n\t\t\t\t     u64 blkno)\n{\n\tu64 blk_end = le64_to_cpu(ext->e_blkno);\n\n\tblk_end += ocfs2_clusters_to_blocks(sb,\n\t\t\t\t    le16_to_cpu(ext->e_leaf_clusters));\n\n\treturn blkno == blk_end;\n}"
  },
  {
    "function_name": "ocfs2_search_extent_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "782-804",
    "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.h",
          "lines": "248-262",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_journal_access_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "755-774",
    "snippet": "int ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_path_bh_journal_access",
          "args": [
            "handle",
            "ci",
            "path",
            "i"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "735-750",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access_path(struct ocfs2_caching_info *ci,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_path *path)\n{\n\tint i, ret = 0;\n\n\tif (!path)\n\t\tgoto out;\n\n\tfor(i = 0; i < path_num_items(path); i++) {\n\t\tret = ocfs2_path_bh_journal_access(handle, ci, path, i);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_path_bh_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "735-750",
    "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "access",
          "args": [
            "handle",
            "ci",
            "path->p_node[idx].bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_path_bh_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "735-750",
          "snippet": "int ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "path"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_path_bh_journal_access(handle_t *handle,\n\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t struct ocfs2_path *path,\n\t\t\t\t int idx)\n{\n\tocfs2_journal_access_func access = path_root_access(path);\n\n\tif (!access)\n\t\taccess = ocfs2_journal_access;\n\n\tif (idx)\n\t\taccess = ocfs2_journal_access_eb;\n\n\treturn access(handle, ci, path->p_node[idx].bh,\n\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n}"
  },
  {
    "function_name": "ocfs2_new_path_from_et",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "722-726",
    "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_new_path",
          "args": [
            "et->et_root_bh",
            "et->et_root_el",
            "et->et_root_journal_access"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "696-714",
          "snippet": "static struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
  },
  {
    "function_name": "ocfs2_new_path_from_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "716-720",
    "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_new_path",
          "args": [
            "path_root_bh(path)",
            "path_root_el(path)",
            "path_root_access(path)"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "696-714",
          "snippet": "static struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "path"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "path"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "path"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
  },
  {
    "function_name": "ocfs2_new_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "696-714",
    "snippet": "static struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "path"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "path"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "path"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "root_bh"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_tree_depth"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*path)",
            "GFP_NOFS"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,\n\t\t\t\t\t struct ocfs2_extent_list *root_el,\n\t\t\t\t\t ocfs2_journal_access_func access)\n{\n\tstruct ocfs2_path *path;\n\n\tBUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);\n\n\tpath = kzalloc(sizeof(*path), GFP_NOFS);\n\tif (path) {\n\t\tpath->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);\n\t\tget_bh(root_bh);\n\t\tpath_root_bh(path) = root_bh;\n\t\tpath_root_el(path) = root_el;\n\t\tpath_root_access(path) = access;\n\t}\n\n\treturn path;\n}"
  },
  {
    "function_name": "ocfs2_path_insert_eb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "679-694",
    "snippet": "static inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,\n\t\t\t\t\tstruct buffer_head *eb_bh)\n{\n\tstruct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t/*\n\t * Right now, no root bh is an extent block, so this helps\n\t * catch code errors with dinode trees. The assertion can be\n\t * safely removed if we ever need to insert extent block\n\t * structures at the root.\n\t */\n\tBUG_ON(index == 0);\n\n\tpath->p_node[index].bh = eb_bh;\n\tpath->p_node[index].el = &eb->h_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index == 0"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nstatic inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,\n\t\t\t\t\tstruct buffer_head *eb_bh)\n{\n\tstruct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;\n\n\t/*\n\t * Right now, no root bh is an extent block, so this helps\n\t * catch code errors with dinode trees. The assertion can be\n\t * safely removed if we ever need to insert extent block\n\t * structures at the root.\n\t */\n\tBUG_ON(index == 0);\n\n\tpath->p_node[index].bh = eb_bh;\n\tpath->p_node[index].el = &eb->h_list;\n}"
  },
  {
    "function_name": "ocfs2_mv_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "656-672",
    "snippet": "static void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dest->p_node[i].bh"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_access(dest) != path_root_access(src)"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "src"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "dest"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_bh(dest) != path_root_bh(src)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "src"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "dest"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tbrelse(dest->p_node[i].bh);\n\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tsrc->p_node[i].bh = NULL;\n\t\tsrc->p_node[i].el = NULL;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_cp_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "633-650",
    "snippet": "static void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_el(dest) != path_root_el(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tocfs2_reinit_path(dest, 1);\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tif (dest->p_node[i].bh)\n\t\t\tget_bh(dest->p_node[i].bh);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "dest->p_node[i].bh"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "dest",
            "1"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "589-616",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_access(dest) != path_root_access(src)"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "src"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "dest"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_el(dest) != path_root_el(src)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "src"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "dest"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path_root_bh(dest) != path_root_bh(src)"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "src"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_root_bh",
          "args": [
            "dest"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)\n{\n\tint i;\n\n\tBUG_ON(path_root_bh(dest) != path_root_bh(src));\n\tBUG_ON(path_root_el(dest) != path_root_el(src));\n\tBUG_ON(path_root_access(dest) != path_root_access(src));\n\n\tocfs2_reinit_path(dest, 1);\n\n\tfor(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {\n\t\tdest->p_node[i].bh = src->p_node[i].bh;\n\t\tdest->p_node[i].el = src->p_node[i].el;\n\n\t\tif (dest->p_node[i].bh)\n\t\t\tget_bh(dest->p_node[i].bh);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_free_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "618-624",
    "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "path",
            "0"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "589-616",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_reinit_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "589-616",
    "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_root_access",
          "args": [
            "path"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "path_root_el(path)->l_tree_depth"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_root_el",
          "args": [
            "path"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "node->bh"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_num_items",
          "args": [
            "path"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
  },
  {
    "function_name": "ocfs2_et_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "569-576",
    "snippet": "static inline int ocfs2_et_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_sanity_check)\n\t\tret = et->et_ops->eo_sanity_check(et);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_sanity_check",
          "args": [
            "et"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_sanity_check)\n\t\tret = et->et_ops->eo_sanity_check(et);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_et_insert_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "559-567",
    "snippet": "static inline int ocfs2_et_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_extent_rec *rec)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_insert_check)\n\t\tret = et->et_ops->eo_insert_check(et, rec);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_insert_check",
          "args": [
            "et",
            "rec"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_extent_rec *rec)\n{\n\tint ret = 0;\n\n\tif (et->et_ops->eo_insert_check)\n\t\tret = et->et_ops->eo_insert_check(et, rec);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_et_extent_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "546-557",
    "snippet": "static inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_extent_rec_contig",
          "args": [
            "ocfs2_metadata_cache_get_super(et->et_ci)",
            "rec",
            "insert_rec"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_rec_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "833-858",
          "snippet": "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tu64 blkno = le64_to_cpu(insert_rec->e_blkno);\n\n\t/*\n\t * Refuse to coalesce extent records with different flag\n\t * fields - we don't want to mix unwritten extents with user\n\t * data.\n\t */\n\tif (ext->e_flags != insert_rec->e_flags)\n\t\treturn CONTIG_NONE;\n\n\tif (ocfs2_extents_adjacent(ext, insert_rec) &&\n\t    ocfs2_block_extent_contig(sb, ext, blkno))\n\t\t\treturn CONTIG_RIGHT;\n\n\tblkno = le64_to_cpu(ext->e_blkno);\n\tif (ocfs2_extents_adjacent(insert_rec, ext) &&\n\t    ocfs2_block_extent_contig(sb, insert_rec, blkno))\n\t\treturn CONTIG_LEFT;\n\n\treturn CONTIG_NONE;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec)\n{\n\tu64 blkno = le64_to_cpu(insert_rec->e_blkno);\n\n\t/*\n\t * Refuse to coalesce extent records with different flag\n\t * fields - we don't want to mix unwritten extents with user\n\t * data.\n\t */\n\tif (ext->e_flags != insert_rec->e_flags)\n\t\treturn CONTIG_NONE;\n\n\tif (ocfs2_extents_adjacent(ext, insert_rec) &&\n\t    ocfs2_block_extent_contig(sb, ext, blkno))\n\t\t\treturn CONTIG_RIGHT;\n\n\tblkno = le64_to_cpu(ext->e_blkno);\n\tif (ocfs2_extents_adjacent(insert_rec, ext) &&\n\t    ocfs2_block_extent_contig(sb, insert_rec, blkno))\n\t\treturn CONTIG_LEFT;\n\n\treturn CONTIG_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "et->et_ops->eo_extent_contig",
          "args": [
            "et",
            "rec",
            "insert_rec"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic inline enum ocfs2_contig_type\n\tocfs2_et_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t       struct ocfs2_extent_rec *rec,\n\t\t\t       struct ocfs2_extent_rec *insert_rec)\n{\n\tif (et->et_ops->eo_extent_contig)\n\t\treturn et->et_ops->eo_extent_contig(et, rec, insert_rec);\n\n\treturn ocfs2_extent_rec_contig(\n\t\t\t\tocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\trec, insert_rec);\n}"
  },
  {
    "function_name": "ocfs2_et_root_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "538-544",
    "snippet": "static inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_root_journal_access",
          "args": [
            "handle",
            "et->et_ci",
            "et->et_root_bh",
            "type"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline int ocfs2_et_root_journal_access(handle_t *handle,\n\t\t\t\t\t       struct ocfs2_extent_tree *et,\n\t\t\t\t\t       int type)\n{\n\treturn et->et_root_journal_access(handle, et->et_ci, et->et_root_bh,\n\t\t\t\t\t  type);\n}"
  },
  {
    "function_name": "ocfs2_et_extent_map_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "531-536",
    "snippet": "static inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_extent_map_truncate",
          "args": [
            "et",
            "clusters"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tif (et->et_ops->eo_extent_map_truncate)\n\t\tet->et_ops->eo_extent_map_truncate(et, clusters);\n}"
  },
  {
    "function_name": "ocfs2_et_extent_map_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "524-529",
    "snippet": "static inline void ocfs2_et_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\tif (et->et_ops->eo_extent_map_insert)\n\t\tet->et_ops->eo_extent_map_insert(et, rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_extent_map_insert",
          "args": [
            "et",
            "rec"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\tif (et->et_ops->eo_extent_map_insert)\n\t\tet->et_ops->eo_extent_map_insert(et, rec);\n}"
  },
  {
    "function_name": "ocfs2_et_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "518-522",
    "snippet": "static inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_update_clusters",
          "args": [
            "et",
            "clusters"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u32 clusters)\n{\n\tet->et_ops->eo_update_clusters(et, clusters);\n}"
  },
  {
    "function_name": "ocfs2_et_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "513-516",
    "snippet": "static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_get_last_eb_blk",
          "args": [
            "et"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\treturn et->et_ops->eo_get_last_eb_blk(et);\n}"
  },
  {
    "function_name": "ocfs2_et_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "507-511",
    "snippet": "static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_set_last_eb_blk",
          "args": [
            "et",
            "new_last_eb_blk"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t    u64 new_last_eb_blk)\n{\n\tet->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_init_refcount_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "499-505",
    "snippet": "void ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static const struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "bh",
            "ocfs2_journal_access_rb",
            "NULL",
            "&ocfs2_refcount_tree_et_ops"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "444-465",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}"
  },
  {
    "function_name": "ocfs2_init_dx_root_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "491-497",
    "snippet": "void ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static const struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "bh",
            "ocfs2_journal_access_dr",
            "NULL",
            "&ocfs2_dx_root_et_ops"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "444-465",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dx_root_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dx_root_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dx_root_update_clusters,\n\t.eo_sanity_check\t= ocfs2_dx_root_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dx_root_fill_root_el,\n};\n\nvoid ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_dr,\n\t\t\t\t NULL, &ocfs2_dx_root_et_ops);\n}"
  },
  {
    "function_name": "ocfs2_init_xattr_value_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "483-489",
    "snippet": "void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static const struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "vb->vb_bh",
            "vb->vb_access",
            "vb",
            "&ocfs2_xattr_value_et_ops"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "444-465",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};\n\nvoid ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}"
  },
  {
    "function_name": "ocfs2_init_xattr_tree_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "475-481",
    "snippet": "void ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static const struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "bh",
            "ocfs2_journal_access_xb",
            "NULL",
            "&ocfs2_xattr_tree_et_ops"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "444-465",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_tree_fill_root_el,\n\t.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,\n};\n\nvoid ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t       struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_xb,\n\t\t\t\t NULL, &ocfs2_xattr_tree_et_ops);\n}"
  },
  {
    "function_name": "ocfs2_init_dinode_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "467-473",
    "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_init_extent_tree",
          "args": [
            "et",
            "ci",
            "bh",
            "ocfs2_journal_access_di",
            "NULL",
            "&ocfs2_dinode_et_ops"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_init_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "444-465",
          "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
  },
  {
    "function_name": "__ocfs2_init_extent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "444-465",
    "snippet": "static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "et->et_ops->eo_fill_max_leaf_clusters",
          "args": [
            "et"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et->et_ops->eo_fill_root_el",
          "args": [
            "et"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh,\n\t\t\t\t     ocfs2_journal_access_func access,\n\t\t\t\t     void *obj,\n\t\t\t\t     const struct ocfs2_extent_tree_operations *ops)\n{\n\tet->et_ops = ops;\n\tet->et_root_bh = bh;\n\tet->et_ci = ci;\n\tet->et_root_journal_access = access;\n\tif (!obj)\n\t\tobj = (void *)bh->b_data;\n\tet->et_object = obj;\n\tet->et_dealloc = NULL;\n\n\tet->et_ops->eo_fill_root_el(et);\n\tif (!et->et_ops->eo_fill_max_leaf_clusters)\n\t\tet->et_max_leaf_clusters = 0;\n\telse\n\t\tet->et_ops->eo_fill_max_leaf_clusters(et);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_extent_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "428-434",
    "snippet": "static enum ocfs2_contig_type\nocfs2_refcount_tree_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *ext,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec)\n{\n\treturn CONTIG_NONE;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);",
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic enum ocfs2_contig_type\n\tocfs2_extent_rec_contig(struct super_block *sb,\n\t\t\t\tstruct ocfs2_extent_rec *ext,\n\t\t\t\tstruct ocfs2_extent_rec *insert_rec);\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic void ocfs2_adjust_rightmost_records(handle_t *handle,\n\t\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_path *path,\n\t\t\t\t\t   struct ocfs2_extent_rec *insert_rec);\n\nstatic enum ocfs2_contig_type\nocfs2_refcount_tree_extent_contig(struct ocfs2_extent_tree *et,\n\t\t\t\t  struct ocfs2_extent_rec *ext,\n\t\t\t\t  struct ocfs2_extent_rec *insert_rec)\n{\n\treturn CONTIG_NONE;\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "420-426",
    "snippet": "static void ocfs2_refcount_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tle32_add_cpu(&rb->rf_clusters, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rb->rf_clusters",
            "clusters"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_refcount_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu32 clusters)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tle32_add_cpu(&rb->rf_clusters, clusters);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "413-418",
    "snippet": "static u64 ocfs2_refcount_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\treturn le64_to_cpu(rb->rf_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rb->rf_last_eb_blk"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic u64 ocfs2_refcount_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\treturn le64_to_cpu(rb->rf_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "405-411",
    "snippet": "static void ocfs2_refcount_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu64 blkno)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\trb->rf_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_refcount_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t\tu64 blkno)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\trb->rf_last_eb_blk = cpu_to_le64(blkno);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "398-403",
    "snippet": "static void ocfs2_refcount_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tet->et_root_el = &rb->rf_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_refcount_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_refcount_block *rb = et->et_object;\n\n\tet->et_root_el = &rb->rf_list;\n}"
  },
  {
    "function_name": "ocfs2_dx_root_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "383-388",
    "snippet": "static void ocfs2_dx_root_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tet->et_root_el = &dx_root->dr_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dx_root_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tet->et_root_el = &dx_root->dr_list;\n}"
  },
  {
    "function_name": "ocfs2_dx_root_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "374-381",
    "snippet": "static int ocfs2_dx_root_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tBUG_ON(!OCFS2_IS_VALID_DX_ROOT(dx_root));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DX_ROOT(dx_root)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DX_ROOT",
          "args": [
            "dx_root"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_dx_root_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tBUG_ON(!OCFS2_IS_VALID_DX_ROOT(dx_root));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dx_root_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "366-372",
    "snippet": "static void ocfs2_dx_root_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u32 clusters)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tle32_add_cpu(&dx_root->dr_clusters, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dx_root->dr_clusters",
            "clusters"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dx_root_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u32 clusters)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tle32_add_cpu(&dx_root->dr_clusters, clusters);\n}"
  },
  {
    "function_name": "ocfs2_dx_root_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "359-364",
    "snippet": "static u64 ocfs2_dx_root_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\treturn le64_to_cpu(dx_root->dr_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dx_root->dr_last_eb_blk"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic u64 ocfs2_dx_root_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\treturn le64_to_cpu(dx_root->dr_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_dx_root_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "351-357",
    "snippet": "static void ocfs2_dx_root_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u64 blkno)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tdx_root->dr_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dx_root_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t  u64 blkno)\n{\n\tstruct ocfs2_dx_root_block *dx_root = et->et_object;\n\n\tdx_root->dr_last_eb_blk = cpu_to_le64(blkno);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "335-341",
    "snippet": "static void ocfs2_xattr_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tle32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&xb->xb_attrs.xb_root.xt_clusters",
            "clusters"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_tree_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tle32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, clusters);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "327-333",
    "snippet": "static u64 ocfs2_xattr_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\treturn le64_to_cpu(xt->xt_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "xt->xt_last_eb_blk"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic u64 ocfs2_xattr_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\treturn le64_to_cpu(xt->xt_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "318-325",
    "snippet": "static void ocfs2_xattr_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u64 blkno)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\txt->xt_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u64 blkno)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\tstruct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;\n\n\txt->xt_last_eb_blk = cpu_to_le64(blkno);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_fill_max_leaf_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "311-316",
    "snippet": "static void ocfs2_xattr_tree_fill_max_leaf_clusters(struct ocfs2_extent_tree *et)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tet->et_max_leaf_clusters =\n\t\tocfs2_clusters_for_bytes(sb, OCFS2_MAX_XATTR_TREE_LEAF_SIZE);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "sb",
            "OCFS2_MAX_XATTR_TREE_LEAF_SIZE"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "757-768",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_tree_fill_max_leaf_clusters(struct ocfs2_extent_tree *et)\n{\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tet->et_max_leaf_clusters =\n\t\tocfs2_clusters_for_bytes(sb, OCFS2_MAX_XATTR_TREE_LEAF_SIZE);\n}"
  },
  {
    "function_name": "ocfs2_xattr_tree_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "304-309",
    "snippet": "static void ocfs2_xattr_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tet->et_root_el = &xb->xb_attrs.xb_root.xt_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_tree_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_block *xb = et->et_object;\n\n\tet->et_root_el = &xb->xb_attrs.xb_root.xt_list;\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "289-295",
    "snippet": "static void ocfs2_xattr_value_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 clusters)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&vb->vb_xv->xr_clusters",
            "clusters"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_value_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u32 clusters)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tle32_add_cpu(&vb->vb_xv->xr_clusters, clusters);\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "282-287",
    "snippet": "static u64 ocfs2_xattr_value_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\treturn le64_to_cpu(vb->vb_xv->xr_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "vb->vb_xv->xr_last_eb_blk"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic u64 ocfs2_xattr_value_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\treturn le64_to_cpu(vb->vb_xv->xr_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "274-280",
    "snippet": "static void ocfs2_xattr_value_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u64 blkno)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tvb->vb_xv->xr_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_value_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t      u64 blkno)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tvb->vb_xv->xr_last_eb_blk = cpu_to_le64(blkno);\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "267-272",
    "snippet": "static void ocfs2_xattr_value_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tet->et_root_el = &vb->vb_xv->xr_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_xattr_value_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_xattr_value_buf *vb = et->et_object;\n\n\tet->et_root_el = &vb->vb_xv->xr_list;\n}"
  },
  {
    "function_name": "ocfs2_dinode_fill_root_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "259-264",
    "snippet": "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tet->et_root_el = &di->id2.i_list;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tet->et_root_el = &di->id2.i_list;\n}"
  },
  {
    "function_name": "ocfs2_dinode_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "249-257",
    "snippet": "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(di)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "di"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "et->et_ops != &ocfs2_dinode_et_ops"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dinode_insert_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "231-247",
    "snippet": "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_super *osb = OCFS2_SB(oi->vfs_inode.i_sb);\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_INLINE_DATA_FL);\n\tmlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&\n\t\t\t(oi->ip_clusters != le32_to_cpu(rec->e_cpos)),\n\t\t\t\"Device %s, asking for sparse allocation: inode %llu, \"\n\t\t\t\"cpos %u, clusters %u\\n\",\n\t\t\tosb->dev_str,\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\trec->e_cpos, oi->ip_clusters);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!ocfs2_sparse_alloc(osb) &&\n\t\t\t(oi->ip_clusters != le32_to_cpu(rec->e_cpos))",
            "\"Device %s, asking for sparse allocation: inode %llu, \"\n\t\t\t\"cpos %u, clusters %u\\n\"",
            "osb->dev_str",
            "(unsigned long long)oi->ip_blkno",
            "rec->e_cpos",
            "oi->ip_clusters"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "501-506",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "oi->ip_dyn_features & OCFS2_INLINE_DATA_FL"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "oi->vfs_inode.i_sb"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "et->et_ci"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "179-182",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_super *osb = OCFS2_SB(oi->vfs_inode.i_sb);\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_INLINE_DATA_FL);\n\tmlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&\n\t\t\t(oi->ip_clusters != le32_to_cpu(rec->e_cpos)),\n\t\t\t\"Device %s, asking for sparse allocation: inode %llu, \"\n\t\t\t\"cpos %u, clusters %u\\n\",\n\t\t\tosb->dev_str,\n\t\t\t(unsigned long long)oi->ip_blkno,\n\t\t\trec->e_cpos, oi->ip_clusters);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dinode_extent_map_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "223-229",
    "snippet": "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_trunc(inode, clusters);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_extent_map_trunc",
          "args": [
            "inode",
            "clusters"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/extent_map.c",
          "lines": "115-145",
          "snippet": "void ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"aops.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"aops.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "et->et_ci"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "179-182",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_trunc(inode, clusters);\n}"
  },
  {
    "function_name": "ocfs2_dinode_extent_map_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "215-221",
    "snippet": "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_insert_rec(inode, rec);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_extent_map_insert_rec",
          "args": [
            "inode",
            "rec"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_insert_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/extent_map.c",
          "lines": "228-287",
          "snippet": "void ocfs2_extent_map_insert_rec(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tstruct ocfs2_extent_map_item *emi, *new_emi = NULL;\n\tstruct ocfs2_extent_map_item ins;\n\n\tins.ei_cpos = le32_to_cpu(rec->e_cpos);\n\tins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t       le64_to_cpu(rec->e_blkno));\n\tins.ei_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tins.ei_flags = rec->e_flags;\n\nsearch:\n\tspin_lock(&oi->ip_lock);\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\tif (ocfs2_try_to_merge_extent_map(emi, &ins)) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * No item could be merged.\n\t *\n\t * Either allocate and add a new item, or overwrite the last recently\n\t * inserted.\n\t */\n\n\tif (em->em_num_items < OCFS2_MAX_EXTENT_MAP_ITEMS) {\n\t\tif (new_emi == NULL) {\n\t\t\tspin_unlock(&oi->ip_lock);\n\n\t\t\tnew_emi = kmalloc(sizeof(*new_emi), GFP_NOFS);\n\t\t\tif (new_emi == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tgoto search;\n\t\t}\n\n\t\tocfs2_copy_emi_fields(new_emi, &ins);\n\t\tlist_add(&new_emi->ei_list, &em->em_list);\n\t\tem->em_num_items++;\n\t\tnew_emi = NULL;\n\t} else {\n\t\tBUG_ON(list_empty(&em->em_list) || em->em_num_items == 0);\n\t\temi = list_entry(em->em_list.prev,\n\t\t\t\t struct ocfs2_extent_map_item, ei_list);\n\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\tocfs2_copy_emi_fields(emi, &ins);\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\nout:\n\tkfree(new_emi);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"aops.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"aops.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_insert_rec(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_rec *rec)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tstruct ocfs2_extent_map_item *emi, *new_emi = NULL;\n\tstruct ocfs2_extent_map_item ins;\n\n\tins.ei_cpos = le32_to_cpu(rec->e_cpos);\n\tins.ei_phys = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t       le64_to_cpu(rec->e_blkno));\n\tins.ei_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\tins.ei_flags = rec->e_flags;\n\nsearch:\n\tspin_lock(&oi->ip_lock);\n\n\tlist_for_each_entry(emi, &em->em_list, ei_list) {\n\t\tif (ocfs2_try_to_merge_extent_map(emi, &ins)) {\n\t\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * No item could be merged.\n\t *\n\t * Either allocate and add a new item, or overwrite the last recently\n\t * inserted.\n\t */\n\n\tif (em->em_num_items < OCFS2_MAX_EXTENT_MAP_ITEMS) {\n\t\tif (new_emi == NULL) {\n\t\t\tspin_unlock(&oi->ip_lock);\n\n\t\t\tnew_emi = kmalloc(sizeof(*new_emi), GFP_NOFS);\n\t\t\tif (new_emi == NULL)\n\t\t\t\tgoto out;\n\n\t\t\tgoto search;\n\t\t}\n\n\t\tocfs2_copy_emi_fields(new_emi, &ins);\n\t\tlist_add(&new_emi->ei_list, &em->em_list);\n\t\tem->em_num_items++;\n\t\tnew_emi = NULL;\n\t} else {\n\t\tBUG_ON(list_empty(&em->em_list) || em->em_num_items == 0);\n\t\temi = list_entry(em->em_list.prev,\n\t\t\t\t struct ocfs2_extent_map_item, ei_list);\n\t\tlist_move(&emi->ei_list, &em->em_list);\n\t\tocfs2_copy_emi_fields(emi, &ins);\n\t}\n\n\tspin_unlock(&oi->ip_lock);\n\nout:\n\tkfree(new_emi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "et->et_ci"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "179-182",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec)\n{\n\tstruct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;\n\n\tocfs2_extent_map_insert_rec(inode, rec);\n}"
  },
  {
    "function_name": "ocfs2_dinode_update_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "203-213",
    "snippet": "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tle32_add_cpu(&di->i_clusters, clusters);\n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = le32_to_cpu(di->i_clusters);\n\tspin_unlock(&oi->ip_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
      "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->i_clusters"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&di->i_clusters",
            "clusters"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_info_to_inode",
          "args": [
            "et->et_ci"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "179-182",
          "snippet": "static inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *cache_info_to_inode(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_inode_info, ip_metadata_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters)\n{\n\tstruct ocfs2_inode_info *oi = cache_info_to_inode(et->et_ci);\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tle32_add_cpu(&di->i_clusters, clusters);\n\tspin_lock(&oi->ip_lock);\n\toi->ip_clusters = le32_to_cpu(di->i_clusters);\n\tspin_unlock(&oi->ip_lock);\n}"
  },
  {
    "function_name": "ocfs2_dinode_get_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "195-201",
    "snippet": "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\treturn le64_to_cpu(di->i_last_eb_blk);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_last_eb_blk"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "et->et_ops != &ocfs2_dinode_et_ops"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\treturn le64_to_cpu(di->i_last_eb_blk);\n}"
  },
  {
    "function_name": "ocfs2_dinode_set_last_eb_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
    "lines": "186-193",
    "snippet": "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tdi->i_last_eb_blk = cpu_to_le64(blkno);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"super.h\"",
      "#include \"file.h\"",
      "#include \"sysfile.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
      "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
      "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
      "static int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);",
      "static const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "et->et_ops != &ocfs2_dinode_et_ops"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_is_dealloc_empty(struct ocfs2_extent_tree *et);\nstatic const struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno)\n{\n\tstruct ocfs2_dinode *di = et->et_object;\n\n\tBUG_ON(et->et_ops != &ocfs2_dinode_et_ops);\n\tdi->i_last_eb_blk = cpu_to_le64(blkno);\n}"
  }
]