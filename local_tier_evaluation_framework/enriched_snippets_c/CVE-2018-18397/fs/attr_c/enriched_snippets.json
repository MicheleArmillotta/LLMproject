[
  {
    "function_name": "notify_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
    "lines": "226-345",
    "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/ima.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/capability.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_inode_post_setattr",
          "args": [
            "dentry",
            "ia_valid"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_inode_post_setattr",
          "args": [
            "dentry"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_change",
          "args": [
            "dentry",
            "ia_valid"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_setattr",
          "args": [
            "dentry",
            "attr"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "simple_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "399-413",
          "snippet": "int simple_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\terror = setattr_prepare(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\terror = setattr_prepare(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode->i_op->setattr",
          "args": [
            "dentry",
            "attr"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_break_deleg",
          "args": [
            "inode",
            "delegated_inode"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_setattr",
          "args": [
            "dentry",
            "attr"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "inode->i_gid"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "inode->i_uid"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgid_has_mapping",
          "args": [
            "inode->i_sb->s_user_ns",
            "attr->ia_gid"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "inode->i_sb->s_user_ns",
            "attr->ia_uid"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_need_killpriv",
          "args": [
            "dentry"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sxid",
          "args": [
            "amode"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_WRITE"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "427-460",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!inode_is_locked(inode)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_is_locked",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "setattr_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
    "lines": "178-203",
    "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec64_trunc(attr->ia_atime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec64_trunc(attr->ia_mtime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec64_trunc(attr->ia_ctime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
    "includes": [
      "#include <linux/ima.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/capability.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable_wrt_inode_uidgid",
          "args": [
            "inode",
            "CAP_FSETID"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "inode->i_gid"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_trunc",
          "args": [
            "attr->ia_ctime",
            "inode->i_sb->s_time_gran"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "timespec64_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2124-2137",
          "snippet": "struct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran)\n{\n\t/* Avoid division in the common cases 1 ns and 1 s. */\n\tif (gran == 1) {\n\t\t/* nothing */\n\t} else if (gran == NSEC_PER_SEC) {\n\t\tt.tv_nsec = 0;\n\t} else if (gran > 1 && gran < NSEC_PER_SEC) {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t} else {\n\t\tWARN(1, \"illegal file time granularity: %u\", gran);\n\t}\n\treturn t;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstruct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran)\n{\n\t/* Avoid division in the common cases 1 ns and 1 s. */\n\tif (gran == 1) {\n\t\t/* nothing */\n\t} else if (gran == NSEC_PER_SEC) {\n\t\tt.tv_nsec = 0;\n\t} else if (gran > 1 && gran < NSEC_PER_SEC) {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t} else {\n\t\tWARN(1, \"illegal file time granularity: %u\", gran);\n\t}\n\treturn t;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec64_trunc(attr->ia_atime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec64_trunc(attr->ia_mtime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec64_trunc(attr->ia_ctime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
  },
  {
    "function_name": "inode_newsize_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
    "lines": "135-160",
    "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
    "includes": [
      "#include <linux/ima.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/capability.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGXFSZ",
            "current",
            "0"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "808-813",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "inode"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_FSIZE"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
  },
  {
    "function_name": "setattr_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
    "lines": "61-116",
    "snippet": "int setattr_prepare(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\tgoto kill_priv;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) && !chown_ok(inode, attr->ia_uid))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) && !chgrp_ok(inode, attr->ia_gid))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\nkill_priv:\n\t/* User has permission for the change */\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tint error;\n\n\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ima.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/capability.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_killpriv",
          "args": [
            "dentry"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable_wrt_inode_uidgid",
          "args": [
            "inode",
            "CAP_FSETID"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "(ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chgrp_ok",
          "args": [
            "inode",
            "attr->ia_gid"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "chgrp_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "34-45",
          "snippet": "static bool chgrp_ok(const struct inode *inode, kgid_t gid)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid) &&\n\t    (in_group_p(gid) || gid_eq(gid, inode->i_gid)))\n\t\treturn true;\n\tif (capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn true;\n\tif (gid_eq(inode->i_gid, INVALID_GID) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nstatic bool chgrp_ok(const struct inode *inode, kgid_t gid)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid) &&\n\t    (in_group_p(gid) || gid_eq(gid, inode->i_gid)))\n\t\treturn true;\n\tif (capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn true;\n\tif (gid_eq(inode->i_gid, INVALID_GID) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chown_ok",
          "args": [
            "inode",
            "attr->ia_uid"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "chown_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "21-32",
          "snippet": "static bool chown_ok(const struct inode *inode, kuid_t uid)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid) &&\n\t    uid_eq(uid, inode->i_uid))\n\t\treturn true;\n\tif (capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn true;\n\tif (uid_eq(inode->i_uid, INVALID_UID) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nstatic bool chown_ok(const struct inode *inode, kuid_t uid)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid) &&\n\t    uid_eq(uid, inode->i_uid))\n\t\treturn true;\n\tif (capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn true;\n\tif (uid_eq(inode->i_uid, INVALID_UID) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "135-160",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint setattr_prepare(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\tgoto kill_priv;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) && !chown_ok(inode, attr->ia_uid))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) && !chgrp_ok(inode, attr->ia_gid))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\nkill_priv:\n\t/* User has permission for the change */\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tint error;\n\n\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "chgrp_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
    "lines": "34-45",
    "snippet": "static bool chgrp_ok(const struct inode *inode, kgid_t gid)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid) &&\n\t    (in_group_p(gid) || gid_eq(gid, inode->i_gid)))\n\t\treturn true;\n\tif (capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn true;\n\tif (gid_eq(inode->i_gid, INVALID_GID) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <linux/ima.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/capability.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "inode->i_sb->s_user_ns",
            "CAP_CHOWN"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "inode->i_gid",
            "INVALID_GID"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable_wrt_inode_uidgid",
          "args": [
            "inode",
            "CAP_CHOWN"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "gid",
            "inode->i_gid"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "gid"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "inode->i_uid"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nstatic bool chgrp_ok(const struct inode *inode, kgid_t gid)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid) &&\n\t    (in_group_p(gid) || gid_eq(gid, inode->i_gid)))\n\t\treturn true;\n\tif (capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn true;\n\tif (gid_eq(inode->i_gid, INVALID_GID) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "chown_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
    "lines": "21-32",
    "snippet": "static bool chown_ok(const struct inode *inode, kuid_t uid)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid) &&\n\t    uid_eq(uid, inode->i_uid))\n\t\treturn true;\n\tif (capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn true;\n\tif (uid_eq(inode->i_uid, INVALID_UID) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <linux/ima.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/capability.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "inode->i_sb->s_user_ns",
            "CAP_CHOWN"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "inode->i_uid",
            "INVALID_UID"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable_wrt_inode_uidgid",
          "args": [
            "inode",
            "CAP_CHOWN"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "uid",
            "inode->i_uid"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "inode->i_uid"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nstatic bool chown_ok(const struct inode *inode, kuid_t uid)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid) &&\n\t    uid_eq(uid, inode->i_uid))\n\t\treturn true;\n\tif (capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn true;\n\tif (uid_eq(inode->i_uid, INVALID_UID) &&\n\t    ns_capable(inode->i_sb->s_user_ns, CAP_CHOWN))\n\t\treturn true;\n\treturn false;\n}"
  }
]