[
  {
    "function_name": "exit_misc_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "865-869",
    "snippet": "static void __exit exit_misc_binfmt(void)\n{\n\tunregister_binfmt(&misc_format);\n\tunregister_filesystem(&bm_fs_type);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type bm_fs_type;",
      "static struct linux_binfmt misc_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_misc_binary,\n};",
      "static struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&bm_fs_type"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/filesystems.c",
          "lines": "103-122",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_binfmt",
          "args": [
            "&misc_format"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "94-99",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct file_system_type bm_fs_type;\nstatic struct linux_binfmt misc_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_misc_binary,\n};\nstatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\nstatic void __exit exit_misc_binfmt(void)\n{\n\tunregister_binfmt(&misc_format);\n\tunregister_filesystem(&bm_fs_type);\n}"
  },
  {
    "function_name": "init_misc_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "857-863",
    "snippet": "static int __init init_misc_binfmt(void)\n{\n\tint err = register_filesystem(&bm_fs_type);\n\tif (!err)\n\t\tinsert_binfmt(&misc_format);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type bm_fs_type;",
      "static struct linux_binfmt misc_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_misc_binary,\n};",
      "static struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_binfmt",
          "args": [
            "&misc_format"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&bm_fs_type"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/filesystems.c",
          "lines": "103-122",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct file_system_type bm_fs_type;\nstatic struct linux_binfmt misc_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_misc_binary,\n};\nstatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\nstatic int __init init_misc_binfmt(void)\n{\n\tint err = register_filesystem(&bm_fs_type);\n\tif (!err)\n\t\tinsert_binfmt(&misc_format);\n\treturn err;\n}"
  },
  {
    "function_name": "bm_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "838-842",
    "snippet": "static struct dentry *bm_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, bm_fill_super);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "bm_fill_super"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "mount_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1219-1240",
          "snippet": "struct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *s;\n\tint error;\n\n\ts = sget(fs_type, compare_single, set_anon_super, flags, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\tif (!s->s_root) {\n\t\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\ts->s_flags |= SB_ACTIVE;\n\t} else {\n\t\tdo_remount_sb(s, flags, data, 0);\n\t}\n\treturn dget(s->s_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *s;\n\tint error;\n\n\ts = sget(fs_type, compare_single, set_anon_super, flags, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\tif (!s->s_root) {\n\t\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\ts->s_flags |= SB_ACTIVE;\n\t} else {\n\t\tdo_remount_sb(s, flags, data, 0);\n\t}\n\treturn dget(s->s_root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *bm_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, bm_fill_super);\n}"
  },
  {
    "function_name": "bm_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "823-836",
    "snippet": "static int bm_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint err;\n\tstatic const struct tree_descr bm_files[] = {\n\t\t[2] = {\"status\", &bm_status_operations, S_IWUSR|S_IRUGO},\n\t\t[3] = {\"register\", &bm_register_operations, S_IWUSR},\n\t\t/* last one */ {\"\"}\n\t};\n\n\terr = simple_fill_super(sb, BINFMTFS_MAGIC, bm_files);\n\tif (!err)\n\t\tsb->s_op = &s_ops;\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations bm_register_operations = {\n\t.write\t\t= bm_register_write,\n\t.llseek\t\t= noop_llseek,\n};",
      "static const struct file_operations bm_status_operations = {\n\t.read\t\t= bm_status_read,\n\t.write\t\t= bm_status_write,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct super_operations s_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.evict_inode\t= bm_evict_inode,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_fill_super",
          "args": [
            "sb",
            "BINFMTFS_MAGIC",
            "bm_files"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "simple_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "509-570",
          "snippet": "int simple_fill_super(struct super_block *s, unsigned long magic,\n\t\t      const struct tree_descr *files)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct dentry *dentry;\n\tint i;\n\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = &simple_super_operations;\n\ts->s_time_gran = 1;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\t/*\n\t * because the root inode is 1, the files array must not contain an\n\t * entry at index 1\n\t */\n\tinode->i_ino = 1;\n\tinode->i_mode = S_IFDIR | 0755;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\troot = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tfor (i = 0; !files->name || files->name[0]; i++, files++) {\n\t\tif (!files->name)\n\t\t\tcontinue;\n\n\t\t/* warn if it tries to conflict with the root inode */\n\t\tif (unlikely(i == 1))\n\t\t\tprintk(KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\", __func__,\n\t\t\t\ts->s_type->name);\n\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = new_inode(s);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_mode = S_IFREG | files->mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_ino = i;\n\t\td_add(dentry, inode);\n\t}\n\ts->s_root = root;\n\treturn 0;\nout:\n\td_genocide(root);\n\tshrink_dcache_parent(root);\n\tdput(root);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations simple_dir_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= dcache_readdir,\n\t.fsync\t\t= noop_fsync,\n};",
            "const struct inode_operations simple_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n};",
            "static const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nconst struct file_operations simple_dir_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= dcache_readdir,\n\t.fsync\t\t= noop_fsync,\n};\nconst struct inode_operations simple_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n};\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nint simple_fill_super(struct super_block *s, unsigned long magic,\n\t\t      const struct tree_descr *files)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct dentry *dentry;\n\tint i;\n\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = &simple_super_operations;\n\ts->s_time_gran = 1;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\t/*\n\t * because the root inode is 1, the files array must not contain an\n\t * entry at index 1\n\t */\n\tinode->i_ino = 1;\n\tinode->i_mode = S_IFDIR | 0755;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\troot = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tfor (i = 0; !files->name || files->name[0]; i++, files++) {\n\t\tif (!files->name)\n\t\t\tcontinue;\n\n\t\t/* warn if it tries to conflict with the root inode */\n\t\tif (unlikely(i == 1))\n\t\t\tprintk(KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\", __func__,\n\t\t\t\ts->s_type->name);\n\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = new_inode(s);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_mode = S_IFREG | files->mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_ino = i;\n\t\td_add(dentry, inode);\n\t}\n\ts->s_root = root;\n\treturn 0;\nout:\n\td_genocide(root);\n\tshrink_dcache_parent(root);\n\tdput(root);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic const struct file_operations bm_register_operations = {\n\t.write\t\t= bm_register_write,\n\t.llseek\t\t= noop_llseek,\n};\nstatic const struct file_operations bm_status_operations = {\n\t.read\t\t= bm_status_read,\n\t.write\t\t= bm_status_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct super_operations s_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.evict_inode\t= bm_evict_inode,\n};\n\nstatic int bm_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint err;\n\tstatic const struct tree_descr bm_files[] = {\n\t\t[2] = {\"status\", &bm_status_operations, S_IWUSR|S_IRUGO},\n\t\t[3] = {\"register\", &bm_register_operations, S_IWUSR},\n\t\t/* last one */ {\"\"}\n\t};\n\n\terr = simple_fill_super(sb, BINFMTFS_MAGIC, bm_files);\n\tif (!err)\n\t\tsb->s_op = &s_ops;\n\treturn err;\n}"
  },
  {
    "function_name": "bm_status_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "778-808",
    "snippet": "static ssize_t bm_status_write(struct file *file, const char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tint res = parse_command(buffer, count);\n\tstruct dentry *root;\n\n\tswitch (res) {\n\tcase 1:\n\t\t/* Disable all handlers. */\n\t\tenabled = 0;\n\t\tbreak;\n\tcase 2:\n\t\t/* Enable all handlers. */\n\t\tenabled = 1;\n\t\tbreak;\n\tcase 3:\n\t\t/* Delete all handlers. */\n\t\troot = file_inode(file)->i_sb->s_root;\n\t\tinode_lock(d_inode(root));\n\n\t\twhile (!list_empty(&entries))\n\t\t\tkill_node(list_first_entry(&entries, Node, list));\n\n\t\tinode_unlock(d_inode(root));\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(entries);",
      "static int enabled = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "d_inode(root)"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "root"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_node",
          "args": [
            "list_first_entry(&entries, Node, list)"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "kill_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "612-625",
          "snippet": "static void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tlist_del_init(&e->list);\n\twrite_unlock(&entries_lock);\n\n\tdentry = e->dentry;\n\tdrop_nlink(d_inode(dentry));\n\td_drop(dentry);\n\tdput(dentry);\n\tsimple_release_fs(&bm_mnt, &entry_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(entries_lock);",
            "static struct vfsmount *bm_mnt;",
            "static int entry_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(entries_lock);\nstatic struct vfsmount *bm_mnt;\nstatic int entry_count;\n\nstatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tlist_del_init(&e->list);\n\twrite_unlock(&entries_lock);\n\n\tdentry = e->dentry;\n\tdrop_nlink(d_inode(dentry));\n\td_drop(dentry);\n\tdput(dentry);\n\tsimple_release_fs(&bm_mnt, &entry_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&entries",
            "Node",
            "list"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&entries"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "d_inode(root)"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_command",
          "args": [
            "buffer",
            "count"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "parse_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "524-543",
          "snippet": "static int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(entries);\nstatic int enabled = 1;\n\nstatic ssize_t bm_status_write(struct file *file, const char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tint res = parse_command(buffer, count);\n\tstruct dentry *root;\n\n\tswitch (res) {\n\tcase 1:\n\t\t/* Disable all handlers. */\n\t\tenabled = 0;\n\t\tbreak;\n\tcase 2:\n\t\t/* Enable all handlers. */\n\t\tenabled = 1;\n\t\tbreak;\n\tcase 3:\n\t\t/* Delete all handlers. */\n\t\troot = file_inode(file)->i_sb->s_root;\n\t\tinode_lock(d_inode(root));\n\n\t\twhile (!list_empty(&entries))\n\t\t\tkill_node(list_first_entry(&entries, Node, list));\n\n\t\tinode_unlock(d_inode(root));\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "bm_status_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "770-776",
    "snippet": "static ssize_t\nbm_status_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tchar *s = enabled ? \"enabled\\n\" : \"disabled\\n\";\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, s, strlen(s));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int enabled = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "nbytes",
            "ppos",
            "s",
            "strlen(s)"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "622-640",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int enabled = 1;\n\nstatic ssize_t\nbm_status_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tchar *s = enabled ? \"enabled\\n\" : \"disabled\\n\";\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, s, strlen(s));\n}"
  },
  {
    "function_name": "bm_register_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "689-761",
    "snippet": "static ssize_t bm_register_write(struct file *file, const char __user *buffer,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tNode *e;\n\tstruct inode *inode;\n\tstruct super_block *sb = file_inode(file)->i_sb;\n\tstruct dentry *root = sb->s_root, *dentry;\n\tint err = 0;\n\n\te = create_entry(buffer, count);\n\n\tif (IS_ERR(e))\n\t\treturn PTR_ERR(e);\n\n\tinode_lock(d_inode(root));\n\tdentry = lookup_one_len(e->name, root, strlen(e->name));\n\terr = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\terr = -EEXIST;\n\tif (d_really_is_positive(dentry))\n\t\tgoto out2;\n\n\tinode = bm_get_inode(sb, S_IFREG | 0644);\n\n\terr = -ENOMEM;\n\tif (!inode)\n\t\tgoto out2;\n\n\terr = simple_pin_fs(&bm_fs_type, &bm_mnt, &entry_count);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tgoto out2;\n\t}\n\n\tif (e->flags & MISC_FMT_OPEN_FILE) {\n\t\tstruct file *f;\n\n\t\tf = open_exec(e->interpreter);\n\t\tif (IS_ERR(f)) {\n\t\t\terr = PTR_ERR(f);\n\t\t\tpr_notice(\"register: failed to install interpreter file %s\\n\", e->interpreter);\n\t\t\tsimple_release_fs(&bm_mnt, &entry_count);\n\t\t\tiput(inode);\n\t\t\tinode = NULL;\n\t\t\tgoto out2;\n\t\t}\n\t\te->interp_file = f;\n\t}\n\n\te->dentry = dget(dentry);\n\tinode->i_private = e;\n\tinode->i_fop = &bm_entry_operations;\n\n\td_instantiate(dentry, inode);\n\twrite_lock(&entries_lock);\n\tlist_add(&e->list, &entries);\n\twrite_unlock(&entries_lock);\n\n\terr = 0;\nout2:\n\tdput(dentry);\nout:\n\tinode_unlock(d_inode(root));\n\n\tif (err) {\n\t\tkfree(e);\n\t\treturn err;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MISC_FMT_OPEN_FILE (1 << 28)"
    ],
    "globals_used": [
      "static LIST_HEAD(entries);",
      "static DEFINE_RWLOCK(entries_lock);",
      "static struct file_system_type bm_fs_type;",
      "static struct vfsmount *bm_mnt;",
      "static int entry_count;",
      "static const struct file_operations bm_entry_operations = {\n\t.read\t\t= bm_entry_read,\n\t.write\t\t= bm_entry_write,\n\t.llseek\t\t= default_llseek,\n};",
      "static struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "e"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "d_inode(root)"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "root"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&entries_lock"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/lock.c",
          "lines": "52-68",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&e->list",
            "&entries"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&entries_lock"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/lock.c",
          "lines": "22-33",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1937-1940",
          "snippet": "struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&bm_mnt",
            "&entry_count"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "simple_release_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "596-605",
          "snippet": "void simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_fs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nvoid simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"register: failed to install interpreter file %s\\n\"",
            "e->interpreter"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "f"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_exec",
          "args": [
            "e->interpreter"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "open_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "880-890",
          "snippet": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_pin_fs",
          "args": [
            "&bm_fs_type",
            "&bm_mnt",
            "&entry_count"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "simple_pin_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "575-593",
          "snippet": "int simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt = NULL;\n\tspin_lock(&pin_fs_lock);\n\tif (unlikely(!*mount)) {\n\t\tspin_unlock(&pin_fs_lock);\n\t\tmnt = vfs_kern_mount(type, SB_KERNMOUNT, type->name, NULL);\n\t\tif (IS_ERR(mnt))\n\t\t\treturn PTR_ERR(mnt);\n\t\tspin_lock(&pin_fs_lock);\n\t\tif (!*mount)\n\t\t\t*mount = mnt;\n\t}\n\tmntget(*mount);\n\t++*count;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_fs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nint simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt = NULL;\n\tspin_lock(&pin_fs_lock);\n\tif (unlikely(!*mount)) {\n\t\tspin_unlock(&pin_fs_lock);\n\t\tmnt = vfs_kern_mount(type, SB_KERNMOUNT, type->name, NULL);\n\t\tif (IS_ERR(mnt))\n\t\t\treturn PTR_ERR(mnt);\n\t\tspin_lock(&pin_fs_lock);\n\t\tif (!*mount)\n\t\t\t*mount = mnt;\n\t}\n\tmntget(*mount);\n\t++*count;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bm_get_inode",
          "args": [
            "sb",
            "S_IFREG | 0644"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "bm_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "588-599",
          "snippet": "static struct inode *bm_get_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\t\tcurrent_time(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct inode *bm_get_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\t\tcurrent_time(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_really_is_positive",
          "args": [
            "dentry"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "e->name",
            "root",
            "strlen(e->name)"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "2559-2574",
          "snippet": "struct dentry *lookup_one_len_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tint err;\n\tstruct dentry *ret;\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tret = lookup_dcache(&this, base, 0);\n\tif (!ret)\n\t\tret = lookup_slow(&this, base, 0);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tint err;\n\tstruct dentry *ret;\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tret = lookup_dcache(&this, base, 0);\n\tif (!ret)\n\t\tret = lookup_slow(&this, base, 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "e->name"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "d_inode(root)"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "e"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "e"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_entry",
          "args": [
            "buffer",
            "count"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "create_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "319-518",
          "snippet": "static Node *create_entry(const char __user *buffer, size_t count)\n{\n\tNode *e;\n\tint memsize, err;\n\tchar *buf, *p;\n\tchar del;\n\n\tpr_debug(\"register: received %zu bytes\\n\", count);\n\n\t/* some sanity checks */\n\terr = -EINVAL;\n\tif ((count < 11) || (count > MAX_REGISTER_LENGTH))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmemsize = sizeof(Node) + count + 8;\n\te = kmalloc(memsize, GFP_KERNEL);\n\tif (!e)\n\t\tgoto out;\n\n\tp = buf = (char *)e + sizeof(Node);\n\n\tmemset(e, 0, sizeof(Node));\n\tif (copy_from_user(buf, buffer, count))\n\t\tgoto efault;\n\n\tdel = *p++;\t/* delimeter */\n\n\tpr_debug(\"register: delim: %#x {%c}\\n\", del, del);\n\n\t/* Pad the buffer with the delim to simplify parsing below. */\n\tmemset(buf + count, del, 8);\n\n\t/* Parse the 'name' field. */\n\te->name = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->name[0] ||\n\t    !strcmp(e->name, \".\") ||\n\t    !strcmp(e->name, \"..\") ||\n\t    strchr(e->name, '/'))\n\t\tgoto einval;\n\n\tpr_debug(\"register: name: {%s}\\n\", e->name);\n\n\t/* Parse the 'type' field. */\n\tswitch (*p++) {\n\tcase 'E':\n\t\tpr_debug(\"register: type: E (extension)\\n\");\n\t\te->flags = 1 << Enabled;\n\t\tbreak;\n\tcase 'M':\n\t\tpr_debug(\"register: type: M (magic)\\n\");\n\t\te->flags = (1 << Enabled) | (1 << Magic);\n\t\tbreak;\n\tdefault:\n\t\tgoto einval;\n\t}\n\tif (*p++ != del)\n\t\tgoto einval;\n\n\tif (test_bit(Magic, &e->flags)) {\n\t\t/* Handle the 'M' (magic) format. */\n\t\tchar *s;\n\n\t\t/* Parse the 'offset' field. */\n\t\ts = strchr(p, del);\n\t\tif (!s)\n\t\t\tgoto einval;\n\t\t*s = '\\0';\n\t\tif (p != s) {\n\t\t\tint r = kstrtoint(p, 10, &e->offset);\n\t\t\tif (r != 0 || e->offset < 0)\n\t\t\t\tgoto einval;\n\t\t}\n\t\tp = s;\n\t\tif (*p++)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: offset: %#x\\n\", e->offset);\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->magic[0])\n\t\t\tgoto einval;\n\t\tif (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, p - e->magic);\n\n\t\t/* Parse the 'mask' field. */\n\t\te->mask = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->mask[0]) {\n\t\t\te->mask = NULL;\n\t\t\tpr_debug(\"register:  mask[raw]: none\\n\");\n\t\t} else if (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register:  mask[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->mask, p - e->mask);\n\n\t\t/*\n\t\t * Decode the magic & mask fields.\n\t\t * Note: while we might have accepted embedded NUL bytes from\n\t\t * above, the unescape helpers here will stop at the first one\n\t\t * it encounters.\n\t\t */\n\t\te->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\n\t\tif (e->mask &&\n\t\t    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\n\t\t\tgoto einval;\n\t\tif (e->size > BINPRM_BUF_SIZE ||\n\t\t    BINPRM_BUF_SIZE - e->size < e->offset)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: magic/mask length: %i\\n\", e->size);\n\t\tif (USE_DEBUG) {\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[decoded]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, e->size);\n\n\t\t\tif (e->mask) {\n\t\t\t\tint i;\n\t\t\t\tchar *masked = kmalloc(e->size, GFP_KERNEL);\n\n\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\tKBUILD_MODNAME \": register:  mask[decoded]: \",\n\t\t\t\t\tDUMP_PREFIX_NONE, e->mask, e->size);\n\n\t\t\t\tif (masked) {\n\t\t\t\t\tfor (i = 0; i < e->size; ++i)\n\t\t\t\t\t\tmasked[i] = e->magic[i] & e->mask[i];\n\t\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\t\tKBUILD_MODNAME \": register:  magic[masked]: \",\n\t\t\t\t\t\tDUMP_PREFIX_NONE, masked, e->size);\n\n\t\t\t\t\tkfree(masked);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Handle the 'E' (extension) format. */\n\n\t\t/* Skip the 'offset' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t\tif (!e->magic[0] || strchr(e->magic, '/'))\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: extension: {%s}\\n\", e->magic);\n\n\t\t/* Skip the 'mask' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t}\n\n\t/* Parse the 'interpreter' field. */\n\te->interpreter = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->interpreter[0])\n\t\tgoto einval;\n\tpr_debug(\"register: interpreter: {%s}\\n\", e->interpreter);\n\n\t/* Parse the 'flags' field. */\n\tp = check_special_flags(p, e);\n\tif (*p == '\\n')\n\t\tp++;\n\tif (p != buf + count)\n\t\tgoto einval;\n\n\treturn e;\n\nout:\n\treturn ERR_PTR(err);\n\nefault:\n\tkfree(e);\n\treturn ERR_PTR(-EFAULT);\neinval:\n\tkfree(e);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_REGISTER_LENGTH 1920"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MAX_REGISTER_LENGTH 1920\n\nstatic Node *create_entry(const char __user *buffer, size_t count)\n{\n\tNode *e;\n\tint memsize, err;\n\tchar *buf, *p;\n\tchar del;\n\n\tpr_debug(\"register: received %zu bytes\\n\", count);\n\n\t/* some sanity checks */\n\terr = -EINVAL;\n\tif ((count < 11) || (count > MAX_REGISTER_LENGTH))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmemsize = sizeof(Node) + count + 8;\n\te = kmalloc(memsize, GFP_KERNEL);\n\tif (!e)\n\t\tgoto out;\n\n\tp = buf = (char *)e + sizeof(Node);\n\n\tmemset(e, 0, sizeof(Node));\n\tif (copy_from_user(buf, buffer, count))\n\t\tgoto efault;\n\n\tdel = *p++;\t/* delimeter */\n\n\tpr_debug(\"register: delim: %#x {%c}\\n\", del, del);\n\n\t/* Pad the buffer with the delim to simplify parsing below. */\n\tmemset(buf + count, del, 8);\n\n\t/* Parse the 'name' field. */\n\te->name = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->name[0] ||\n\t    !strcmp(e->name, \".\") ||\n\t    !strcmp(e->name, \"..\") ||\n\t    strchr(e->name, '/'))\n\t\tgoto einval;\n\n\tpr_debug(\"register: name: {%s}\\n\", e->name);\n\n\t/* Parse the 'type' field. */\n\tswitch (*p++) {\n\tcase 'E':\n\t\tpr_debug(\"register: type: E (extension)\\n\");\n\t\te->flags = 1 << Enabled;\n\t\tbreak;\n\tcase 'M':\n\t\tpr_debug(\"register: type: M (magic)\\n\");\n\t\te->flags = (1 << Enabled) | (1 << Magic);\n\t\tbreak;\n\tdefault:\n\t\tgoto einval;\n\t}\n\tif (*p++ != del)\n\t\tgoto einval;\n\n\tif (test_bit(Magic, &e->flags)) {\n\t\t/* Handle the 'M' (magic) format. */\n\t\tchar *s;\n\n\t\t/* Parse the 'offset' field. */\n\t\ts = strchr(p, del);\n\t\tif (!s)\n\t\t\tgoto einval;\n\t\t*s = '\\0';\n\t\tif (p != s) {\n\t\t\tint r = kstrtoint(p, 10, &e->offset);\n\t\t\tif (r != 0 || e->offset < 0)\n\t\t\t\tgoto einval;\n\t\t}\n\t\tp = s;\n\t\tif (*p++)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: offset: %#x\\n\", e->offset);\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->magic[0])\n\t\t\tgoto einval;\n\t\tif (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, p - e->magic);\n\n\t\t/* Parse the 'mask' field. */\n\t\te->mask = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->mask[0]) {\n\t\t\te->mask = NULL;\n\t\t\tpr_debug(\"register:  mask[raw]: none\\n\");\n\t\t} else if (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register:  mask[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->mask, p - e->mask);\n\n\t\t/*\n\t\t * Decode the magic & mask fields.\n\t\t * Note: while we might have accepted embedded NUL bytes from\n\t\t * above, the unescape helpers here will stop at the first one\n\t\t * it encounters.\n\t\t */\n\t\te->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\n\t\tif (e->mask &&\n\t\t    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\n\t\t\tgoto einval;\n\t\tif (e->size > BINPRM_BUF_SIZE ||\n\t\t    BINPRM_BUF_SIZE - e->size < e->offset)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: magic/mask length: %i\\n\", e->size);\n\t\tif (USE_DEBUG) {\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[decoded]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, e->size);\n\n\t\t\tif (e->mask) {\n\t\t\t\tint i;\n\t\t\t\tchar *masked = kmalloc(e->size, GFP_KERNEL);\n\n\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\tKBUILD_MODNAME \": register:  mask[decoded]: \",\n\t\t\t\t\tDUMP_PREFIX_NONE, e->mask, e->size);\n\n\t\t\t\tif (masked) {\n\t\t\t\t\tfor (i = 0; i < e->size; ++i)\n\t\t\t\t\t\tmasked[i] = e->magic[i] & e->mask[i];\n\t\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\t\tKBUILD_MODNAME \": register:  magic[masked]: \",\n\t\t\t\t\t\tDUMP_PREFIX_NONE, masked, e->size);\n\n\t\t\t\t\tkfree(masked);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Handle the 'E' (extension) format. */\n\n\t\t/* Skip the 'offset' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t\tif (!e->magic[0] || strchr(e->magic, '/'))\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: extension: {%s}\\n\", e->magic);\n\n\t\t/* Skip the 'mask' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t}\n\n\t/* Parse the 'interpreter' field. */\n\te->interpreter = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->interpreter[0])\n\t\tgoto einval;\n\tpr_debug(\"register: interpreter: {%s}\\n\", e->interpreter);\n\n\t/* Parse the 'flags' field. */\n\tp = check_special_flags(p, e);\n\tif (*p == '\\n')\n\t\tp++;\n\tif (p != buf + count)\n\t\tgoto einval;\n\n\treturn e;\n\nout:\n\treturn ERR_PTR(err);\n\nefault:\n\tkfree(e);\n\treturn ERR_PTR(-EFAULT);\neinval:\n\tkfree(e);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MISC_FMT_OPEN_FILE (1 << 28)\n\nstatic LIST_HEAD(entries);\nstatic DEFINE_RWLOCK(entries_lock);\nstatic struct file_system_type bm_fs_type;\nstatic struct vfsmount *bm_mnt;\nstatic int entry_count;\nstatic const struct file_operations bm_entry_operations = {\n\t.read\t\t= bm_entry_read,\n\t.write\t\t= bm_entry_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\nstatic ssize_t bm_register_write(struct file *file, const char __user *buffer,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tNode *e;\n\tstruct inode *inode;\n\tstruct super_block *sb = file_inode(file)->i_sb;\n\tstruct dentry *root = sb->s_root, *dentry;\n\tint err = 0;\n\n\te = create_entry(buffer, count);\n\n\tif (IS_ERR(e))\n\t\treturn PTR_ERR(e);\n\n\tinode_lock(d_inode(root));\n\tdentry = lookup_one_len(e->name, root, strlen(e->name));\n\terr = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\terr = -EEXIST;\n\tif (d_really_is_positive(dentry))\n\t\tgoto out2;\n\n\tinode = bm_get_inode(sb, S_IFREG | 0644);\n\n\terr = -ENOMEM;\n\tif (!inode)\n\t\tgoto out2;\n\n\terr = simple_pin_fs(&bm_fs_type, &bm_mnt, &entry_count);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tgoto out2;\n\t}\n\n\tif (e->flags & MISC_FMT_OPEN_FILE) {\n\t\tstruct file *f;\n\n\t\tf = open_exec(e->interpreter);\n\t\tif (IS_ERR(f)) {\n\t\t\terr = PTR_ERR(f);\n\t\t\tpr_notice(\"register: failed to install interpreter file %s\\n\", e->interpreter);\n\t\t\tsimple_release_fs(&bm_mnt, &entry_count);\n\t\t\tiput(inode);\n\t\t\tinode = NULL;\n\t\t\tgoto out2;\n\t\t}\n\t\te->interp_file = f;\n\t}\n\n\te->dentry = dget(dentry);\n\tinode->i_private = e;\n\tinode->i_fop = &bm_entry_operations;\n\n\td_instantiate(dentry, inode);\n\twrite_lock(&entries_lock);\n\tlist_add(&e->list, &entries);\n\twrite_unlock(&entries_lock);\n\n\terr = 0;\nout2:\n\tdput(dentry);\nout:\n\tinode_unlock(d_inode(root));\n\n\tif (err) {\n\t\tkfree(e);\n\t\treturn err;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "bm_entry_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "648-679",
    "snippet": "static ssize_t bm_entry_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct dentry *root;\n\tNode *e = file_inode(file)->i_private;\n\tint res = parse_command(buffer, count);\n\n\tswitch (res) {\n\tcase 1:\n\t\t/* Disable this handler. */\n\t\tclear_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 2:\n\t\t/* Enable this handler. */\n\t\tset_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 3:\n\t\t/* Delete this handler. */\n\t\troot = file_inode(file)->i_sb->s_root;\n\t\tinode_lock(d_inode(root));\n\n\t\tif (!list_empty(&e->list))\n\t\t\tkill_node(e);\n\n\t\tinode_unlock(d_inode(root));\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "d_inode(root)"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "root"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_node",
          "args": [
            "e"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "kill_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "612-625",
          "snippet": "static void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tlist_del_init(&e->list);\n\twrite_unlock(&entries_lock);\n\n\tdentry = e->dentry;\n\tdrop_nlink(d_inode(dentry));\n\td_drop(dentry);\n\tdput(dentry);\n\tsimple_release_fs(&bm_mnt, &entry_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(entries_lock);",
            "static struct vfsmount *bm_mnt;",
            "static int entry_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(entries_lock);\nstatic struct vfsmount *bm_mnt;\nstatic int entry_count;\n\nstatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tlist_del_init(&e->list);\n\twrite_unlock(&entries_lock);\n\n\tdentry = e->dentry;\n\tdrop_nlink(d_inode(dentry));\n\td_drop(dentry);\n\tdput(dentry);\n\tsimple_release_fs(&bm_mnt, &entry_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&e->list"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "d_inode(root)"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "Enabled",
            "&e->flags"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "914-918",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "Enabled",
            "&e->flags"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "920-924",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_command",
          "args": [
            "buffer",
            "count"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "parse_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "524-543",
          "snippet": "static int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic ssize_t bm_entry_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct dentry *root;\n\tNode *e = file_inode(file)->i_private;\n\tint res = parse_command(buffer, count);\n\n\tswitch (res) {\n\tcase 1:\n\t\t/* Disable this handler. */\n\t\tclear_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 2:\n\t\t/* Enable this handler. */\n\t\tset_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 3:\n\t\t/* Delete this handler. */\n\t\troot = file_inode(file)->i_sb->s_root;\n\t\tinode_lock(d_inode(root));\n\n\t\tif (!list_empty(&e->list))\n\t\t\tkill_node(e);\n\n\t\tinode_unlock(d_inode(root));\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "bm_entry_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "629-646",
    "snippet": "static ssize_t\nbm_entry_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tNode *e = file_inode(file)->i_private;\n\tssize_t res;\n\tchar *page;\n\n\tpage = (char *) __get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tentry_status(e, page);\n\n\tres = simple_read_from_buffer(buf, nbytes, ppos, page, strlen(page));\n\n\tfree_page((unsigned long) page);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) page"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xfs/xfs_buf.c",
          "lines": "305-313",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_errortag.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "nbytes",
            "ppos",
            "page",
            "strlen(page)"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "622-640",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "page"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_status",
          "args": [
            "e",
            "page"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "entry_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "547-586",
          "snippet": "static void entry_status(Node *e, char *page)\n{\n\tchar *dp = page;\n\tconst char *status = \"disabled\";\n\n\tif (test_bit(Enabled, &e->flags))\n\t\tstatus = \"enabled\";\n\n\tif (!VERBOSE_STATUS) {\n\t\tsprintf(page, \"%s\\n\", status);\n\t\treturn;\n\t}\n\n\tdp += sprintf(dp, \"%s\\ninterpreter %s\\n\", status, e->interpreter);\n\n\t/* print the special flags */\n\tdp += sprintf(dp, \"flags: \");\n\tif (e->flags & MISC_FMT_PRESERVE_ARGV0)\n\t\t*dp++ = 'P';\n\tif (e->flags & MISC_FMT_OPEN_BINARY)\n\t\t*dp++ = 'O';\n\tif (e->flags & MISC_FMT_CREDENTIALS)\n\t\t*dp++ = 'C';\n\tif (e->flags & MISC_FMT_OPEN_FILE)\n\t\t*dp++ = 'F';\n\t*dp++ = '\\n';\n\n\tif (!test_bit(Magic, &e->flags)) {\n\t\tsprintf(dp, \"extension .%s\\n\", e->magic);\n\t} else {\n\t\tdp += sprintf(dp, \"offset %i\\nmagic \", e->offset);\n\t\tdp = bin2hex(dp, e->magic, e->size);\n\t\tif (e->mask) {\n\t\t\tdp += sprintf(dp, \"\\nmask \");\n\t\t\tdp = bin2hex(dp, e->mask, e->size);\n\t\t}\n\t\t*dp++ = '\\n';\n\t\t*dp = '\\0';\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MISC_FMT_OPEN_FILE (1 << 28)",
            "#define MISC_FMT_CREDENTIALS (1 << 29)",
            "#define MISC_FMT_OPEN_BINARY (1 << 30)",
            "#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)"
          ],
          "globals_used": [
            "static int enabled = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MISC_FMT_OPEN_FILE (1 << 28)\n#define MISC_FMT_CREDENTIALS (1 << 29)\n#define MISC_FMT_OPEN_BINARY (1 << 30)\n#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)\n\nstatic int enabled = 1;\n\nstatic void entry_status(Node *e, char *page)\n{\n\tchar *dp = page;\n\tconst char *status = \"disabled\";\n\n\tif (test_bit(Enabled, &e->flags))\n\t\tstatus = \"enabled\";\n\n\tif (!VERBOSE_STATUS) {\n\t\tsprintf(page, \"%s\\n\", status);\n\t\treturn;\n\t}\n\n\tdp += sprintf(dp, \"%s\\ninterpreter %s\\n\", status, e->interpreter);\n\n\t/* print the special flags */\n\tdp += sprintf(dp, \"flags: \");\n\tif (e->flags & MISC_FMT_PRESERVE_ARGV0)\n\t\t*dp++ = 'P';\n\tif (e->flags & MISC_FMT_OPEN_BINARY)\n\t\t*dp++ = 'O';\n\tif (e->flags & MISC_FMT_CREDENTIALS)\n\t\t*dp++ = 'C';\n\tif (e->flags & MISC_FMT_OPEN_FILE)\n\t\t*dp++ = 'F';\n\t*dp++ = '\\n';\n\n\tif (!test_bit(Magic, &e->flags)) {\n\t\tsprintf(dp, \"extension .%s\\n\", e->magic);\n\t} else {\n\t\tdp += sprintf(dp, \"offset %i\\nmagic \", e->offset);\n\t\tdp = bin2hex(dp, e->magic, e->size);\n\t\tif (e->mask) {\n\t\t\tdp += sprintf(dp, \"\\nmask \");\n\t\t\tdp = bin2hex(dp, e->mask, e->size);\n\t\t}\n\t\t*dp++ = '\\n';\n\t\t*dp = '\\0';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic ssize_t\nbm_entry_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tNode *e = file_inode(file)->i_private;\n\tssize_t res;\n\tchar *page;\n\n\tpage = (char *) __get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tentry_status(e, page);\n\n\tres = simple_read_from_buffer(buf, nbytes, ppos, page, strlen(page));\n\n\tfree_page((unsigned long) page);\n\treturn res;\n}"
  },
  {
    "function_name": "kill_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "612-625",
    "snippet": "static void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tlist_del_init(&e->list);\n\twrite_unlock(&entries_lock);\n\n\tdentry = e->dentry;\n\tdrop_nlink(d_inode(dentry));\n\td_drop(dentry);\n\tdput(dentry);\n\tsimple_release_fs(&bm_mnt, &entry_count);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(entries_lock);",
      "static struct vfsmount *bm_mnt;",
      "static int entry_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&bm_mnt",
            "&entry_count"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "simple_release_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "596-605",
          "snippet": "void simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_fs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nvoid simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "477-482",
          "snippet": "void d_drop(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_drop(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "d_inode(dentry)"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "283-289",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&entries_lock"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/lock.c",
          "lines": "52-68",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&e->list"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&entries_lock"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/lock.c",
          "lines": "22-33",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(entries_lock);\nstatic struct vfsmount *bm_mnt;\nstatic int entry_count;\n\nstatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tlist_del_init(&e->list);\n\twrite_unlock(&entries_lock);\n\n\tdentry = e->dentry;\n\tdrop_nlink(d_inode(dentry));\n\td_drop(dentry);\n\tdput(dentry);\n\tsimple_release_fs(&bm_mnt, &entry_count);\n}"
  },
  {
    "function_name": "bm_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "601-610",
    "snippet": "static void bm_evict_inode(struct inode *inode)\n{\n\tNode *e = inode->i_private;\n\n\tif (e && e->flags & MISC_FMT_OPEN_FILE)\n\t\tfilp_close(e->interp_file, NULL);\n\n\tclear_inode(inode);\n\tkfree(e);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MISC_FMT_OPEN_FILE (1 << 28)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "e"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "504-521",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "e->interp_file",
            "NULL"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1130-1148",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MISC_FMT_OPEN_FILE (1 << 28)\n\nstatic void bm_evict_inode(struct inode *inode)\n{\n\tNode *e = inode->i_private;\n\n\tif (e && e->flags & MISC_FMT_OPEN_FILE)\n\t\tfilp_close(e->interp_file, NULL);\n\n\tclear_inode(inode);\n\tkfree(e);\n}"
  },
  {
    "function_name": "bm_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "588-599",
    "snippet": "static struct inode *bm_get_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\t\tcurrent_time(inode);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "870-891",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);",
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "discard_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "982-992",
          "snippet": "void discard_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n\tiput(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid discard_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n\tiput(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct inode *bm_get_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\t\tcurrent_time(inode);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "entry_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "547-586",
    "snippet": "static void entry_status(Node *e, char *page)\n{\n\tchar *dp = page;\n\tconst char *status = \"disabled\";\n\n\tif (test_bit(Enabled, &e->flags))\n\t\tstatus = \"enabled\";\n\n\tif (!VERBOSE_STATUS) {\n\t\tsprintf(page, \"%s\\n\", status);\n\t\treturn;\n\t}\n\n\tdp += sprintf(dp, \"%s\\ninterpreter %s\\n\", status, e->interpreter);\n\n\t/* print the special flags */\n\tdp += sprintf(dp, \"flags: \");\n\tif (e->flags & MISC_FMT_PRESERVE_ARGV0)\n\t\t*dp++ = 'P';\n\tif (e->flags & MISC_FMT_OPEN_BINARY)\n\t\t*dp++ = 'O';\n\tif (e->flags & MISC_FMT_CREDENTIALS)\n\t\t*dp++ = 'C';\n\tif (e->flags & MISC_FMT_OPEN_FILE)\n\t\t*dp++ = 'F';\n\t*dp++ = '\\n';\n\n\tif (!test_bit(Magic, &e->flags)) {\n\t\tsprintf(dp, \"extension .%s\\n\", e->magic);\n\t} else {\n\t\tdp += sprintf(dp, \"offset %i\\nmagic \", e->offset);\n\t\tdp = bin2hex(dp, e->magic, e->size);\n\t\tif (e->mask) {\n\t\t\tdp += sprintf(dp, \"\\nmask \");\n\t\t\tdp = bin2hex(dp, e->mask, e->size);\n\t\t}\n\t\t*dp++ = '\\n';\n\t\t*dp = '\\0';\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MISC_FMT_OPEN_FILE (1 << 28)",
      "#define MISC_FMT_CREDENTIALS (1 << 29)",
      "#define MISC_FMT_OPEN_BINARY (1 << 30)",
      "#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)"
    ],
    "globals_used": [
      "static int enabled = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bin2hex",
          "args": [
            "dp",
            "e->mask",
            "e->size"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\"\\nmask \""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin2hex",
          "args": [
            "dp",
            "e->magic",
            "e->size"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\"offset %i\\nmagic \"",
            "e->offset"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\"extension .%s\\n\"",
            "e->magic"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "Magic",
            "&e->flags"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\"flags: \""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dp",
            "\"%s\\ninterpreter %s\\n\"",
            "status",
            "e->interpreter"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1608-1627",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n\nstatic inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%s\\n\"",
            "status"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MISC_FMT_OPEN_FILE (1 << 28)\n#define MISC_FMT_CREDENTIALS (1 << 29)\n#define MISC_FMT_OPEN_BINARY (1 << 30)\n#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)\n\nstatic int enabled = 1;\n\nstatic void entry_status(Node *e, char *page)\n{\n\tchar *dp = page;\n\tconst char *status = \"disabled\";\n\n\tif (test_bit(Enabled, &e->flags))\n\t\tstatus = \"enabled\";\n\n\tif (!VERBOSE_STATUS) {\n\t\tsprintf(page, \"%s\\n\", status);\n\t\treturn;\n\t}\n\n\tdp += sprintf(dp, \"%s\\ninterpreter %s\\n\", status, e->interpreter);\n\n\t/* print the special flags */\n\tdp += sprintf(dp, \"flags: \");\n\tif (e->flags & MISC_FMT_PRESERVE_ARGV0)\n\t\t*dp++ = 'P';\n\tif (e->flags & MISC_FMT_OPEN_BINARY)\n\t\t*dp++ = 'O';\n\tif (e->flags & MISC_FMT_CREDENTIALS)\n\t\t*dp++ = 'C';\n\tif (e->flags & MISC_FMT_OPEN_FILE)\n\t\t*dp++ = 'F';\n\t*dp++ = '\\n';\n\n\tif (!test_bit(Magic, &e->flags)) {\n\t\tsprintf(dp, \"extension .%s\\n\", e->magic);\n\t} else {\n\t\tdp += sprintf(dp, \"offset %i\\nmagic \", e->offset);\n\t\tdp = bin2hex(dp, e->magic, e->size);\n\t\tif (e->mask) {\n\t\t\tdp += sprintf(dp, \"\\nmask \");\n\t\t\tdp = bin2hex(dp, e->mask, e->size);\n\t\t}\n\t\t*dp++ = '\\n';\n\t\t*dp = '\\0';\n\t}\n}"
  },
  {
    "function_name": "parse_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "524-543",
    "snippet": "static int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "s",
            "buffer",
            "count"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "create_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "319-518",
    "snippet": "static Node *create_entry(const char __user *buffer, size_t count)\n{\n\tNode *e;\n\tint memsize, err;\n\tchar *buf, *p;\n\tchar del;\n\n\tpr_debug(\"register: received %zu bytes\\n\", count);\n\n\t/* some sanity checks */\n\terr = -EINVAL;\n\tif ((count < 11) || (count > MAX_REGISTER_LENGTH))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmemsize = sizeof(Node) + count + 8;\n\te = kmalloc(memsize, GFP_KERNEL);\n\tif (!e)\n\t\tgoto out;\n\n\tp = buf = (char *)e + sizeof(Node);\n\n\tmemset(e, 0, sizeof(Node));\n\tif (copy_from_user(buf, buffer, count))\n\t\tgoto efault;\n\n\tdel = *p++;\t/* delimeter */\n\n\tpr_debug(\"register: delim: %#x {%c}\\n\", del, del);\n\n\t/* Pad the buffer with the delim to simplify parsing below. */\n\tmemset(buf + count, del, 8);\n\n\t/* Parse the 'name' field. */\n\te->name = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->name[0] ||\n\t    !strcmp(e->name, \".\") ||\n\t    !strcmp(e->name, \"..\") ||\n\t    strchr(e->name, '/'))\n\t\tgoto einval;\n\n\tpr_debug(\"register: name: {%s}\\n\", e->name);\n\n\t/* Parse the 'type' field. */\n\tswitch (*p++) {\n\tcase 'E':\n\t\tpr_debug(\"register: type: E (extension)\\n\");\n\t\te->flags = 1 << Enabled;\n\t\tbreak;\n\tcase 'M':\n\t\tpr_debug(\"register: type: M (magic)\\n\");\n\t\te->flags = (1 << Enabled) | (1 << Magic);\n\t\tbreak;\n\tdefault:\n\t\tgoto einval;\n\t}\n\tif (*p++ != del)\n\t\tgoto einval;\n\n\tif (test_bit(Magic, &e->flags)) {\n\t\t/* Handle the 'M' (magic) format. */\n\t\tchar *s;\n\n\t\t/* Parse the 'offset' field. */\n\t\ts = strchr(p, del);\n\t\tif (!s)\n\t\t\tgoto einval;\n\t\t*s = '\\0';\n\t\tif (p != s) {\n\t\t\tint r = kstrtoint(p, 10, &e->offset);\n\t\t\tif (r != 0 || e->offset < 0)\n\t\t\t\tgoto einval;\n\t\t}\n\t\tp = s;\n\t\tif (*p++)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: offset: %#x\\n\", e->offset);\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->magic[0])\n\t\t\tgoto einval;\n\t\tif (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, p - e->magic);\n\n\t\t/* Parse the 'mask' field. */\n\t\te->mask = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->mask[0]) {\n\t\t\te->mask = NULL;\n\t\t\tpr_debug(\"register:  mask[raw]: none\\n\");\n\t\t} else if (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register:  mask[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->mask, p - e->mask);\n\n\t\t/*\n\t\t * Decode the magic & mask fields.\n\t\t * Note: while we might have accepted embedded NUL bytes from\n\t\t * above, the unescape helpers here will stop at the first one\n\t\t * it encounters.\n\t\t */\n\t\te->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\n\t\tif (e->mask &&\n\t\t    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\n\t\t\tgoto einval;\n\t\tif (e->size > BINPRM_BUF_SIZE ||\n\t\t    BINPRM_BUF_SIZE - e->size < e->offset)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: magic/mask length: %i\\n\", e->size);\n\t\tif (USE_DEBUG) {\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[decoded]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, e->size);\n\n\t\t\tif (e->mask) {\n\t\t\t\tint i;\n\t\t\t\tchar *masked = kmalloc(e->size, GFP_KERNEL);\n\n\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\tKBUILD_MODNAME \": register:  mask[decoded]: \",\n\t\t\t\t\tDUMP_PREFIX_NONE, e->mask, e->size);\n\n\t\t\t\tif (masked) {\n\t\t\t\t\tfor (i = 0; i < e->size; ++i)\n\t\t\t\t\t\tmasked[i] = e->magic[i] & e->mask[i];\n\t\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\t\tKBUILD_MODNAME \": register:  magic[masked]: \",\n\t\t\t\t\t\tDUMP_PREFIX_NONE, masked, e->size);\n\n\t\t\t\t\tkfree(masked);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Handle the 'E' (extension) format. */\n\n\t\t/* Skip the 'offset' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t\tif (!e->magic[0] || strchr(e->magic, '/'))\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: extension: {%s}\\n\", e->magic);\n\n\t\t/* Skip the 'mask' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t}\n\n\t/* Parse the 'interpreter' field. */\n\te->interpreter = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->interpreter[0])\n\t\tgoto einval;\n\tpr_debug(\"register: interpreter: {%s}\\n\", e->interpreter);\n\n\t/* Parse the 'flags' field. */\n\tp = check_special_flags(p, e);\n\tif (*p == '\\n')\n\t\tp++;\n\tif (p != buf + count)\n\t\tgoto einval;\n\n\treturn e;\n\nout:\n\treturn ERR_PTR(err);\n\nefault:\n\tkfree(e);\n\treturn ERR_PTR(-EFAULT);\neinval:\n\tkfree(e);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_REGISTER_LENGTH 1920"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "e"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_special_flags",
          "args": [
            "p",
            "e"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "check_special_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "275-312",
          "snippet": "static char *check_special_flags(char *sfs, Node *e)\n{\n\tchar *p = sfs;\n\tint cont = 1;\n\n\t/* special flags */\n\twhile (cont) {\n\t\tswitch (*p) {\n\t\tcase 'P':\n\t\t\tpr_debug(\"register: flag: P (preserve argv0)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_PRESERVE_ARGV0;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tpr_debug(\"register: flag: O (open binary)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_BINARY;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tpr_debug(\"register: flag: C (preserve creds)\\n\");\n\t\t\tp++;\n\t\t\t/* this flags also implies the\n\t\t\t   open-binary flag */\n\t\t\te->flags |= (MISC_FMT_CREDENTIALS |\n\t\t\t\t\tMISC_FMT_OPEN_BINARY);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tpr_debug(\"register: flag: F: open interpreter file now\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_FILE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcont = 0;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MISC_FMT_OPEN_FILE (1 << 28)",
            "#define MISC_FMT_CREDENTIALS (1 << 29)",
            "#define MISC_FMT_OPEN_BINARY (1 << 30)",
            "#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MISC_FMT_OPEN_FILE (1 << 28)\n#define MISC_FMT_CREDENTIALS (1 << 29)\n#define MISC_FMT_OPEN_BINARY (1 << 30)\n#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)\n\nstatic char *check_special_flags(char *sfs, Node *e)\n{\n\tchar *p = sfs;\n\tint cont = 1;\n\n\t/* special flags */\n\twhile (cont) {\n\t\tswitch (*p) {\n\t\tcase 'P':\n\t\t\tpr_debug(\"register: flag: P (preserve argv0)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_PRESERVE_ARGV0;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tpr_debug(\"register: flag: O (open binary)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_BINARY;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tpr_debug(\"register: flag: C (preserve creds)\\n\");\n\t\t\tp++;\n\t\t\t/* this flags also implies the\n\t\t\t   open-binary flag */\n\t\t\te->flags |= (MISC_FMT_CREDENTIALS |\n\t\t\t\t\tMISC_FMT_OPEN_BINARY);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tpr_debug(\"register: flag: F: open interpreter file now\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_FILE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcont = 0;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: interpreter: {%s}\\n\"",
            "e->interpreter"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "del"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "del"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: extension: {%s}\\n\"",
            "e->magic"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "e->magic",
            "'/'"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "del"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "del"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump_bytes",
          "args": [
            "KBUILD_MODNAME \": register:  magic[masked]: \"",
            "DUMP_PREFIX_NONE",
            "masked",
            "e->size"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump_bytes",
          "args": [
            "KBUILD_MODNAME \": register:  mask[decoded]: \"",
            "DUMP_PREFIX_NONE",
            "e->mask",
            "e->size"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "e->size",
            "GFP_KERNEL"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_hex_dump_bytes",
          "args": [
            "KBUILD_MODNAME \": register: magic[decoded]: \"",
            "DUMP_PREFIX_NONE",
            "e->magic",
            "e->size"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: magic/mask length: %i\\n\"",
            "e->size"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_unescape_inplace",
          "args": [
            "e->mask",
            "UNESCAPE_HEX"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_unescape_inplace",
          "args": [
            "e->magic",
            "UNESCAPE_HEX"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump_bytes",
          "args": [
            "KBUILD_MODNAME \": register:  mask[raw]: \"",
            "DUMP_PREFIX_NONE",
            "e->mask",
            "p - e->mask"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register:  mask[raw]: none\\n\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanarg",
          "args": [
            "p",
            "del"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "scanarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "258-273",
          "snippet": "static char *scanarg(char *s, char del)\n{\n\tchar c;\n\n\twhile ((c = *s++) != del) {\n\t\tif (c == '\\\\' && *s == 'x') {\n\t\t\ts++;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\ts[-1] ='\\0';\n\treturn s;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *scanarg(char *s, char del)\n{\n\tchar c;\n\n\twhile ((c = *s++) != del) {\n\t\tif (c == '\\\\' && *s == 'x') {\n\t\t\ts++;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\ts[-1] ='\\0';\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_hex_dump_bytes",
          "args": [
            "KBUILD_MODNAME \": register: magic[raw]: \"",
            "DUMP_PREFIX_NONE",
            "e->magic",
            "p - e->magic"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: offset: %#x\\n\"",
            "e->offset"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "p",
            "10",
            "&e->offset"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xfs/xfs_super.c",
          "lines": "126-156",
          "snippet": "STATIC int\nsuffix_kstrtoint(const substring_t *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value;\n\tint\tret = 0;\n\n\tvalue = match_strdup(s);\n\tif (!value)\n\t\treturn -ENOMEM;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(value, base, &_res))\n\t\tret = -EINVAL;\n\tkfree(value);\n\t*res = _res << shift_left_factor;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/dax.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_reflink.h\"",
            "#include \"xfs_bmap_item.h\"",
            "#include \"xfs_refcount_item.h\"",
            "#include \"xfs_rmap_item.h\"",
            "#include \"xfs_ondisk.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/dax.h>\n#include <linux/namei.h>\n#include \"xfs_reflink.h\"\n#include \"xfs_bmap_item.h\"\n#include \"xfs_refcount_item.h\"\n#include \"xfs_rmap_item.h\"\n#include \"xfs_ondisk.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC int\nsuffix_kstrtoint(const substring_t *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value;\n\tint\tret = 0;\n\n\tvalue = match_strdup(s);\n\tif (!value)\n\t\treturn -ENOMEM;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(value, base, &_res))\n\t\tret = -EINVAL;\n\tkfree(value);\n\t*res = _res << shift_left_factor;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "del"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "Magic",
            "&e->flags"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: type: M (magic)\\n\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: type: E (extension)\\n\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: name: {%s}\\n\"",
            "e->name"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "e->name",
            "'/'"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "e->name",
            "\"..\""
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "27-35",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "del"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf + count",
            "del",
            "8"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: delim: %#x {%c}\\n\"",
            "del",
            "del"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "buffer",
            "count"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "e",
            "0",
            "sizeof(Node)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: received %zu bytes\\n\"",
            "count"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MAX_REGISTER_LENGTH 1920\n\nstatic Node *create_entry(const char __user *buffer, size_t count)\n{\n\tNode *e;\n\tint memsize, err;\n\tchar *buf, *p;\n\tchar del;\n\n\tpr_debug(\"register: received %zu bytes\\n\", count);\n\n\t/* some sanity checks */\n\terr = -EINVAL;\n\tif ((count < 11) || (count > MAX_REGISTER_LENGTH))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmemsize = sizeof(Node) + count + 8;\n\te = kmalloc(memsize, GFP_KERNEL);\n\tif (!e)\n\t\tgoto out;\n\n\tp = buf = (char *)e + sizeof(Node);\n\n\tmemset(e, 0, sizeof(Node));\n\tif (copy_from_user(buf, buffer, count))\n\t\tgoto efault;\n\n\tdel = *p++;\t/* delimeter */\n\n\tpr_debug(\"register: delim: %#x {%c}\\n\", del, del);\n\n\t/* Pad the buffer with the delim to simplify parsing below. */\n\tmemset(buf + count, del, 8);\n\n\t/* Parse the 'name' field. */\n\te->name = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->name[0] ||\n\t    !strcmp(e->name, \".\") ||\n\t    !strcmp(e->name, \"..\") ||\n\t    strchr(e->name, '/'))\n\t\tgoto einval;\n\n\tpr_debug(\"register: name: {%s}\\n\", e->name);\n\n\t/* Parse the 'type' field. */\n\tswitch (*p++) {\n\tcase 'E':\n\t\tpr_debug(\"register: type: E (extension)\\n\");\n\t\te->flags = 1 << Enabled;\n\t\tbreak;\n\tcase 'M':\n\t\tpr_debug(\"register: type: M (magic)\\n\");\n\t\te->flags = (1 << Enabled) | (1 << Magic);\n\t\tbreak;\n\tdefault:\n\t\tgoto einval;\n\t}\n\tif (*p++ != del)\n\t\tgoto einval;\n\n\tif (test_bit(Magic, &e->flags)) {\n\t\t/* Handle the 'M' (magic) format. */\n\t\tchar *s;\n\n\t\t/* Parse the 'offset' field. */\n\t\ts = strchr(p, del);\n\t\tif (!s)\n\t\t\tgoto einval;\n\t\t*s = '\\0';\n\t\tif (p != s) {\n\t\t\tint r = kstrtoint(p, 10, &e->offset);\n\t\t\tif (r != 0 || e->offset < 0)\n\t\t\t\tgoto einval;\n\t\t}\n\t\tp = s;\n\t\tif (*p++)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: offset: %#x\\n\", e->offset);\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->magic[0])\n\t\t\tgoto einval;\n\t\tif (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, p - e->magic);\n\n\t\t/* Parse the 'mask' field. */\n\t\te->mask = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->mask[0]) {\n\t\t\te->mask = NULL;\n\t\t\tpr_debug(\"register:  mask[raw]: none\\n\");\n\t\t} else if (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register:  mask[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->mask, p - e->mask);\n\n\t\t/*\n\t\t * Decode the magic & mask fields.\n\t\t * Note: while we might have accepted embedded NUL bytes from\n\t\t * above, the unescape helpers here will stop at the first one\n\t\t * it encounters.\n\t\t */\n\t\te->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\n\t\tif (e->mask &&\n\t\t    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\n\t\t\tgoto einval;\n\t\tif (e->size > BINPRM_BUF_SIZE ||\n\t\t    BINPRM_BUF_SIZE - e->size < e->offset)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: magic/mask length: %i\\n\", e->size);\n\t\tif (USE_DEBUG) {\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[decoded]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, e->size);\n\n\t\t\tif (e->mask) {\n\t\t\t\tint i;\n\t\t\t\tchar *masked = kmalloc(e->size, GFP_KERNEL);\n\n\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\tKBUILD_MODNAME \": register:  mask[decoded]: \",\n\t\t\t\t\tDUMP_PREFIX_NONE, e->mask, e->size);\n\n\t\t\t\tif (masked) {\n\t\t\t\t\tfor (i = 0; i < e->size; ++i)\n\t\t\t\t\t\tmasked[i] = e->magic[i] & e->mask[i];\n\t\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\t\tKBUILD_MODNAME \": register:  magic[masked]: \",\n\t\t\t\t\t\tDUMP_PREFIX_NONE, masked, e->size);\n\n\t\t\t\t\tkfree(masked);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Handle the 'E' (extension) format. */\n\n\t\t/* Skip the 'offset' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t\tif (!e->magic[0] || strchr(e->magic, '/'))\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: extension: {%s}\\n\", e->magic);\n\n\t\t/* Skip the 'mask' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t}\n\n\t/* Parse the 'interpreter' field. */\n\te->interpreter = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->interpreter[0])\n\t\tgoto einval;\n\tpr_debug(\"register: interpreter: {%s}\\n\", e->interpreter);\n\n\t/* Parse the 'flags' field. */\n\tp = check_special_flags(p, e);\n\tif (*p == '\\n')\n\t\tp++;\n\tif (p != buf + count)\n\t\tgoto einval;\n\n\treturn e;\n\nout:\n\treturn ERR_PTR(err);\n\nefault:\n\tkfree(e);\n\treturn ERR_PTR(-EFAULT);\neinval:\n\tkfree(e);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "check_special_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "275-312",
    "snippet": "static char *check_special_flags(char *sfs, Node *e)\n{\n\tchar *p = sfs;\n\tint cont = 1;\n\n\t/* special flags */\n\twhile (cont) {\n\t\tswitch (*p) {\n\t\tcase 'P':\n\t\t\tpr_debug(\"register: flag: P (preserve argv0)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_PRESERVE_ARGV0;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tpr_debug(\"register: flag: O (open binary)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_BINARY;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tpr_debug(\"register: flag: C (preserve creds)\\n\");\n\t\t\tp++;\n\t\t\t/* this flags also implies the\n\t\t\t   open-binary flag */\n\t\t\te->flags |= (MISC_FMT_CREDENTIALS |\n\t\t\t\t\tMISC_FMT_OPEN_BINARY);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tpr_debug(\"register: flag: F: open interpreter file now\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_FILE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcont = 0;\n\t\t}\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MISC_FMT_OPEN_FILE (1 << 28)",
      "#define MISC_FMT_CREDENTIALS (1 << 29)",
      "#define MISC_FMT_OPEN_BINARY (1 << 30)",
      "#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: flag: F: open interpreter file now\\n\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: flag: C (preserve creds)\\n\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: flag: O (open binary)\\n\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"register: flag: P (preserve argv0)\\n\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MISC_FMT_OPEN_FILE (1 << 28)\n#define MISC_FMT_CREDENTIALS (1 << 29)\n#define MISC_FMT_OPEN_BINARY (1 << 30)\n#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)\n\nstatic char *check_special_flags(char *sfs, Node *e)\n{\n\tchar *p = sfs;\n\tint cont = 1;\n\n\t/* special flags */\n\twhile (cont) {\n\t\tswitch (*p) {\n\t\tcase 'P':\n\t\t\tpr_debug(\"register: flag: P (preserve argv0)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_PRESERVE_ARGV0;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tpr_debug(\"register: flag: O (open binary)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_BINARY;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tpr_debug(\"register: flag: C (preserve creds)\\n\");\n\t\t\tp++;\n\t\t\t/* this flags also implies the\n\t\t\t   open-binary flag */\n\t\t\te->flags |= (MISC_FMT_CREDENTIALS |\n\t\t\t\t\tMISC_FMT_OPEN_BINARY);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tpr_debug(\"register: flag: F: open interpreter file now\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_FILE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcont = 0;\n\t\t}\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "scanarg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "258-273",
    "snippet": "static char *scanarg(char *s, char del)\n{\n\tchar c;\n\n\twhile ((c = *s++) != del) {\n\t\tif (c == '\\\\' && *s == 'x') {\n\t\t\ts++;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\ts[-1] ='\\0';\n\treturn s;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "*s++"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "*s++"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *scanarg(char *s, char del)\n{\n\tchar c;\n\n\twhile ((c = *s++) != del) {\n\t\tif (c == '\\\\' && *s == 'x') {\n\t\t\ts++;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\ts[-1] ='\\0';\n\treturn s;\n}"
  },
  {
    "function_name": "load_misc_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "130-248",
    "snippet": "static int load_misc_binary(struct linux_binprm *bprm)\n{\n\tNode *fmt;\n\tstruct file *interp_file = NULL;\n\tint retval;\n\tint fd_binary = -1;\n\n\tretval = -ENOEXEC;\n\tif (!enabled)\n\t\treturn retval;\n\n\t/* to keep locking time low, we copy the interpreter string */\n\tread_lock(&entries_lock);\n\tfmt = check_file(bprm);\n\tif (fmt)\n\t\tdget(fmt->dentry);\n\tread_unlock(&entries_lock);\n\tif (!fmt)\n\t\treturn retval;\n\n\t/* Need to be able to load the file after exec */\n\tretval = -ENOENT;\n\tif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\n\t\tgoto ret;\n\n\tif (!(fmt->flags & MISC_FMT_PRESERVE_ARGV0)) {\n\t\tretval = remove_arg_zero(bprm);\n\t\tif (retval)\n\t\t\tgoto ret;\n\t}\n\n\tif (fmt->flags & MISC_FMT_OPEN_BINARY) {\n\n\t\t/* if the binary should be opened on behalf of the\n\t\t * interpreter than keep it open and assign descriptor\n\t\t * to it\n\t\t */\n\t\tfd_binary = get_unused_fd_flags(0);\n\t\tif (fd_binary < 0) {\n\t\t\tretval = fd_binary;\n\t\t\tgoto ret;\n\t\t}\n\t\tfd_install(fd_binary, bprm->file);\n\n\t\t/* if the binary is not readable than enforce mm->dumpable=0\n\t\t   regardless of the interpreter's permissions */\n\t\twould_dump(bprm, bprm->file);\n\n\t\tallow_write_access(bprm->file);\n\t\tbprm->file = NULL;\n\n\t\t/* mark the bprm that fd should be passed to interp */\n\t\tbprm->interp_flags |= BINPRM_FLAGS_EXECFD;\n\t\tbprm->interp_data = fd_binary;\n\n\t} else {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t\tbprm->file = NULL;\n\t}\n\t/* make argv[1] be the path to the binary */\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\tbprm->argc++;\n\n\t/* add the interp as argv[0] */\n\tretval = copy_strings_kernel(1, &fmt->interpreter, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\tbprm->argc++;\n\n\t/* Update interp in case binfmt_script needs it. */\n\tretval = bprm_change_interp(fmt->interpreter, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tif (fmt->flags & MISC_FMT_OPEN_FILE) {\n\t\tinterp_file = file_clone_open(fmt->interp_file);\n\t\tif (!IS_ERR(interp_file))\n\t\t\tdeny_write_access(interp_file);\n\t} else {\n\t\tinterp_file = open_exec(fmt->interpreter);\n\t}\n\tretval = PTR_ERR(interp_file);\n\tif (IS_ERR(interp_file))\n\t\tgoto error;\n\n\tbprm->file = interp_file;\n\tif (fmt->flags & MISC_FMT_CREDENTIALS) {\n\t\tloff_t pos = 0;\n\n\t\t/*\n\t\t * No need to call prepare_binprm(), it's already been\n\t\t * done.  bprm->buf is stale, update from interp_file.\n\t\t */\n\t\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\t\tretval = kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE,\n\t\t\t\t&pos);\n\t} else\n\t\tretval = prepare_binprm(bprm);\n\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = search_binary_handler(bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\nret:\n\tdput(fmt->dentry);\n\treturn retval;\nerror:\n\tif (fd_binary > 0)\n\t\tksys_close(fd_binary);\n\tbprm->interp_flags = 0;\n\tbprm->interp_data = 0;\n\tgoto ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MISC_FMT_OPEN_FILE (1 << 28)",
      "#define MISC_FMT_CREDENTIALS (1 << 29)",
      "#define MISC_FMT_OPEN_BINARY (1 << 30)",
      "#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)"
    ],
    "globals_used": [
      "static int enabled = 1;",
      "static DEFINE_RWLOCK(entries_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ksys_close",
          "args": [
            "fd_binary"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "fmt->dentry"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_binary_handler",
          "args": [
            "bprm"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "search_binary_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1632-1682",
          "snippet": "int search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(formats);",
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nint search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_binprm",
          "args": [
            "bprm"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_binprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1568-1583",
          "snippet": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\tloff_t pos = 0;\n\n\tbprm_fill_uid(bprm);\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->called_set_creds = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\tloff_t pos = 0;\n\n\tbprm_fill_uid(bprm);\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->called_set_creds = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "bprm->file",
            "bprm->buf",
            "BINPRM_BUF_SIZE",
            "&pos"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bprm->buf",
            "0",
            "BINPRM_BUF_SIZE"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "interp_file"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "interp_file"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_exec",
          "args": [
            "fmt->interpreter"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "open_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "880-890",
          "snippet": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deny_write_access",
          "args": [
            "interp_file"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "interp_file"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_clone_open",
          "args": [
            "fmt->interp_file"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bprm_change_interp",
          "args": [
            "fmt->interpreter",
            "bprm"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "bprm_change_interp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1433-1442",
          "snippet": "int bprm_change_interp(const char *interp, struct linux_binprm *bprm)\n{\n\t/* If a binfmt changed the interp, free it first. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint bprm_change_interp(const char *interp, struct linux_binprm *bprm)\n{\n\t/* If a binfmt changed the interp, free it first. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_strings_kernel",
          "args": [
            "1",
            "&fmt->interpreter",
            "bprm"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "copy_strings_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "592-606",
          "snippet": "int copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "bprm->file"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "bprm->file"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "bprm->file"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "would_dump",
          "args": [
            "bprm",
            "bprm->file"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "would_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1309-1327",
          "snippet": "void would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd_binary",
            "bprm->file"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "0"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "542-545",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_arg_zero",
          "args": [
            "bprm"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "remove_arg_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1592-1625",
          "snippet": "int remove_arg_zero(struct linux_binprm *bprm)\n{\n\tint ret = 0;\n\tunsigned long offset;\n\tchar *kaddr;\n\tstruct page *page;\n\n\tif (!bprm->argc)\n\t\treturn 0;\n\n\tdo {\n\t\toffset = bprm->p & ~PAGE_MASK;\n\t\tpage = get_arg_page(bprm, bprm->p, 0);\n\t\tif (!page) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\n\t\tfor (; offset < PAGE_SIZE && kaddr[offset];\n\t\t\t\toffset++, bprm->p++)\n\t\t\t;\n\n\t\tkunmap_atomic(kaddr);\n\t\tput_arg_page(page);\n\t} while (offset == PAGE_SIZE);\n\n\tbprm->p++;\n\tbprm->argc--;\n\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint remove_arg_zero(struct linux_binprm *bprm)\n{\n\tint ret = 0;\n\tunsigned long offset;\n\tchar *kaddr;\n\tstruct page *page;\n\n\tif (!bprm->argc)\n\t\treturn 0;\n\n\tdo {\n\t\toffset = bprm->p & ~PAGE_MASK;\n\t\tpage = get_arg_page(bprm, bprm->p, 0);\n\t\tif (!page) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\n\t\tfor (; offset < PAGE_SIZE && kaddr[offset];\n\t\t\t\toffset++, bprm->p++)\n\t\t\t;\n\n\t\tkunmap_atomic(kaddr);\n\t\tput_arg_page(page);\n\t} while (offset == PAGE_SIZE);\n\n\tbprm->p++;\n\tbprm->argc--;\n\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&entries_lock"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/locking.c",
          "lines": "204-222",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\t/* atomic_dec_and_test implies a barrier */\n\tif (atomic_dec_and_test(&eb->blocking_readers))\n\t\tcond_wake_up_nomb(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\t/* atomic_dec_and_test implies a barrier */\n\tif (atomic_dec_and_test(&eb->blocking_readers))\n\t\tcond_wake_up_nomb(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "fmt->dentry"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_file",
          "args": [
            "bprm"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "check_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
          "lines": "88-125",
          "snippet": "static Node *check_file(struct linux_binprm *bprm)\n{\n\tchar *p = strrchr(bprm->interp, '.');\n\tstruct list_head *l;\n\n\t/* Walk all the registered handlers. */\n\tlist_for_each(l, &entries) {\n\t\tNode *e = list_entry(l, Node, list);\n\t\tchar *s;\n\t\tint j;\n\n\t\t/* Make sure this one is currently enabled. */\n\t\tif (!test_bit(Enabled, &e->flags))\n\t\t\tcontinue;\n\n\t\t/* Do matching based on extension if applicable. */\n\t\tif (!test_bit(Magic, &e->flags)) {\n\t\t\tif (p && !strcmp(e->magic, p + 1))\n\t\t\t\treturn e;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do matching based on magic & mask. */\n\t\ts = bprm->buf + e->offset;\n\t\tif (e->mask) {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]) & e->mask[j])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (j == e->size)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(entries);",
            "static int enabled = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(entries);\nstatic int enabled = 1;\n\nstatic Node *check_file(struct linux_binprm *bprm)\n{\n\tchar *p = strrchr(bprm->interp, '.');\n\tstruct list_head *l;\n\n\t/* Walk all the registered handlers. */\n\tlist_for_each(l, &entries) {\n\t\tNode *e = list_entry(l, Node, list);\n\t\tchar *s;\n\t\tint j;\n\n\t\t/* Make sure this one is currently enabled. */\n\t\tif (!test_bit(Enabled, &e->flags))\n\t\t\tcontinue;\n\n\t\t/* Do matching based on extension if applicable. */\n\t\tif (!test_bit(Magic, &e->flags)) {\n\t\t\tif (p && !strcmp(e->magic, p + 1))\n\t\t\t\treturn e;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do matching based on magic & mask. */\n\t\ts = bprm->buf + e->offset;\n\t\tif (e->mask) {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]) & e->mask[j])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (j == e->size)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&entries_lock"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/inode.c",
          "lines": "549-1195",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MISC_FMT_OPEN_FILE (1 << 28)\n#define MISC_FMT_CREDENTIALS (1 << 29)\n#define MISC_FMT_OPEN_BINARY (1 << 30)\n#define MISC_FMT_PRESERVE_ARGV0 (1 << 31)\n\nstatic int enabled = 1;\nstatic DEFINE_RWLOCK(entries_lock);\n\nstatic int load_misc_binary(struct linux_binprm *bprm)\n{\n\tNode *fmt;\n\tstruct file *interp_file = NULL;\n\tint retval;\n\tint fd_binary = -1;\n\n\tretval = -ENOEXEC;\n\tif (!enabled)\n\t\treturn retval;\n\n\t/* to keep locking time low, we copy the interpreter string */\n\tread_lock(&entries_lock);\n\tfmt = check_file(bprm);\n\tif (fmt)\n\t\tdget(fmt->dentry);\n\tread_unlock(&entries_lock);\n\tif (!fmt)\n\t\treturn retval;\n\n\t/* Need to be able to load the file after exec */\n\tretval = -ENOENT;\n\tif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\n\t\tgoto ret;\n\n\tif (!(fmt->flags & MISC_FMT_PRESERVE_ARGV0)) {\n\t\tretval = remove_arg_zero(bprm);\n\t\tif (retval)\n\t\t\tgoto ret;\n\t}\n\n\tif (fmt->flags & MISC_FMT_OPEN_BINARY) {\n\n\t\t/* if the binary should be opened on behalf of the\n\t\t * interpreter than keep it open and assign descriptor\n\t\t * to it\n\t\t */\n\t\tfd_binary = get_unused_fd_flags(0);\n\t\tif (fd_binary < 0) {\n\t\t\tretval = fd_binary;\n\t\t\tgoto ret;\n\t\t}\n\t\tfd_install(fd_binary, bprm->file);\n\n\t\t/* if the binary is not readable than enforce mm->dumpable=0\n\t\t   regardless of the interpreter's permissions */\n\t\twould_dump(bprm, bprm->file);\n\n\t\tallow_write_access(bprm->file);\n\t\tbprm->file = NULL;\n\n\t\t/* mark the bprm that fd should be passed to interp */\n\t\tbprm->interp_flags |= BINPRM_FLAGS_EXECFD;\n\t\tbprm->interp_data = fd_binary;\n\n\t} else {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t\tbprm->file = NULL;\n\t}\n\t/* make argv[1] be the path to the binary */\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\tbprm->argc++;\n\n\t/* add the interp as argv[0] */\n\tretval = copy_strings_kernel(1, &fmt->interpreter, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\tbprm->argc++;\n\n\t/* Update interp in case binfmt_script needs it. */\n\tretval = bprm_change_interp(fmt->interpreter, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tif (fmt->flags & MISC_FMT_OPEN_FILE) {\n\t\tinterp_file = file_clone_open(fmt->interp_file);\n\t\tif (!IS_ERR(interp_file))\n\t\t\tdeny_write_access(interp_file);\n\t} else {\n\t\tinterp_file = open_exec(fmt->interpreter);\n\t}\n\tretval = PTR_ERR(interp_file);\n\tif (IS_ERR(interp_file))\n\t\tgoto error;\n\n\tbprm->file = interp_file;\n\tif (fmt->flags & MISC_FMT_CREDENTIALS) {\n\t\tloff_t pos = 0;\n\n\t\t/*\n\t\t * No need to call prepare_binprm(), it's already been\n\t\t * done.  bprm->buf is stale, update from interp_file.\n\t\t */\n\t\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\t\tretval = kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE,\n\t\t\t\t&pos);\n\t} else\n\t\tretval = prepare_binprm(bprm);\n\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = search_binary_handler(bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\nret:\n\tdput(fmt->dentry);\n\treturn retval;\nerror:\n\tif (fd_binary > 0)\n\t\tksys_close(fd_binary);\n\tbprm->interp_flags = 0;\n\tbprm->interp_data = 0;\n\tgoto ret;\n}"
  },
  {
    "function_name": "check_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_misc.c",
    "lines": "88-125",
    "snippet": "static Node *check_file(struct linux_binprm *bprm)\n{\n\tchar *p = strrchr(bprm->interp, '.');\n\tstruct list_head *l;\n\n\t/* Walk all the registered handlers. */\n\tlist_for_each(l, &entries) {\n\t\tNode *e = list_entry(l, Node, list);\n\t\tchar *s;\n\t\tint j;\n\n\t\t/* Make sure this one is currently enabled. */\n\t\tif (!test_bit(Enabled, &e->flags))\n\t\t\tcontinue;\n\n\t\t/* Do matching based on extension if applicable. */\n\t\tif (!test_bit(Magic, &e->flags)) {\n\t\t\tif (p && !strcmp(e->magic, p + 1))\n\t\t\t\treturn e;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do matching based on magic & mask. */\n\t\ts = bprm->buf + e->offset;\n\t\tif (e->mask) {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]) & e->mask[j])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (j == e->size)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/magic.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(entries);",
      "static int enabled = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "e->magic",
            "p + 1"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "27-35",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "Magic",
            "&e->flags"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l",
            "Node",
            "list"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "l",
            "&entries"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "bprm->interp",
            "'.'"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/string_helpers.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include <linux/magic.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(entries);\nstatic int enabled = 1;\n\nstatic Node *check_file(struct linux_binprm *bprm)\n{\n\tchar *p = strrchr(bprm->interp, '.');\n\tstruct list_head *l;\n\n\t/* Walk all the registered handlers. */\n\tlist_for_each(l, &entries) {\n\t\tNode *e = list_entry(l, Node, list);\n\t\tchar *s;\n\t\tint j;\n\n\t\t/* Make sure this one is currently enabled. */\n\t\tif (!test_bit(Enabled, &e->flags))\n\t\t\tcontinue;\n\n\t\t/* Do matching based on extension if applicable. */\n\t\tif (!test_bit(Magic, &e->flags)) {\n\t\t\tif (p && !strcmp(e->magic, p + 1))\n\t\t\t\treturn e;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do matching based on magic & mask. */\n\t\ts = bprm->buf + e->offset;\n\t\tif (e->mask) {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]) & e->mask[j])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (j == e->size)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}"
  }
]