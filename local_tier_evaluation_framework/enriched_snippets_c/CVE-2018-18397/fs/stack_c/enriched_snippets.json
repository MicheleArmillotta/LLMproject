[
  {
    "function_name": "fsstack_copy_attr_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/stack.c",
    "lines": "63-75",
    "snippet": "void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}",
    "includes": [
      "#include <linux/fs_stack.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "dest",
            "src->i_nlink"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "317-328",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\n\tdest->i_mode = src->i_mode;\n\tdest->i_uid = src->i_uid;\n\tdest->i_gid = src->i_gid;\n\tdest->i_rdev = src->i_rdev;\n\tdest->i_atime = src->i_atime;\n\tdest->i_mtime = src->i_mtime;\n\tdest->i_ctime = src->i_ctime;\n\tdest->i_blkbits = src->i_blkbits;\n\tdest->i_flags = src->i_flags;\n\tset_nlink(dest, src->i_nlink);\n}"
  },
  {
    "function_name": "fsstack_copy_inode_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/stack.c",
    "lines": "10-59",
    "snippet": "void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}",
    "includes": [
      "#include <linux/fs_stack.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dst->i_lock"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dst",
            "i_size"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2436-2448",
          "snippet": "static inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dst->i_lock"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "src"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n\tloff_t i_size;\n\tblkcnt_t i_blocks;\n\n\t/*\n\t * i_size_read() includes its own seqlocking and protection from\n\t * preemption (see include/linux/fs.h): we need nothing extra for\n\t * that here, and prefer to avoid nesting locks than attempt to keep\n\t * i_size and i_blocks in sync together.\n\t */\n\ti_size = i_size_read(src);\n\n\t/*\n\t * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to\n\t * keep the two halves of i_blocks in sync despite SMP or PREEMPT -\n\t * though stat's generic_fillattr() doesn't bother, and we won't be\n\t * applying quotas (where i_blocks does become important) at the\n\t * upper level.\n\t *\n\t * We don't actually know what locking is used at the lower level;\n\t * but if it's a filesystem that supports quotas, it will be using\n\t * i_lock as in inode_add_bytes().\n\t */\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&src->i_lock);\n\ti_blocks = src->i_blocks;\n\tif (sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&src->i_lock);\n\n\t/*\n\t * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for\n\t * fsstack_copy_inode_size() to hold some lock around\n\t * i_size_write(), otherwise i_size_read() may spin forever (see\n\t * include/linux/fs.h).  We don't necessarily hold i_mutex when this\n\t * is called, so take i_lock for that case.\n\t *\n\t * And if CONFIG_LBDAF (on 32-bit), continue our effort to keep the\n\t * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock\n\t * for that case too, and do both at once by combining the tests.\n\t *\n\t * There is none of this locking overhead in the 64-bit case.\n\t */\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_lock(&dst->i_lock);\n\ti_size_write(dst, i_size);\n\tdst->i_blocks = i_blocks;\n\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n\t\tspin_unlock(&dst->i_lock);\n}"
  }
]