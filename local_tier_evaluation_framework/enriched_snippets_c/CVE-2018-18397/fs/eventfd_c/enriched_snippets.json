[
  {
    "function_name": "do_eventfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "383-410",
    "snippet": "static int do_eventfd(unsigned int count, int flags)\n{\n\tstruct eventfd_ctx *ctx;\n\tint fd;\n\n\t/* Check the EFD_* constants for consistency.  */\n\tBUILD_BUG_ON(EFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(EFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~EFD_FLAGS_SET)\n\t\treturn -EINVAL;\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tkref_init(&ctx->kref);\n\tinit_waitqueue_head(&ctx->wqh);\n\tctx->count = count;\n\tctx->flags = flags;\n\n\tfd = anon_inode_getfd(\"[eventfd]\", &eventfd_fops, ctx,\n\t\t\t      O_RDWR | (flags & EFD_SHARED_FCNTL_FLAGS));\n\tif (fd < 0)\n\t\teventfd_free_ctx(ctx);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_free_ctx",
          "args": [
            "ctx"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_free_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "70-73",
          "snippet": "static void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"[eventfd]\"",
            "&eventfd_fops",
            "ctx",
            "O_RDWR | (flags & EFD_SHARED_FCNTL_FLAGS)"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "anon_inode_getfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
          "lines": "121-144",
          "snippet": "int anon_inode_getfd(const char *name, const struct file_operations *fops,\n\t\t     void *priv, int flags)\n{\n\tint error, fd;\n\tstruct file *file;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\treturn error;\n\tfd = error;\n\n\tfile = anon_inode_getfile(name, fops, priv, flags);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\tfd_install(fd, file);\n\n\treturn fd;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nint anon_inode_getfd(const char *name, const struct file_operations *fops,\n\t\t     void *priv, int flags)\n{\n\tint error, fd;\n\tstruct file *file;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\treturn error;\n\tfd = error;\n\n\tfile = anon_inode_getfile(name, fops, priv, flags);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\tfd_install(fd, file);\n\n\treturn fd;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ctx->wqh"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&ctx->kref"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ctx)",
            "GFP_KERNEL"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "EFD_NONBLOCK != O_NONBLOCK"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "EFD_CLOEXEC != O_CLOEXEC"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int do_eventfd(unsigned int count, int flags)\n{\n\tstruct eventfd_ctx *ctx;\n\tint fd;\n\n\t/* Check the EFD_* constants for consistency.  */\n\tBUILD_BUG_ON(EFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(EFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~EFD_FLAGS_SET)\n\t\treturn -EINVAL;\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tkref_init(&ctx->kref);\n\tinit_waitqueue_head(&ctx->wqh);\n\tctx->count = count;\n\tctx->flags = flags;\n\n\tfd = anon_inode_getfd(\"[eventfd]\", &eventfd_fops, ctx,\n\t\t\t      O_RDWR | (flags & EFD_SHARED_FCNTL_FLAGS));\n\tif (fd < 0)\n\t\teventfd_free_ctx(ctx);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "eventfd_ctx_fileget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "370-380",
    "snippet": "struct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\n{\n\tstruct eventfd_ctx *ctx;\n\n\tif (file->f_op != &eventfd_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx = file->private_data;\n\tkref_get(&ctx->kref);\n\treturn ctx;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&ctx->kref"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};\n\nstruct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\n{\n\tstruct eventfd_ctx *ctx;\n\n\tif (file->f_op != &eventfd_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx = file->private_data;\n\tkref_get(&ctx->kref);\n\treturn ctx;\n}"
  },
  {
    "function_name": "eventfd_ctx_fdget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "349-358",
    "snippet": "struct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_fileget",
          "args": [
            "f.file"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_fileget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "370-380",
          "snippet": "struct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\n{\n\tstruct eventfd_ctx *ctx;\n\n\tif (file->f_op != &eventfd_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx = file->private_data;\n\tkref_get(&ctx->kref);\n\treturn ctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};\n\nstruct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\n{\n\tstruct eventfd_ctx *ctx;\n\n\tif (file->f_op != &eventfd_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx = file->private_data;\n\tkref_get(&ctx->kref);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_fdget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "349-358",
          "snippet": "struct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstruct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}"
  },
  {
    "function_name": "eventfd_fget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "324-337",
    "snippet": "struct file *eventfd_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (file->f_op != &eventfd_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn file;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "fd"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_fget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "324-337",
          "snippet": "struct file *eventfd_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (file->f_op != &eventfd_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn file;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations eventfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= eventfd_show_fdinfo,\n#endif\n\t.release\t= eventfd_release,\n\t.poll\t\t= eventfd_poll,\n\t.read\t\t= eventfd_read,\n\t.write\t\t= eventfd_write,\n\t.llseek\t\t= noop_llseek,\n};\n\nstruct file *eventfd_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (file->f_op != &eventfd_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn file;\n}"
  },
  {
    "function_name": "eventfd_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "292-300",
    "snippet": "static void eventfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct eventfd_ctx *ctx = f->private_data;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tseq_printf(m, \"eventfd-count: %16llx\\n\",\n\t\t   (unsigned long long)ctx->count);\n\tspin_unlock_irq(&ctx->wqh.lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"eventfd-count: %16llx\\n\"",
            "(unsigned long long)ctx->count"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "401-408",
          "snippet": "void seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct eventfd_ctx *ctx = f->private_data;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tseq_printf(m, \"eventfd-count: %16llx\\n\",\n\t\t   (unsigned long long)ctx->count);\n\tspin_unlock_irq(&ctx->wqh.lock);\n}"
  },
  {
    "function_name": "eventfd_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "244-289",
    "snippet": "static ssize_t eventfd_write(struct file *file, const char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\t__u64 ucnt;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tif (count < sizeof(ucnt))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&ucnt, buf, sizeof(ucnt)))\n\t\treturn -EFAULT;\n\tif (ucnt == ULLONG_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctx->wqh.lock);\n\tres = -EAGAIN;\n\tif (ULLONG_MAX - ctx->count > ucnt)\n\t\tres = sizeof(ucnt);\n\telse if (!(file->f_flags & O_NONBLOCK)) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (res = 0;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ULLONG_MAX - ctx->count > ucnt) {\n\t\t\t\tres = sizeof(ucnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res > 0)) {\n\t\tctx->count += ucnt;\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "&ctx->wqh",
            "EPOLLIN"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wqh"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "res > 0"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ctx->wqh",
            "&wait"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "&ctx->wqh",
            "&wait"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ucnt",
            "buf",
            "sizeof(ucnt)"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t eventfd_write(struct file *file, const char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\t__u64 ucnt;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tif (count < sizeof(ucnt))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&ucnt, buf, sizeof(ucnt)))\n\t\treturn -EFAULT;\n\tif (ucnt == ULLONG_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctx->wqh.lock);\n\tres = -EAGAIN;\n\tif (ULLONG_MAX - ctx->count > ucnt)\n\t\tres = sizeof(ucnt);\n\telse if (!(file->f_flags & O_NONBLOCK)) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (res = 0;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ULLONG_MAX - ctx->count > ucnt) {\n\t\t\t\tres = sizeof(ucnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res > 0)) {\n\t\tctx->count += ucnt;\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\treturn res;\n}"
  },
  {
    "function_name": "eventfd_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "197-242",
    "snippet": "static ssize_t eventfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\t__u64 ucnt = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tif (count < sizeof(ucnt))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tres = -EAGAIN;\n\tif (ctx->count > 0)\n\t\tres = sizeof(ucnt);\n\telse if (!(file->f_flags & O_NONBLOCK)) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ctx->count > 0) {\n\t\t\t\tres = sizeof(ucnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res > 0)) {\n\t\teventfd_ctx_do_read(ctx, &ucnt);\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, EPOLLOUT);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\tif (res > 0 && put_user(ucnt, (__u64 __user *)buf))\n\t\treturn -EFAULT;\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "ucnt",
            "(__u64 __user *)buf"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "&ctx->wqh",
            "EPOLLOUT"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wqh"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_do_read",
          "args": [
            "ctx",
            "&ucnt"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_do_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "162-166",
          "snippet": "static void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "res > 0"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ctx->wqh",
            "&wait"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "&ctx->wqh",
            "&wait"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->wqh.lock"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t eventfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\t__u64 ucnt = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tif (count < sizeof(ucnt))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tres = -EAGAIN;\n\tif (ctx->count > 0)\n\t\tres = sizeof(ucnt);\n\telse if (!(file->f_flags & O_NONBLOCK)) {\n\t\t__add_wait_queue(&ctx->wqh, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ctx->count > 0) {\n\t\t\t\tres = sizeof(ucnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\t}\n\t\t__remove_wait_queue(&ctx->wqh, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\tif (likely(res > 0)) {\n\t\teventfd_ctx_do_read(ctx, &ucnt);\n\t\tif (waitqueue_active(&ctx->wqh))\n\t\t\twake_up_locked_poll(&ctx->wqh, EPOLLOUT);\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\tif (res > 0 && put_user(ucnt, (__u64 __user *)buf))\n\t\treturn -EFAULT;\n\n\treturn res;\n}"
  },
  {
    "function_name": "eventfd_ctx_remove_wait_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "181-194",
    "snippet": "int eventfd_ctx_remove_wait_queue(struct eventfd_ctx *ctx, wait_queue_entry_t *wait,\n\t\t\t\t  __u64 *cnt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\teventfd_ctx_do_read(ctx, cnt);\n\t__remove_wait_queue(&ctx->wqh, wait);\n\tif (*cnt != 0 && waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, EPOLLOUT);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn *cnt != 0 ? 0 : -EAGAIN;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->wqh.lock",
            "flags"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "&ctx->wqh",
            "EPOLLOUT"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wqh"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ctx->wqh",
            "wait"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_do_read",
          "args": [
            "ctx",
            "cnt"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_do_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "162-166",
          "snippet": "static void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->wqh.lock",
            "flags"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nint eventfd_ctx_remove_wait_queue(struct eventfd_ctx *ctx, wait_queue_entry_t *wait,\n\t\t\t\t  __u64 *cnt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\teventfd_ctx_do_read(ctx, cnt);\n\t__remove_wait_queue(&ctx->wqh, wait);\n\tif (*cnt != 0 && waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, EPOLLOUT);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn *cnt != 0 ? 0 : -EAGAIN;\n}"
  },
  {
    "function_name": "eventfd_ctx_do_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "162-166",
    "snippet": "static void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\n{\n\t*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\n\tctx->count -= *cnt;\n}"
  },
  {
    "function_name": "eventfd_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "104-160",
    "snippet": "static __poll_t eventfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\t__poll_t events = 0;\n\tu64 count;\n\n\tpoll_wait(file, &ctx->wqh, wait);\n\n\t/*\n\t * All writes to ctx->count occur within ctx->wqh.lock.  This read\n\t * can be done outside ctx->wqh.lock because we know that poll_wait\n\t * takes that lock (through add_wait_queue) if our caller will sleep.\n\t *\n\t * The read _can_ therefore seep into add_wait_queue's critical\n\t * section, but cannot move above it!  add_wait_queue's spin_lock acts\n\t * as an acquire barrier and ensures that the read be ordered properly\n\t * against the writes.  The following CAN happen and is safe:\n\t *\n\t *     poll                               write\n\t *     -----------------                  ------------\n\t *     lock ctx->wqh.lock (in poll_wait)\n\t *     count = ctx->count\n\t *     __add_wait_queue\n\t *     unlock ctx->wqh.lock\n\t *                                        lock ctx->qwh.lock\n\t *                                        ctx->count += n\n\t *                                        if (waitqueue_active)\n\t *                                          wake_up_locked_poll\n\t *                                        unlock ctx->qwh.lock\n\t *     eventfd_poll returns 0\n\t *\n\t * but the following, which would miss a wakeup, cannot happen:\n\t *\n\t *     poll                               write\n\t *     -----------------                  ------------\n\t *     count = ctx->count (INVALID!)\n\t *                                        lock ctx->qwh.lock\n\t *                                        ctx->count += n\n\t *                                        **waitqueue_active is false**\n\t *                                        **no wake_up_locked_poll!**\n\t *                                        unlock ctx->qwh.lock\n\t *     lock ctx->wqh.lock (in poll_wait)\n\t *     __add_wait_queue\n\t *     unlock ctx->wqh.lock\n\t *     eventfd_poll returns 0\n\t */\n\tcount = READ_ONCE(ctx->count);\n\n\tif (count > 0)\n\t\tevents |= EPOLLIN;\n\tif (count == ULLONG_MAX)\n\t\tevents |= EPOLLERR;\n\tif (ULLONG_MAX - 1 > count)\n\t\tevents |= EPOLLOUT;\n\n\treturn events;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ctx->count"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&ctx->wqh",
            "wait"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic __poll_t eventfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\t__poll_t events = 0;\n\tu64 count;\n\n\tpoll_wait(file, &ctx->wqh, wait);\n\n\t/*\n\t * All writes to ctx->count occur within ctx->wqh.lock.  This read\n\t * can be done outside ctx->wqh.lock because we know that poll_wait\n\t * takes that lock (through add_wait_queue) if our caller will sleep.\n\t *\n\t * The read _can_ therefore seep into add_wait_queue's critical\n\t * section, but cannot move above it!  add_wait_queue's spin_lock acts\n\t * as an acquire barrier and ensures that the read be ordered properly\n\t * against the writes.  The following CAN happen and is safe:\n\t *\n\t *     poll                               write\n\t *     -----------------                  ------------\n\t *     lock ctx->wqh.lock (in poll_wait)\n\t *     count = ctx->count\n\t *     __add_wait_queue\n\t *     unlock ctx->wqh.lock\n\t *                                        lock ctx->qwh.lock\n\t *                                        ctx->count += n\n\t *                                        if (waitqueue_active)\n\t *                                          wake_up_locked_poll\n\t *                                        unlock ctx->qwh.lock\n\t *     eventfd_poll returns 0\n\t *\n\t * but the following, which would miss a wakeup, cannot happen:\n\t *\n\t *     poll                               write\n\t *     -----------------                  ------------\n\t *     count = ctx->count (INVALID!)\n\t *                                        lock ctx->qwh.lock\n\t *                                        ctx->count += n\n\t *                                        **waitqueue_active is false**\n\t *                                        **no wake_up_locked_poll!**\n\t *                                        unlock ctx->qwh.lock\n\t *     lock ctx->wqh.lock (in poll_wait)\n\t *     __add_wait_queue\n\t *     unlock ctx->wqh.lock\n\t *     eventfd_poll returns 0\n\t */\n\tcount = READ_ONCE(ctx->count);\n\n\tif (count > 0)\n\t\tevents |= EPOLLIN;\n\tif (count == ULLONG_MAX)\n\t\tevents |= EPOLLERR;\n\tif (ULLONG_MAX - 1 > count)\n\t\tevents |= EPOLLOUT;\n\n\treturn events;\n}"
  },
  {
    "function_name": "eventfd_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "95-102",
    "snippet": "static int eventfd_release(struct inode *inode, struct file *file)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\n\twake_up_poll(&ctx->wqh, EPOLLHUP);\n\teventfd_ctx_put(ctx);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "ctx"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "89-92",
          "snippet": "void eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nvoid eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "&ctx->wqh",
            "EPOLLHUP"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int eventfd_release(struct inode *inode, struct file *file)\n{\n\tstruct eventfd_ctx *ctx = file->private_data;\n\n\twake_up_poll(&ctx->wqh, EPOLLHUP);\n\teventfd_ctx_put(ctx);\n\treturn 0;\n}"
  },
  {
    "function_name": "eventfd_ctx_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "89-92",
    "snippet": "void eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&ctx->kref",
            "eventfd_free"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nvoid eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}"
  },
  {
    "function_name": "eventfd_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "75-80",
    "snippet": "static void eventfd_free(struct kref *kref)\n{\n\tstruct eventfd_ctx *ctx = container_of(kref, struct eventfd_ctx, kref);\n\n\teventfd_free_ctx(ctx);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_free_ctx",
          "args": [
            "ctx"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_free_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "70-73",
          "snippet": "static void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structeventfd_ctx",
            "kref"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_free(struct kref *kref)\n{\n\tstruct eventfd_ctx *ctx = container_of(kref, struct eventfd_ctx, kref);\n\n\teventfd_free_ctx(ctx);\n}"
  },
  {
    "function_name": "eventfd_free_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "70-73",
    "snippet": "static void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void eventfd_free_ctx(struct eventfd_ctx *ctx)\n{\n\tkfree(ctx);\n}"
  },
  {
    "function_name": "eventfd_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "54-67",
    "snippet": "__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ULLONG_MAX - ctx->count < n)\n\t\tn = ULLONG_MAX - ctx->count;\n\tctx->count += n;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn n;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->wqh.lock",
            "flags"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "&ctx->wqh",
            "EPOLLIN"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wqh"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->wqh.lock",
            "flags"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\n__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ULLONG_MAX - ctx->count < n)\n\t\tn = ULLONG_MAX - ctx->count;\n\tctx->count += n;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn n;\n}"
  },
  {
    "function_name": "eventfd2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "412-415",
    "snippet": "SYSCALL_DEFINE2(eventfd2, unsigned int, count, int, flags)\n{\n\treturn do_eventfd(count, flags);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE2(eventfd2, unsigned int, count, int, flags)\n{\n\treturn do_eventfd(count, flags);\n}"
  },
  {
    "function_name": "eventfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
    "lines": "417-420",
    "snippet": "SYSCALL_DEFINE1(eventfd, unsigned int, count)\n{\n\treturn do_eventfd(count, 0);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/kref.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE1(eventfd, unsigned int, count)\n{\n\treturn do_eventfd(count, 0);\n}"
  }
]