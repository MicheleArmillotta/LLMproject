[
  {
    "function_name": "mpage_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "742-758",
    "snippet": "int mpage_writepage(struct page *page, get_block_t get_block,\n\tstruct writeback_control *wbc)\n{\n\tstruct mpage_data mpd = {\n\t\t.bio = NULL,\n\t\t.last_block_in_bio = 0,\n\t\t.get_block = get_block,\n\t\t.use_writepage = 0,\n\t};\n\tint ret = __mpage_writepage(page, wbc, &mpd);\n\tif (mpd.bio) {\n\t\tint op_flags = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\t  REQ_SYNC : 0);\n\t\tmpage_bio_submit(REQ_OP_WRITE, op_flags, mpd.bio);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "REQ_OP_WRITE",
            "op_flags",
            "mpd.bio"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "61-68",
          "snippet": "static struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mpage_writepage",
          "args": [
            "page",
            "wbc",
            "&mpd"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "__mpage_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "496-690",
          "snippet": "static int __mpage_writepage(struct page *page, struct writeback_control *wbc,\n\t\t      void *data)\n{\n\tstruct mpage_data *mpd = data;\n\tstruct bio *bio = mpd->bio;\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tunsigned long end_index;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tsector_t last_block;\n\tsector_t block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_unmapped = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint boundary = 0;\n\tsector_t boundary_block = 0;\n\tstruct block_device *boundary_bdev = NULL;\n\tint length;\n\tstruct buffer_head map_bh;\n\tloff_t i_size = i_size_read(inode);\n\tint ret = 0;\n\tint op_flags = wbc_to_write_flags(wbc);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\t/* If they're all mapped and dirty, do it */\n\t\tpage_block = 0;\n\t\tdo {\n\t\t\tBUG_ON(buffer_locked(bh));\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t/*\n\t\t\t\t * unmapped dirty buffers are created by\n\t\t\t\t * __set_page_dirty_buffers -> mmapped data\n\t\t\t\t */\n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tgoto confused;\n\t\t\t\tif (first_unmapped == blocks_per_page)\n\t\t\t\t\tfirst_unmapped = page_block;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_unmapped != blocks_per_page)\n\t\t\t\tgoto confused;\t/* hole -> non-hole */\n\n\t\t\tif (!buffer_dirty(bh) || !buffer_uptodate(bh))\n\t\t\t\tgoto confused;\n\t\t\tif (page_block) {\n\t\t\t\tif (bh->b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\t\tgoto confused;\n\t\t\t}\n\t\t\tblocks[page_block++] = bh->b_blocknr;\n\t\t\tboundary = buffer_boundary(bh);\n\t\t\tif (boundary) {\n\t\t\t\tboundary_block = bh->b_blocknr;\n\t\t\t\tboundary_bdev = bh->b_bdev;\n\t\t\t}\n\t\t\tbdev = bh->b_bdev;\n\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\tif (first_unmapped)\n\t\t\tgoto page_is_mapped;\n\n\t\t/*\n\t\t * Page has buffers, but they are all unmapped. The page was\n\t\t * created by pagein or read over a hole which was handled by\n\t\t * block_read_full_page().  If this address_space is also\n\t\t * using mpage_readpages then this can rarely happen.\n\t\t */\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * The page has no buffers: map it to disk\n\t */\n\tBUG_ON(!PageUptodate(page));\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = (i_size - 1) >> blkbits;\n\tmap_bh.b_page = page;\n\tfor (page_block = 0; page_block < blocks_per_page; ) {\n\n\t\tmap_bh.b_state = 0;\n\t\tmap_bh.b_size = 1 << blkbits;\n\t\tif (mpd->get_block(inode, block_in_file, &map_bh, 1))\n\t\t\tgoto confused;\n\t\tif (buffer_new(&map_bh))\n\t\t\tclean_bdev_bh_alias(&map_bh);\n\t\tif (buffer_boundary(&map_bh)) {\n\t\t\tboundary_block = map_bh.b_blocknr;\n\t\t\tboundary_bdev = map_bh.b_bdev;\n\t\t}\n\t\tif (page_block) {\n\t\t\tif (map_bh.b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\tgoto confused;\n\t\t}\n\t\tblocks[page_block++] = map_bh.b_blocknr;\n\t\tboundary = buffer_boundary(&map_bh);\n\t\tbdev = map_bh.b_bdev;\n\t\tif (block_in_file == last_block)\n\t\t\tbreak;\n\t\tblock_in_file++;\n\t}\n\tBUG_ON(page_block == 0);\n\n\tfirst_unmapped = page_block;\n\npage_is_mapped:\n\tend_index = i_size >> PAGE_SHIFT;\n\tif (page->index >= end_index) {\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining memory\n\t\t * is zeroed when mapped, and writes to that region are not\n\t\t * written out to the file.\"\n\t\t */\n\t\tunsigned offset = i_size & (PAGE_SIZE - 1);\n\n\t\tif (page->index > end_index || !offset)\n\t\t\tgoto confused;\n\t\tzero_user_segment(page, offset, PAGE_SIZE);\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && mpd->last_block_in_bio != blocks[0] - 1)\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_unmapped == blocks_per_page) {\n\t\t\tif (!bdev_write_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage, wbc))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\tBIO_MAX_PAGES, GFP_NOFS|__GFP_HIGH);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\n\t\twbc_init_bio(wbc, bio);\n\t\tbio->bi_write_hint = inode->i_write_hint;\n\t}\n\n\t/*\n\t * Must try to add the page before marking the buffer clean or\n\t * the confused fail path above (OOM) will be very confused when\n\t * it finds all bh marked clean (i.e. it will not write anything)\n\t */\n\twbc_account_io(wbc, page, PAGE_SIZE);\n\tlength = first_unmapped << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\t\tgoto alloc_new;\n\t}\n\n\tclean_buffers(page, first_unmapped);\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tif (boundary || (first_unmapped != blocks_per_page)) {\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\t\tif (boundary_block) {\n\t\t\twrite_boundary_block(boundary_bdev,\n\t\t\t\t\tboundary_block, 1 << blkbits);\n\t\t}\n\t} else {\n\t\tmpd->last_block_in_bio = blocks[blocks_per_page - 1];\n\t}\n\tgoto out;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\n\tif (mpd->use_writepage) {\n\t\tret = mapping->a_ops->writepage(page, wbc);\n\t} else {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\t/*\n\t * The caller has a ref on the inode, so *mapping is stable\n\t */\n\tmapping_set_error(mapping, ret);\nout:\n\tmpd->bio = bio;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int __mpage_writepage(struct page *page, struct writeback_control *wbc,\n\t\t      void *data)\n{\n\tstruct mpage_data *mpd = data;\n\tstruct bio *bio = mpd->bio;\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tunsigned long end_index;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tsector_t last_block;\n\tsector_t block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_unmapped = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint boundary = 0;\n\tsector_t boundary_block = 0;\n\tstruct block_device *boundary_bdev = NULL;\n\tint length;\n\tstruct buffer_head map_bh;\n\tloff_t i_size = i_size_read(inode);\n\tint ret = 0;\n\tint op_flags = wbc_to_write_flags(wbc);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\t/* If they're all mapped and dirty, do it */\n\t\tpage_block = 0;\n\t\tdo {\n\t\t\tBUG_ON(buffer_locked(bh));\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t/*\n\t\t\t\t * unmapped dirty buffers are created by\n\t\t\t\t * __set_page_dirty_buffers -> mmapped data\n\t\t\t\t */\n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tgoto confused;\n\t\t\t\tif (first_unmapped == blocks_per_page)\n\t\t\t\t\tfirst_unmapped = page_block;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_unmapped != blocks_per_page)\n\t\t\t\tgoto confused;\t/* hole -> non-hole */\n\n\t\t\tif (!buffer_dirty(bh) || !buffer_uptodate(bh))\n\t\t\t\tgoto confused;\n\t\t\tif (page_block) {\n\t\t\t\tif (bh->b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\t\tgoto confused;\n\t\t\t}\n\t\t\tblocks[page_block++] = bh->b_blocknr;\n\t\t\tboundary = buffer_boundary(bh);\n\t\t\tif (boundary) {\n\t\t\t\tboundary_block = bh->b_blocknr;\n\t\t\t\tboundary_bdev = bh->b_bdev;\n\t\t\t}\n\t\t\tbdev = bh->b_bdev;\n\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\tif (first_unmapped)\n\t\t\tgoto page_is_mapped;\n\n\t\t/*\n\t\t * Page has buffers, but they are all unmapped. The page was\n\t\t * created by pagein or read over a hole which was handled by\n\t\t * block_read_full_page().  If this address_space is also\n\t\t * using mpage_readpages then this can rarely happen.\n\t\t */\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * The page has no buffers: map it to disk\n\t */\n\tBUG_ON(!PageUptodate(page));\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = (i_size - 1) >> blkbits;\n\tmap_bh.b_page = page;\n\tfor (page_block = 0; page_block < blocks_per_page; ) {\n\n\t\tmap_bh.b_state = 0;\n\t\tmap_bh.b_size = 1 << blkbits;\n\t\tif (mpd->get_block(inode, block_in_file, &map_bh, 1))\n\t\t\tgoto confused;\n\t\tif (buffer_new(&map_bh))\n\t\t\tclean_bdev_bh_alias(&map_bh);\n\t\tif (buffer_boundary(&map_bh)) {\n\t\t\tboundary_block = map_bh.b_blocknr;\n\t\t\tboundary_bdev = map_bh.b_bdev;\n\t\t}\n\t\tif (page_block) {\n\t\t\tif (map_bh.b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\tgoto confused;\n\t\t}\n\t\tblocks[page_block++] = map_bh.b_blocknr;\n\t\tboundary = buffer_boundary(&map_bh);\n\t\tbdev = map_bh.b_bdev;\n\t\tif (block_in_file == last_block)\n\t\t\tbreak;\n\t\tblock_in_file++;\n\t}\n\tBUG_ON(page_block == 0);\n\n\tfirst_unmapped = page_block;\n\npage_is_mapped:\n\tend_index = i_size >> PAGE_SHIFT;\n\tif (page->index >= end_index) {\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining memory\n\t\t * is zeroed when mapped, and writes to that region are not\n\t\t * written out to the file.\"\n\t\t */\n\t\tunsigned offset = i_size & (PAGE_SIZE - 1);\n\n\t\tif (page->index > end_index || !offset)\n\t\t\tgoto confused;\n\t\tzero_user_segment(page, offset, PAGE_SIZE);\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && mpd->last_block_in_bio != blocks[0] - 1)\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_unmapped == blocks_per_page) {\n\t\t\tif (!bdev_write_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage, wbc))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\tBIO_MAX_PAGES, GFP_NOFS|__GFP_HIGH);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\n\t\twbc_init_bio(wbc, bio);\n\t\tbio->bi_write_hint = inode->i_write_hint;\n\t}\n\n\t/*\n\t * Must try to add the page before marking the buffer clean or\n\t * the confused fail path above (OOM) will be very confused when\n\t * it finds all bh marked clean (i.e. it will not write anything)\n\t */\n\twbc_account_io(wbc, page, PAGE_SIZE);\n\tlength = first_unmapped << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\t\tgoto alloc_new;\n\t}\n\n\tclean_buffers(page, first_unmapped);\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tif (boundary || (first_unmapped != blocks_per_page)) {\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\t\tif (boundary_block) {\n\t\t\twrite_boundary_block(boundary_bdev,\n\t\t\t\t\tboundary_block, 1 << blkbits);\n\t\t}\n\t} else {\n\t\tmpd->last_block_in_bio = blocks[blocks_per_page - 1];\n\t}\n\tgoto out;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\n\tif (mpd->use_writepage) {\n\t\tret = mapping->a_ops->writepage(page, wbc);\n\t} else {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\t/*\n\t * The caller has a ref on the inode, so *mapping is stable\n\t */\n\tmapping_set_error(mapping, ret);\nout:\n\tmpd->bio = bio;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_writepage(struct page *page, get_block_t get_block,\n\tstruct writeback_control *wbc)\n{\n\tstruct mpage_data mpd = {\n\t\t.bio = NULL,\n\t\t.last_block_in_bio = 0,\n\t\t.get_block = get_block,\n\t\t.use_writepage = 0,\n\t};\n\tint ret = __mpage_writepage(page, wbc, &mpd);\n\tif (mpd.bio) {\n\t\tint op_flags = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\t  REQ_SYNC : 0);\n\t\tmpage_bio_submit(REQ_OP_WRITE, op_flags, mpd.bio);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "mpage_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "711-739",
    "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio) {\n\t\t\tint op_flags = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\t\t  REQ_SYNC : 0);\n\t\t\tmpage_bio_submit(REQ_OP_WRITE, op_flags, mpd.bio);\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "REQ_OP_WRITE",
            "op_flags",
            "mpd.bio"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "61-68",
          "snippet": "static struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_cache_pages",
          "args": [
            "mapping",
            "wbc",
            "__mpage_writepage",
            "&mpd"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_writepages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio) {\n\t\t\tint op_flags = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\t\t  REQ_SYNC : 0);\n\t\t\tmpage_bio_submit(REQ_OP_WRITE, op_flags, mpd.bio);\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
  },
  {
    "function_name": "__mpage_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "496-690",
    "snippet": "static int __mpage_writepage(struct page *page, struct writeback_control *wbc,\n\t\t      void *data)\n{\n\tstruct mpage_data *mpd = data;\n\tstruct bio *bio = mpd->bio;\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tunsigned long end_index;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tsector_t last_block;\n\tsector_t block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_unmapped = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint boundary = 0;\n\tsector_t boundary_block = 0;\n\tstruct block_device *boundary_bdev = NULL;\n\tint length;\n\tstruct buffer_head map_bh;\n\tloff_t i_size = i_size_read(inode);\n\tint ret = 0;\n\tint op_flags = wbc_to_write_flags(wbc);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\t/* If they're all mapped and dirty, do it */\n\t\tpage_block = 0;\n\t\tdo {\n\t\t\tBUG_ON(buffer_locked(bh));\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t/*\n\t\t\t\t * unmapped dirty buffers are created by\n\t\t\t\t * __set_page_dirty_buffers -> mmapped data\n\t\t\t\t */\n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tgoto confused;\n\t\t\t\tif (first_unmapped == blocks_per_page)\n\t\t\t\t\tfirst_unmapped = page_block;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_unmapped != blocks_per_page)\n\t\t\t\tgoto confused;\t/* hole -> non-hole */\n\n\t\t\tif (!buffer_dirty(bh) || !buffer_uptodate(bh))\n\t\t\t\tgoto confused;\n\t\t\tif (page_block) {\n\t\t\t\tif (bh->b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\t\tgoto confused;\n\t\t\t}\n\t\t\tblocks[page_block++] = bh->b_blocknr;\n\t\t\tboundary = buffer_boundary(bh);\n\t\t\tif (boundary) {\n\t\t\t\tboundary_block = bh->b_blocknr;\n\t\t\t\tboundary_bdev = bh->b_bdev;\n\t\t\t}\n\t\t\tbdev = bh->b_bdev;\n\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\tif (first_unmapped)\n\t\t\tgoto page_is_mapped;\n\n\t\t/*\n\t\t * Page has buffers, but they are all unmapped. The page was\n\t\t * created by pagein or read over a hole which was handled by\n\t\t * block_read_full_page().  If this address_space is also\n\t\t * using mpage_readpages then this can rarely happen.\n\t\t */\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * The page has no buffers: map it to disk\n\t */\n\tBUG_ON(!PageUptodate(page));\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = (i_size - 1) >> blkbits;\n\tmap_bh.b_page = page;\n\tfor (page_block = 0; page_block < blocks_per_page; ) {\n\n\t\tmap_bh.b_state = 0;\n\t\tmap_bh.b_size = 1 << blkbits;\n\t\tif (mpd->get_block(inode, block_in_file, &map_bh, 1))\n\t\t\tgoto confused;\n\t\tif (buffer_new(&map_bh))\n\t\t\tclean_bdev_bh_alias(&map_bh);\n\t\tif (buffer_boundary(&map_bh)) {\n\t\t\tboundary_block = map_bh.b_blocknr;\n\t\t\tboundary_bdev = map_bh.b_bdev;\n\t\t}\n\t\tif (page_block) {\n\t\t\tif (map_bh.b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\tgoto confused;\n\t\t}\n\t\tblocks[page_block++] = map_bh.b_blocknr;\n\t\tboundary = buffer_boundary(&map_bh);\n\t\tbdev = map_bh.b_bdev;\n\t\tif (block_in_file == last_block)\n\t\t\tbreak;\n\t\tblock_in_file++;\n\t}\n\tBUG_ON(page_block == 0);\n\n\tfirst_unmapped = page_block;\n\npage_is_mapped:\n\tend_index = i_size >> PAGE_SHIFT;\n\tif (page->index >= end_index) {\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining memory\n\t\t * is zeroed when mapped, and writes to that region are not\n\t\t * written out to the file.\"\n\t\t */\n\t\tunsigned offset = i_size & (PAGE_SIZE - 1);\n\n\t\tif (page->index > end_index || !offset)\n\t\t\tgoto confused;\n\t\tzero_user_segment(page, offset, PAGE_SIZE);\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && mpd->last_block_in_bio != blocks[0] - 1)\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_unmapped == blocks_per_page) {\n\t\t\tif (!bdev_write_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage, wbc))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\tBIO_MAX_PAGES, GFP_NOFS|__GFP_HIGH);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\n\t\twbc_init_bio(wbc, bio);\n\t\tbio->bi_write_hint = inode->i_write_hint;\n\t}\n\n\t/*\n\t * Must try to add the page before marking the buffer clean or\n\t * the confused fail path above (OOM) will be very confused when\n\t * it finds all bh marked clean (i.e. it will not write anything)\n\t */\n\twbc_account_io(wbc, page, PAGE_SIZE);\n\tlength = first_unmapped << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\t\tgoto alloc_new;\n\t}\n\n\tclean_buffers(page, first_unmapped);\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tif (boundary || (first_unmapped != blocks_per_page)) {\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\t\tif (boundary_block) {\n\t\t\twrite_boundary_block(boundary_bdev,\n\t\t\t\t\tboundary_block, 1 << blkbits);\n\t\t}\n\t} else {\n\t\tmpd->last_block_in_bio = blocks[blocks_per_page - 1];\n\t}\n\tgoto out;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\n\tif (mpd->use_writepage) {\n\t\tret = mapping->a_ops->writepage(page, wbc);\n\t} else {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\t/*\n\t * The caller has a ref on the inode, so *mapping is stable\n\t */\n\tmapping_set_error(mapping, ret);\nout:\n\tmpd->bio = bio;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "ret"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->writepage",
          "args": [
            "page",
            "wbc"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "REQ_OP_WRITE",
            "op_flags",
            "bio"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "61-68",
          "snippet": "static struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_boundary_block",
          "args": [
            "boundary_bdev",
            "boundary_block",
            "1 << blkbits"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "write_boundary_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "532-541",
          "snippet": "void write_boundary_block(struct block_device *bdev,\n\t\t\tsector_t bblock, unsigned blocksize)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, bblock + 1, blocksize);\n\tif (bh) {\n\t\tif (buffer_dirty(bh))\n\t\t\tll_rw_block(REQ_OP_WRITE, 0, 1, &bh);\n\t\tput_bh(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid write_boundary_block(struct block_device *bdev,\n\t\t\tsector_t bblock, unsigned blocksize)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, bblock + 1, blocksize);\n\tif (bh) {\n\t\tif (buffer_dirty(bh))\n\t\t\tll_rw_block(REQ_OP_WRITE, 0, 1, &bh);\n\t\tput_bh(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/write.c",
          "lines": "333-344",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH)\n\t\tset_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/iversion.h>",
            "#include <linux/wait.h>",
            "#include <linux/freezer.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH)\n\t\tset_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_buffers",
          "args": [
            "page",
            "first_unmapped"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "clean_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "461-484",
          "snippet": "static void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "length",
            "0"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbc_account_io",
          "args": [
            "wbc",
            "page",
            "PAGE_SIZE"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "wbc_account_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "683-714",
          "snippet": "void wbc_account_io(struct writeback_control *wbc, struct page *page,\n\t\t    size_t bytes)\n{\n\tint id;\n\n\t/*\n\t * pageout() path doesn't attach @wbc to the inode being written\n\t * out.  This is intentional as we don't want the function to block\n\t * behind a slow cgroup.  Ultimately, we want pageout() to kick off\n\t * regular writeback instead of writing things out itself.\n\t */\n\tif (!wbc->wb)\n\t\treturn;\n\n\tid = mem_cgroup_css_from_page(page)->id;\n\n\tif (id == wbc->wb_id) {\n\t\twbc->wb_bytes += bytes;\n\t\treturn;\n\t}\n\n\tif (id == wbc->wb_lcand_id)\n\t\twbc->wb_lcand_bytes += bytes;\n\n\t/* Boyer-Moore majority vote algorithm */\n\tif (!wbc->wb_tcand_bytes)\n\t\twbc->wb_tcand_id = id;\n\tif (id == wbc->wb_tcand_id)\n\t\twbc->wb_tcand_bytes += bytes;\n\telse\n\t\twbc->wb_tcand_bytes -= min(bytes, wbc->wb_tcand_bytes);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wbc_account_io(struct writeback_control *wbc, struct page *page,\n\t\t    size_t bytes)\n{\n\tint id;\n\n\t/*\n\t * pageout() path doesn't attach @wbc to the inode being written\n\t * out.  This is intentional as we don't want the function to block\n\t * behind a slow cgroup.  Ultimately, we want pageout() to kick off\n\t * regular writeback instead of writing things out itself.\n\t */\n\tif (!wbc->wb)\n\t\treturn;\n\n\tid = mem_cgroup_css_from_page(page)->id;\n\n\tif (id == wbc->wb_id) {\n\t\twbc->wb_bytes += bytes;\n\t\treturn;\n\t}\n\n\tif (id == wbc->wb_lcand_id)\n\t\twbc->wb_lcand_bytes += bytes;\n\n\t/* Boyer-Moore majority vote algorithm */\n\tif (!wbc->wb_tcand_bytes)\n\t\twbc->wb_tcand_id = id;\n\tif (id == wbc->wb_tcand_id)\n\t\twbc->wb_tcand_bytes += bytes;\n\telse\n\t\twbc->wb_tcand_bytes -= min(bytes, wbc->wb_tcand_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbc_init_bio",
          "args": [
            "wbc",
            "bio"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_alloc",
          "args": [
            "bdev",
            "blocks[0] << (blkbits - 9)",
            "BIO_MAX_PAGES",
            "GFP_NOFS|__GFP_HIGH"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "70-91",
          "snippet": "static struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\t/* Restrict the given (page cache) mask for slab allocations */\n\tgfp_flags &= GFP_KERNEL;\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\t/* Restrict the given (page cache) mask for slab allocations */\n\tgfp_flags &= GFP_KERNEL;\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_write_page",
          "args": [
            "bdev",
            "blocks[0] << (blkbits - 9)",
            "page",
            "wbc"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "695-718",
          "snippet": "int bdev_write_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page, struct writeback_control *wbc)\n{\n\tint result;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (!ops->rw_page || bdev_get_integrity(bdev))\n\t\treturn -EOPNOTSUPP;\n\tresult = blk_queue_enter(bdev->bd_queue, 0);\n\tif (result)\n\t\treturn result;\n\n\tset_page_writeback(page);\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page,\n\t\t\t      REQ_OP_WRITE);\n\tif (result) {\n\t\tend_page_writeback(page);\n\t} else {\n\t\tclean_page_buffers(page);\n\t\tunlock_page(page);\n\t}\n\tblk_queue_exit(bdev->bd_queue);\n\treturn result;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bdev_write_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page, struct writeback_control *wbc)\n{\n\tint result;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (!ops->rw_page || bdev_get_integrity(bdev))\n\t\treturn -EOPNOTSUPP;\n\tresult = blk_queue_enter(bdev->bd_queue, 0);\n\tif (result)\n\t\treturn result;\n\n\tset_page_writeback(page);\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page,\n\t\t\t      REQ_OP_WRITE);\n\tif (result) {\n\t\tend_page_writeback(page);\n\t} else {\n\t\tclean_page_buffers(page);\n\t\tunlock_page(page);\n\t}\n\tblk_queue_exit(bdev->bd_queue);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset",
            "PAGE_SIZE"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_block == 0"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_boundary",
          "args": [
            "&map_bh"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_boundary",
          "args": [
            "&map_bh"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_bdev_bh_alias",
          "args": [
            "&map_bh"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "&map_bh"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpd->get_block",
          "args": [
            "inode",
            "block_in_file",
            "&map_bh",
            "1"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/minix/itree_common.c",
          "lines": "146-207",
          "snippet": "static int get_block(struct inode * inode, sector_t block,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, block, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh, inode->i_sb, block_to_cpu(chain[depth-1].key));\n\t\t/* Clean up and exit */\n\t\tpartial = chain+depth-1; /* the whole chain */\n\t\tgoto cleanup;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t/*\n\t * Indirect block might be removed by truncate while we were\n\t * reading it. Handling of that case (forget what we've got and\n\t * reread) is taken out of the main path.\n\t */\n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int get_block(struct inode * inode, sector_t block,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, block, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh, inode->i_sb, block_to_cpu(chain[depth-1].key));\n\t\t/* Clean up and exit */\n\t\tpartial = chain+depth-1; /* the whole chain */\n\t\tgoto cleanup;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t/*\n\t * Indirect block might be removed by truncate while we were\n\t * reading it. Handling of that case (forget what we've got and\n\t * reread) is taken out of the main path.\n\t */\n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_boundary",
          "args": [
            "bh"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buffer_locked(bh)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "clean_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "491-494",
          "snippet": "void clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbc_to_write_flags",
          "args": [
            "wbc"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int __mpage_writepage(struct page *page, struct writeback_control *wbc,\n\t\t      void *data)\n{\n\tstruct mpage_data *mpd = data;\n\tstruct bio *bio = mpd->bio;\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tunsigned long end_index;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tsector_t last_block;\n\tsector_t block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_unmapped = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint boundary = 0;\n\tsector_t boundary_block = 0;\n\tstruct block_device *boundary_bdev = NULL;\n\tint length;\n\tstruct buffer_head map_bh;\n\tloff_t i_size = i_size_read(inode);\n\tint ret = 0;\n\tint op_flags = wbc_to_write_flags(wbc);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\t/* If they're all mapped and dirty, do it */\n\t\tpage_block = 0;\n\t\tdo {\n\t\t\tBUG_ON(buffer_locked(bh));\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\t/*\n\t\t\t\t * unmapped dirty buffers are created by\n\t\t\t\t * __set_page_dirty_buffers -> mmapped data\n\t\t\t\t */\n\t\t\t\tif (buffer_dirty(bh))\n\t\t\t\t\tgoto confused;\n\t\t\t\tif (first_unmapped == blocks_per_page)\n\t\t\t\t\tfirst_unmapped = page_block;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first_unmapped != blocks_per_page)\n\t\t\t\tgoto confused;\t/* hole -> non-hole */\n\n\t\t\tif (!buffer_dirty(bh) || !buffer_uptodate(bh))\n\t\t\t\tgoto confused;\n\t\t\tif (page_block) {\n\t\t\t\tif (bh->b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\t\tgoto confused;\n\t\t\t}\n\t\t\tblocks[page_block++] = bh->b_blocknr;\n\t\t\tboundary = buffer_boundary(bh);\n\t\t\tif (boundary) {\n\t\t\t\tboundary_block = bh->b_blocknr;\n\t\t\t\tboundary_bdev = bh->b_bdev;\n\t\t\t}\n\t\t\tbdev = bh->b_bdev;\n\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\tif (first_unmapped)\n\t\t\tgoto page_is_mapped;\n\n\t\t/*\n\t\t * Page has buffers, but they are all unmapped. The page was\n\t\t * created by pagein or read over a hole which was handled by\n\t\t * block_read_full_page().  If this address_space is also\n\t\t * using mpage_readpages then this can rarely happen.\n\t\t */\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * The page has no buffers: map it to disk\n\t */\n\tBUG_ON(!PageUptodate(page));\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = (i_size - 1) >> blkbits;\n\tmap_bh.b_page = page;\n\tfor (page_block = 0; page_block < blocks_per_page; ) {\n\n\t\tmap_bh.b_state = 0;\n\t\tmap_bh.b_size = 1 << blkbits;\n\t\tif (mpd->get_block(inode, block_in_file, &map_bh, 1))\n\t\t\tgoto confused;\n\t\tif (buffer_new(&map_bh))\n\t\t\tclean_bdev_bh_alias(&map_bh);\n\t\tif (buffer_boundary(&map_bh)) {\n\t\t\tboundary_block = map_bh.b_blocknr;\n\t\t\tboundary_bdev = map_bh.b_bdev;\n\t\t}\n\t\tif (page_block) {\n\t\t\tif (map_bh.b_blocknr != blocks[page_block-1] + 1)\n\t\t\t\tgoto confused;\n\t\t}\n\t\tblocks[page_block++] = map_bh.b_blocknr;\n\t\tboundary = buffer_boundary(&map_bh);\n\t\tbdev = map_bh.b_bdev;\n\t\tif (block_in_file == last_block)\n\t\t\tbreak;\n\t\tblock_in_file++;\n\t}\n\tBUG_ON(page_block == 0);\n\n\tfirst_unmapped = page_block;\n\npage_is_mapped:\n\tend_index = i_size >> PAGE_SHIFT;\n\tif (page->index >= end_index) {\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining memory\n\t\t * is zeroed when mapped, and writes to that region are not\n\t\t * written out to the file.\"\n\t\t */\n\t\tunsigned offset = i_size & (PAGE_SIZE - 1);\n\n\t\tif (page->index > end_index || !offset)\n\t\t\tgoto confused;\n\t\tzero_user_segment(page, offset, PAGE_SIZE);\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (bio && mpd->last_block_in_bio != blocks[0] - 1)\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\nalloc_new:\n\tif (bio == NULL) {\n\t\tif (first_unmapped == blocks_per_page) {\n\t\t\tif (!bdev_write_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage, wbc))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\tBIO_MAX_PAGES, GFP_NOFS|__GFP_HIGH);\n\t\tif (bio == NULL)\n\t\t\tgoto confused;\n\n\t\twbc_init_bio(wbc, bio);\n\t\tbio->bi_write_hint = inode->i_write_hint;\n\t}\n\n\t/*\n\t * Must try to add the page before marking the buffer clean or\n\t * the confused fail path above (OOM) will be very confused when\n\t * it finds all bh marked clean (i.e. it will not write anything)\n\t */\n\twbc_account_io(wbc, page, PAGE_SIZE);\n\tlength = first_unmapped << blkbits;\n\tif (bio_add_page(bio, page, length, 0) < length) {\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\t\tgoto alloc_new;\n\t}\n\n\tclean_buffers(page, first_unmapped);\n\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tif (boundary || (first_unmapped != blocks_per_page)) {\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\t\tif (boundary_block) {\n\t\t\twrite_boundary_block(boundary_bdev,\n\t\t\t\t\tboundary_block, 1 << blkbits);\n\t\t}\n\t} else {\n\t\tmpd->last_block_in_bio = blocks[blocks_per_page - 1];\n\t}\n\tgoto out;\n\nconfused:\n\tif (bio)\n\t\tbio = mpage_bio_submit(REQ_OP_WRITE, op_flags, bio);\n\n\tif (mpd->use_writepage) {\n\t\tret = mapping->a_ops->writepage(page, wbc);\n\t} else {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\t/*\n\t * The caller has a ref on the inode, so *mapping is stable\n\t */\n\tmapping_set_error(mapping, ret);\nout:\n\tmpd->bio = bio;\n\treturn ret;\n}"
  },
  {
    "function_name": "clean_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "491-494",
    "snippet": "void clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_buffers",
          "args": [
            "page",
            "~0U"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "clean_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "461-484",
          "snippet": "static void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}"
  },
  {
    "function_name": "clean_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "461-484",
    "snippet": "static void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3249-3295",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "clean_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "491-494",
          "snippet": "void clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void clean_buffers(struct page *page, unsigned first_unmapped)\n{\n\tunsigned buffer_counter = 0;\n\tstruct buffer_head *bh, *head;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = page_buffers(page);\n\tbh = head;\n\n\tdo {\n\t\tif (buffer_counter++ == first_unmapped)\n\t\t\tbreak;\n\t\tclear_buffer_dirty(bh);\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * we cannot drop the bh if the page is not uptodate or a concurrent\n\t * readpage would fail to serialize with the bh and it would read from\n\t * disk before we reach the platter.\n\t */\n\tif (buffer_heads_over_limit && PageUptodate(page))\n\t\ttry_to_free_buffers(page);\n}"
  },
  {
    "function_name": "mpage_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "418-430",
    "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct mpage_readpage_args args = {\n\t\t.page = page,\n\t\t.nr_pages = 1,\n\t\t.get_block = get_block,\n\t};\n\n\targs.bio = do_mpage_readpage(&args);\n\tif (args.bio)\n\t\tmpage_bio_submit(REQ_OP_READ, 0, args.bio);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "REQ_OP_READ",
            "0",
            "args.bio"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "61-68",
          "snippet": "static struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mpage_readpage",
          "args": [
            "&args"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "do_mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "156-338",
          "snippet": "static struct bio *do_mpage_readpage(struct mpage_readpage_args *args)\n{\n\tstruct page *page = args->page;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *map_bh = &args->map_bh;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tint op_flags;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\tgfp_t gfp;\n\n\tif (args->is_readahead) {\n\t\top_flags = REQ_RAHEAD;\n\t\tgfp = readahead_gfp_mask(page->mapping);\n\t} else {\n\t\top_flags = 0;\n\t\tgfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t}\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = block_in_file + args->nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) &&\n\t\t\tblock_in_file > args->first_logical_block &&\n\t\t\tblock_in_file < (args->first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - args->first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (args->get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\targs->first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (args->bio && (args->last_block_in_bio != blocks[0] - 1))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\nalloc_new:\n\tif (args->bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\targs->bio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\tmin_t(int, args->nr_pages,\n\t\t\t\t\t      BIO_MAX_PAGES),\n\t\t\t\t\tgfp);\n\t\tif (args->bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(args->bio, page, length, 0) < length) {\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - args->first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\telse\n\t\targs->last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn args->bio;\n\nconfused:\n\tif (args->bio)\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\tif (!PageUptodate(page))\n\t\tblock_read_full_page(page, args->get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *do_mpage_readpage(struct mpage_readpage_args *args)\n{\n\tstruct page *page = args->page;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *map_bh = &args->map_bh;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tint op_flags;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\tgfp_t gfp;\n\n\tif (args->is_readahead) {\n\t\top_flags = REQ_RAHEAD;\n\t\tgfp = readahead_gfp_mask(page->mapping);\n\t} else {\n\t\top_flags = 0;\n\t\tgfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t}\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = block_in_file + args->nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) &&\n\t\t\tblock_in_file > args->first_logical_block &&\n\t\t\tblock_in_file < (args->first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - args->first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (args->get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\targs->first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (args->bio && (args->last_block_in_bio != blocks[0] - 1))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\nalloc_new:\n\tif (args->bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\targs->bio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\tmin_t(int, args->nr_pages,\n\t\t\t\t\t      BIO_MAX_PAGES),\n\t\t\t\t\tgfp);\n\t\tif (args->bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(args->bio, page, length, 0) < length) {\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - args->first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\telse\n\t\targs->last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn args->bio;\n\nconfused:\n\tif (args->bio)\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\tif (!PageUptodate(page))\n\t\tblock_read_full_page(page, args->get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct mpage_readpage_args args = {\n\t\t.page = page,\n\t\t.nr_pages = 1,\n\t\t.get_block = get_block,\n\t};\n\n\targs.bio = do_mpage_readpage(&args);\n\tif (args.bio)\n\t\tmpage_bio_submit(REQ_OP_READ, 0, args.bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "mpage_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "384-412",
    "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct mpage_readpage_args args = {\n\t\t.get_block = get_block,\n\t\t.is_readahead = true,\n\t};\n\tunsigned page_idx;\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = lru_to_page(pages);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index,\n\t\t\t\t\treadahead_gfp_mask(mapping))) {\n\t\t\targs.page = page;\n\t\t\targs.nr_pages = nr_pages - page_idx;\n\t\t\targs.bio = do_mpage_readpage(&args);\n\t\t}\n\t\tput_page(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (args.bio)\n\t\tmpage_bio_submit(REQ_OP_READ, REQ_RAHEAD, args.bio);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "REQ_OP_READ",
            "REQ_RAHEAD",
            "args.bio"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "61-68",
          "snippet": "static struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(pages)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mpage_readpage",
          "args": [
            "&args"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "do_mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "156-338",
          "snippet": "static struct bio *do_mpage_readpage(struct mpage_readpage_args *args)\n{\n\tstruct page *page = args->page;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *map_bh = &args->map_bh;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tint op_flags;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\tgfp_t gfp;\n\n\tif (args->is_readahead) {\n\t\top_flags = REQ_RAHEAD;\n\t\tgfp = readahead_gfp_mask(page->mapping);\n\t} else {\n\t\top_flags = 0;\n\t\tgfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t}\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = block_in_file + args->nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) &&\n\t\t\tblock_in_file > args->first_logical_block &&\n\t\t\tblock_in_file < (args->first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - args->first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (args->get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\targs->first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (args->bio && (args->last_block_in_bio != blocks[0] - 1))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\nalloc_new:\n\tif (args->bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\targs->bio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\tmin_t(int, args->nr_pages,\n\t\t\t\t\t      BIO_MAX_PAGES),\n\t\t\t\t\tgfp);\n\t\tif (args->bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(args->bio, page, length, 0) < length) {\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - args->first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\telse\n\t\targs->last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn args->bio;\n\nconfused:\n\tif (args->bio)\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\tif (!PageUptodate(page))\n\t\tblock_read_full_page(page, args->get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *do_mpage_readpage(struct mpage_readpage_args *args)\n{\n\tstruct page *page = args->page;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *map_bh = &args->map_bh;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tint op_flags;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\tgfp_t gfp;\n\n\tif (args->is_readahead) {\n\t\top_flags = REQ_RAHEAD;\n\t\tgfp = readahead_gfp_mask(page->mapping);\n\t} else {\n\t\top_flags = 0;\n\t\tgfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t}\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = block_in_file + args->nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) &&\n\t\t\tblock_in_file > args->first_logical_block &&\n\t\t\tblock_in_file < (args->first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - args->first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (args->get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\targs->first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (args->bio && (args->last_block_in_bio != blocks[0] - 1))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\nalloc_new:\n\tif (args->bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\targs->bio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\tmin_t(int, args->nr_pages,\n\t\t\t\t\t      BIO_MAX_PAGES),\n\t\t\t\t\tgfp);\n\t\tif (args->bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(args->bio, page, length, 0) < length) {\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - args->first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\telse\n\t\targs->last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn args->bio;\n\nconfused:\n\tif (args->bio)\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\tif (!PageUptodate(page))\n\t\tblock_read_full_page(page, args->get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "page->index",
            "readahead_gfp_mask(mapping)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readahead_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetchw",
          "args": [
            "&page->flags"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "pages"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct mpage_readpage_args args = {\n\t\t.get_block = get_block,\n\t\t.is_readahead = true,\n\t};\n\tunsigned page_idx;\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = lru_to_page(pages);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index,\n\t\t\t\t\treadahead_gfp_mask(mapping))) {\n\t\t\targs.page = page;\n\t\t\targs.nr_pages = nr_pages - page_idx;\n\t\t\targs.bio = do_mpage_readpage(&args);\n\t\t}\n\t\tput_page(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (args.bio)\n\t\tmpage_bio_submit(REQ_OP_READ, REQ_RAHEAD, args.bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_mpage_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "156-338",
    "snippet": "static struct bio *do_mpage_readpage(struct mpage_readpage_args *args)\n{\n\tstruct page *page = args->page;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *map_bh = &args->map_bh;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tint op_flags;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\tgfp_t gfp;\n\n\tif (args->is_readahead) {\n\t\top_flags = REQ_RAHEAD;\n\t\tgfp = readahead_gfp_mask(page->mapping);\n\t} else {\n\t\top_flags = 0;\n\t\tgfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t}\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = block_in_file + args->nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) &&\n\t\t\tblock_in_file > args->first_logical_block &&\n\t\t\tblock_in_file < (args->first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - args->first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (args->get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\targs->first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (args->bio && (args->last_block_in_bio != blocks[0] - 1))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\nalloc_new:\n\tif (args->bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\targs->bio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\tmin_t(int, args->nr_pages,\n\t\t\t\t\t      BIO_MAX_PAGES),\n\t\t\t\t\tgfp);\n\t\tif (args->bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(args->bio, page, length, 0) < length) {\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - args->first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\telse\n\t\targs->last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn args->bio;\n\nconfused:\n\tif (args->bio)\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\tif (!PageUptodate(page))\n\t\tblock_read_full_page(page, args->get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "args->get_block"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2218-2301",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_bio_submit",
          "args": [
            "REQ_OP_READ",
            "op_flags",
            "args->bio"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_bio_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "61-68",
          "snippet": "static struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_boundary",
          "args": [
            "map_bh"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "args->bio",
            "page",
            "length",
            "0"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_alloc",
          "args": [
            "bdev",
            "blocks[0] << (blkbits - 9)",
            "min_t(int, args->nr_pages,\n\t\t\t\t\t      BIO_MAX_PAGES)",
            "gfp"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "70-91",
          "snippet": "static struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\t/* Restrict the given (page cache) mask for slab allocations */\n\tgfp_flags &= GFP_KERNEL;\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\t/* Restrict the given (page cache) mask for slab allocations */\n\tgfp_flags &= GFP_KERNEL;\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "args->nr_pages",
            "BIO_MAX_PAGES"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_page",
          "args": [
            "bdev",
            "blocks[0] << (blkbits - 9)",
            "page"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "657-673",
          "snippet": "int bdev_read_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page)\n{\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tint result = -EOPNOTSUPP;\n\n\tif (!ops->rw_page || bdev_get_integrity(bdev))\n\t\treturn result;\n\n\tresult = blk_queue_enter(bdev->bd_queue, 0);\n\tif (result)\n\t\treturn result;\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page,\n\t\t\t      REQ_OP_READ);\n\tblk_queue_exit(bdev->bd_queue);\n\treturn result;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bdev_read_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page)\n{\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tint result = -EOPNOTSUPP;\n\n\tif (!ops->rw_page || bdev_get_integrity(bdev))\n\t\treturn result;\n\n\tresult = blk_queue_enter(bdev->bd_queue, 0);\n\tif (result)\n\t\treturn result;\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page,\n\t\t\t      REQ_OP_READ);\n\tblk_queue_exit(bdev->bd_queue);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleancache_get_page",
          "args": [
            "page"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "first_hole << blkbits",
            "PAGE_SIZE"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "map_bh"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_buffer_to_page",
          "args": [
            "page",
            "map_bh",
            "page_block"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "map_buffer_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "103-134",
          "snippet": "static void \nmap_buffer_to_page(struct page *page, struct buffer_head *bh, int page_block) \n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bh, *head;\n\tint block = 0;\n\n\tif (!page_has_buffers(page)) {\n\t\t/*\n\t\t * don't make any buffers if there is only one buffer on\n\t\t * the page and the page just needs to be set up to date\n\t\t */\n\t\tif (inode->i_blkbits == PAGE_SHIFT &&\n\t\t    buffer_uptodate(bh)) {\n\t\t\tSetPageUptodate(page);    \n\t\t\treturn;\n\t\t}\n\t\tcreate_empty_buffers(page, i_blocksize(inode), 0);\n\t}\n\thead = page_buffers(page);\n\tpage_bh = head;\n\tdo {\n\t\tif (block == page_block) {\n\t\t\tpage_bh->b_state = bh->b_state;\n\t\t\tpage_bh->b_bdev = bh->b_bdev;\n\t\t\tpage_bh->b_blocknr = bh->b_blocknr;\n\t\t\tbreak;\n\t\t}\n\t\tpage_bh = page_bh->b_this_page;\n\t\tblock++;\n\t} while (page_bh != head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void \nmap_buffer_to_page(struct page *page, struct buffer_head *bh, int page_block) \n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bh, *head;\n\tint block = 0;\n\n\tif (!page_has_buffers(page)) {\n\t\t/*\n\t\t * don't make any buffers if there is only one buffer on\n\t\t * the page and the page just needs to be set up to date\n\t\t */\n\t\tif (inode->i_blkbits == PAGE_SHIFT &&\n\t\t    buffer_uptodate(bh)) {\n\t\t\tSetPageUptodate(page);    \n\t\t\treturn;\n\t\t}\n\t\tcreate_empty_buffers(page, i_blocksize(inode), 0);\n\t}\n\thead = page_buffers(page);\n\tpage_bh = head;\n\tdo {\n\t\tif (block == page_block) {\n\t\t\tpage_bh->b_state = bh->b_state;\n\t\t\tpage_bh->b_bdev = bh->b_bdev;\n\t\t\tpage_bh->b_blocknr = bh->b_blocknr;\n\t\t\tbreak;\n\t\t}\n\t\tpage_bh = page_bh->b_this_page;\n\t\tblock++;\n\t} while (page_bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "map_bh"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "map_bh"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->get_block",
          "args": [
            "inode",
            "block_in_file",
            "map_bh",
            "0"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/minix/itree_common.c",
          "lines": "146-207",
          "snippet": "static int get_block(struct inode * inode, sector_t block,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, block, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh, inode->i_sb, block_to_cpu(chain[depth-1].key));\n\t\t/* Clean up and exit */\n\t\tpartial = chain+depth-1; /* the whole chain */\n\t\tgoto cleanup;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t/*\n\t * Indirect block might be removed by truncate while we were\n\t * reading it. Handling of that case (forget what we've got and\n\t * reread) is taken out of the main path.\n\t */\n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int get_block(struct inode * inode, sector_t block,\n\t\t\tstruct buffer_head *bh, int create)\n{\n\tint err = -EIO;\n\tint offsets[DEPTH];\n\tIndirect chain[DEPTH];\n\tIndirect *partial;\n\tint left;\n\tint depth = block_to_path(inode, block, offsets);\n\n\tif (depth == 0)\n\t\tgoto out;\n\nreread:\n\tpartial = get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\ngot_it:\n\t\tmap_bh(bh, inode->i_sb, block_to_cpu(chain[depth-1].key));\n\t\t/* Clean up and exit */\n\t\tpartial = chain+depth-1; /* the whole chain */\n\t\tgoto cleanup;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO) {\ncleanup:\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\nout:\n\t\treturn err;\n\t}\n\n\t/*\n\t * Indirect block might be removed by truncate while we were\n\t * reading it. Handling of that case (forget what we've got and\n\t * reread) is taken out of the main path.\n\t */\n\tif (err == -EAGAIN)\n\t\tgoto changed;\n\n\tleft = (chain + depth) - partial;\n\terr = alloc_branch(inode, left, offsets+(partial-chain), partial);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (splice_branch(inode, chain, partial, left) < 0)\n\t\tgoto changed;\n\n\tset_buffer_new(bh);\n\tgoto got_it;\n\nchanged:\n\twhile (partial > chain) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tgoto reread;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "map_bh"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "map_bh"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_constraint",
          "args": [
            "page->mapping",
            "GFP_KERNEL"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readahead_gfp_mask",
          "args": [
            "page->mapping"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *do_mpage_readpage(struct mpage_readpage_args *args)\n{\n\tstruct page *page = args->page;\n\tstruct inode *inode = page->mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocks_per_page = PAGE_SIZE >> blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *map_bh = &args->map_bh;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t blocks[MAX_BUF_PER_PAGE];\n\tunsigned page_block;\n\tunsigned first_hole = blocks_per_page;\n\tstruct block_device *bdev = NULL;\n\tint length;\n\tint fully_mapped = 1;\n\tint op_flags;\n\tunsigned nblocks;\n\tunsigned relative_block;\n\tgfp_t gfp;\n\n\tif (args->is_readahead) {\n\t\top_flags = REQ_RAHEAD;\n\t\tgfp = readahead_gfp_mask(page->mapping);\n\t} else {\n\t\top_flags = 0;\n\t\tgfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t}\n\n\tif (page_has_buffers(page))\n\t\tgoto confused;\n\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\tlast_block = block_in_file + args->nr_pages * blocks_per_page;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\tpage_block = 0;\n\n\t/*\n\t * Map blocks using the result from the previous get_blocks call first.\n\t */\n\tnblocks = map_bh->b_size >> blkbits;\n\tif (buffer_mapped(map_bh) &&\n\t\t\tblock_in_file > args->first_logical_block &&\n\t\t\tblock_in_file < (args->first_logical_block + nblocks)) {\n\t\tunsigned map_offset = block_in_file - args->first_logical_block;\n\t\tunsigned last = nblocks - map_offset;\n\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == last) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr + map_offset +\n\t\t\t\t\t\trelative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\t/*\n\t * Then do more get_blocks calls until we are done with this page.\n\t */\n\tmap_bh->b_page = page;\n\twhile (page_block < blocks_per_page) {\n\t\tmap_bh->b_state = 0;\n\t\tmap_bh->b_size = 0;\n\n\t\tif (block_in_file < last_block) {\n\t\t\tmap_bh->b_size = (last_block-block_in_file) << blkbits;\n\t\t\tif (args->get_block(inode, block_in_file, map_bh, 0))\n\t\t\t\tgoto confused;\n\t\t\targs->first_logical_block = block_in_file;\n\t\t}\n\n\t\tif (!buffer_mapped(map_bh)) {\n\t\t\tfully_mapped = 0;\n\t\t\tif (first_hole == blocks_per_page)\n\t\t\t\tfirst_hole = page_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* some filesystems will copy data into the page during\n\t\t * the get_block call, in which case we don't want to\n\t\t * read it again.  map_buffer_to_page copies the data\n\t\t * we just collected from get_block into the page's buffers\n\t\t * so readpage doesn't have to repeat the get_block call\n\t\t */\n\t\tif (buffer_uptodate(map_bh)) {\n\t\t\tmap_buffer_to_page(page, map_bh, page_block);\n\t\t\tgoto confused;\n\t\t}\n\t\n\t\tif (first_hole != blocks_per_page)\n\t\t\tgoto confused;\t\t/* hole -> non-hole */\n\n\t\t/* Contiguous blocks? */\n\t\tif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\n\t\t\tgoto confused;\n\t\tnblocks = map_bh->b_size >> blkbits;\n\t\tfor (relative_block = 0; ; relative_block++) {\n\t\t\tif (relative_block == nblocks) {\n\t\t\t\tclear_buffer_mapped(map_bh);\n\t\t\t\tbreak;\n\t\t\t} else if (page_block == blocks_per_page)\n\t\t\t\tbreak;\n\t\t\tblocks[page_block] = map_bh->b_blocknr+relative_block;\n\t\t\tpage_block++;\n\t\t\tblock_in_file++;\n\t\t}\n\t\tbdev = map_bh->b_bdev;\n\t}\n\n\tif (first_hole != blocks_per_page) {\n\t\tzero_user_segment(page, first_hole << blkbits, PAGE_SIZE);\n\t\tif (first_hole == 0) {\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto out;\n\t\t}\n\t} else if (fully_mapped) {\n\t\tSetPageMappedToDisk(page);\n\t}\n\n\tif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\n\t    cleancache_get_page(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tgoto confused;\n\t}\n\n\t/*\n\t * This page will go to BIO.  Do we need to send this BIO off first?\n\t */\n\tif (args->bio && (args->last_block_in_bio != blocks[0] - 1))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\nalloc_new:\n\tif (args->bio == NULL) {\n\t\tif (first_hole == blocks_per_page) {\n\t\t\tif (!bdev_read_page(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\t\t\t\tpage))\n\t\t\t\tgoto out;\n\t\t}\n\t\targs->bio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\n\t\t\t\t\tmin_t(int, args->nr_pages,\n\t\t\t\t\t      BIO_MAX_PAGES),\n\t\t\t\t\tgfp);\n\t\tif (args->bio == NULL)\n\t\t\tgoto confused;\n\t}\n\n\tlength = first_hole << blkbits;\n\tif (bio_add_page(args->bio, page, length, 0) < length) {\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\t\tgoto alloc_new;\n\t}\n\n\trelative_block = block_in_file - args->first_logical_block;\n\tnblocks = map_bh->b_size >> blkbits;\n\tif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\n\t    (first_hole != blocks_per_page))\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\telse\n\t\targs->last_block_in_bio = blocks[blocks_per_page - 1];\nout:\n\treturn args->bio;\n\nconfused:\n\tif (args->bio)\n\t\targs->bio = mpage_bio_submit(REQ_OP_READ, op_flags, args->bio);\n\tif (!PageUptodate(page))\n\t\tblock_read_full_page(page, args->get_block);\n\telse\n\t\tunlock_page(page);\n\tgoto out;\n}"
  },
  {
    "function_name": "map_buffer_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "103-134",
    "snippet": "static void \nmap_buffer_to_page(struct page *page, struct buffer_head *bh, int page_block) \n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bh, *head;\n\tint block = 0;\n\n\tif (!page_has_buffers(page)) {\n\t\t/*\n\t\t * don't make any buffers if there is only one buffer on\n\t\t * the page and the page just needs to be set up to date\n\t\t */\n\t\tif (inode->i_blkbits == PAGE_SHIFT &&\n\t\t    buffer_uptodate(bh)) {\n\t\t\tSetPageUptodate(page);    \n\t\t\treturn;\n\t\t}\n\t\tcreate_empty_buffers(page, i_blocksize(inode), 0);\n\t}\n\thead = page_buffers(page);\n\tpage_bh = head;\n\tdo {\n\t\tif (block == page_block) {\n\t\t\tpage_bh->b_state = bh->b_state;\n\t\t\tpage_bh->b_bdev = bh->b_bdev;\n\t\t\tpage_bh->b_blocknr = bh->b_blocknr;\n\t\t\tbreak;\n\t\t}\n\t\tpage_bh = page_bh->b_this_page;\n\t\tblock++;\n\t} while (page_bh != head);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "clean_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "491-494",
          "snippet": "void clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "i_blocksize(inode)",
            "0"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1511-1538",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, true);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, true);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void \nmap_buffer_to_page(struct page *page, struct buffer_head *bh, int page_block) \n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *page_bh, *head;\n\tint block = 0;\n\n\tif (!page_has_buffers(page)) {\n\t\t/*\n\t\t * don't make any buffers if there is only one buffer on\n\t\t * the page and the page just needs to be set up to date\n\t\t */\n\t\tif (inode->i_blkbits == PAGE_SHIFT &&\n\t\t    buffer_uptodate(bh)) {\n\t\t\tSetPageUptodate(page);    \n\t\t\treturn;\n\t\t}\n\t\tcreate_empty_buffers(page, i_blocksize(inode), 0);\n\t}\n\thead = page_buffers(page);\n\tpage_bh = head;\n\tdo {\n\t\tif (block == page_block) {\n\t\t\tpage_bh->b_state = bh->b_state;\n\t\t\tpage_bh->b_bdev = bh->b_bdev;\n\t\t\tpage_bh->b_blocknr = bh->b_blocknr;\n\t\t\tbreak;\n\t\t}\n\t\tpage_bh = page_bh->b_this_page;\n\t\tblock++;\n\t} while (page_bh != head);\n}"
  },
  {
    "function_name": "mpage_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "70-91",
    "snippet": "static struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\t/* Restrict the given (page cache) mask for slab allocations */\n\tgfp_flags &= GFP_KERNEL;\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "bio",
            "bdev"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "gfp_flags",
            "nr_vecs"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.c",
          "lines": "2667-2676",
          "snippet": "struct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set btrfs_bioset;\n\nstruct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *\nmpage_alloc(struct block_device *bdev,\n\t\tsector_t first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct bio *bio;\n\n\t/* Restrict the given (page cache) mask for slab allocations */\n\tgfp_flags &= GFP_KERNEL;\n\tbio = bio_alloc(gfp_flags, nr_vecs);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2))\n\t\t\tbio = bio_alloc(gfp_flags, nr_vecs);\n\t}\n\n\tif (bio) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t}\n\treturn bio;\n}"
  },
  {
    "function_name": "mpage_bio_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "61-68",
    "snippet": "static struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "bio"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-116",
          "snippet": "static struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guard_bio_eod",
          "args": [
            "op",
            "bio"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "guard_bio_eod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2996-3038",
          "snippet": "void guard_bio_eod(int op, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = bio_last_bvec_all(bio);\n\tunsigned truncated_bytes;\n\tstruct hd_struct *part;\n\n\trcu_read_lock();\n\tpart = __disk_get_part(bio->bi_disk, bio->bi_partno);\n\tif (part)\n\t\tmaxsector = part_nr_sects_read(part);\n\telse\n\t\tmaxsector = get_capacity(bio->bi_disk);\n\trcu_read_unlock();\n\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif (op == REQ_OP_READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid guard_bio_eod(int op, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = bio_last_bvec_all(bio);\n\tunsigned truncated_bytes;\n\tstruct hd_struct *part;\n\n\trcu_read_lock();\n\tpart = __disk_get_part(bio->bi_disk, bio->bi_partno);\n\tif (part)\n\t\tmaxsector = part_nr_sects_read(part);\n\telse\n\t\tmaxsector = get_capacity(bio->bi_disk);\n\trcu_read_unlock();\n\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif (op == REQ_OP_READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_set_op_attrs",
          "args": [
            "bio",
            "op",
            "op_flags"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)\n{\n\tbio->bi_end_io = mpage_end_io;\n\tbio_set_op_attrs(bio, op, op_flags);\n\tguard_bio_eod(op, bio);\n\tsubmit_bio(bio);\n\treturn NULL;\n}"
  },
  {
    "function_name": "mpage_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
    "lines": "47-59",
    "snippet": "static void mpage_end_io(struct bio *bio)\n{\n\tstruct bio_vec *bv;\n\tint i;\n\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tstruct page *page = bv->bv_page;\n\t\tpage_endio(page, bio_op(bio),\n\t\t\t   blk_status_to_errno(bio->bi_status));\n\t}\n\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mpage.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/highmem.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_endio",
          "args": [
            "page",
            "bio_op(bio)",
            "blk_status_to_errno(bio->bi_status)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "bio->bi_status"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_op",
          "args": [
            "bio"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bv",
            "bio",
            "i"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void mpage_end_io(struct bio *bio)\n{\n\tstruct bio_vec *bv;\n\tint i;\n\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tstruct page *page = bv->bv_page;\n\t\tpage_endio(page, bio_op(bio),\n\t\t\t   blk_status_to_errno(bio->bi_status));\n\t}\n\n\tbio_put(bio);\n}"
  }
]