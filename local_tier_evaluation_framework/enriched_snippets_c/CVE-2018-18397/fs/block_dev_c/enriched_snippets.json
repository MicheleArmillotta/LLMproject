[
  {
    "function_name": "iterate_bdevs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "2133-2172",
    "snippet": "void iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\tlist_for_each_entry(inode, &blockdev_superblock->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct block_device *bdev;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||\n\t\t    mapping->nrpages == 0) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * s_inode_list_lock  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * s_inode_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\t\tbdev = I_BDEV(inode);\n\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tif (bdev->bd_openers)\n\t\t\tfunc(bdev, arg);\n\t\tmutex_unlock(&bdev->bd_mutex);\n\n\t\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\t}\n\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\tiput(old_inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct super_block *blockdev_superblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "old_inode"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blockdev_superblock->s_inode_list_lock"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blockdev_superblock->s_inode_list_lock"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "bdev",
            "arg"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "6797-6802",
          "snippet": "static int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "inode"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "394-397",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "inode",
            "&blockdev_superblock->s_inodes",
            "i_sb_list"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct super_block *blockdev_superblock;\n\nvoid iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\tlist_for_each_entry(inode, &blockdev_superblock->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct block_device *bdev;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||\n\t\t    mapping->nrpages == 0) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * s_inode_list_lock  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * s_inode_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\t\tbdev = I_BDEV(inode);\n\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tif (bdev->bd_openers)\n\t\t\tfunc(bdev, arg);\n\t\tmutex_unlock(&bdev->bd_mutex);\n\n\t\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\t}\n\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\tiput(old_inode);\n}"
  },
  {
    "function_name": "__invalidate_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "2112-2130",
    "snippet": "int __invalidate_device(struct block_device *bdev, bool kill_dirty)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tint res = 0;\n\n\tif (sb) {\n\t\t/*\n\t\t * no need to lock the super, get_super holds the\n\t\t * read mutex so the filesystem cannot go away\n\t\t * under us (->put_super runs with the write lock\n\t\t * hold).\n\t\t */\n\t\tshrink_dcache_sb(sb);\n\t\tres = invalidate_inodes(sb, kill_dirty);\n\t\tdrop_super(sb);\n\t}\n\tinvalidate_bdev(bdev);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_bdev",
          "args": [
            "bdev"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "91-104",
          "snippet": "void invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_bh_lrus();\n\t\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\t\tinvalidate_mapping_pages(mapping, 0, -1);\n\t}\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_bh_lrus();\n\t\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\t\tinvalidate_mapping_pages(mapping, 0, -1);\n\t}\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_super",
          "args": [
            "sb"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "drop_super_exclusive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "583-587",
          "snippet": "void drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inodes",
          "args": [
            "sb",
            "kill_dirty"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "657-691",
          "snippet": "int invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_sb",
          "args": [
            "sb"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1189-1202",
          "snippet": "void shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, 1024);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (list_lru_count(&sb->s_dentry_lru) > 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, 1024);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (list_lru_count(&sb->s_dentry_lru) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_super",
          "args": [
            "bdev"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "user_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "809-834",
          "snippet": "struct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint __invalidate_device(struct block_device *bdev, bool kill_dirty)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tint res = 0;\n\n\tif (sb) {\n\t\t/*\n\t\t * no need to lock the super, get_super holds the\n\t\t * read mutex so the filesystem cannot go away\n\t\t * under us (->put_super runs with the write lock\n\t\t * hold).\n\t\t */\n\t\tshrink_dcache_sb(sb);\n\t\tres = invalidate_inodes(sb, kill_dirty);\n\t\tdrop_super(sb);\n\t}\n\tinvalidate_bdev(bdev);\n\treturn res;\n}"
  },
  {
    "function_name": "lookup_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "2078-2109",
    "snippet": "struct block_device *lookup_bdev(const char *pathname)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tif (!pathname || !*pathname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = kern_path(pathname, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = d_backing_inode(path.dentry);\n\terror = -ENOTBLK;\n\tif (!S_ISBLK(inode->i_mode))\n\t\tgoto fail;\n\terror = -EACCES;\n\tif (!may_open_dev(&path))\n\t\tgoto fail;\n\terror = -ENOMEM;\n\tbdev = bd_acquire(inode);\n\tif (!bdev)\n\t\tgoto fail;\nout:\n\tpath_put(&path);\n\treturn bdev;\nfail:\n\tbdev = ERR_PTR(error);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bd_acquire",
          "args": [
            "inode"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "bd_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "931-970",
          "snippet": "static struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev && !inode_unhashed(bdev->bd_inode)) {\n\t\tbdgrab(bdev);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\t/*\n\t * i_bdev references block device inode that was already shut down\n\t * (corresponding device got removed).  Remove the reference and look\n\t * up block device inode again just in case new device got\n\t * reestablished under the same device number.\n\t */\n\tif (bdev)\n\t\tbd_forget(inode);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tbdgrab(bdev);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev && !inode_unhashed(bdev->bd_inode)) {\n\t\tbdgrab(bdev);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\t/*\n\t * i_bdev references block device inode that was already shut down\n\t * (corresponding device got removed).  Remove the reference and look\n\t * up block device inode again just in case new device got\n\t * reestablished under the same device number.\n\t */\n\tif (bdev)\n\t\tbd_forget(inode);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tbdgrab(bdev);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_open_dev",
          "args": [
            "&path"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "may_open_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "2940-2944",
          "snippet": "bool may_open_dev(const struct path *path)\n{\n\treturn !(path->mnt->mnt_flags & MNT_NODEV) &&\n\t\t!(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nbool may_open_dev(const struct path *path)\n{\n\treturn !(path->mnt->mnt_flags & MNT_NODEV) &&\n\t\t!(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path.dentry"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "pathname",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "2432-2436",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\treturn filename_lookup(AT_FDCWD, getname_kernel(name),\n\t\t\t       flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\treturn filename_lookup(AT_FDCWD, getname_kernel(name),\n\t\t\t       flags, path, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *lookup_bdev(const char *pathname)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tif (!pathname || !*pathname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = kern_path(pathname, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = d_backing_inode(path.dentry);\n\terror = -ENOTBLK;\n\tif (!S_ISBLK(inode->i_mode))\n\t\tgoto fail;\n\terror = -EACCES;\n\tif (!may_open_dev(&path))\n\t\tgoto fail;\n\terror = -ENOMEM;\n\tbdev = bd_acquire(inode);\n\tif (!bdev)\n\t\tgoto fail;\nout:\n\tpath_put(&path);\n\treturn bdev;\nfail:\n\tbdev = ERR_PTR(error);\n\tgoto out;\n}"
  },
  {
    "function_name": "ioctl_by_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "2058-2066",
    "snippet": "int ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)\n{\n\tint res;\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tres = blkdev_ioctl(bdev, 0, cmd, arg);\n\tset_fs(old_fs);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkdev_ioctl",
          "args": [
            "bdev",
            "0",
            "cmd",
            "arg"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)\n{\n\tint res;\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tres = blkdev_ioctl(bdev, 0, cmd, arg);\n\tset_fs(old_fs);\n\treturn res;\n}"
  },
  {
    "function_name": "blkdev_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1976-2039",
    "snippet": "static long blkdev_fallocate(struct file *file, int mode, loff_t start,\n\t\t\t     loff_t len)\n{\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(file));\n\tstruct address_space *mapping;\n\tloff_t end = start + len - 1;\n\tloff_t isize;\n\tint error;\n\n\t/* Fail if we don't recognize the flags. */\n\tif (mode & ~BLKDEV_FALLOC_FL_SUPPORTED)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Don't go off the end of the device. */\n\tisize = i_size_read(bdev->bd_inode);\n\tif (start >= isize)\n\t\treturn -EINVAL;\n\tif (end >= isize) {\n\t\tif (mode & FALLOC_FL_KEEP_SIZE) {\n\t\t\tlen = isize - start;\n\t\t\tend = start + len - 1;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Don't allow IO that isn't aligned to logical block size.\n\t */\n\tif ((start | len) & (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\t/* Invalidate the page cache, including dirty pages. */\n\tmapping = bdev->bd_inode->i_mapping;\n\ttruncate_inode_pages_range(mapping, start, end);\n\n\tswitch (mode) {\n\tcase FALLOC_FL_ZERO_RANGE:\n\tcase FALLOC_FL_ZERO_RANGE | FALLOC_FL_KEEP_SIZE:\n\t\terror = blkdev_issue_zeroout(bdev, start >> 9, len >> 9,\n\t\t\t\t\t    GFP_KERNEL, BLKDEV_ZERO_NOUNMAP);\n\t\tbreak;\n\tcase FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE:\n\t\terror = blkdev_issue_zeroout(bdev, start >> 9, len >> 9,\n\t\t\t\t\t     GFP_KERNEL, BLKDEV_ZERO_NOFALLBACK);\n\t\tbreak;\n\tcase FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE | FALLOC_FL_NO_HIDE_STALE:\n\t\terror = blkdev_issue_discard(bdev, start >> 9, len >> 9,\n\t\t\t\t\t     GFP_KERNEL, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Invalidate again; if someone wandered in and dirtied a page,\n\t * the caller will be given -EBUSY.  The third argument is\n\t * inclusive, so the rounding here is safe.\n\t */\n\treturn invalidate_inode_pages2_range(mapping,\n\t\t\t\t\t     start >> PAGE_SHIFT,\n\t\t\t\t\t     end >> PAGE_SHIFT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define\tBLKDEV_FALLOC_FL_SUPPORTED\t\t\t\t\t\\\n\t\t(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\t\t\\\n\t\t FALLOC_FL_ZERO_RANGE | FALLOC_FL_NO_HIDE_STALE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "mapping",
            "start >> PAGE_SHIFT",
            "end >> PAGE_SHIFT"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_discard",
          "args": [
            "bdev",
            "start >> 9",
            "len >> 9",
            "GFP_KERNEL",
            "0"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_zeroout",
          "args": [
            "bdev",
            "start >> 9",
            "len >> 9",
            "GFP_KERNEL",
            "BLKDEV_ZERO_NOFALLBACK"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_zeroout",
          "args": [
            "bdev",
            "start >> 9",
            "len >> 9",
            "GFP_KERNEL",
            "BLKDEV_ZERO_NOUNMAP"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "mapping",
            "start",
            "end"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "bdev_file_inode(file)"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_file_inode",
          "args": [
            "file"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\n#define\tBLKDEV_FALLOC_FL_SUPPORTED\t\t\t\t\t\\\n\t\t(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\t\t\\\n\t\t FALLOC_FL_ZERO_RANGE | FALLOC_FL_NO_HIDE_STALE)\n\nstatic long blkdev_fallocate(struct file *file, int mode, loff_t start,\n\t\t\t     loff_t len)\n{\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(file));\n\tstruct address_space *mapping;\n\tloff_t end = start + len - 1;\n\tloff_t isize;\n\tint error;\n\n\t/* Fail if we don't recognize the flags. */\n\tif (mode & ~BLKDEV_FALLOC_FL_SUPPORTED)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Don't go off the end of the device. */\n\tisize = i_size_read(bdev->bd_inode);\n\tif (start >= isize)\n\t\treturn -EINVAL;\n\tif (end >= isize) {\n\t\tif (mode & FALLOC_FL_KEEP_SIZE) {\n\t\t\tlen = isize - start;\n\t\t\tend = start + len - 1;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Don't allow IO that isn't aligned to logical block size.\n\t */\n\tif ((start | len) & (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\t/* Invalidate the page cache, including dirty pages. */\n\tmapping = bdev->bd_inode->i_mapping;\n\ttruncate_inode_pages_range(mapping, start, end);\n\n\tswitch (mode) {\n\tcase FALLOC_FL_ZERO_RANGE:\n\tcase FALLOC_FL_ZERO_RANGE | FALLOC_FL_KEEP_SIZE:\n\t\terror = blkdev_issue_zeroout(bdev, start >> 9, len >> 9,\n\t\t\t\t\t    GFP_KERNEL, BLKDEV_ZERO_NOUNMAP);\n\t\tbreak;\n\tcase FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE:\n\t\terror = blkdev_issue_zeroout(bdev, start >> 9, len >> 9,\n\t\t\t\t\t     GFP_KERNEL, BLKDEV_ZERO_NOFALLBACK);\n\t\tbreak;\n\tcase FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE | FALLOC_FL_NO_HIDE_STALE:\n\t\terror = blkdev_issue_discard(bdev, start >> 9, len >> 9,\n\t\t\t\t\t     GFP_KERNEL, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Invalidate again; if someone wandered in and dirtied a page,\n\t * the caller will be given -EBUSY.  The third argument is\n\t * inclusive, so the rounding here is safe.\n\t */\n\treturn invalidate_inode_pages2_range(mapping,\n\t\t\t\t\t     start >> PAGE_SHIFT,\n\t\t\t\t\t     end >> PAGE_SHIFT);\n}"
  },
  {
    "function_name": "blkdev_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1954-1958",
    "snippet": "static int blkdev_writepages(struct address_space *mapping,\n\t\t\t     struct writeback_control *wbc)\n{\n\treturn generic_writepages(mapping, wbc);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_writepages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_writepages(struct address_space *mapping,\n\t\t\t     struct writeback_control *wbc)\n{\n\treturn generic_writepages(mapping, wbc);\n}"
  },
  {
    "function_name": "blkdev_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1944-1952",
    "snippet": "static int blkdev_releasepage(struct page *page, gfp_t wait)\n{\n\tstruct super_block *super = BDEV_I(page->mapping->host)->bdev.bd_super;\n\n\tif (super && super->s_op->bdev_try_to_free_page)\n\t\treturn super->s_op->bdev_try_to_free_page(super, page, wait);\n\n\treturn try_to_free_buffers(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3249-3295",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "super->s_op->bdev_try_to_free_page",
          "args": [
            "super",
            "page",
            "wait"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_try_to_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/super.c",
          "lines": "1198-1210",
          "snippet": "static int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn jbd2_journal_try_to_free_buffers(journal, page,\n\t\t\t\t\t\twait & ~__GFP_DIRECT_RECLAIM);\n\treturn try_to_free_buffers(page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"fsmap.h\"",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/iversion.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/dax.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_sync_fs(struct super_block *sb, int wait);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"fsmap.h\"\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/iversion.h>\n#include <linux/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/dax.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_sync_fs(struct super_block *sb, int wait);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nstatic int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn jbd2_journal_try_to_free_buffers(journal, page,\n\t\t\t\t\t\twait & ~__GFP_DIRECT_RECLAIM);\n\treturn try_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_releasepage(struct page *page, gfp_t wait)\n{\n\tstruct super_block *super = BDEV_I(page->mapping->host)->bdev.bd_super;\n\n\tif (super && super->s_op->bdev_try_to_free_page)\n\t\treturn super->s_op->bdev_try_to_free_page(super, page, wait);\n\n\treturn try_to_free_buffers(page);\n}"
  },
  {
    "function_name": "blkdev_read_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1924-1937",
    "snippet": "ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *bd_inode = bdev_file_inode(file);\n\tloff_t size = i_size_read(bd_inode);\n\tloff_t pos = iocb->ki_pos;\n\n\tif (pos >= size)\n\t\treturn 0;\n\n\tsize -= pos;\n\tiov_iter_truncate(to, size);\n\treturn generic_file_read_iter(iocb, to);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "to",
            "size"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bd_inode"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_file_inode",
          "args": [
            "file"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *bd_inode = bdev_file_inode(file);\n\tloff_t size = i_size_read(bd_inode);\n\tloff_t pos = iocb->ki_pos;\n\n\tif (pos >= size)\n\t\treturn 0;\n\n\tsize -= pos;\n\tiov_iter_truncate(to, size);\n\treturn generic_file_read_iter(iocb, to);\n}"
  },
  {
    "function_name": "blkdev_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1893-1921",
    "snippet": "ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *bd_inode = bdev_file_inode(file);\n\tloff_t size = i_size_read(bd_inode);\n\tstruct blk_plug plug;\n\tssize_t ret;\n\n\tif (bdev_read_only(I_BDEV(bd_inode)))\n\t\treturn -EPERM;\n\n\tif (!iov_iter_count(from))\n\t\treturn 0;\n\n\tif (iocb->ki_pos >= size)\n\t\treturn -ENOSPC;\n\n\tif ((iocb->ki_flags & (IOCB_NOWAIT | IOCB_DIRECT)) == IOCB_NOWAIT)\n\t\treturn -EOPNOTSUPP;\n\n\tiov_iter_truncate(from, size - iocb->ki_pos);\n\n\tblk_start_plug(&plug);\n\tret = __generic_file_write_iter(iocb, from);\n\tif (ret > 0)\n\t\tret = generic_write_sync(iocb, ret);\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "iocb",
            "ret"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "size - iocb->ki_pos"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "I_BDEV(bd_inode)"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "bd_inode"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bd_inode"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_file_inode",
          "args": [
            "file"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *bd_inode = bdev_file_inode(file);\n\tloff_t size = i_size_read(bd_inode);\n\tstruct blk_plug plug;\n\tssize_t ret;\n\n\tif (bdev_read_only(I_BDEV(bd_inode)))\n\t\treturn -EPERM;\n\n\tif (!iov_iter_count(from))\n\t\treturn 0;\n\n\tif (iocb->ki_pos >= size)\n\t\treturn -ENOSPC;\n\n\tif ((iocb->ki_flags & (IOCB_NOWAIT | IOCB_DIRECT)) == IOCB_NOWAIT)\n\t\treturn -EOPNOTSUPP;\n\n\tiov_iter_truncate(from, size - iocb->ki_pos);\n\n\tblk_start_plug(&plug);\n\tret = __generic_file_write_iter(iocb, from);\n\tif (ret > 0)\n\t\tret = generic_write_sync(iocb, ret);\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
  },
  {
    "function_name": "block_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1869-1884",
    "snippet": "static long block_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(file));\n\tfmode_t mode = file->f_mode;\n\n\t/*\n\t * O_NDELAY can be altered using fcntl(.., F_SETFL, ..), so we have\n\t * to updated it before every ioctl.\n\t */\n\tif (file->f_flags & O_NDELAY)\n\t\tmode |= FMODE_NDELAY;\n\telse\n\t\tmode &= ~FMODE_NDELAY;\n\n\treturn blkdev_ioctl(bdev, mode, cmd, arg);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_ioctl",
          "args": [
            "bdev",
            "mode",
            "cmd",
            "arg"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "bdev_file_inode(file)"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_file_inode",
          "args": [
            "file"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic long block_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(file));\n\tfmode_t mode = file->f_mode;\n\n\t/*\n\t * O_NDELAY can be altered using fcntl(.., F_SETFL, ..), so we have\n\t * to updated it before every ioctl.\n\t */\n\tif (file->f_flags & O_NDELAY)\n\t\tmode |= FMODE_NDELAY;\n\telse\n\t\tmode &= ~FMODE_NDELAY;\n\n\treturn blkdev_ioctl(bdev, mode, cmd, arg);\n}"
  },
  {
    "function_name": "blkdev_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1862-1867",
    "snippet": "static int blkdev_close(struct inode * inode, struct file * filp)\n{\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(filp));\n\tblkdev_put(bdev, filp->f_mode);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "filp->f_mode"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1814-1859",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "bdev_file_inode(filp)"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_file_inode",
          "args": [
            "filp"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_close(struct inode * inode, struct file * filp)\n{\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(filp));\n\tblkdev_put(bdev, filp->f_mode);\n\treturn 0;\n}"
  },
  {
    "function_name": "blkdev_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1814-1859",
    "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blkdev_put",
          "args": [
            "bdev",
            "mode",
            "0"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1778-1812",
          "snippet": "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\n\t\tbdev_write_inode(bdev);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk_and_module(disk);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\n\t\tbdev_write_inode(bdev);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk_and_module(disk);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_flush_events",
          "args": [
            "bdev->bd_disk",
            "DISK_EVENT_MEDIA_CHANGE"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unblock_events",
          "args": [
            "bdev->bd_disk"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "--bdev->bd_contains->bd_holders < 0"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "--bdev->bd_holders < 0"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
  },
  {
    "function_name": "__blkdev_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1778-1812",
    "snippet": "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\n\t\tbdev_write_inode(bdev);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk_and_module(disk);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blkdev_put",
          "args": [
            "victim",
            "mode",
            "1"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1778-1812",
          "snippet": "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\n\t\tbdev_write_inode(bdev);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk_and_module(disk);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "924-927",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_disk_and_module",
          "args": [
            "disk"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_put_part",
          "args": [
            "bdev->bd_part"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk->fops->release",
          "args": [
            "disk",
            "mode"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_write_inode",
          "args": [
            "bdev"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "57-75",
          "snippet": "static void bdev_write_inode(struct block_device *bdev)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tint ret;\n\n\tspin_lock(&inode->i_lock);\n\twhile (inode->i_state & I_DIRTY) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tret = write_inode_now(inode, true);\n\t\tif (ret) {\n\t\t\tchar name[BDEVNAME_SIZE];\n\t\t\tpr_warn_ratelimited(\"VFS: Dirty inode writeback failed \"\n\t\t\t\t\t    \"for block device %s (err=%d).\\n\",\n\t\t\t\t\t    bdevname(bdev, name), ret);\n\t\t}\n\t\tspin_lock(&inode->i_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void bdev_write_inode(struct block_device *bdev)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tint ret;\n\n\tspin_lock(&inode->i_lock);\n\twhile (inode->i_state & I_DIRTY) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tret = write_inode_now(inode, true);\n\t\tif (ret) {\n\t\t\tchar name[BDEVNAME_SIZE];\n\t\t\tpr_warn_ratelimited(\"VFS: Dirty inode writeback failed \"\n\t\t\t\t\t    \"for block device %s (err=%d).\\n\",\n\t\t\t\t\t    bdevname(bdev, name), ret);\n\t\t}\n\t\tspin_lock(&inode->i_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_bdev",
          "args": [
            "bdev"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "kill_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "78-87",
          "snippet": "void kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "bdev"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "456-459",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "bdev->bd_holders"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&bdev->bd_mutex",
            "for_part"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\n\t\tbdev_write_inode(bdev);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk_and_module(disk);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}"
  },
  {
    "function_name": "blkdev_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1747-1776",
    "snippet": "static int blkdev_open(struct inode * inode, struct file * filp)\n{\n\tstruct block_device *bdev;\n\n\t/*\n\t * Preserve backwards compatibility and allow large file access\n\t * even if userspace doesn't ask for it explicitly. Some mkfs\n\t * binary needs it. We might want to drop this workaround\n\t * during an unstable branch.\n\t */\n\tfilp->f_flags |= O_LARGEFILE;\n\n\tfilp->f_mode |= FMODE_NOWAIT;\n\n\tif (filp->f_flags & O_NDELAY)\n\t\tfilp->f_mode |= FMODE_NDELAY;\n\tif (filp->f_flags & O_EXCL)\n\t\tfilp->f_mode |= FMODE_EXCL;\n\tif ((filp->f_flags & O_ACCMODE) == 3)\n\t\tfilp->f_mode |= FMODE_WRITE_IOCTL;\n\n\tbdev = bd_acquire(inode);\n\tif (bdev == NULL)\n\t\treturn -ENOMEM;\n\n\tfilp->f_mapping = bdev->bd_inode->i_mapping;\n\tfilp->f_wb_err = filemap_sample_wb_err(filp->f_mapping);\n\n\treturn blkdev_get(bdev, filp->f_mode, filp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_get",
          "args": [
            "bdev",
            "filp->f_mode",
            "filp"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1730-1744",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_sample_wb_err",
          "args": [
            "filp->f_mapping"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_acquire",
          "args": [
            "inode"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "bd_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "931-970",
          "snippet": "static struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev && !inode_unhashed(bdev->bd_inode)) {\n\t\tbdgrab(bdev);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\t/*\n\t * i_bdev references block device inode that was already shut down\n\t * (corresponding device got removed).  Remove the reference and look\n\t * up block device inode again just in case new device got\n\t * reestablished under the same device number.\n\t */\n\tif (bdev)\n\t\tbd_forget(inode);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tbdgrab(bdev);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev && !inode_unhashed(bdev->bd_inode)) {\n\t\tbdgrab(bdev);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\t/*\n\t * i_bdev references block device inode that was already shut down\n\t * (corresponding device got removed).  Remove the reference and look\n\t * up block device inode again just in case new device got\n\t * reestablished under the same device number.\n\t */\n\tif (bdev)\n\t\tbd_forget(inode);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tbdgrab(bdev);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_open(struct inode * inode, struct file * filp)\n{\n\tstruct block_device *bdev;\n\n\t/*\n\t * Preserve backwards compatibility and allow large file access\n\t * even if userspace doesn't ask for it explicitly. Some mkfs\n\t * binary needs it. We might want to drop this workaround\n\t * during an unstable branch.\n\t */\n\tfilp->f_flags |= O_LARGEFILE;\n\n\tfilp->f_mode |= FMODE_NOWAIT;\n\n\tif (filp->f_flags & O_NDELAY)\n\t\tfilp->f_mode |= FMODE_NDELAY;\n\tif (filp->f_flags & O_EXCL)\n\t\tfilp->f_mode |= FMODE_EXCL;\n\tif ((filp->f_flags & O_ACCMODE) == 3)\n\t\tfilp->f_mode |= FMODE_WRITE_IOCTL;\n\n\tbdev = bd_acquire(inode);\n\tif (bdev == NULL)\n\t\treturn -ENOMEM;\n\n\tfilp->f_mapping = bdev->bd_inode->i_mapping;\n\tfilp->f_wb_err = filemap_sample_wb_err(filp->f_mapping);\n\n\treturn blkdev_get(bdev, filp->f_mode, filp);\n}"
  },
  {
    "function_name": "blkdev_get_by_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1730-1744",
    "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get",
          "args": [
            "bdev",
            "mode",
            "holder"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1730-1744",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdget",
          "args": [
            "dev"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "bdget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "866-897",
          "snippet": "struct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = i_blocksize(inode);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations def_blk_aops;",
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);",
            "struct super_block *blockdev_superblock",
            "static LIST_HEAD(all_bdevs);",
            "static const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= blkdev_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic const struct address_space_operations def_blk_aops;\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\nstruct super_block *blockdev_superblock;\nstatic LIST_HEAD(all_bdevs);\nstatic const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= blkdev_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};\n\nstruct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = i_blocksize(inode);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
  },
  {
    "function_name": "blkdev_get_by_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1685-1705",
    "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "mode"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1814-1859",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "bdev"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get",
          "args": [
            "bdev",
            "mode",
            "holder"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1730-1744",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_bdev",
          "args": [
            "path"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "2078-2109",
          "snippet": "struct block_device *lookup_bdev(const char *pathname)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tif (!pathname || !*pathname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = kern_path(pathname, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = d_backing_inode(path.dentry);\n\terror = -ENOTBLK;\n\tif (!S_ISBLK(inode->i_mode))\n\t\tgoto fail;\n\terror = -EACCES;\n\tif (!may_open_dev(&path))\n\t\tgoto fail;\n\terror = -ENOMEM;\n\tbdev = bd_acquire(inode);\n\tif (!bdev)\n\t\tgoto fail;\nout:\n\tpath_put(&path);\n\treturn bdev;\nfail:\n\tbdev = ERR_PTR(error);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *lookup_bdev(const char *pathname)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tif (!pathname || !*pathname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = kern_path(pathname, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = d_backing_inode(path.dentry);\n\terror = -ENOTBLK;\n\tif (!S_ISBLK(inode->i_mode))\n\t\tgoto fail;\n\terror = -EACCES;\n\tif (!may_open_dev(&path))\n\t\tgoto fail;\n\terror = -ENOMEM;\n\tbdev = bd_acquire(inode);\n\tif (!bdev)\n\t\tgoto fail;\nout:\n\tpath_put(&path);\n\treturn bdev;\nfail:\n\tbdev = ERR_PTR(error);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
  },
  {
    "function_name": "blkdev_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1602-1665",
    "snippet": "int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder)\n{\n\tstruct block_device *whole = NULL;\n\tint res;\n\n\tWARN_ON_ONCE((mode & FMODE_EXCL) && !holder);\n\n\tif ((mode & FMODE_EXCL) && holder) {\n\t\twhole = bd_start_claiming(bdev, holder);\n\t\tif (IS_ERR(whole)) {\n\t\t\tbdput(bdev);\n\t\t\treturn PTR_ERR(whole);\n\t\t}\n\t}\n\n\tres = __blkdev_get(bdev, mode, 0);\n\n\tif (whole) {\n\t\tstruct gendisk *disk = whole->bd_disk;\n\n\t\t/* finish claiming */\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tspin_lock(&bdev_lock);\n\n\t\tif (!res) {\n\t\t\tBUG_ON(!bd_may_claim(bdev, whole, holder));\n\t\t\t/*\n\t\t\t * Note that for a whole device bd_holders\n\t\t\t * will be incremented twice, and bd_holder\n\t\t\t * will be set to bd_may_claim before being\n\t\t\t * set to holder\n\t\t\t */\n\t\t\twhole->bd_holders++;\n\t\t\twhole->bd_holder = bd_may_claim;\n\t\t\tbdev->bd_holders++;\n\t\t\tbdev->bd_holder = holder;\n\t\t}\n\n\t\t/* tell others that we're done */\n\t\tBUG_ON(whole->bd_claiming != holder);\n\t\twhole->bd_claiming = NULL;\n\t\twake_up_bit(&whole->bd_claiming, 0);\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * Block event polling for write claims if requested.  Any\n\t\t * write holder makes the write_holder state stick until\n\t\t * all are released.  This is good enough and tracking\n\t\t * individual writeable reference is too fragile given the\n\t\t * way @mode is used in blkdev_get/put().\n\t\t */\n\t\tif (!res && (mode & FMODE_WRITE) && !bdev->bd_write_holder &&\n\t\t    (disk->flags & GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE)) {\n\t\t\tbdev->bd_write_holder = true;\n\t\t\tdisk_block_events(disk);\n\t\t}\n\n\t\tmutex_unlock(&bdev->bd_mutex);\n\t\tbdput(whole);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "whole"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "924-927",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_block_events",
          "args": [
            "disk"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&whole->bd_claiming",
            "0"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "whole->bd_claiming != holder"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bd_may_claim(bdev, whole, holder)"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_may_claim",
          "args": [
            "bdev",
            "whole",
            "holder"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "bd_may_claim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1003-1019",
          "snippet": "static bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (whole == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (whole == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blkdev_get",
          "args": [
            "bdev",
            "mode",
            "0"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1435-1581",
          "snippet": "static int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\tbool first_open = false;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tfirst_open = true;\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tbdev->bd_partno = partno;\n\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk_and_module(disk);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\n\t\tif (bdev->bd_bdi == &noop_backing_dev_info)\n\t\t\tbdev->bd_bdi = bdi_get(disk->queue->backing_dev_info);\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\t/* only one opener holds refs to the module and disk */\n\tif (!first_open)\n\t\tput_disk_and_module(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk_and_module(disk);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\tbool first_open = false;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tfirst_open = true;\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tbdev->bd_partno = partno;\n\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk_and_module(disk);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\n\t\tif (bdev->bd_bdi == &noop_backing_dev_info)\n\t\t\tbdev->bd_bdi = bdi_get(disk->queue->backing_dev_info);\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\t/* only one opener holds refs to the module and disk */\n\tif (!first_open)\n\t\tput_disk_and_module(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk_and_module(disk);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "whole"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "whole"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_start_claiming",
          "args": [
            "bdev",
            "holder"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "bd_start_claiming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1108-1155",
          "snippet": "static struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tput_disk_and_module(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tput_disk_and_module(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(mode & FMODE_EXCL) && !holder"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nint blkdev_get(struct block_device *bdev, fmode_t mode, void *holder)\n{\n\tstruct block_device *whole = NULL;\n\tint res;\n\n\tWARN_ON_ONCE((mode & FMODE_EXCL) && !holder);\n\n\tif ((mode & FMODE_EXCL) && holder) {\n\t\twhole = bd_start_claiming(bdev, holder);\n\t\tif (IS_ERR(whole)) {\n\t\t\tbdput(bdev);\n\t\t\treturn PTR_ERR(whole);\n\t\t}\n\t}\n\n\tres = __blkdev_get(bdev, mode, 0);\n\n\tif (whole) {\n\t\tstruct gendisk *disk = whole->bd_disk;\n\n\t\t/* finish claiming */\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tspin_lock(&bdev_lock);\n\n\t\tif (!res) {\n\t\t\tBUG_ON(!bd_may_claim(bdev, whole, holder));\n\t\t\t/*\n\t\t\t * Note that for a whole device bd_holders\n\t\t\t * will be incremented twice, and bd_holder\n\t\t\t * will be set to bd_may_claim before being\n\t\t\t * set to holder\n\t\t\t */\n\t\t\twhole->bd_holders++;\n\t\t\twhole->bd_holder = bd_may_claim;\n\t\t\tbdev->bd_holders++;\n\t\t\tbdev->bd_holder = holder;\n\t\t}\n\n\t\t/* tell others that we're done */\n\t\tBUG_ON(whole->bd_claiming != holder);\n\t\twhole->bd_claiming = NULL;\n\t\twake_up_bit(&whole->bd_claiming, 0);\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * Block event polling for write claims if requested.  Any\n\t\t * write holder makes the write_holder state stick until\n\t\t * all are released.  This is good enough and tracking\n\t\t * individual writeable reference is too fragile given the\n\t\t * way @mode is used in blkdev_get/put().\n\t\t */\n\t\tif (!res && (mode & FMODE_WRITE) && !bdev->bd_write_holder &&\n\t\t    (disk->flags & GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE)) {\n\t\t\tbdev->bd_write_holder = true;\n\t\t\tdisk_block_events(disk);\n\t\t}\n\n\t\tmutex_unlock(&bdev->bd_mutex);\n\t\tbdput(whole);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "__blkdev_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1435-1581",
    "snippet": "static int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\tbool first_open = false;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tfirst_open = true;\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tbdev->bd_partno = partno;\n\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk_and_module(disk);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\n\t\tif (bdev->bd_bdi == &noop_backing_dev_info)\n\t\t\tbdev->bd_bdi = bdi_get(disk->queue->backing_dev_info);\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\t/* only one opener holds refs to the module and disk */\n\tif (!first_open)\n\t\tput_disk_and_module(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk_and_module(disk);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "924-927",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_disk_and_module",
          "args": [
            "disk"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unblock_events",
          "args": [
            "disk"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blkdev_put",
          "args": [
            "bdev->bd_contains",
            "mode",
            "1"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1778-1812",
          "snippet": "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\n\t\tbdev_write_inode(bdev);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk_and_module(disk);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\n\t\tbdev_write_inode(bdev);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk_and_module(disk);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_put_part",
          "args": [
            "bdev->bd_part"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_disk_and_module",
          "args": [
            "disk"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unblock_events",
          "args": [
            "disk"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_partitions",
          "args": [
            "bdev->bd_disk",
            "bdev"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rescan_partitions",
          "args": [
            "bdev->bd_disk",
            "bdev"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev->bd_disk->fops->open",
          "args": [
            "bdev",
            "mode"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_get",
          "args": [
            "disk->queue->backing_dev_info"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_set_size",
          "args": [
            "bdev",
            "(loff_t)bdev->bd_part->nr_sects << 9"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "bd_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1409-1423",
          "snippet": "void bd_set_size(struct block_device *bdev, loff_t size)\n{\n\tunsigned bsize = bdev_logical_block_size(bdev);\n\n\tinode_lock(bdev->bd_inode);\n\ti_size_write(bdev->bd_inode, size);\n\tinode_unlock(bdev->bd_inode);\n\twhile (bsize < PAGE_SIZE) {\n\t\tif (size & bsize)\n\t\t\tbreak;\n\t\tbsize <<= 1;\n\t}\n\tbdev->bd_block_size = bsize;\n\tbdev->bd_inode->i_blkbits = blksize_bits(bsize);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bd_set_size(struct block_device *bdev, loff_t size)\n{\n\tunsigned bsize = bdev_logical_block_size(bdev);\n\n\tinode_lock(bdev->bd_inode);\n\ti_size_write(bdev->bd_inode, size);\n\tinode_unlock(bdev->bd_inode);\n\twhile (bsize < PAGE_SIZE) {\n\t\tif (size & bsize)\n\t\t\tbreak;\n\t\tbsize <<= 1;\n\t}\n\tbdev->bd_block_size = bsize;\n\tbdev->bd_inode->i_blkbits = blksize_bits(bsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_get_part",
          "args": [
            "disk",
            "partno"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blkdev_get",
          "args": [
            "whole",
            "mode",
            "1"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1435-1581",
          "snippet": "static int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\tbool first_open = false;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tfirst_open = true;\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tbdev->bd_partno = partno;\n\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk_and_module(disk);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\n\t\tif (bdev->bd_bdi == &noop_backing_dev_info)\n\t\t\tbdev->bd_bdi = bdi_get(disk->queue->backing_dev_info);\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\t/* only one opener holds refs to the module and disk */\n\tif (!first_open)\n\t\tput_disk_and_module(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk_and_module(disk);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "for_part"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdget_disk",
          "args": [
            "disk",
            "0"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_partitions",
          "args": [
            "disk",
            "bdev"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rescan_partitions",
          "args": [
            "disk",
            "bdev"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_capacity",
          "args": [
            "disk"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_disk_and_module",
          "args": [
            "disk"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unblock_events",
          "args": [
            "disk"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_put_part",
          "args": [
            "bdev->bd_part"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk->fops->open",
          "args": [
            "bdev",
            "mode"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_get_part",
          "args": [
            "disk",
            "partno"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&bdev->bd_mutex",
            "for_part"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_block_events",
          "args": [
            "disk"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_gendisk",
          "args": [
            "bdev",
            "&partno"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_get_gendisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1064-1083",
          "snippet": "static struct gendisk *bdev_get_gendisk(struct block_device *bdev, int *partno)\n{\n\tstruct gendisk *disk = get_gendisk(bdev->bd_dev, partno);\n\n\tif (!disk)\n\t\treturn NULL;\n\t/*\n\t * Now that we hold gendisk reference we make sure bdev we looked up is\n\t * not stale. If it is, it means device got removed and created before\n\t * we looked up gendisk and we fail open in such case. Associating\n\t * unhashed bdev with newly created gendisk could lead to two bdevs\n\t * (and thus two independent caches) being associated with one device\n\t * which is bad.\n\t */\n\tif (inode_unhashed(bdev->bd_inode)) {\n\t\tput_disk_and_module(disk);\n\t\treturn NULL;\n\t}\n\treturn disk;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct gendisk *bdev_get_gendisk(struct block_device *bdev, int *partno)\n{\n\tstruct gendisk *disk = get_gendisk(bdev->bd_dev, partno);\n\n\tif (!disk)\n\t\treturn NULL;\n\t/*\n\t * Now that we hold gendisk reference we make sure bdev we looked up is\n\t * not stale. If it is, it means device got removed and created before\n\t * we looked up gendisk and we fail open in such case. Associating\n\t * unhashed bdev with newly created gendisk could lead to two bdevs\n\t * (and thus two independent caches) being associated with one device\n\t * which is bad.\n\t */\n\tif (inode_unhashed(bdev->bd_inode)) {\n\t\tput_disk_and_module(disk);\n\t\treturn NULL;\n\t}\n\treturn disk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devcgroup_inode_permission",
          "args": [
            "bdev->bd_inode",
            "perm"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\tbool first_open = false;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tfirst_open = true;\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tbdev->bd_partno = partno;\n\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk_and_module(disk);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\n\t\tif (bdev->bd_bdi == &noop_backing_dev_info)\n\t\t\tbdev->bd_bdi = bdi_get(disk->queue->backing_dev_info);\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\t/* only one opener holds refs to the module and disk */\n\tif (!first_open)\n\t\tput_disk_and_module(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk_and_module(disk);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bd_set_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1409-1423",
    "snippet": "void bd_set_size(struct block_device *bdev, loff_t size)\n{\n\tunsigned bsize = bdev_logical_block_size(bdev);\n\n\tinode_lock(bdev->bd_inode);\n\ti_size_write(bdev->bd_inode, size);\n\tinode_unlock(bdev->bd_inode);\n\twhile (bsize < PAGE_SIZE) {\n\t\tif (size & bsize)\n\t\t\tbreak;\n\t\tbsize <<= 1;\n\t}\n\tbdev->bd_block_size = bsize;\n\tbdev->bd_inode->i_blkbits = blksize_bits(bsize);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "bsize"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "bdev->bd_inode",
            "size"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2436-2448",
          "snippet": "static inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bd_set_size(struct block_device *bdev, loff_t size)\n{\n\tunsigned bsize = bdev_logical_block_size(bdev);\n\n\tinode_lock(bdev->bd_inode);\n\ti_size_write(bdev->bd_inode, size);\n\tinode_unlock(bdev->bd_inode);\n\twhile (bsize < PAGE_SIZE) {\n\t\tif (size & bsize)\n\t\t\tbreak;\n\t\tbsize <<= 1;\n\t}\n\tbdev->bd_block_size = bsize;\n\tbdev->bd_inode->i_blkbits = blksize_bits(bsize);\n}"
  },
  {
    "function_name": "check_disk_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1390-1405",
    "snippet": "int check_disk_change(struct block_device *bdev)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tconst struct block_device_operations *bdops = disk->fops;\n\tunsigned int events;\n\n\tevents = disk_clear_events(disk, DISK_EVENT_MEDIA_CHANGE |\n\t\t\t\t   DISK_EVENT_EJECT_REQUEST);\n\tif (!(events & DISK_EVENT_MEDIA_CHANGE))\n\t\treturn 0;\n\n\tflush_disk(bdev, true);\n\tif (bdops->revalidate_disk)\n\t\tbdops->revalidate_disk(bdev->bd_disk);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdops->revalidate_disk",
          "args": [
            "bdev->bd_disk"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "revalidate_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1361-1378",
          "snippet": "int revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev, ret == 0);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev, ret == 0);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_disk",
          "args": [
            "bdev",
            "true"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "flush_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1310-1322",
          "snippet": "static void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\",\n\t\t       bdev->bd_disk ? bdev->bd_disk->disk_name : \"\");\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\",\n\t\t       bdev->bd_disk ? bdev->bd_disk->disk_name : \"\");\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_clear_events",
          "args": [
            "disk",
            "DISK_EVENT_MEDIA_CHANGE |\n\t\t\t\t   DISK_EVENT_EJECT_REQUEST"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint check_disk_change(struct block_device *bdev)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tconst struct block_device_operations *bdops = disk->fops;\n\tunsigned int events;\n\n\tevents = disk_clear_events(disk, DISK_EVENT_MEDIA_CHANGE |\n\t\t\t\t   DISK_EVENT_EJECT_REQUEST);\n\tif (!(events & DISK_EVENT_MEDIA_CHANGE))\n\t\treturn 0;\n\n\tflush_disk(bdev, true);\n\tif (bdops->revalidate_disk)\n\t\tbdops->revalidate_disk(bdev->bd_disk);\n\treturn 1;\n}"
  },
  {
    "function_name": "revalidate_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1361-1378",
    "snippet": "int revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev, ret == 0);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "924-927",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_disk_size_change",
          "args": [
            "disk",
            "bdev",
            "ret == 0"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "check_disk_size_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1334-1351",
          "snippet": "void check_disk_size_change(struct gendisk *disk, struct block_device *bdev,\n\t\tbool verbose)\n{\n\tloff_t disk_size, bdev_size;\n\n\tdisk_size = (loff_t)get_capacity(disk) << 9;\n\tbdev_size = i_size_read(bdev->bd_inode);\n\tif (disk_size != bdev_size) {\n\t\tif (verbose) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"%s: detected capacity change from %lld to %lld\\n\",\n\t\t\t       disk->disk_name, bdev_size, disk_size);\n\t\t}\n\t\ti_size_write(bdev->bd_inode, disk_size);\n\t\tif (bdev_size > disk_size)\n\t\t\tflush_disk(bdev, false);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid check_disk_size_change(struct gendisk *disk, struct block_device *bdev,\n\t\tbool verbose)\n{\n\tloff_t disk_size, bdev_size;\n\n\tdisk_size = (loff_t)get_capacity(disk) << 9;\n\tbdev_size = i_size_read(bdev->bd_inode);\n\tif (disk_size != bdev_size) {\n\t\tif (verbose) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"%s: detected capacity change from %lld to %lld\\n\",\n\t\t\t       disk->disk_name, bdev_size, disk_size);\n\t\t}\n\t\ti_size_write(bdev->bd_inode, disk_size);\n\t\tif (bdev_size > disk_size)\n\t\t\tflush_disk(bdev, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdget_disk",
          "args": [
            "disk",
            "0"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk->fops->revalidate_disk",
          "args": [
            "disk"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "revalidate_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1361-1378",
          "snippet": "int revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev, ret == 0);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev, ret == 0);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}"
  },
  {
    "function_name": "check_disk_size_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1334-1351",
    "snippet": "void check_disk_size_change(struct gendisk *disk, struct block_device *bdev,\n\t\tbool verbose)\n{\n\tloff_t disk_size, bdev_size;\n\n\tdisk_size = (loff_t)get_capacity(disk) << 9;\n\tbdev_size = i_size_read(bdev->bd_inode);\n\tif (disk_size != bdev_size) {\n\t\tif (verbose) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"%s: detected capacity change from %lld to %lld\\n\",\n\t\t\t       disk->disk_name, bdev_size, disk_size);\n\t\t}\n\t\ti_size_write(bdev->bd_inode, disk_size);\n\t\tif (bdev_size > disk_size)\n\t\t\tflush_disk(bdev, false);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_disk",
          "args": [
            "bdev",
            "false"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "flush_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1310-1322",
          "snippet": "static void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\",\n\t\t       bdev->bd_disk ? bdev->bd_disk->disk_name : \"\");\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\",\n\t\t       bdev->bd_disk ? bdev->bd_disk->disk_name : \"\");\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "bdev->bd_inode",
            "disk_size"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2436-2448",
          "snippet": "static inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"%s: detected capacity change from %lld to %lld\\n\"",
            "disk->disk_name",
            "bdev_size",
            "disk_size"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_capacity",
          "args": [
            "disk"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid check_disk_size_change(struct gendisk *disk, struct block_device *bdev,\n\t\tbool verbose)\n{\n\tloff_t disk_size, bdev_size;\n\n\tdisk_size = (loff_t)get_capacity(disk) << 9;\n\tbdev_size = i_size_read(bdev->bd_inode);\n\tif (disk_size != bdev_size) {\n\t\tif (verbose) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"%s: detected capacity change from %lld to %lld\\n\",\n\t\t\t       disk->disk_name, bdev_size, disk_size);\n\t\t}\n\t\ti_size_write(bdev->bd_inode, disk_size);\n\t\tif (bdev_size > disk_size)\n\t\t\tflush_disk(bdev, false);\n\t}\n}"
  },
  {
    "function_name": "flush_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1310-1322",
    "snippet": "static void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\",\n\t\t       bdev->bd_disk ? bdev->bd_disk->disk_name : \"\");\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disk_part_scan_enabled",
          "args": [
            "bdev->bd_disk"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\"",
            "bdev->bd_disk ? bdev->bd_disk->disk_name : \"\""
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cachefiles/namei.c",
          "lines": "74-81",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__invalidate_device",
          "args": [
            "bdev",
            "kill_dirty"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "__invalidate_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "2112-2130",
          "snippet": "int __invalidate_device(struct block_device *bdev, bool kill_dirty)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tint res = 0;\n\n\tif (sb) {\n\t\t/*\n\t\t * no need to lock the super, get_super holds the\n\t\t * read mutex so the filesystem cannot go away\n\t\t * under us (->put_super runs with the write lock\n\t\t * hold).\n\t\t */\n\t\tshrink_dcache_sb(sb);\n\t\tres = invalidate_inodes(sb, kill_dirty);\n\t\tdrop_super(sb);\n\t}\n\tinvalidate_bdev(bdev);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint __invalidate_device(struct block_device *bdev, bool kill_dirty)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tint res = 0;\n\n\tif (sb) {\n\t\t/*\n\t\t * no need to lock the super, get_super holds the\n\t\t * read mutex so the filesystem cannot go away\n\t\t * under us (->put_super runs with the write lock\n\t\t * hold).\n\t\t */\n\t\tshrink_dcache_sb(sb);\n\t\tres = invalidate_inodes(sb, kill_dirty);\n\t\tdrop_super(sb);\n\t}\n\tinvalidate_bdev(bdev);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\",\n\t\t       bdev->bd_disk ? bdev->bd_disk->disk_name : \"\");\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}"
  },
  {
    "function_name": "bd_unlink_disk_holder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1278-1296",
    "snippet": "void bd_unlink_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tmutex_lock(&bdev->bd_mutex);\n\n\tholder = bd_find_holder_disk(bdev, disk);\n\n\tif (!WARN_ON_ONCE(holder == NULL) && !--holder->refcnt) {\n\t\tdel_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\n\t\tdel_symlink(bdev->bd_part->holder_dir,\n\t\t\t    &disk_to_dev(disk)->kobj);\n\t\tkobject_put(bdev->bd_part->holder_dir);\n\t\tlist_del_init(&holder->list);\n\t\tkfree(holder);\n\t}\n\n\tmutex_unlock(&bdev->bd_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "holder"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&holder->list"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "bdev->bd_part->holder_dir"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_symlink",
          "args": [
            "bdev->bd_part->holder_dir",
            "&disk_to_dev(disk)->kobj"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "del_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1180-1183",
          "snippet": "static void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_to_dev",
          "args": [
            "disk"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_to_dev",
          "args": [
            "bdev->bd_part"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "holder == NULL"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_find_holder_disk",
          "args": [
            "bdev",
            "disk"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "bd_find_holder_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1164-1173",
          "snippet": "static struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bd_unlink_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tmutex_lock(&bdev->bd_mutex);\n\n\tholder = bd_find_holder_disk(bdev, disk);\n\n\tif (!WARN_ON_ONCE(holder == NULL) && !--holder->refcnt) {\n\t\tdel_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\n\t\tdel_symlink(bdev->bd_part->holder_dir,\n\t\t\t    &disk_to_dev(disk)->kobj);\n\t\tkobject_put(bdev->bd_part->holder_dir);\n\t\tlist_del_init(&holder->list);\n\t\tkfree(holder);\n\t}\n\n\tmutex_unlock(&bdev->bd_mutex);\n}"
  },
  {
    "function_name": "bd_link_disk_holder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1213-1265",
    "snippet": "int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\tint ret = 0;\n\n\tmutex_lock(&bdev->bd_mutex);\n\n\tWARN_ON_ONCE(!bdev->bd_holder);\n\n\t/* FIXME: remove the following once add_disk() handles errors */\n\tif (WARN_ON(!disk->slave_dir || !bdev->bd_part->holder_dir))\n\t\tgoto out_unlock;\n\n\tholder = bd_find_holder_disk(bdev, disk);\n\tif (holder) {\n\t\tholder->refcnt++;\n\t\tgoto out_unlock;\n\t}\n\n\tholder = kzalloc(sizeof(*holder), GFP_KERNEL);\n\tif (!holder) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_LIST_HEAD(&holder->list);\n\tholder->disk = disk;\n\tholder->refcnt = 1;\n\n\tret = add_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = add_symlink(bdev->bd_part->holder_dir, &disk_to_dev(disk)->kobj);\n\tif (ret)\n\t\tgoto out_del;\n\t/*\n\t * bdev could be deleted beneath us which would implicitly destroy\n\t * the holder directory.  Hold on to it.\n\t */\n\tkobject_get(bdev->bd_part->holder_dir);\n\n\tlist_add(&holder->list, &bdev->bd_holder_disks);\n\tgoto out_unlock;\n\nout_del:\n\tdel_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\nout_free:\n\tkfree(holder);\nout_unlock:\n\tmutex_unlock(&bdev->bd_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "holder"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_symlink",
          "args": [
            "disk->slave_dir",
            "&part_to_dev(bdev->bd_part)->kobj"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "del_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1180-1183",
          "snippet": "static void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}"
        }
      },
      {
        "call_info": {
          "callee": "part_to_dev",
          "args": [
            "bdev->bd_part"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&holder->list",
            "&bdev->bd_holder_disks"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_get",
          "args": [
            "bdev->bd_part->holder_dir"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_symlink",
          "args": [
            "bdev->bd_part->holder_dir",
            "&disk_to_dev(disk)->kobj"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "add_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1175-1178",
          "snippet": "static int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_to_dev",
          "args": [
            "disk"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_to_dev",
          "args": [
            "bdev->bd_part"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&holder->list"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*holder)",
            "GFP_KERNEL"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_find_holder_disk",
          "args": [
            "bdev",
            "disk"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "bd_find_holder_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1164-1173",
          "snippet": "static struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!disk->slave_dir || !bdev->bd_part->holder_dir"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!bdev->bd_holder"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\tint ret = 0;\n\n\tmutex_lock(&bdev->bd_mutex);\n\n\tWARN_ON_ONCE(!bdev->bd_holder);\n\n\t/* FIXME: remove the following once add_disk() handles errors */\n\tif (WARN_ON(!disk->slave_dir || !bdev->bd_part->holder_dir))\n\t\tgoto out_unlock;\n\n\tholder = bd_find_holder_disk(bdev, disk);\n\tif (holder) {\n\t\tholder->refcnt++;\n\t\tgoto out_unlock;\n\t}\n\n\tholder = kzalloc(sizeof(*holder), GFP_KERNEL);\n\tif (!holder) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_LIST_HEAD(&holder->list);\n\tholder->disk = disk;\n\tholder->refcnt = 1;\n\n\tret = add_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = add_symlink(bdev->bd_part->holder_dir, &disk_to_dev(disk)->kobj);\n\tif (ret)\n\t\tgoto out_del;\n\t/*\n\t * bdev could be deleted beneath us which would implicitly destroy\n\t * the holder directory.  Hold on to it.\n\t */\n\tkobject_get(bdev->bd_part->holder_dir);\n\n\tlist_add(&holder->list, &bdev->bd_holder_disks);\n\tgoto out_unlock;\n\nout_del:\n\tdel_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\nout_free:\n\tkfree(holder);\nout_unlock:\n\tmutex_unlock(&bdev->bd_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "del_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1180-1183",
    "snippet": "static void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_remove_link",
          "args": [
            "from",
            "kobject_name(to)"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_remove_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sysfs/symlink.c",
          "lines": "142-152",
          "snippet": "void sysfs_remove_link(struct kobject *kobj, const char *name)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tkernfs_remove_by_name(parent, name);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid sysfs_remove_link(struct kobject *kobj, const char *name)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tkernfs_remove_by_name(parent, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_name",
          "args": [
            "to"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}"
  },
  {
    "function_name": "add_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1175-1178",
    "snippet": "static int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_link",
          "args": [
            "from",
            "to",
            "kobject_name(to)"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_create_link_nowarn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sysfs/symlink.c",
          "lines": "104-108",
          "snippet": "int sysfs_create_link_nowarn(struct kobject *kobj, struct kobject *target,\n\t\t\t     const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 0);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint sysfs_create_link_nowarn(struct kobject *kobj, struct kobject *target,\n\t\t\t     const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_name",
          "args": [
            "to"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}"
  },
  {
    "function_name": "bd_find_holder_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1164-1173",
    "snippet": "static struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "holder",
            "&bdev->bd_holder_disks",
            "list"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}"
  },
  {
    "function_name": "bd_start_claiming",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1108-1155",
    "snippet": "static struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tput_disk_and_module(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "whole"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "924-927",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bd_prepare_to_claim",
          "args": [
            "bdev",
            "whole",
            "holder"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "bd_prepare_to_claim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1039-1062",
          "snippet": "static int bd_prepare_to_claim(struct block_device *bdev,\n\t\t\t       struct block_device *whole, void *holder)\n{\nretry:\n\t/* if someone else claimed, fail */\n\tif (!bd_may_claim(bdev, whole, holder))\n\t\treturn -EBUSY;\n\n\t/* if claiming is already in progress, wait for it to finish */\n\tif (whole->bd_claiming) {\n\t\twait_queue_head_t *wq = bit_waitqueue(&whole->bd_claiming, 0);\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&bdev_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait);\n\t\tspin_lock(&bdev_lock);\n\t\tgoto retry;\n\t}\n\n\t/* yay, all mine */\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic int bd_prepare_to_claim(struct block_device *bdev,\n\t\t\t       struct block_device *whole, void *holder)\n{\nretry:\n\t/* if someone else claimed, fail */\n\tif (!bd_may_claim(bdev, whole, holder))\n\t\treturn -EBUSY;\n\n\t/* if claiming is already in progress, wait for it to finish */\n\tif (whole->bd_claiming) {\n\t\twait_queue_head_t *wq = bit_waitqueue(&whole->bd_claiming, 0);\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&bdev_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait);\n\t\tspin_lock(&bdev_lock);\n\t\tgoto retry;\n\t}\n\n\t/* yay, all mine */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_disk_and_module",
          "args": [
            "disk"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdgrab",
          "args": [
            "bdev"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "bdgrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "905-909",
          "snippet": "struct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdget_disk",
          "args": [
            "disk",
            "0"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENXIO"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_gendisk",
          "args": [
            "bdev",
            "&partno"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_get_gendisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1064-1083",
          "snippet": "static struct gendisk *bdev_get_gendisk(struct block_device *bdev, int *partno)\n{\n\tstruct gendisk *disk = get_gendisk(bdev->bd_dev, partno);\n\n\tif (!disk)\n\t\treturn NULL;\n\t/*\n\t * Now that we hold gendisk reference we make sure bdev we looked up is\n\t * not stale. If it is, it means device got removed and created before\n\t * we looked up gendisk and we fail open in such case. Associating\n\t * unhashed bdev with newly created gendisk could lead to two bdevs\n\t * (and thus two independent caches) being associated with one device\n\t * which is bad.\n\t */\n\tif (inode_unhashed(bdev->bd_inode)) {\n\t\tput_disk_and_module(disk);\n\t\treturn NULL;\n\t}\n\treturn disk;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct gendisk *bdev_get_gendisk(struct block_device *bdev, int *partno)\n{\n\tstruct gendisk *disk = get_gendisk(bdev->bd_dev, partno);\n\n\tif (!disk)\n\t\treturn NULL;\n\t/*\n\t * Now that we hold gendisk reference we make sure bdev we looked up is\n\t * not stale. If it is, it means device got removed and created before\n\t * we looked up gendisk and we fail open in such case. Associating\n\t * unhashed bdev with newly created gendisk could lead to two bdevs\n\t * (and thus two independent caches) being associated with one device\n\t * which is bad.\n\t */\n\tif (inode_unhashed(bdev->bd_inode)) {\n\t\tput_disk_and_module(disk);\n\t\treturn NULL;\n\t}\n\treturn disk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tput_disk_and_module(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}"
  },
  {
    "function_name": "bdev_get_gendisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1064-1083",
    "snippet": "static struct gendisk *bdev_get_gendisk(struct block_device *bdev, int *partno)\n{\n\tstruct gendisk *disk = get_gendisk(bdev->bd_dev, partno);\n\n\tif (!disk)\n\t\treturn NULL;\n\t/*\n\t * Now that we hold gendisk reference we make sure bdev we looked up is\n\t * not stale. If it is, it means device got removed and created before\n\t * we looked up gendisk and we fail open in such case. Associating\n\t * unhashed bdev with newly created gendisk could lead to two bdevs\n\t * (and thus two independent caches) being associated with one device\n\t * which is bad.\n\t */\n\tif (inode_unhashed(bdev->bd_inode)) {\n\t\tput_disk_and_module(disk);\n\t\treturn NULL;\n\t}\n\treturn disk;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_disk_and_module",
          "args": [
            "disk"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gendisk",
          "args": [
            "bdev->bd_dev",
            "partno"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_get_gendisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1064-1083",
          "snippet": "static struct gendisk *bdev_get_gendisk(struct block_device *bdev, int *partno)\n{\n\tstruct gendisk *disk = get_gendisk(bdev->bd_dev, partno);\n\n\tif (!disk)\n\t\treturn NULL;\n\t/*\n\t * Now that we hold gendisk reference we make sure bdev we looked up is\n\t * not stale. If it is, it means device got removed and created before\n\t * we looked up gendisk and we fail open in such case. Associating\n\t * unhashed bdev with newly created gendisk could lead to two bdevs\n\t * (and thus two independent caches) being associated with one device\n\t * which is bad.\n\t */\n\tif (inode_unhashed(bdev->bd_inode)) {\n\t\tput_disk_and_module(disk);\n\t\treturn NULL;\n\t}\n\treturn disk;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct gendisk *bdev_get_gendisk(struct block_device *bdev, int *partno)\n{\n\tstruct gendisk *disk = get_gendisk(bdev->bd_dev, partno);\n\n\tif (!disk)\n\t\treturn NULL;\n\t/*\n\t * Now that we hold gendisk reference we make sure bdev we looked up is\n\t * not stale. If it is, it means device got removed and created before\n\t * we looked up gendisk and we fail open in such case. Associating\n\t * unhashed bdev with newly created gendisk could lead to two bdevs\n\t * (and thus two independent caches) being associated with one device\n\t * which is bad.\n\t */\n\tif (inode_unhashed(bdev->bd_inode)) {\n\t\tput_disk_and_module(disk);\n\t\treturn NULL;\n\t}\n\treturn disk;\n}"
  },
  {
    "function_name": "bd_prepare_to_claim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1039-1062",
    "snippet": "static int bd_prepare_to_claim(struct block_device *bdev,\n\t\t\t       struct block_device *whole, void *holder)\n{\nretry:\n\t/* if someone else claimed, fail */\n\tif (!bd_may_claim(bdev, whole, holder))\n\t\treturn -EBUSY;\n\n\t/* if claiming is already in progress, wait for it to finish */\n\tif (whole->bd_claiming) {\n\t\twait_queue_head_t *wq = bit_waitqueue(&whole->bd_claiming, 0);\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&bdev_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait);\n\t\tspin_lock(&bdev_lock);\n\t\tgoto retry;\n\t}\n\n\t/* yay, all mine */\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&wait"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&whole->bd_claiming",
            "0"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_may_claim",
          "args": [
            "bdev",
            "whole",
            "holder"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "bd_may_claim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1003-1019",
          "snippet": "static bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (whole == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (whole == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic int bd_prepare_to_claim(struct block_device *bdev,\n\t\t\t       struct block_device *whole, void *holder)\n{\nretry:\n\t/* if someone else claimed, fail */\n\tif (!bd_may_claim(bdev, whole, holder))\n\t\treturn -EBUSY;\n\n\t/* if claiming is already in progress, wait for it to finish */\n\tif (whole->bd_claiming) {\n\t\twait_queue_head_t *wq = bit_waitqueue(&whole->bd_claiming, 0);\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&bdev_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait);\n\t\tspin_lock(&bdev_lock);\n\t\tgoto retry;\n\t}\n\n\t/* yay, all mine */\n\treturn 0;\n}"
  },
  {
    "function_name": "bd_may_claim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "1003-1019",
    "snippet": "static bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (whole == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (whole == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}"
  },
  {
    "function_name": "bd_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "974-987",
    "snippet": "void bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tbdput(bdev);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "924-927",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_is_blkdev_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tbdput(bdev);\n}"
  },
  {
    "function_name": "bd_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "931-970",
    "snippet": "static struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev && !inode_unhashed(bdev->bd_inode)) {\n\t\tbdgrab(bdev);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\t/*\n\t * i_bdev references block device inode that was already shut down\n\t * (corresponding device got removed).  Remove the reference and look\n\t * up block device inode again just in case new device got\n\t * reestablished under the same device number.\n\t */\n\tif (bdev)\n\t\tbd_forget(inode);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tbdgrab(bdev);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdgrab",
          "args": [
            "bdev"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "bdgrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "905-909",
          "snippet": "struct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdget",
          "args": [
            "inode->i_rdev"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "bdget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "866-897",
          "snippet": "struct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = i_blocksize(inode);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations def_blk_aops;",
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);",
            "struct super_block *blockdev_superblock",
            "static LIST_HEAD(all_bdevs);",
            "static const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= blkdev_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic const struct address_space_operations def_blk_aops;\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\nstruct super_block *blockdev_superblock;\nstatic LIST_HEAD(all_bdevs);\nstatic const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= blkdev_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};\n\nstruct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = i_blocksize(inode);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bd_forget",
          "args": [
            "inode"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "bd_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "974-987",
          "snippet": "void bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tbdput(bdev);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tbdput(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev && !inode_unhashed(bdev->bd_inode)) {\n\t\tbdgrab(bdev);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\t/*\n\t * i_bdev references block device inode that was already shut down\n\t * (corresponding device got removed).  Remove the reference and look\n\t * up block device inode again just in case new device got\n\t * reestablished under the same device number.\n\t */\n\tif (bdev)\n\t\tbd_forget(inode);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tbdgrab(bdev);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}"
  },
  {
    "function_name": "bdput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "924-927",
    "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
  },
  {
    "function_name": "nr_blockdev_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "912-922",
    "snippet": "long nr_blockdev_pages(void)\n{\n\tstruct block_device *bdev;\n\tlong ret = 0;\n\tspin_lock(&bdev_lock);\n\tlist_for_each_entry(bdev, &all_bdevs, bd_list) {\n\t\tret += bdev->bd_inode->i_mapping->nrpages;\n\t}\n\tspin_unlock(&bdev_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);",
      "static LIST_HEAD(all_bdevs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bdev",
            "&all_bdevs",
            "bd_list"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\nstatic LIST_HEAD(all_bdevs);\n\nlong nr_blockdev_pages(void)\n{\n\tstruct block_device *bdev;\n\tlong ret = 0;\n\tspin_lock(&bdev_lock);\n\tlist_for_each_entry(bdev, &all_bdevs, bd_list) {\n\t\tret += bdev->bd_inode->i_mapping->nrpages;\n\t}\n\tspin_unlock(&bdev_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "bdgrab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "905-909",
    "snippet": "struct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "402-405",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}"
  },
  {
    "function_name": "bdget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "866-897",
    "snippet": "struct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = i_blocksize(inode);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations def_blk_aops;",
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);",
      "struct super_block *blockdev_superblock",
      "static LIST_HEAD(all_bdevs);",
      "static const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= blkdev_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "970-979",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW & ~I_CREATING;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW & ~I_CREATING;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bdev->bd_list",
            "&all_bdevs"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "&inode->i_data",
            "GFP_USER"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "blockdev_superblock",
            "hash(dev)",
            "bdev_test",
            "bdev_set",
            "&dev"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1119-1136",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5(sb, hashval, test, data);\n\n\tif (!inode) {\n\t\tstruct inode *new = alloc_inode(sb);\n\n\t\tif (new) {\n\t\t\tnew->i_state = 0;\n\t\t\tinode = inode_insert5(new, hashval, test, set, data);\n\t\t\tif (unlikely(inode != new))\n\t\t\t\tdestroy_inode(new);\n\t\t}\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5(sb, hashval, test, data);\n\n\tif (!inode) {\n\t\tstruct inode *new = alloc_inode(sb);\n\n\t\tif (new) {\n\t\t\tnew->i_state = 0;\n\t\t\tinode = inode_insert5(new, hashval, test, set, data);\n\t\t\tif (unlikely(inode != new))\n\t\t\t\tdestroy_inode(new);\n\t\t}\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "dev"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_unhash_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "855-864",
          "snippet": "void bdev_unhash_inode(dev_t dev)\n{\n\tstruct inode *inode;\n\n\tinode = ilookup5(blockdev_superblock, hash(dev), bdev_test, &dev);\n\tif (inode) {\n\t\tremove_inode_hash(inode);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct super_block *blockdev_superblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct super_block *blockdev_superblock;\n\nvoid bdev_unhash_inode(dev_t dev)\n{\n\tstruct inode *inode;\n\n\tinode = ilookup5(blockdev_superblock, hash(dev), bdev_test, &dev);\n\tif (inode) {\n\t\tremove_inode_hash(inode);\n\t\tiput(inode);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic const struct address_space_operations def_blk_aops;\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\nstruct super_block *blockdev_superblock;\nstatic LIST_HEAD(all_bdevs);\nstatic const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= blkdev_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};\n\nstruct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = i_blocksize(inode);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}"
  },
  {
    "function_name": "bdev_unhash_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "855-864",
    "snippet": "void bdev_unhash_inode(dev_t dev)\n{\n\tstruct inode *inode;\n\n\tinode = ilookup5(blockdev_superblock, hash(dev), bdev_test, &dev);\n\tif (inode) {\n\t\tremove_inode_hash(inode);\n\t\tiput(inode);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct super_block *blockdev_superblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_inode_hash",
          "args": [
            "inode"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "494-501",
          "snippet": "void __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "blockdev_superblock",
            "hash(dev)",
            "bdev_test",
            "&dev"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1340-1354",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode;\nagain:\n\tinode = ilookup5_nowait(sb, hashval, test, data);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode;\nagain:\n\tinode = ilookup5_nowait(sb, hashval, test, data);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "dev"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_unhash_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "855-864",
          "snippet": "void bdev_unhash_inode(dev_t dev)\n{\n\tstruct inode *inode;\n\n\tinode = ilookup5(blockdev_superblock, hash(dev), bdev_test, &dev);\n\tif (inode) {\n\t\tremove_inode_hash(inode);\n\t\tiput(inode);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct super_block *blockdev_superblock;\n\nvoid bdev_unhash_inode(dev_t dev)\n{\n\tstruct inode *inode;\n\n\tinode = ilookup5(blockdev_superblock, hash(dev), bdev_test, &dev);\n\tif (inode) {\n\t\tremove_inode_hash(inode);\n\t\tiput(inode);\n\t}\n}"
  },
  {
    "function_name": "bdev_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "843-847",
    "snippet": "static int bdev_set(struct inode *inode, void *data)\n{\n\tBDEV_I(inode)->bdev.bd_dev = *(dev_t *)data;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int bdev_set(struct inode *inode, void *data)\n{\n\tBDEV_I(inode)->bdev.bd_dev = *(dev_t *)data;\n\treturn 0;\n}"
  },
  {
    "function_name": "bdev_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "838-841",
    "snippet": "static int bdev_test(struct inode *inode, void *data)\n{\n\treturn BDEV_I(inode)->bdev.bd_dev == *(dev_t *)data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int bdev_test(struct inode *inode, void *data)\n{\n\treturn BDEV_I(inode)->bdev.bd_dev == *(dev_t *)data;\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "833-836",
    "snippet": "static inline unsigned long hash(dev_t dev)\n{\n\treturn MAJOR(dev)+MINOR(dev);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline unsigned long hash(dev_t dev)\n{\n\treturn MAJOR(dev)+MINOR(dev);\n}"
  },
  {
    "function_name": "bdev_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "810-826",
    "snippet": "void __init bdev_cache_init(void)\n{\n\tint err;\n\tstatic struct vfsmount *bd_mnt;\n\n\tbdev_cachep = kmem_cache_create(\"bdev_cache\", sizeof(struct bdev_inode),\n\t\t\t0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT|SLAB_PANIC),\n\t\t\tinit_once);\n\terr = register_filesystem(&bd_type);\n\tif (err)\n\t\tpanic(\"Cannot register bdev pseudo-fs\");\n\tbd_mnt = kern_mount(&bd_type);\n\tif (IS_ERR(bd_mnt))\n\t\tpanic(\"Cannot create bdev pseudo-fs\");\n\tblockdev_superblock = bd_mnt->mnt_sb;   /* For writeback */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * bdev_cachep",
      "static struct file_system_type bd_type = {\n\t.name\t\t= \"bdev\",\n\t.mount\t\t= bd_mount,\n\t.kill_sb\t= kill_anon_super,\n};",
      "struct super_block *blockdev_superblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Cannot create bdev pseudo-fs\""
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bd_mnt"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&bd_type"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Cannot register bdev pseudo-fs\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&bd_type"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/filesystems.c",
          "lines": "103-122",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"bdev_cache\"",
            "sizeof(struct bdev_inode)",
            "0",
            "(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT|SLAB_PANIC)",
            "init_once"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * bdev_cachep;\nstatic struct file_system_type bd_type = {\n\t.name\t\t= \"bdev\",\n\t.mount\t\t= bd_mount,\n\t.kill_sb\t= kill_anon_super,\n};\nstruct super_block *blockdev_superblock;\n\nvoid __init bdev_cache_init(void)\n{\n\tint err;\n\tstatic struct vfsmount *bd_mnt;\n\n\tbdev_cachep = kmem_cache_create(\"bdev_cache\", sizeof(struct bdev_inode),\n\t\t\t0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT|SLAB_PANIC),\n\t\t\tinit_once);\n\terr = register_filesystem(&bd_type);\n\tif (err)\n\t\tpanic(\"Cannot register bdev pseudo-fs\");\n\tbd_mnt = kern_mount(&bd_type);\n\tif (IS_ERR(bd_mnt))\n\t\tpanic(\"Cannot create bdev pseudo-fs\");\n\tblockdev_superblock = bd_mnt->mnt_sb;   /* For writeback */\n}"
  },
  {
    "function_name": "bd_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "791-799",
    "snippet": "static struct dentry *bd_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tstruct dentry *dent;\n\tdent = mount_pseudo(fs_type, \"bdev:\", &bdev_sops, NULL, BDEVFS_MAGIC);\n\tif (!IS_ERR(dent))\n\t\tdent->d_sb->s_iflags |= SB_I_CGROUPWB;\n\treturn dent;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations bdev_sops = {\n\t.statfs = simple_statfs,\n\t.alloc_inode = bdev_alloc_inode,\n\t.destroy_inode = bdev_destroy_inode,\n\t.drop_inode = generic_delete_inode,\n\t.evict_inode = bdev_evict_inode,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_pseudo",
          "args": [
            "fs_type",
            "\"bdev:\"",
            "&bdev_sops",
            "NULL",
            "BDEVFS_MAGIC"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic const struct super_operations bdev_sops = {\n\t.statfs = simple_statfs,\n\t.alloc_inode = bdev_alloc_inode,\n\t.destroy_inode = bdev_destroy_inode,\n\t.drop_inode = generic_delete_inode,\n\t.evict_inode = bdev_evict_inode,\n};\n\nstatic struct dentry *bd_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tstruct dentry *dent;\n\tdent = mount_pseudo(fs_type, \"bdev:\", &bdev_sops, NULL, BDEVFS_MAGIC);\n\tif (!IS_ERR(dent))\n\t\tdent->d_sb->s_iflags |= SB_I_CGROUPWB;\n\treturn dent;\n}"
  },
  {
    "function_name": "bdev_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "766-781",
    "snippet": "static void bdev_evict_inode(struct inode *inode)\n{\n\tstruct block_device *bdev = &BDEV_I(inode)->bdev;\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode); /* is it needed here? */\n\tclear_inode(inode);\n\tspin_lock(&bdev_lock);\n\tlist_del_init(&bdev->bd_list);\n\tspin_unlock(&bdev_lock);\n\t/* Detach inode from wb early as bdi_put() may free bdi->wb */\n\tinode_detach_wb(inode);\n\tif (bdev->bd_bdi != &noop_backing_dev_info) {\n\t\tbdi_put(bdev->bd_bdi);\n\t\tbdev->bd_bdi = &noop_backing_dev_info;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_put",
          "args": [
            "bdev->bd_bdi"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_detach_wb",
          "args": [
            "inode"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bdev->bd_list"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "504-521",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "759-771",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic void bdev_evict_inode(struct inode *inode)\n{\n\tstruct block_device *bdev = &BDEV_I(inode)->bdev;\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode); /* is it needed here? */\n\tclear_inode(inode);\n\tspin_lock(&bdev_lock);\n\tlist_del_init(&bdev->bd_list);\n\tspin_unlock(&bdev_lock);\n\t/* Detach inode from wb early as bdi_put() may free bdi->wb */\n\tinode_detach_wb(inode);\n\tif (bdev->bd_bdi != &noop_backing_dev_info) {\n\t\tbdi_put(bdev->bd_bdi);\n\t\tbdev->bd_bdi = &noop_backing_dev_info;\n\t}\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "749-764",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct bdev_inode *ei = (struct bdev_inode *) foo;\n\tstruct block_device *bdev = &ei->bdev;\n\n\tmemset(bdev, 0, sizeof(*bdev));\n\tmutex_init(&bdev->bd_mutex);\n\tINIT_LIST_HEAD(&bdev->bd_list);\n#ifdef CONFIG_SYSFS\n\tINIT_LIST_HEAD(&bdev->bd_holder_disks);\n#endif\n\tbdev->bd_bdi = &noop_backing_dev_info;\n\tinode_init_once(&ei->vfs_inode);\n\t/* Initialize mutex for freeze. */\n\tmutex_init(&bdev->bd_fsfreeze_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "371-381",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_io_list);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\t__address_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_io_list);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\t__address_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bdev->bd_holder_disks"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bdev->bd_list"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bdev",
            "0",
            "sizeof(*bdev)"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct bdev_inode *ei = (struct bdev_inode *) foo;\n\tstruct block_device *bdev = &ei->bdev;\n\n\tmemset(bdev, 0, sizeof(*bdev));\n\tmutex_init(&bdev->bd_mutex);\n\tINIT_LIST_HEAD(&bdev->bd_list);\n#ifdef CONFIG_SYSFS\n\tINIT_LIST_HEAD(&bdev->bd_holder_disks);\n#endif\n\tbdev->bd_bdi = &noop_backing_dev_info;\n\tinode_init_once(&ei->vfs_inode);\n\t/* Initialize mutex for freeze. */\n\tmutex_init(&bdev->bd_fsfreeze_mutex);\n}"
  },
  {
    "function_name": "bdev_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "744-747",
    "snippet": "static void bdev_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, bdev_i_callback);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "bdev_i_callback"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void bdev_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, bdev_i_callback);\n}"
  },
  {
    "function_name": "bdev_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "736-742",
    "snippet": "static void bdev_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct bdev_inode *bdi = BDEV_I(inode);\n\n\tkmem_cache_free(bdev_cachep, bdi);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * bdev_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "bdev_cachep",
            "bdi"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * bdev_cachep;\n\nstatic void bdev_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct bdev_inode *bdi = BDEV_I(inode);\n\n\tkmem_cache_free(bdev_cachep, bdi);\n}"
  },
  {
    "function_name": "bdev_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "728-734",
    "snippet": "static struct inode *bdev_alloc_inode(struct super_block *sb)\n{\n\tstruct bdev_inode *ei = kmem_cache_alloc(bdev_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * bdev_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "bdev_cachep",
            "GFP_KERNEL"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * bdev_cachep;\n\nstatic struct inode *bdev_alloc_inode(struct super_block *sb)\n{\n\tstruct bdev_inode *ei = kmem_cache_alloc(bdev_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "bdev_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "695-718",
    "snippet": "int bdev_write_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page, struct writeback_control *wbc)\n{\n\tint result;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (!ops->rw_page || bdev_get_integrity(bdev))\n\t\treturn -EOPNOTSUPP;\n\tresult = blk_queue_enter(bdev->bd_queue, 0);\n\tif (result)\n\t\treturn result;\n\n\tset_page_writeback(page);\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page,\n\t\t\t      REQ_OP_WRITE);\n\tif (result) {\n\t\tend_page_writeback(page);\n\t} else {\n\t\tclean_page_buffers(page);\n\t\tunlock_page(page);\n\t}\n\tblk_queue_exit(bdev->bd_queue);\n\treturn result;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_queue_exit",
          "args": [
            "bdev->bd_queue"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_page_buffers",
          "args": [
            "page"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "clean_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "491-494",
          "snippet": "void clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid clean_page_buffers(struct page *page)\n{\n\tclean_buffers(page, ~0U);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/write.c",
          "lines": "346-360",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tbool is_done;\n\n\tis_done = nfs_page_group_sync_on_bit(req, PG_WB_END);\n\tnfs_unlock_request(req);\n\tif (!is_done)\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/iversion.h>",
            "#include <linux/wait.h>",
            "#include <linux/freezer.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tbool is_done;\n\n\tis_done = nfs_page_group_sync_on_bit(req, PG_WB_END);\n\tnfs_unlock_request(req);\n\tif (!is_done)\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->rw_page",
          "args": [
            "bdev",
            "sector + get_start_sect(bdev)",
            "page",
            "REQ_OP_WRITE"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_start_sect",
          "args": [
            "bdev"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/write.c",
          "lines": "333-344",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH)\n\t\tset_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/iversion.h>",
            "#include <linux/wait.h>",
            "#include <linux/freezer.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH)\n\t\tset_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_queue_enter",
          "args": [
            "bdev->bd_queue",
            "0"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_integrity",
          "args": [
            "bdev"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bdev_write_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page, struct writeback_control *wbc)\n{\n\tint result;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (!ops->rw_page || bdev_get_integrity(bdev))\n\t\treturn -EOPNOTSUPP;\n\tresult = blk_queue_enter(bdev->bd_queue, 0);\n\tif (result)\n\t\treturn result;\n\n\tset_page_writeback(page);\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page,\n\t\t\t      REQ_OP_WRITE);\n\tif (result) {\n\t\tend_page_writeback(page);\n\t} else {\n\t\tclean_page_buffers(page);\n\t\tunlock_page(page);\n\t}\n\tblk_queue_exit(bdev->bd_queue);\n\treturn result;\n}"
  },
  {
    "function_name": "bdev_read_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "657-673",
    "snippet": "int bdev_read_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page)\n{\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tint result = -EOPNOTSUPP;\n\n\tif (!ops->rw_page || bdev_get_integrity(bdev))\n\t\treturn result;\n\n\tresult = blk_queue_enter(bdev->bd_queue, 0);\n\tif (result)\n\t\treturn result;\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page,\n\t\t\t      REQ_OP_READ);\n\tblk_queue_exit(bdev->bd_queue);\n\treturn result;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_queue_exit",
          "args": [
            "bdev->bd_queue"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->rw_page",
          "args": [
            "bdev",
            "sector + get_start_sect(bdev)",
            "page",
            "REQ_OP_READ"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_start_sect",
          "args": [
            "bdev"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_enter",
          "args": [
            "bdev->bd_queue",
            "0"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_integrity",
          "args": [
            "bdev"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bdev_read_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page)\n{\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tint result = -EOPNOTSUPP;\n\n\tif (!ops->rw_page || bdev_get_integrity(bdev))\n\t\treturn result;\n\n\tresult = blk_queue_enter(bdev->bd_queue, 0);\n\tif (result)\n\t\treturn result;\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page,\n\t\t\t      REQ_OP_READ);\n\tblk_queue_exit(bdev->bd_queue);\n\treturn result;\n}"
  },
  {
    "function_name": "blkdev_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "618-638",
    "snippet": "int blkdev_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *bd_inode = bdev_file_inode(filp);\n\tstruct block_device *bdev = I_BDEV(bd_inode);\n\tint error;\n\t\n\terror = file_write_and_wait_range(filp, start, end);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * There is no need to serialise calls to blkdev_issue_flush with\n\t * i_mutex and doing so causes performance issues with concurrent\n\t * O_SYNC writers to a block device.\n\t */\n\terror = blkdev_issue_flush(bdev, GFP_KERNEL, NULL);\n\tif (error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "bdev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_write_and_wait_range",
          "args": [
            "filp",
            "start",
            "end"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "bd_inode"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_file_inode",
          "args": [
            "filp"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint blkdev_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *bd_inode = bdev_file_inode(filp);\n\tstruct block_device *bdev = I_BDEV(bd_inode);\n\tint error;\n\t\n\terror = file_write_and_wait_range(filp, start, end);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * There is no need to serialise calls to blkdev_issue_flush with\n\t * i_mutex and doing so causes performance issues with concurrent\n\t * O_SYNC writers to a block device.\n\t */\n\terror = blkdev_issue_flush(bdev, GFP_KERNEL, NULL);\n\tif (error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}"
  },
  {
    "function_name": "block_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "607-616",
    "snippet": "static loff_t block_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *bd_inode = bdev_file_inode(file);\n\tloff_t retval;\n\n\tinode_lock(bd_inode);\n\tretval = fixed_size_llseek(file, offset, whence, i_size_read(bd_inode));\n\tinode_unlock(bd_inode);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "bd_inode"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_size_llseek",
          "args": [
            "file",
            "offset",
            "whence",
            "i_size_read(bd_inode)"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_size_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "162-171",
          "snippet": "loff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bd_inode"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "bd_inode"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_file_inode",
          "args": [
            "file"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic loff_t block_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *bd_inode = bdev_file_inode(file);\n\tloff_t retval;\n\n\tinode_lock(bd_inode);\n\tretval = fixed_size_llseek(file, offset, whence, i_size_read(bd_inode));\n\tinode_unlock(bd_inode);\n\treturn retval;\n}"
  },
  {
    "function_name": "blkdev_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "589-600",
    "snippet": "static int blkdev_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint ret;\n\tret = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2121-2154",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint ret;\n\tret = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "blkdev_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "581-587",
    "snippet": "static int blkdev_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\treturn block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\t blkdev_get_block);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "blkdev_get_block"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2064-2084",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\treturn block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\t blkdev_get_block);\n}"
  },
  {
    "function_name": "blkdev_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "575-579",
    "snippet": "static int blkdev_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, blkdev_get_block);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "blkdev_get_block"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "384-412",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct mpage_readpage_args args = {\n\t\t.get_block = get_block,\n\t\t.is_readahead = true,\n\t};\n\tunsigned page_idx;\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = lru_to_page(pages);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index,\n\t\t\t\t\treadahead_gfp_mask(mapping))) {\n\t\t\targs.page = page;\n\t\t\targs.nr_pages = nr_pages - page_idx;\n\t\t\targs.bio = do_mpage_readpage(&args);\n\t\t}\n\t\tput_page(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (args.bio)\n\t\tmpage_bio_submit(REQ_OP_READ, REQ_RAHEAD, args.bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct mpage_readpage_args args = {\n\t\t.get_block = get_block,\n\t\t.is_readahead = true,\n\t};\n\tunsigned page_idx;\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = lru_to_page(pages);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index,\n\t\t\t\t\treadahead_gfp_mask(mapping))) {\n\t\t\targs.page = page;\n\t\t\targs.nr_pages = nr_pages - page_idx;\n\t\t\targs.bio = do_mpage_readpage(&args);\n\t\t}\n\t\tput_page(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (args.bio)\n\t\tmpage_bio_submit(REQ_OP_READ, REQ_RAHEAD, args.bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, blkdev_get_block);\n}"
  },
  {
    "function_name": "blkdev_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "570-573",
    "snippet": "static int blkdev_readpage(struct file * file, struct page * page)\n{\n\treturn block_read_full_page(page, blkdev_get_block);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "blkdev_get_block"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2218-2301",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_readpage(struct file * file, struct page * page)\n{\n\treturn block_read_full_page(page, blkdev_get_block);\n}"
  },
  {
    "function_name": "blkdev_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "565-568",
    "snippet": "static int blkdev_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, blkdev_get_block, wbc);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "blkdev_get_block",
            "wbc"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2921-2957",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, blkdev_get_block, wbc);\n}"
  },
  {
    "function_name": "thaw_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "538-562",
    "snippet": "int thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error)\n\t\tbdev->bd_fsfreeze_count++;\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thaw_super",
          "args": [
            "sb"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1577-1581",
          "snippet": "int thaw_super(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\treturn thaw_super_locked(sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint thaw_super(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\treturn thaw_super_locked(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error)\n\t\tbdev->bd_fsfreeze_count++;\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "freeze_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "491-528",
    "snippet": "struct super_block *freeze_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\tint error = 0;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (++bdev->bd_fsfreeze_count > 1) {\n\t\t/*\n\t\t * We don't even need to grab a reference - the first call\n\t\t * to freeze_bdev grab an active reference and only the last\n\t\t * thaw_bdev drops it.\n\t\t */\n\t\tsb = get_super(bdev);\n\t\tif (sb)\n\t\t\tdrop_super(sb);\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn sb;\n\t}\n\n\tsb = get_active_super(bdev);\n\tif (!sb)\n\t\tgoto out;\n\tif (sb->s_op->freeze_super)\n\t\terror = sb->s_op->freeze_super(sb);\n\telse\n\t\terror = freeze_super(sb);\n\tif (error) {\n\t\tdeactivate_super(sb);\n\t\tbdev->bd_fsfreeze_count--;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn ERR_PTR(error);\n\t}\n\tdeactivate_super(sb);\n out:\n\tsync_blockdev(bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn sb;\t/* thaw_bdev releases s->s_umount */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "bdev"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "456-459",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_super",
          "args": [
            "sb"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "356-362",
          "snippet": "void deactivate_super(struct super_block *s)\n{\n        if (!atomic_add_unless(&s->s_active, -1, 1)) {\n\t\tdown_write(&s->s_umount);\n\t\tdeactivate_locked_super(s);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nvoid deactivate_super(struct super_block *s)\n{\n        if (!atomic_add_unless(&s->s_active, -1, 1)) {\n\t\tdown_write(&s->s_umount);\n\t\tdeactivate_locked_super(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_super",
          "args": [
            "sb"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1473-1533",
          "snippet": "int freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & SB_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\tdown_write(&sb->s_umount);\n\n\t/* Now we go and block page faults... */\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsb_freeze_unlock(sb);\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * For debugging purposes so that fs can warn if it sees write activity\n\t * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tlockdep_sb_freeze_release(sb);\n\tup_write(&sb->s_umount);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & SB_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\tdown_write(&sb->s_umount);\n\n\t/* Now we go and block page faults... */\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsb_freeze_unlock(sb);\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * For debugging purposes so that fs can warn if it sees write activity\n\t * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tlockdep_sb_freeze_release(sb);\n\tup_write(&sb->s_umount);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_active_super",
          "args": [
            "bdev"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "get_active_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "786-807",
          "snippet": "struct super_block *get_active_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\nrestart:\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tif (!grab_super(sb))\n\t\t\t\tgoto restart;\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn sb;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *get_active_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\nrestart:\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tif (!grab_super(sb))\n\t\t\t\tgoto restart;\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn sb;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_super",
          "args": [
            "sb"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "drop_super_exclusive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "583-587",
          "snippet": "void drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_super",
          "args": [
            "bdev"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "user_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "809-834",
          "snippet": "struct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct super_block *freeze_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\tint error = 0;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (++bdev->bd_fsfreeze_count > 1) {\n\t\t/*\n\t\t * We don't even need to grab a reference - the first call\n\t\t * to freeze_bdev grab an active reference and only the last\n\t\t * thaw_bdev drops it.\n\t\t */\n\t\tsb = get_super(bdev);\n\t\tif (sb)\n\t\t\tdrop_super(sb);\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn sb;\n\t}\n\n\tsb = get_active_super(bdev);\n\tif (!sb)\n\t\tgoto out;\n\tif (sb->s_op->freeze_super)\n\t\terror = sb->s_op->freeze_super(sb);\n\telse\n\t\terror = freeze_super(sb);\n\tif (error) {\n\t\tdeactivate_super(sb);\n\t\tbdev->bd_fsfreeze_count--;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn ERR_PTR(error);\n\t}\n\tdeactivate_super(sb);\n out:\n\tsync_blockdev(bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn sb;\t/* thaw_bdev releases s->s_umount */\n}"
  },
  {
    "function_name": "fsync_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "467-476",
    "snippet": "int fsync_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tif (sb) {\n\t\tint res = sync_filesystem(sb);\n\t\tdrop_super(sb);\n\t\treturn res;\n\t}\n\treturn sync_blockdev(bdev);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "bdev"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "456-459",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_super",
          "args": [
            "sb"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "drop_super_exclusive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "583-587",
          "snippet": "void drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
          "lines": "48-68",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_super",
          "args": [
            "bdev"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "user_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "809-834",
          "snippet": "struct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint fsync_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tif (sb) {\n\t\tint res = sync_filesystem(sb);\n\t\tdrop_super(sb);\n\t\treturn res;\n\t}\n\treturn sync_blockdev(bdev);\n}"
  },
  {
    "function_name": "sync_blockdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "456-459",
    "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sync_blockdev",
          "args": [
            "bdev",
            "1"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "443-450",
          "snippet": "int __sync_blockdev(struct block_device *bdev, int wait)\n{\n\tif (!bdev)\n\t\treturn 0;\n\tif (!wait)\n\t\treturn filemap_flush(bdev->bd_inode->i_mapping);\n\treturn filemap_write_and_wait(bdev->bd_inode->i_mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint __sync_blockdev(struct block_device *bdev, int wait)\n{\n\tif (!bdev)\n\t\treturn 0;\n\tif (!wait)\n\t\treturn filemap_flush(bdev->bd_inode->i_mapping);\n\treturn filemap_write_and_wait(bdev->bd_inode->i_mapping);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
  },
  {
    "function_name": "__sync_blockdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "443-450",
    "snippet": "int __sync_blockdev(struct block_device *bdev, int wait)\n{\n\tif (!bdev)\n\t\treturn 0;\n\tif (!wait)\n\t\treturn filemap_flush(bdev->bd_inode->i_mapping);\n\treturn filemap_write_and_wait(bdev->bd_inode->i_mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "bdev->bd_inode->i_mapping"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "bdev->bd_inode->i_mapping"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint __sync_blockdev(struct block_device *bdev, int wait)\n{\n\tif (!bdev)\n\t\treturn 0;\n\tif (!wait)\n\t\treturn filemap_flush(bdev->bd_inode->i_mapping);\n\treturn filemap_write_and_wait(bdev->bd_inode->i_mapping);\n}"
  },
  {
    "function_name": "blkdev_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "437-440",
    "snippet": "static __init int blkdev_init(void)\n{\n\treturn bioset_init(&blkdev_dio_pool, 4, offsetof(struct blkdev_dio, bio), BIOSET_NEED_BVECS);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bio_set blkdev_dio_pool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bioset_init",
          "args": [
            "&blkdev_dio_pool",
            "4",
            "offsetof(struct blkdev_dio, bio)",
            "BIOSET_NEED_BVECS"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct bio_set blkdev_dio_pool;\n\nstatic __init int blkdev_init(void)\n{\n\treturn bioset_init(&blkdev_dio_pool, 4, offsetof(struct blkdev_dio, bio), BIOSET_NEED_BVECS);\n}"
  },
  {
    "function_name": "blkdev_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "423-435",
    "snippet": "static ssize_t\nblkdev_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tint nr_pages;\n\n\tnr_pages = iov_iter_npages(iter, BIO_MAX_PAGES + 1);\n\tif (!nr_pages)\n\t\treturn 0;\n\tif (is_sync_kiocb(iocb) && nr_pages <= BIO_MAX_PAGES)\n\t\treturn __blkdev_direct_IO_simple(iocb, iter, nr_pages);\n\n\treturn __blkdev_direct_IO(iocb, iter, min(nr_pages, BIO_MAX_PAGES));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blkdev_direct_IO",
          "args": [
            "iocb",
            "iter",
            "min(nr_pages, BIO_MAX_PAGES)"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "322-421",
          "snippet": "static ssize_t\n__blkdev_direct_IO(struct kiocb *iocb, struct iov_iter *iter, int nr_pages)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = bdev_file_inode(file);\n\tstruct block_device *bdev = I_BDEV(inode);\n\tstruct blk_plug plug;\n\tstruct blkdev_dio *dio;\n\tstruct bio *bio;\n\tbool is_read = (iov_iter_rw(iter) == READ), is_sync;\n\tloff_t pos = iocb->ki_pos;\n\tblk_qc_t qc = BLK_QC_T_NONE;\n\tint ret = 0;\n\n\tif ((pos | iov_iter_alignment(iter)) &\n\t    (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\tbio = bio_alloc_bioset(GFP_KERNEL, nr_pages, &blkdev_dio_pool);\n\tbio_get(bio); /* extra ref for the completion handler */\n\n\tdio = container_of(bio, struct blkdev_dio, bio);\n\tdio->is_sync = is_sync = is_sync_kiocb(iocb);\n\tif (dio->is_sync)\n\t\tdio->waiter = current;\n\telse\n\t\tdio->iocb = iocb;\n\n\tdio->size = 0;\n\tdio->multi_bio = false;\n\tdio->should_dirty = is_read && iter_is_iovec(iter);\n\n\tblk_start_plug(&plug);\n\tfor (;;) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = pos >> 9;\n\t\tbio->bi_write_hint = iocb->ki_hint;\n\t\tbio->bi_private = dio;\n\t\tbio->bi_end_io = blkdev_bio_end_io;\n\t\tbio->bi_ioprio = iocb->ki_ioprio;\n\n\t\tret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (unlikely(ret)) {\n\t\t\tbio->bi_status = BLK_STS_IOERR;\n\t\t\tbio_endio(bio);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_read) {\n\t\t\tbio->bi_opf = REQ_OP_READ;\n\t\t\tif (dio->should_dirty)\n\t\t\t\tbio_set_pages_dirty(bio);\n\t\t} else {\n\t\t\tbio->bi_opf = dio_bio_write_op(iocb);\n\t\t\ttask_io_account_write(bio->bi_iter.bi_size);\n\t\t}\n\n\t\tdio->size += bio->bi_iter.bi_size;\n\t\tpos += bio->bi_iter.bi_size;\n\n\t\tnr_pages = iov_iter_npages(iter, BIO_MAX_PAGES);\n\t\tif (!nr_pages) {\n\t\t\tqc = submit_bio(bio);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!dio->multi_bio) {\n\t\t\tdio->multi_bio = true;\n\t\t\tatomic_set(&dio->ref, 2);\n\t\t} else {\n\t\t\tatomic_inc(&dio->ref);\n\t\t}\n\n\t\tsubmit_bio(bio);\n\t\tbio = bio_alloc(GFP_KERNEL, nr_pages);\n\t}\n\tblk_finish_plug(&plug);\n\n\tif (!is_sync)\n\t\treturn -EIOCBQUEUED;\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(dio->waiter))\n\t\t\tbreak;\n\n\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t    !blk_poll(bdev_get_queue(bdev), qc))\n\t\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!ret)\n\t\tret = blk_status_to_errno(dio->bio.bi_status);\n\tif (likely(!ret))\n\t\tret = dio->size;\n\n\tbio_put(&dio->bio);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set blkdev_dio_pool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct bio_set blkdev_dio_pool;\n\nstatic ssize_t\n__blkdev_direct_IO(struct kiocb *iocb, struct iov_iter *iter, int nr_pages)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = bdev_file_inode(file);\n\tstruct block_device *bdev = I_BDEV(inode);\n\tstruct blk_plug plug;\n\tstruct blkdev_dio *dio;\n\tstruct bio *bio;\n\tbool is_read = (iov_iter_rw(iter) == READ), is_sync;\n\tloff_t pos = iocb->ki_pos;\n\tblk_qc_t qc = BLK_QC_T_NONE;\n\tint ret = 0;\n\n\tif ((pos | iov_iter_alignment(iter)) &\n\t    (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\tbio = bio_alloc_bioset(GFP_KERNEL, nr_pages, &blkdev_dio_pool);\n\tbio_get(bio); /* extra ref for the completion handler */\n\n\tdio = container_of(bio, struct blkdev_dio, bio);\n\tdio->is_sync = is_sync = is_sync_kiocb(iocb);\n\tif (dio->is_sync)\n\t\tdio->waiter = current;\n\telse\n\t\tdio->iocb = iocb;\n\n\tdio->size = 0;\n\tdio->multi_bio = false;\n\tdio->should_dirty = is_read && iter_is_iovec(iter);\n\n\tblk_start_plug(&plug);\n\tfor (;;) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = pos >> 9;\n\t\tbio->bi_write_hint = iocb->ki_hint;\n\t\tbio->bi_private = dio;\n\t\tbio->bi_end_io = blkdev_bio_end_io;\n\t\tbio->bi_ioprio = iocb->ki_ioprio;\n\n\t\tret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (unlikely(ret)) {\n\t\t\tbio->bi_status = BLK_STS_IOERR;\n\t\t\tbio_endio(bio);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_read) {\n\t\t\tbio->bi_opf = REQ_OP_READ;\n\t\t\tif (dio->should_dirty)\n\t\t\t\tbio_set_pages_dirty(bio);\n\t\t} else {\n\t\t\tbio->bi_opf = dio_bio_write_op(iocb);\n\t\t\ttask_io_account_write(bio->bi_iter.bi_size);\n\t\t}\n\n\t\tdio->size += bio->bi_iter.bi_size;\n\t\tpos += bio->bi_iter.bi_size;\n\n\t\tnr_pages = iov_iter_npages(iter, BIO_MAX_PAGES);\n\t\tif (!nr_pages) {\n\t\t\tqc = submit_bio(bio);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!dio->multi_bio) {\n\t\t\tdio->multi_bio = true;\n\t\t\tatomic_set(&dio->ref, 2);\n\t\t} else {\n\t\t\tatomic_inc(&dio->ref);\n\t\t}\n\n\t\tsubmit_bio(bio);\n\t\tbio = bio_alloc(GFP_KERNEL, nr_pages);\n\t}\n\tblk_finish_plug(&plug);\n\n\tif (!is_sync)\n\t\treturn -EIOCBQUEUED;\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(dio->waiter))\n\t\t\tbreak;\n\n\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t    !blk_poll(bdev_get_queue(bdev), qc))\n\t\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!ret)\n\t\tret = blk_status_to_errno(dio->bio.bi_status);\n\tif (likely(!ret))\n\t\tret = dio->size;\n\n\tbio_put(&dio->bio);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nr_pages",
            "BIO_MAX_PAGES"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "bd_start_claiming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1108-1155",
          "snippet": "static struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tput_disk_and_module(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = bdev_get_gendisk(bdev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tput_disk_and_module(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blkdev_direct_IO_simple",
          "args": [
            "iocb",
            "iter",
            "nr_pages"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_direct_IO_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "187-263",
          "snippet": "static ssize_t\n__blkdev_direct_IO_simple(struct kiocb *iocb, struct iov_iter *iter,\n\t\tint nr_pages)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(file));\n\tstruct bio_vec inline_vecs[DIO_INLINE_BIO_VECS], *vecs, *bvec;\n\tloff_t pos = iocb->ki_pos;\n\tbool should_dirty = false;\n\tstruct bio bio;\n\tssize_t ret;\n\tblk_qc_t qc;\n\tint i;\n\n\tif ((pos | iov_iter_alignment(iter)) &\n\t    (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\tif (nr_pages <= DIO_INLINE_BIO_VECS)\n\t\tvecs = inline_vecs;\n\telse {\n\t\tvecs = kmalloc_array(nr_pages, sizeof(struct bio_vec),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!vecs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tbio_init(&bio, vecs, nr_pages);\n\tbio_set_dev(&bio, bdev);\n\tbio.bi_iter.bi_sector = pos >> 9;\n\tbio.bi_write_hint = iocb->ki_hint;\n\tbio.bi_private = current;\n\tbio.bi_end_io = blkdev_bio_end_io_simple;\n\tbio.bi_ioprio = iocb->ki_ioprio;\n\n\tret = bio_iov_iter_get_pages(&bio, iter);\n\tif (unlikely(ret))\n\t\tgoto out;\n\tret = bio.bi_iter.bi_size;\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tbio.bi_opf = REQ_OP_READ;\n\t\tif (iter_is_iovec(iter))\n\t\t\tshould_dirty = true;\n\t} else {\n\t\tbio.bi_opf = dio_bio_write_op(iocb);\n\t\ttask_io_account_write(ret);\n\t}\n\n\tqc = submit_bio(&bio);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio.bi_private))\n\t\t\tbreak;\n\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t    !blk_poll(bdev_get_queue(bdev), qc))\n\t\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tbio_for_each_segment_all(bvec, &bio, i) {\n\t\tif (should_dirty && !PageCompound(bvec->bv_page))\n\t\t\tset_page_dirty_lock(bvec->bv_page);\n\t\tput_page(bvec->bv_page);\n\t}\n\n\tif (unlikely(bio.bi_status))\n\t\tret = blk_status_to_errno(bio.bi_status);\n\nout:\n\tif (vecs != inline_vecs)\n\t\tkfree(vecs);\n\n\tbio_uninit(&bio);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define DIO_INLINE_BIO_VECS 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\n#define DIO_INLINE_BIO_VECS 4\n\nstatic ssize_t\n__blkdev_direct_IO_simple(struct kiocb *iocb, struct iov_iter *iter,\n\t\tint nr_pages)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(file));\n\tstruct bio_vec inline_vecs[DIO_INLINE_BIO_VECS], *vecs, *bvec;\n\tloff_t pos = iocb->ki_pos;\n\tbool should_dirty = false;\n\tstruct bio bio;\n\tssize_t ret;\n\tblk_qc_t qc;\n\tint i;\n\n\tif ((pos | iov_iter_alignment(iter)) &\n\t    (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\tif (nr_pages <= DIO_INLINE_BIO_VECS)\n\t\tvecs = inline_vecs;\n\telse {\n\t\tvecs = kmalloc_array(nr_pages, sizeof(struct bio_vec),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!vecs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tbio_init(&bio, vecs, nr_pages);\n\tbio_set_dev(&bio, bdev);\n\tbio.bi_iter.bi_sector = pos >> 9;\n\tbio.bi_write_hint = iocb->ki_hint;\n\tbio.bi_private = current;\n\tbio.bi_end_io = blkdev_bio_end_io_simple;\n\tbio.bi_ioprio = iocb->ki_ioprio;\n\n\tret = bio_iov_iter_get_pages(&bio, iter);\n\tif (unlikely(ret))\n\t\tgoto out;\n\tret = bio.bi_iter.bi_size;\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tbio.bi_opf = REQ_OP_READ;\n\t\tif (iter_is_iovec(iter))\n\t\t\tshould_dirty = true;\n\t} else {\n\t\tbio.bi_opf = dio_bio_write_op(iocb);\n\t\ttask_io_account_write(ret);\n\t}\n\n\tqc = submit_bio(&bio);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio.bi_private))\n\t\t\tbreak;\n\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t    !blk_poll(bdev_get_queue(bdev), qc))\n\t\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tbio_for_each_segment_all(bvec, &bio, i) {\n\t\tif (should_dirty && !PageCompound(bvec->bv_page))\n\t\t\tset_page_dirty_lock(bvec->bv_page);\n\t\tput_page(bvec->bv_page);\n\t}\n\n\tif (unlikely(bio.bi_status))\n\t\tret = blk_status_to_errno(bio.bi_status);\n\nout:\n\tif (vecs != inline_vecs)\n\t\tkfree(vecs);\n\n\tbio_uninit(&bio);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_npages",
          "args": [
            "iter",
            "BIO_MAX_PAGES + 1"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic ssize_t\nblkdev_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tint nr_pages;\n\n\tnr_pages = iov_iter_npages(iter, BIO_MAX_PAGES + 1);\n\tif (!nr_pages)\n\t\treturn 0;\n\tif (is_sync_kiocb(iocb) && nr_pages <= BIO_MAX_PAGES)\n\t\treturn __blkdev_direct_IO_simple(iocb, iter, nr_pages);\n\n\treturn __blkdev_direct_IO(iocb, iter, min(nr_pages, BIO_MAX_PAGES));\n}"
  },
  {
    "function_name": "__blkdev_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "322-421",
    "snippet": "static ssize_t\n__blkdev_direct_IO(struct kiocb *iocb, struct iov_iter *iter, int nr_pages)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = bdev_file_inode(file);\n\tstruct block_device *bdev = I_BDEV(inode);\n\tstruct blk_plug plug;\n\tstruct blkdev_dio *dio;\n\tstruct bio *bio;\n\tbool is_read = (iov_iter_rw(iter) == READ), is_sync;\n\tloff_t pos = iocb->ki_pos;\n\tblk_qc_t qc = BLK_QC_T_NONE;\n\tint ret = 0;\n\n\tif ((pos | iov_iter_alignment(iter)) &\n\t    (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\tbio = bio_alloc_bioset(GFP_KERNEL, nr_pages, &blkdev_dio_pool);\n\tbio_get(bio); /* extra ref for the completion handler */\n\n\tdio = container_of(bio, struct blkdev_dio, bio);\n\tdio->is_sync = is_sync = is_sync_kiocb(iocb);\n\tif (dio->is_sync)\n\t\tdio->waiter = current;\n\telse\n\t\tdio->iocb = iocb;\n\n\tdio->size = 0;\n\tdio->multi_bio = false;\n\tdio->should_dirty = is_read && iter_is_iovec(iter);\n\n\tblk_start_plug(&plug);\n\tfor (;;) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = pos >> 9;\n\t\tbio->bi_write_hint = iocb->ki_hint;\n\t\tbio->bi_private = dio;\n\t\tbio->bi_end_io = blkdev_bio_end_io;\n\t\tbio->bi_ioprio = iocb->ki_ioprio;\n\n\t\tret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (unlikely(ret)) {\n\t\t\tbio->bi_status = BLK_STS_IOERR;\n\t\t\tbio_endio(bio);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_read) {\n\t\t\tbio->bi_opf = REQ_OP_READ;\n\t\t\tif (dio->should_dirty)\n\t\t\t\tbio_set_pages_dirty(bio);\n\t\t} else {\n\t\t\tbio->bi_opf = dio_bio_write_op(iocb);\n\t\t\ttask_io_account_write(bio->bi_iter.bi_size);\n\t\t}\n\n\t\tdio->size += bio->bi_iter.bi_size;\n\t\tpos += bio->bi_iter.bi_size;\n\n\t\tnr_pages = iov_iter_npages(iter, BIO_MAX_PAGES);\n\t\tif (!nr_pages) {\n\t\t\tqc = submit_bio(bio);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!dio->multi_bio) {\n\t\t\tdio->multi_bio = true;\n\t\t\tatomic_set(&dio->ref, 2);\n\t\t} else {\n\t\t\tatomic_inc(&dio->ref);\n\t\t}\n\n\t\tsubmit_bio(bio);\n\t\tbio = bio_alloc(GFP_KERNEL, nr_pages);\n\t}\n\tblk_finish_plug(&plug);\n\n\tif (!is_sync)\n\t\treturn -EIOCBQUEUED;\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(dio->waiter))\n\t\t\tbreak;\n\n\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t    !blk_poll(bdev_get_queue(bdev), qc))\n\t\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!ret)\n\t\tret = blk_status_to_errno(dio->bio.bi_status);\n\tif (likely(!ret))\n\t\tret = dio->size;\n\n\tbio_put(&dio->bio);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bio_set blkdev_dio_pool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "&dio->bio"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "dio->bio.bi_status"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_poll",
          "args": [
            "bdev_get_queue(bdev)",
            "qc"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dio->waiter"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_KERNEL",
            "nr_pages"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.c",
          "lines": "2667-2676",
          "snippet": "struct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set btrfs_bioset;\n\nstruct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "bio"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-116",
          "snippet": "static struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dio->ref"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dio->ref",
            "2"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_npages",
          "args": [
            "iter",
            "BIO_MAX_PAGES"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_account_write",
          "args": [
            "bio->bi_iter.bi_size"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dio_bio_write_op",
          "args": [
            "iocb"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "dio_bio_write_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "167-175",
          "snippet": "static unsigned int dio_bio_write_op(struct kiocb *iocb)\n{\n\tunsigned int op = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\n\t/* avoid the need for a I/O completion work item */\n\tif (iocb->ki_flags & IOCB_DSYNC)\n\t\top |= REQ_FUA;\n\treturn op;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic unsigned int dio_bio_write_op(struct kiocb *iocb)\n{\n\tunsigned int op = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\n\t/* avoid the need for a I/O completion work item */\n\tif (iocb->ki_flags & IOCB_DSYNC)\n\t\top |= REQ_FUA;\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_set_pages_dirty",
          "args": [
            "bio"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "bio"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/scrub.c",
          "lines": "2708-2722",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct btrfs_fs_info *fs_info = sparity->sctx->fs_info;\n\n\tif (bio->bi_status)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tbio_put(bio);\n\n\tbtrfs_init_work(&sparity->work, btrfs_scrubparity_helper,\n\t\t\tscrub_parity_bio_endio_worker, NULL, NULL);\n\tbtrfs_queue_work(fs_info->scrub_parity_workers, &sparity->work);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_bio_end_io(struct bio *bio);",
            "static void scrub_bio_end_io_worker(struct btrfs_work *work);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_wr_bio_end_io(struct bio *bio);",
            "static void scrub_wr_bio_end_io_worker(struct btrfs_work *work);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/sched/mm.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_bio_end_io(struct bio *bio);\nstatic void scrub_bio_end_io_worker(struct btrfs_work *work);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_wr_bio_end_io(struct bio *bio);\nstatic void scrub_wr_bio_end_io_worker(struct btrfs_work *work);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct btrfs_fs_info *fs_info = sparity->sctx->fs_info;\n\n\tif (bio->bi_status)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tbio_put(bio);\n\n\tbtrfs_init_work(&sparity->work, btrfs_scrubparity_helper,\n\t\t\tscrub_parity_bio_endio_worker, NULL, NULL);\n\tbtrfs_queue_work(fs_info->scrub_parity_workers, &sparity->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_iov_iter_get_pages",
          "args": [
            "bio",
            "iter"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "bio",
            "bdev"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter_is_iovec",
          "args": [
            "iter"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "bio",
            "structblkdev_dio",
            "bio"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "bio"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc_bioset",
          "args": [
            "GFP_KERNEL",
            "nr_pages",
            "&blkdev_dio_pool"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_alignment",
          "args": [
            "iter"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "inode"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_file_inode",
          "args": [
            "file"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct bio_set blkdev_dio_pool;\n\nstatic ssize_t\n__blkdev_direct_IO(struct kiocb *iocb, struct iov_iter *iter, int nr_pages)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = bdev_file_inode(file);\n\tstruct block_device *bdev = I_BDEV(inode);\n\tstruct blk_plug plug;\n\tstruct blkdev_dio *dio;\n\tstruct bio *bio;\n\tbool is_read = (iov_iter_rw(iter) == READ), is_sync;\n\tloff_t pos = iocb->ki_pos;\n\tblk_qc_t qc = BLK_QC_T_NONE;\n\tint ret = 0;\n\n\tif ((pos | iov_iter_alignment(iter)) &\n\t    (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\tbio = bio_alloc_bioset(GFP_KERNEL, nr_pages, &blkdev_dio_pool);\n\tbio_get(bio); /* extra ref for the completion handler */\n\n\tdio = container_of(bio, struct blkdev_dio, bio);\n\tdio->is_sync = is_sync = is_sync_kiocb(iocb);\n\tif (dio->is_sync)\n\t\tdio->waiter = current;\n\telse\n\t\tdio->iocb = iocb;\n\n\tdio->size = 0;\n\tdio->multi_bio = false;\n\tdio->should_dirty = is_read && iter_is_iovec(iter);\n\n\tblk_start_plug(&plug);\n\tfor (;;) {\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector = pos >> 9;\n\t\tbio->bi_write_hint = iocb->ki_hint;\n\t\tbio->bi_private = dio;\n\t\tbio->bi_end_io = blkdev_bio_end_io;\n\t\tbio->bi_ioprio = iocb->ki_ioprio;\n\n\t\tret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (unlikely(ret)) {\n\t\t\tbio->bi_status = BLK_STS_IOERR;\n\t\t\tbio_endio(bio);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_read) {\n\t\t\tbio->bi_opf = REQ_OP_READ;\n\t\t\tif (dio->should_dirty)\n\t\t\t\tbio_set_pages_dirty(bio);\n\t\t} else {\n\t\t\tbio->bi_opf = dio_bio_write_op(iocb);\n\t\t\ttask_io_account_write(bio->bi_iter.bi_size);\n\t\t}\n\n\t\tdio->size += bio->bi_iter.bi_size;\n\t\tpos += bio->bi_iter.bi_size;\n\n\t\tnr_pages = iov_iter_npages(iter, BIO_MAX_PAGES);\n\t\tif (!nr_pages) {\n\t\t\tqc = submit_bio(bio);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!dio->multi_bio) {\n\t\t\tdio->multi_bio = true;\n\t\t\tatomic_set(&dio->ref, 2);\n\t\t} else {\n\t\t\tatomic_inc(&dio->ref);\n\t\t}\n\n\t\tsubmit_bio(bio);\n\t\tbio = bio_alloc(GFP_KERNEL, nr_pages);\n\t}\n\tblk_finish_plug(&plug);\n\n\tif (!is_sync)\n\t\treturn -EIOCBQUEUED;\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(dio->waiter))\n\t\t\tbreak;\n\n\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t    !blk_poll(bdev_get_queue(bdev), qc))\n\t\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!ret)\n\t\tret = blk_status_to_errno(dio->bio.bi_status);\n\tif (likely(!ret))\n\t\tret = dio->size;\n\n\tbio_put(&dio->bio);\n\treturn ret;\n}"
  },
  {
    "function_name": "blkdev_bio_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "280-320",
    "snippet": "static void blkdev_bio_end_io(struct bio *bio)\n{\n\tstruct blkdev_dio *dio = bio->bi_private;\n\tbool should_dirty = dio->should_dirty;\n\n\tif (dio->multi_bio && !atomic_dec_and_test(&dio->ref)) {\n\t\tif (bio->bi_status && !dio->bio.bi_status)\n\t\t\tdio->bio.bi_status = bio->bi_status;\n\t} else {\n\t\tif (!dio->is_sync) {\n\t\t\tstruct kiocb *iocb = dio->iocb;\n\t\t\tssize_t ret;\n\n\t\t\tif (likely(!dio->bio.bi_status)) {\n\t\t\t\tret = dio->size;\n\t\t\t\tiocb->ki_pos += ret;\n\t\t\t} else {\n\t\t\t\tret = blk_status_to_errno(dio->bio.bi_status);\n\t\t\t}\n\n\t\t\tdio->iocb->ki_complete(iocb, ret, 0);\n\t\t\tbio_put(&dio->bio);\n\t\t} else {\n\t\t\tstruct task_struct *waiter = dio->waiter;\n\n\t\t\tWRITE_ONCE(dio->waiter, NULL);\n\t\t\twake_up_process(waiter);\n\t\t}\n\t}\n\n\tif (should_dirty) {\n\t\tbio_check_pages_dirty(bio);\n\t} else {\n\t\tstruct bio_vec *bvec;\n\t\tint i;\n\n\t\tbio_for_each_segment_all(bvec, bio, i)\n\t\t\tput_page(bvec->bv_page);\n\t\tbio_put(bio);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "bvec->bv_page"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_check_pages_dirty",
          "args": [
            "bio"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "waiter"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "dio->waiter",
            "NULL"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "&dio->bio"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dio->iocb->ki_complete",
          "args": [
            "iocb",
            "ret",
            "0"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "dio->bio.bi_status"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!dio->bio.bi_status"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&dio->ref"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void blkdev_bio_end_io(struct bio *bio)\n{\n\tstruct blkdev_dio *dio = bio->bi_private;\n\tbool should_dirty = dio->should_dirty;\n\n\tif (dio->multi_bio && !atomic_dec_and_test(&dio->ref)) {\n\t\tif (bio->bi_status && !dio->bio.bi_status)\n\t\t\tdio->bio.bi_status = bio->bi_status;\n\t} else {\n\t\tif (!dio->is_sync) {\n\t\t\tstruct kiocb *iocb = dio->iocb;\n\t\t\tssize_t ret;\n\n\t\t\tif (likely(!dio->bio.bi_status)) {\n\t\t\t\tret = dio->size;\n\t\t\t\tiocb->ki_pos += ret;\n\t\t\t} else {\n\t\t\t\tret = blk_status_to_errno(dio->bio.bi_status);\n\t\t\t}\n\n\t\t\tdio->iocb->ki_complete(iocb, ret, 0);\n\t\t\tbio_put(&dio->bio);\n\t\t} else {\n\t\t\tstruct task_struct *waiter = dio->waiter;\n\n\t\t\tWRITE_ONCE(dio->waiter, NULL);\n\t\t\twake_up_process(waiter);\n\t\t}\n\t}\n\n\tif (should_dirty) {\n\t\tbio_check_pages_dirty(bio);\n\t} else {\n\t\tstruct bio_vec *bvec;\n\t\tint i;\n\n\t\tbio_for_each_segment_all(bvec, bio, i)\n\t\t\tput_page(bvec->bv_page);\n\t\tbio_put(bio);\n\t}\n}"
  },
  {
    "function_name": "__blkdev_direct_IO_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "187-263",
    "snippet": "static ssize_t\n__blkdev_direct_IO_simple(struct kiocb *iocb, struct iov_iter *iter,\n\t\tint nr_pages)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(file));\n\tstruct bio_vec inline_vecs[DIO_INLINE_BIO_VECS], *vecs, *bvec;\n\tloff_t pos = iocb->ki_pos;\n\tbool should_dirty = false;\n\tstruct bio bio;\n\tssize_t ret;\n\tblk_qc_t qc;\n\tint i;\n\n\tif ((pos | iov_iter_alignment(iter)) &\n\t    (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\tif (nr_pages <= DIO_INLINE_BIO_VECS)\n\t\tvecs = inline_vecs;\n\telse {\n\t\tvecs = kmalloc_array(nr_pages, sizeof(struct bio_vec),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!vecs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tbio_init(&bio, vecs, nr_pages);\n\tbio_set_dev(&bio, bdev);\n\tbio.bi_iter.bi_sector = pos >> 9;\n\tbio.bi_write_hint = iocb->ki_hint;\n\tbio.bi_private = current;\n\tbio.bi_end_io = blkdev_bio_end_io_simple;\n\tbio.bi_ioprio = iocb->ki_ioprio;\n\n\tret = bio_iov_iter_get_pages(&bio, iter);\n\tif (unlikely(ret))\n\t\tgoto out;\n\tret = bio.bi_iter.bi_size;\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tbio.bi_opf = REQ_OP_READ;\n\t\tif (iter_is_iovec(iter))\n\t\t\tshould_dirty = true;\n\t} else {\n\t\tbio.bi_opf = dio_bio_write_op(iocb);\n\t\ttask_io_account_write(ret);\n\t}\n\n\tqc = submit_bio(&bio);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio.bi_private))\n\t\t\tbreak;\n\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t    !blk_poll(bdev_get_queue(bdev), qc))\n\t\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tbio_for_each_segment_all(bvec, &bio, i) {\n\t\tif (should_dirty && !PageCompound(bvec->bv_page))\n\t\t\tset_page_dirty_lock(bvec->bv_page);\n\t\tput_page(bvec->bv_page);\n\t}\n\n\tif (unlikely(bio.bi_status))\n\t\tret = blk_status_to_errno(bio.bi_status);\n\nout:\n\tif (vecs != inline_vecs)\n\t\tkfree(vecs);\n\n\tbio_uninit(&bio);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define DIO_INLINE_BIO_VECS 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_uninit",
          "args": [
            "&bio"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vecs"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "bio.bi_status"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bio.bi_status"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "bvec->bv_page"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty_lock",
          "args": [
            "bvec->bv_page"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "bvec->bv_page"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "&bio",
            "i"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_poll",
          "args": [
            "bdev_get_queue(bdev)",
            "qc"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "bdev"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "bio.bi_private"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "&bio"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-116",
          "snippet": "static struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_io_account_write",
          "args": [
            "ret"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dio_bio_write_op",
          "args": [
            "iocb"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "dio_bio_write_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "167-175",
          "snippet": "static unsigned int dio_bio_write_op(struct kiocb *iocb)\n{\n\tunsigned int op = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\n\t/* avoid the need for a I/O completion work item */\n\tif (iocb->ki_flags & IOCB_DSYNC)\n\t\top |= REQ_FUA;\n\treturn op;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic unsigned int dio_bio_write_op(struct kiocb *iocb)\n{\n\tunsigned int op = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\n\t/* avoid the need for a I/O completion work item */\n\tif (iocb->ki_flags & IOCB_DSYNC)\n\t\top |= REQ_FUA;\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_is_iovec",
          "args": [
            "iter"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_iov_iter_get_pages",
          "args": [
            "&bio",
            "iter"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "&bio",
            "bdev"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_init",
          "args": [
            "&bio",
            "vecs",
            "nr_pages"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_pages",
            "sizeof(struct bio_vec)",
            "GFP_KERNEL"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_alignment",
          "args": [
            "iter"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "bdev_file_inode(file)"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_file_inode",
          "args": [
            "file"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\n#define DIO_INLINE_BIO_VECS 4\n\nstatic ssize_t\n__blkdev_direct_IO_simple(struct kiocb *iocb, struct iov_iter *iter,\n\t\tint nr_pages)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct block_device *bdev = I_BDEV(bdev_file_inode(file));\n\tstruct bio_vec inline_vecs[DIO_INLINE_BIO_VECS], *vecs, *bvec;\n\tloff_t pos = iocb->ki_pos;\n\tbool should_dirty = false;\n\tstruct bio bio;\n\tssize_t ret;\n\tblk_qc_t qc;\n\tint i;\n\n\tif ((pos | iov_iter_alignment(iter)) &\n\t    (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\tif (nr_pages <= DIO_INLINE_BIO_VECS)\n\t\tvecs = inline_vecs;\n\telse {\n\t\tvecs = kmalloc_array(nr_pages, sizeof(struct bio_vec),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!vecs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tbio_init(&bio, vecs, nr_pages);\n\tbio_set_dev(&bio, bdev);\n\tbio.bi_iter.bi_sector = pos >> 9;\n\tbio.bi_write_hint = iocb->ki_hint;\n\tbio.bi_private = current;\n\tbio.bi_end_io = blkdev_bio_end_io_simple;\n\tbio.bi_ioprio = iocb->ki_ioprio;\n\n\tret = bio_iov_iter_get_pages(&bio, iter);\n\tif (unlikely(ret))\n\t\tgoto out;\n\tret = bio.bi_iter.bi_size;\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tbio.bi_opf = REQ_OP_READ;\n\t\tif (iter_is_iovec(iter))\n\t\t\tshould_dirty = true;\n\t} else {\n\t\tbio.bi_opf = dio_bio_write_op(iocb);\n\t\ttask_io_account_write(ret);\n\t}\n\n\tqc = submit_bio(&bio);\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio.bi_private))\n\t\t\tbreak;\n\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t    !blk_poll(bdev_get_queue(bdev), qc))\n\t\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tbio_for_each_segment_all(bvec, &bio, i) {\n\t\tif (should_dirty && !PageCompound(bvec->bv_page))\n\t\t\tset_page_dirty_lock(bvec->bv_page);\n\t\tput_page(bvec->bv_page);\n\t}\n\n\tif (unlikely(bio.bi_status))\n\t\tret = blk_status_to_errno(bio.bi_status);\n\nout:\n\tif (vecs != inline_vecs)\n\t\tkfree(vecs);\n\n\tbio_uninit(&bio);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "blkdev_bio_end_io_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "179-185",
    "snippet": "static void blkdev_bio_end_io_simple(struct bio *bio)\n{\n\tstruct task_struct *waiter = bio->bi_private;\n\n\tWRITE_ONCE(bio->bi_private, NULL);\n\twake_up_process(waiter);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "waiter"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "bio->bi_private",
            "NULL"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void blkdev_bio_end_io_simple(struct bio *bio)\n{\n\tstruct task_struct *waiter = bio->bi_private;\n\n\tWRITE_ONCE(bio->bi_private, NULL);\n\twake_up_process(waiter);\n}"
  },
  {
    "function_name": "dio_bio_write_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "167-175",
    "snippet": "static unsigned int dio_bio_write_op(struct kiocb *iocb)\n{\n\tunsigned int op = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\n\t/* avoid the need for a I/O completion work item */\n\tif (iocb->ki_flags & IOCB_DSYNC)\n\t\top |= REQ_FUA;\n\treturn op;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic unsigned int dio_bio_write_op(struct kiocb *iocb)\n{\n\tunsigned int op = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\n\t/* avoid the need for a I/O completion work item */\n\tif (iocb->ki_flags & IOCB_DSYNC)\n\t\top |= REQ_FUA;\n\treturn op;\n}"
  },
  {
    "function_name": "bdev_file_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "162-165",
    "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
  },
  {
    "function_name": "blkdev_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "152-160",
    "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "inode"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "sb_min_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "142-148",
    "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "size"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "129-138",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
  },
  {
    "function_name": "sb_set_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "129-138",
    "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "size"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "sb->s_bdev",
            "size"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "129-138",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
  },
  {
    "function_name": "set_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "107-125",
    "snippet": "int set_blocksize(struct block_device *bdev, int size)\n{\n\t/* Size must be a power of two, and between 512 and PAGE_SIZE */\n\tif (size > PAGE_SIZE || size < 512 || !is_power_of_2(size))\n\t\treturn -EINVAL;\n\n\t/* Size cannot be smaller than the size supported by the device */\n\tif (size < bdev_logical_block_size(bdev))\n\t\treturn -EINVAL;\n\n\t/* Don't change the size if it is same as current */\n\tif (bdev->bd_block_size != size) {\n\t\tsync_blockdev(bdev);\n\t\tbdev->bd_block_size = size;\n\t\tbdev->bd_inode->i_blkbits = blksize_bits(size);\n\t\tkill_bdev(bdev);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_bdev",
          "args": [
            "bdev"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "kill_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "78-87",
          "snippet": "void kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "size"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "bdev"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "456-459",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "size"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint set_blocksize(struct block_device *bdev, int size)\n{\n\t/* Size must be a power of two, and between 512 and PAGE_SIZE */\n\tif (size > PAGE_SIZE || size < 512 || !is_power_of_2(size))\n\t\treturn -EINVAL;\n\n\t/* Size cannot be smaller than the size supported by the device */\n\tif (size < bdev_logical_block_size(bdev))\n\t\treturn -EINVAL;\n\n\t/* Don't change the size if it is same as current */\n\tif (bdev->bd_block_size != size) {\n\t\tsync_blockdev(bdev);\n\t\tbdev->bd_block_size = size;\n\t\tbdev->bd_inode->i_blkbits = blksize_bits(size);\n\t\tkill_bdev(bdev);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "invalidate_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "91-104",
    "snippet": "void invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_bh_lrus();\n\t\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\t\tinvalidate_mapping_pages(mapping, 0, -1);\n\t}\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_invalidate_inode",
          "args": [
            "mapping"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "mapping",
            "0",
            "-1"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_bh_lrus",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bh_lrus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1392-1395",
          "snippet": "void invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_bh_lrus();\n\t\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\t\tinvalidate_mapping_pages(mapping, 0, -1);\n\t}\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}"
  },
  {
    "function_name": "kill_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "78-87",
    "snippet": "void kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "mapping",
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_bh_lrus",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bh_lrus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1392-1395",
          "snippet": "void invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrexceptional == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}"
  },
  {
    "function_name": "bdev_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "57-75",
    "snippet": "static void bdev_write_inode(struct block_device *bdev)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tint ret;\n\n\tspin_lock(&inode->i_lock);\n\twhile (inode->i_state & I_DIRTY) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tret = write_inode_now(inode, true);\n\t\tif (ret) {\n\t\t\tchar name[BDEVNAME_SIZE];\n\t\t\tpr_warn_ratelimited(\"VFS: Dirty inode writeback failed \"\n\t\t\t\t\t    \"for block device %s (err=%d).\\n\",\n\t\t\t\t\t    bdevname(bdev, name), ret);\n\t\t}\n\t\tspin_lock(&inode->i_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"VFS: Dirty inode writeback failed \"\n\t\t\t\t\t    \"for block device %s (err=%d).\\n\"",
            "bdevname(bdev, name)",
            "ret"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "name"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "inode",
            "true"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2433-2447",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, &wbc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void bdev_write_inode(struct block_device *bdev)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tint ret;\n\n\tspin_lock(&inode->i_lock);\n\twhile (inode->i_state & I_DIRTY) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tret = write_inode_now(inode, true);\n\t\tif (ret) {\n\t\t\tchar name[BDEVNAME_SIZE];\n\t\t\tpr_warn_ratelimited(\"VFS: Dirty inode writeback failed \"\n\t\t\t\t\t    \"for block device %s (err=%d).\\n\",\n\t\t\t\t\t    bdevname(bdev, name), ret);\n\t\t}\n\t\tspin_lock(&inode->i_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "I_BDEV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "51-54",
    "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
  },
  {
    "function_name": "BDEV_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
    "lines": "46-49",
    "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/falloc.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/badblocks.h>",
      "#include <linux/dax.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/dax.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode",
            "structbdev_inode",
            "vfs_inode"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
  }
]