[
  {
    "function_name": "init_pipe_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "1173-1185",
    "snippet": "static int __init init_pipe_fs(void)\n{\n\tint err = register_filesystem(&pipe_fs_type);\n\n\tif (!err) {\n\t\tpipe_mnt = kern_mount(&pipe_fs_type);\n\t\tif (IS_ERR(pipe_mnt)) {\n\t\t\terr = PTR_ERR(pipe_mnt);\n\t\t\tunregister_filesystem(&pipe_fs_type);\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type pipe_fs_type = {\n\t.name\t\t= \"pipefs\",\n\t.mount\t\t= pipefs_mount,\n\t.kill_sb\t= kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&pipe_fs_type"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/filesystems.c",
          "lines": "103-122",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pipe_mnt"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pipe_mnt"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&pipe_fs_type"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic struct file_system_type pipe_fs_type = {\n\t.name\t\t= \"pipefs\",\n\t.mount\t\t= pipefs_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic int __init init_pipe_fs(void)\n{\n\tint err = register_filesystem(&pipe_fs_type);\n\n\tif (!err) {\n\t\tpipe_mnt = kern_mount(&pipe_fs_type);\n\t\tif (IS_ERR(pipe_mnt)) {\n\t\t\terr = PTR_ERR(pipe_mnt);\n\t\t\tunregister_filesystem(&pipe_fs_type);\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "pipefs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "1160-1165",
    "snippet": "static struct dentry *pipefs_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"pipe:\", &pipefs_ops,\n\t\t\t&pipefs_dentry_operations, PIPEFS_MAGIC);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dentry_operations pipefs_dentry_operations = {\n\t.d_dname\t= pipefs_dname,\n};",
      "static const struct super_operations pipefs_ops = {\n\t.destroy_inode = free_inode_nonrcu,\n\t.statfs = simple_statfs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_pseudo",
          "args": [
            "fs_type",
            "\"pipe:\"",
            "&pipefs_ops",
            "&pipefs_dentry_operations",
            "PIPEFS_MAGIC"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic const struct dentry_operations pipefs_dentry_operations = {\n\t.d_dname\t= pipefs_dname,\n};\nstatic const struct super_operations pipefs_ops = {\n\t.destroy_inode = free_inode_nonrcu,\n\t.statfs = simple_statfs,\n};\n\nstatic struct dentry *pipefs_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"pipe:\", &pipefs_ops,\n\t\t\t&pipefs_dentry_operations, PIPEFS_MAGIC);\n}"
  },
  {
    "function_name": "pipe_fcntl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "1122-1147",
    "snippet": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\t__pipe_lock(pipe);\n\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ:\n\t\tret = pipe_set_size(pipe, arg);\n\t\tbreak;\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\t__pipe_unlock(pipe);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_set_size",
          "args": [
            "pipe",
            "arg"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "1028-1110",
          "snippet": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int size, nr_pages;\n\tunsigned long user_bufs;\n\tlong ret = 0;\n\n\tsize = round_pipe_size(arg);\n\tnr_pages = size >> PAGE_SHIFT;\n\n\tif (!nr_pages)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If trying to increase the pipe capacity, check that an\n\t * unprivileged user is not trying to exceed various limits\n\t * (soft limit check here, hard limit check just below).\n\t * Decreasing the pipe capacity is always permitted, even\n\t * if the user is currently over a limit.\n\t */\n\tif (nr_pages > pipe->buffers &&\n\t\t\tsize > pipe_max_size && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tuser_bufs = account_pipe_buffers(pipe->user, pipe->buffers, nr_pages);\n\n\tif (nr_pages > pipe->buffers &&\n\t\t\t(too_many_pipe_buffers_hard(user_bufs) ||\n\t\t\t too_many_pipe_buffers_soft(user_bufs)) &&\n\t\t\tis_unprivileged_user()) {\n\t\tret = -EPERM;\n\t\tgoto out_revert_acct;\n\t}\n\n\t/*\n\t * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't\n\t * expect a lot of shrink+grow operations, just free and allocate\n\t * again like we would do for growing. If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tif (nr_pages < pipe->nrbufs) {\n\t\tret = -EBUSY;\n\t\tgoto out_revert_acct;\n\t}\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_revert_acct;\n\t}\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indexes.\n\t */\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n\nout_revert_acct:\n\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->buffers);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int pipe_max_size = 1048576;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int pipe_max_size = 1048576;\n\nstatic long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int size, nr_pages;\n\tunsigned long user_bufs;\n\tlong ret = 0;\n\n\tsize = round_pipe_size(arg);\n\tnr_pages = size >> PAGE_SHIFT;\n\n\tif (!nr_pages)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If trying to increase the pipe capacity, check that an\n\t * unprivileged user is not trying to exceed various limits\n\t * (soft limit check here, hard limit check just below).\n\t * Decreasing the pipe capacity is always permitted, even\n\t * if the user is currently over a limit.\n\t */\n\tif (nr_pages > pipe->buffers &&\n\t\t\tsize > pipe_max_size && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tuser_bufs = account_pipe_buffers(pipe->user, pipe->buffers, nr_pages);\n\n\tif (nr_pages > pipe->buffers &&\n\t\t\t(too_many_pipe_buffers_hard(user_bufs) ||\n\t\t\t too_many_pipe_buffers_soft(user_bufs)) &&\n\t\t\tis_unprivileged_user()) {\n\t\tret = -EPERM;\n\t\tgoto out_revert_acct;\n\t}\n\n\t/*\n\t * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't\n\t * expect a lot of shrink+grow operations, just free and allocate\n\t * again like we would do for growing. If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tif (nr_pages < pipe->nrbufs) {\n\t\tret = -EBUSY;\n\t\tgoto out_revert_acct;\n\t}\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_revert_acct;\n\t}\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indexes.\n\t */\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n\nout_revert_acct:\n\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->buffers);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "file"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "1117-1120",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nlong pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\t__pipe_lock(pipe);\n\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ:\n\t\tret = pipe_set_size(pipe, arg);\n\t\tbreak;\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\t__pipe_unlock(pipe);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_pipe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "1117-1120",
    "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
  },
  {
    "function_name": "pipe_set_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "1028-1110",
    "snippet": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int size, nr_pages;\n\tunsigned long user_bufs;\n\tlong ret = 0;\n\n\tsize = round_pipe_size(arg);\n\tnr_pages = size >> PAGE_SHIFT;\n\n\tif (!nr_pages)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If trying to increase the pipe capacity, check that an\n\t * unprivileged user is not trying to exceed various limits\n\t * (soft limit check here, hard limit check just below).\n\t * Decreasing the pipe capacity is always permitted, even\n\t * if the user is currently over a limit.\n\t */\n\tif (nr_pages > pipe->buffers &&\n\t\t\tsize > pipe_max_size && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tuser_bufs = account_pipe_buffers(pipe->user, pipe->buffers, nr_pages);\n\n\tif (nr_pages > pipe->buffers &&\n\t\t\t(too_many_pipe_buffers_hard(user_bufs) ||\n\t\t\t too_many_pipe_buffers_soft(user_bufs)) &&\n\t\t\tis_unprivileged_user()) {\n\t\tret = -EPERM;\n\t\tgoto out_revert_acct;\n\t}\n\n\t/*\n\t * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't\n\t * expect a lot of shrink+grow operations, just free and allocate\n\t * again like we would do for growing. If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tif (nr_pages < pipe->nrbufs) {\n\t\tret = -EBUSY;\n\t\tgoto out_revert_acct;\n\t}\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_revert_acct;\n\t}\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indexes.\n\t */\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n\nout_revert_acct:\n\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->buffers);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int pipe_max_size = 1048576;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_pipe_buffers",
          "args": [
            "pipe->user",
            "nr_pages",
            "pipe->buffers"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "account_pipe_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "600-604",
          "snippet": "static unsigned long account_pipe_buffers(struct user_struct *user,\n                                 unsigned long old, unsigned long new)\n{\n\treturn atomic_long_add_return(new - old, &user->pipe_bufs);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic unsigned long account_pipe_buffers(struct user_struct *user,\n                                 unsigned long old, unsigned long new)\n{\n\treturn atomic_long_add_return(new - old, &user->pipe_bufs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pipe->bufs"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bufs + head",
            "pipe->bufs",
            "tail * sizeof(struct pipe_buffer)"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bufs",
            "pipe->bufs + pipe->curbuf",
            "head * sizeof(struct pipe_buffer)"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bufs"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_pages",
            "sizeof(*bufs)",
            "GFP_KERNEL_ACCOUNT | __GFP_NOWARN"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_unprivileged_user",
          "args": [],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "is_unprivileged_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "620-623",
          "snippet": "static bool is_unprivileged_user(void)\n{\n\treturn !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic bool is_unprivileged_user(void)\n{\n\treturn !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "too_many_pipe_buffers_soft",
          "args": [
            "user_bufs"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_pipe_buffers_soft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "606-611",
          "snippet": "static bool too_many_pipe_buffers_soft(unsigned long user_bufs)\n{\n\tunsigned long soft_limit = READ_ONCE(pipe_user_pages_soft);\n\n\treturn soft_limit && user_bufs > soft_limit;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;\n\nstatic bool too_many_pipe_buffers_soft(unsigned long user_bufs)\n{\n\tunsigned long soft_limit = READ_ONCE(pipe_user_pages_soft);\n\n\treturn soft_limit && user_bufs > soft_limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "too_many_pipe_buffers_hard",
          "args": [
            "user_bufs"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_pipe_buffers_hard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "613-618",
          "snippet": "static bool too_many_pipe_buffers_hard(unsigned long user_bufs)\n{\n\tunsigned long hard_limit = READ_ONCE(pipe_user_pages_hard);\n\n\treturn hard_limit && user_bufs > hard_limit;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long pipe_user_pages_hard;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned long pipe_user_pages_hard;\n\nstatic bool too_many_pipe_buffers_hard(unsigned long user_bufs)\n{\n\tunsigned long hard_limit = READ_ONCE(pipe_user_pages_hard);\n\n\treturn hard_limit && user_bufs > hard_limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_pipe_size",
          "args": [
            "arg"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "round_pipe_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "1012-1022",
          "snippet": "unsigned int round_pipe_size(unsigned long size)\n{\n\tif (size > (1U << 31))\n\t\treturn 0;\n\n\t/* Minimum pipe size, as required by POSIX */\n\tif (size < PAGE_SIZE)\n\t\treturn PAGE_SIZE;\n\n\treturn roundup_pow_of_two(size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int round_pipe_size(unsigned long size)\n{\n\tif (size > (1U << 31))\n\t\treturn 0;\n\n\t/* Minimum pipe size, as required by POSIX */\n\tif (size < PAGE_SIZE)\n\t\treturn PAGE_SIZE;\n\n\treturn roundup_pow_of_two(size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int pipe_max_size = 1048576;\n\nstatic long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int size, nr_pages;\n\tunsigned long user_bufs;\n\tlong ret = 0;\n\n\tsize = round_pipe_size(arg);\n\tnr_pages = size >> PAGE_SHIFT;\n\n\tif (!nr_pages)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If trying to increase the pipe capacity, check that an\n\t * unprivileged user is not trying to exceed various limits\n\t * (soft limit check here, hard limit check just below).\n\t * Decreasing the pipe capacity is always permitted, even\n\t * if the user is currently over a limit.\n\t */\n\tif (nr_pages > pipe->buffers &&\n\t\t\tsize > pipe_max_size && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tuser_bufs = account_pipe_buffers(pipe->user, pipe->buffers, nr_pages);\n\n\tif (nr_pages > pipe->buffers &&\n\t\t\t(too_many_pipe_buffers_hard(user_bufs) ||\n\t\t\t too_many_pipe_buffers_soft(user_bufs)) &&\n\t\t\tis_unprivileged_user()) {\n\t\tret = -EPERM;\n\t\tgoto out_revert_acct;\n\t}\n\n\t/*\n\t * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't\n\t * expect a lot of shrink+grow operations, just free and allocate\n\t * again like we would do for growing. If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tif (nr_pages < pipe->nrbufs) {\n\t\tret = -EBUSY;\n\t\tgoto out_revert_acct;\n\t}\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_revert_acct;\n\t}\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indexes.\n\t */\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n\nout_revert_acct:\n\t(void) account_pipe_buffers(pipe->user, nr_pages, pipe->buffers);\n\treturn ret;\n}"
  },
  {
    "function_name": "round_pipe_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "1012-1022",
    "snippet": "unsigned int round_pipe_size(unsigned long size)\n{\n\tif (size > (1U << 31))\n\t\treturn 0;\n\n\t/* Minimum pipe size, as required by POSIX */\n\tif (size < PAGE_SIZE)\n\t\treturn PAGE_SIZE;\n\n\treturn roundup_pow_of_two(size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "size"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int round_pipe_size(unsigned long size)\n{\n\tif (size > (1U << 31))\n\t\treturn 0;\n\n\t/* Minimum pipe size, as required by POSIX */\n\tif (size < PAGE_SIZE)\n\t\treturn PAGE_SIZE;\n\n\treturn roundup_pow_of_two(size);\n}"
  },
  {
    "function_name": "fifo_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "872-995",
    "snippet": "static int fifo_open(struct inode *inode, struct file *filp)\n{\n\tstruct pipe_inode_info *pipe;\n\tbool is_pipe = inode->i_sb->s_magic == PIPEFS_MAGIC;\n\tint ret;\n\n\tfilp->f_version = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (inode->i_pipe) {\n\t\tpipe = inode->i_pipe;\n\t\tpipe->files++;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\t\tpipe->files = 1;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (unlikely(inode->i_pipe)) {\n\t\t\tinode->i_pipe->files++;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tfree_pipe_info(pipe);\n\t\t\tpipe = inode->i_pipe;\n\t\t} else {\n\t\t\tinode->i_pipe = pipe;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t}\n\t}\n\tfilp->private_data = pipe;\n\t/* OK, we have a pipe and it's pinned down */\n\n\t__pipe_lock(pipe);\n\n\t/* We can only do regular read/write on fifos */\n\tfilp->f_mode &= (FMODE_READ | FMODE_WRITE);\n\n\tswitch (filp->f_mode) {\n\tcase FMODE_READ:\n\t/*\n\t *  O_RDONLY\n\t *  POSIX.1 says that O_NONBLOCK means return with the FIFO\n\t *  opened, even when there is no process writing the FIFO.\n\t */\n\t\tpipe->r_counter++;\n\t\tif (pipe->readers++ == 0)\n\t\t\twake_up_partner(pipe);\n\n\t\tif (!is_pipe && !pipe->writers) {\n\t\t\tif ((filp->f_flags & O_NONBLOCK)) {\n\t\t\t\t/* suppress EPOLLHUP until we have\n\t\t\t\t * seen a writer */\n\t\t\t\tfilp->f_version = pipe->w_counter;\n\t\t\t} else {\n\t\t\t\tif (wait_for_partner(pipe, &pipe->w_counter))\n\t\t\t\t\tgoto err_rd;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\n\tcase FMODE_WRITE:\n\t/*\n\t *  O_WRONLY\n\t *  POSIX.1 says that O_NONBLOCK means return -1 with\n\t *  errno=ENXIO when there is no process reading the FIFO.\n\t */\n\t\tret = -ENXIO;\n\t\tif (!is_pipe && (filp->f_flags & O_NONBLOCK) && !pipe->readers)\n\t\t\tgoto err;\n\n\t\tpipe->w_counter++;\n\t\tif (!pipe->writers++)\n\t\t\twake_up_partner(pipe);\n\n\t\tif (!is_pipe && !pipe->readers) {\n\t\t\tif (wait_for_partner(pipe, &pipe->r_counter))\n\t\t\t\tgoto err_wr;\n\t\t}\n\t\tbreak;\n\t\n\tcase FMODE_READ | FMODE_WRITE:\n\t/*\n\t *  O_RDWR\n\t *  POSIX.1 leaves this case \"undefined\" when O_NONBLOCK is set.\n\t *  This implementation will NEVER block on a O_RDWR open, since\n\t *  the process can at least talk to itself.\n\t */\n\n\t\tpipe->readers++;\n\t\tpipe->writers++;\n\t\tpipe->r_counter++;\n\t\tpipe->w_counter++;\n\t\tif (pipe->readers == 1 || pipe->writers == 1)\n\t\t\twake_up_partner(pipe);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* Ok! */\n\t__pipe_unlock(pipe);\n\treturn 0;\n\nerr_rd:\n\tif (!--pipe->readers)\n\t\twake_up_interruptible(&pipe->wait);\n\tret = -ERESTARTSYS;\n\tgoto err;\n\nerr_wr:\n\tif (!--pipe->writers)\n\t\twake_up_interruptible(&pipe->wait);\n\tret = -ERESTARTSYS;\n\tgoto err;\n\nerr:\n\t__pipe_unlock(pipe);\n\n\tput_pipe_info(inode, pipe);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pipe_info",
          "args": [
            "inode",
            "pipe"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "put_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "544-557",
          "snippet": "static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_partner",
          "args": [
            "pipe"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_partner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "867-870",
          "snippet": "static void wake_up_partner(struct pipe_inode_info *pipe)\n{\n\twake_up_interruptible(&pipe->wait);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void wake_up_partner(struct pipe_inode_info *pipe)\n{\n\twake_up_interruptible(&pipe->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_partner",
          "args": [
            "pipe",
            "&pipe->r_counter"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_partner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "855-865",
          "snippet": "static int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)\n{\n\tint cur = *cnt;\t\n\n\twhile (cur == *cnt) {\n\t\tpipe_wait(pipe);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn cur == *cnt ? -ERESTARTSYS : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)\n{\n\tint cur = *cnt;\t\n\n\twhile (cur == *cnt) {\n\t\tpipe_wait(pipe);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn cur == *cnt ? -ERESTARTSYS : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pipe_info",
          "args": [
            "pipe"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "free_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "670-685",
          "snippet": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\t(void) account_pipe_buffers(pipe->user, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\t(void) account_pipe_buffers(pipe->user, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_pipe"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pipe_info",
          "args": [],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "625-668",
          "snippet": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\tstruct user_struct *user = get_current_user();\n\tunsigned long user_bufs;\n\tunsigned int max_size = READ_ONCE(pipe_max_size);\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n\tif (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))\n\t\tpipe_bufs = max_size >> PAGE_SHIFT;\n\n\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\n\n\tif (too_many_pipe_buffers_soft(user_bufs) && is_unprivileged_user()) {\n\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, 1);\n\t\tpipe_bufs = 1;\n\t}\n\n\tif (too_many_pipe_buffers_hard(user_bufs) && is_unprivileged_user())\n\t\tgoto out_revert_acct;\n\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->buffers = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\nout_revert_acct:\n\t(void) account_pipe_buffers(user, pipe_bufs, 0);\n\tkfree(pipe);\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int pipe_max_size = 1048576;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int pipe_max_size = 1048576;\n\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\tstruct user_struct *user = get_current_user();\n\tunsigned long user_bufs;\n\tunsigned int max_size = READ_ONCE(pipe_max_size);\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n\tif (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))\n\t\tpipe_bufs = max_size >> PAGE_SHIFT;\n\n\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\n\n\tif (too_many_pipe_buffers_soft(user_bufs) && is_unprivileged_user()) {\n\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, 1);\n\t\tpipe_bufs = 1;\n\t}\n\n\tif (too_many_pipe_buffers_hard(user_bufs) && is_unprivileged_user())\n\t\tgoto out_revert_acct;\n\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->buffers = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\nout_revert_acct:\n\t(void) account_pipe_buffers(user, pipe_bufs, 0);\n\tkfree(pipe);\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int fifo_open(struct inode *inode, struct file *filp)\n{\n\tstruct pipe_inode_info *pipe;\n\tbool is_pipe = inode->i_sb->s_magic == PIPEFS_MAGIC;\n\tint ret;\n\n\tfilp->f_version = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (inode->i_pipe) {\n\t\tpipe = inode->i_pipe;\n\t\tpipe->files++;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\t\tpipe->files = 1;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (unlikely(inode->i_pipe)) {\n\t\t\tinode->i_pipe->files++;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tfree_pipe_info(pipe);\n\t\t\tpipe = inode->i_pipe;\n\t\t} else {\n\t\t\tinode->i_pipe = pipe;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t}\n\t}\n\tfilp->private_data = pipe;\n\t/* OK, we have a pipe and it's pinned down */\n\n\t__pipe_lock(pipe);\n\n\t/* We can only do regular read/write on fifos */\n\tfilp->f_mode &= (FMODE_READ | FMODE_WRITE);\n\n\tswitch (filp->f_mode) {\n\tcase FMODE_READ:\n\t/*\n\t *  O_RDONLY\n\t *  POSIX.1 says that O_NONBLOCK means return with the FIFO\n\t *  opened, even when there is no process writing the FIFO.\n\t */\n\t\tpipe->r_counter++;\n\t\tif (pipe->readers++ == 0)\n\t\t\twake_up_partner(pipe);\n\n\t\tif (!is_pipe && !pipe->writers) {\n\t\t\tif ((filp->f_flags & O_NONBLOCK)) {\n\t\t\t\t/* suppress EPOLLHUP until we have\n\t\t\t\t * seen a writer */\n\t\t\t\tfilp->f_version = pipe->w_counter;\n\t\t\t} else {\n\t\t\t\tif (wait_for_partner(pipe, &pipe->w_counter))\n\t\t\t\t\tgoto err_rd;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\n\tcase FMODE_WRITE:\n\t/*\n\t *  O_WRONLY\n\t *  POSIX.1 says that O_NONBLOCK means return -1 with\n\t *  errno=ENXIO when there is no process reading the FIFO.\n\t */\n\t\tret = -ENXIO;\n\t\tif (!is_pipe && (filp->f_flags & O_NONBLOCK) && !pipe->readers)\n\t\t\tgoto err;\n\n\t\tpipe->w_counter++;\n\t\tif (!pipe->writers++)\n\t\t\twake_up_partner(pipe);\n\n\t\tif (!is_pipe && !pipe->readers) {\n\t\t\tif (wait_for_partner(pipe, &pipe->r_counter))\n\t\t\t\tgoto err_wr;\n\t\t}\n\t\tbreak;\n\t\n\tcase FMODE_READ | FMODE_WRITE:\n\t/*\n\t *  O_RDWR\n\t *  POSIX.1 leaves this case \"undefined\" when O_NONBLOCK is set.\n\t *  This implementation will NEVER block on a O_RDWR open, since\n\t *  the process can at least talk to itself.\n\t */\n\n\t\tpipe->readers++;\n\t\tpipe->writers++;\n\t\tpipe->r_counter++;\n\t\tpipe->w_counter++;\n\t\tif (pipe->readers == 1 || pipe->writers == 1)\n\t\t\twake_up_partner(pipe);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* Ok! */\n\t__pipe_unlock(pipe);\n\treturn 0;\n\nerr_rd:\n\tif (!--pipe->readers)\n\t\twake_up_interruptible(&pipe->wait);\n\tret = -ERESTARTSYS;\n\tgoto err;\n\nerr_wr:\n\tif (!--pipe->writers)\n\t\twake_up_interruptible(&pipe->wait);\n\tret = -ERESTARTSYS;\n\tgoto err;\n\nerr:\n\t__pipe_unlock(pipe);\n\n\tput_pipe_info(inode, pipe);\n\treturn ret;\n}"
  },
  {
    "function_name": "wake_up_partner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "867-870",
    "snippet": "static void wake_up_partner(struct pipe_inode_info *pipe)\n{\n\twake_up_interruptible(&pipe->wait);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void wake_up_partner(struct pipe_inode_info *pipe)\n{\n\twake_up_interruptible(&pipe->wait);\n}"
  },
  {
    "function_name": "wait_for_partner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "855-865",
    "snippet": "static int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)\n{\n\tint cur = *cnt;\t\n\n\twhile (cur == *cnt) {\n\t\tpipe_wait(pipe);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn cur == *cnt ? -ERESTARTSYS : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "106-119",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)\n{\n\tint cur = *cnt;\t\n\n\twhile (cur == *cnt) {\n\t\tpipe_wait(pipe);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn cur == *cnt ? -ERESTARTSYS : 0;\n}"
  },
  {
    "function_name": "do_pipe2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "823-843",
    "snippet": "static int do_pipe2(int __user *fildes, int flags)\n{\n\tstruct file *files[2];\n\tint fd[2];\n\tint error;\n\n\terror = __do_pipe_flags(fd, files, flags);\n\tif (!error) {\n\t\tif (unlikely(copy_to_user(fildes, fd, sizeof(fd)))) {\n\t\t\tfput(files[0]);\n\t\t\tfput(files[1]);\n\t\t\tput_unused_fd(fd[0]);\n\t\t\tput_unused_fd(fd[1]);\n\t\t\terror = -EFAULT;\n\t\t} else {\n\t\t\tfd_install(fd[0], files[0]);\n\t\t\tfd_install(fd[1], files[1]);\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd[1]",
            "files[1]"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd[1]"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "556-562",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "files[1]"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copy_to_user(fildes, fd, sizeof(fd))"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "fildes",
            "fd",
            "sizeof(fd)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_pipe_flags",
          "args": [
            "fd",
            "files",
            "flags"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "__do_pipe_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "773-806",
          "snippet": "static int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int do_pipe2(int __user *fildes, int flags)\n{\n\tstruct file *files[2];\n\tint fd[2];\n\tint error;\n\n\terror = __do_pipe_flags(fd, files, flags);\n\tif (!error) {\n\t\tif (unlikely(copy_to_user(fildes, fd, sizeof(fd)))) {\n\t\t\tfput(files[0]);\n\t\t\tfput(files[1]);\n\t\t\tput_unused_fd(fd[0]);\n\t\t\tput_unused_fd(fd[1]);\n\t\t\terror = -EFAULT;\n\t\t} else {\n\t\t\tfd_install(fd[0], files[0]);\n\t\t\tfd_install(fd[1], files[1]);\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "do_pipe_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "808-817",
    "snippet": "int do_pipe_flags(int *fd, int flags)\n{\n\tstruct file *files[2];\n\tint error = __do_pipe_flags(fd, files, flags);\n\tif (!error) {\n\t\tfd_install(fd[0], files[0]);\n\t\tfd_install(fd[1], files[1]);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd[1]",
            "files[1]"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_pipe_flags",
          "args": [
            "fd",
            "files",
            "flags"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "__do_pipe_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "773-806",
          "snippet": "static int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint do_pipe_flags(int *fd, int flags)\n{\n\tstruct file *files[2];\n\tint error = __do_pipe_flags(fd, files, flags);\n\tif (!error) {\n\t\tfd_install(fd[0], files[0]);\n\t\tfd_install(fd[1], files[1]);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "__do_pipe_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "773-806",
    "snippet": "static int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "files[1]"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fdr"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "556-562",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_fd_pair",
          "args": [
            "fdr",
            "fdw"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "flags"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "542-545",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_pipe_files",
          "args": [
            "files",
            "flags"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "create_pipe_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "742-771",
          "snippet": "int create_pipe_files(struct file **res, int flags)\n{\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\tf = alloc_file_pseudo(inode, pipe_mnt, \"\",\n\t\t\t\tO_WRONLY | (flags & (O_NONBLOCK | O_DIRECT)),\n\t\t\t\t&pipefifo_fops);\n\tif (IS_ERR(f)) {\n\t\tfree_pipe_info(inode->i_pipe);\n\t\tiput(inode);\n\t\treturn PTR_ERR(f);\n\t}\n\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file_clone(f, O_RDONLY | (flags & O_NONBLOCK),\n\t\t\t\t  &pipefifo_fops);\n\tif (IS_ERR(res[0])) {\n\t\tput_pipe_info(inode, inode->i_pipe);\n\t\tfput(f);\n\t\treturn PTR_ERR(res[0]);\n\t}\n\tres[0]->private_data = inode->i_pipe;\n\tres[1] = f;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nint create_pipe_files(struct file **res, int flags)\n{\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\tf = alloc_file_pseudo(inode, pipe_mnt, \"\",\n\t\t\t\tO_WRONLY | (flags & (O_NONBLOCK | O_DIRECT)),\n\t\t\t\t&pipefifo_fops);\n\tif (IS_ERR(f)) {\n\t\tfree_pipe_info(inode->i_pipe);\n\t\tiput(inode);\n\t\treturn PTR_ERR(f);\n\t}\n\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file_clone(f, O_RDONLY | (flags & O_NONBLOCK),\n\t\t\t\t  &pipefifo_fops);\n\tif (IS_ERR(res[0])) {\n\t\tput_pipe_info(inode, inode->i_pipe);\n\t\tfput(f);\n\t\treturn PTR_ERR(res[0]);\n\t}\n\tres[0]->private_data = inode->i_pipe;\n\tres[1] = f;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}"
  },
  {
    "function_name": "create_pipe_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "742-771",
    "snippet": "int create_pipe_files(struct file **res, int flags)\n{\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\tf = alloc_file_pseudo(inode, pipe_mnt, \"\",\n\t\t\t\tO_WRONLY | (flags & (O_NONBLOCK | O_DIRECT)),\n\t\t\t\t&pipefifo_fops);\n\tif (IS_ERR(f)) {\n\t\tfree_pipe_info(inode->i_pipe);\n\t\tiput(inode);\n\t\treturn PTR_ERR(f);\n\t}\n\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file_clone(f, O_RDONLY | (flags & O_NONBLOCK),\n\t\t\t\t  &pipefifo_fops);\n\tif (IS_ERR(res[0])) {\n\t\tput_pipe_info(inode, inode->i_pipe);\n\t\tfput(f);\n\t\treturn PTR_ERR(res[0]);\n\t}\n\tres[0]->private_data = inode->i_pipe;\n\tres[1] = f;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res[0]"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pipe_info",
          "args": [
            "inode",
            "inode->i_pipe"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "put_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "544-557",
          "snippet": "static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res[0]"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_file_clone",
          "args": [
            "f",
            "O_RDONLY | (flags & O_NONBLOCK)",
            "&pipefifo_fops"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_file_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "240-249",
          "snippet": "struct file *alloc_file_clone(struct file *base, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct file *f = alloc_file(&base->f_path, flags, fops);\n\tif (!IS_ERR(f)) {\n\t\tpath_get(&f->f_path);\n\t\tf->f_mapping = base->f_mapping;\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file_clone(struct file *base, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct file *f = alloc_file(&base->f_path, flags, fops);\n\tif (!IS_ERR(f)) {\n\t\tpath_get(&f->f_path);\n\t\tf->f_mapping = base->f_mapping;\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "f"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pipe_info",
          "args": [
            "inode->i_pipe"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "free_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "670-685",
          "snippet": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\t(void) account_pipe_buffers(pipe->user, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\t(void) account_pipe_buffers(pipe->user, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_file_pseudo",
          "args": [
            "inode",
            "pipe_mnt",
            "\"\"",
            "O_WRONLY | (flags & (O_NONBLOCK | O_DIRECT))",
            "&pipefifo_fops"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_file_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "213-237",
          "snippet": "struct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,\n\t\t\t\tconst char *name, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstatic const struct dentry_operations anon_ops = {\n\t\t.d_dname = simple_dname\n\t};\n\tstruct qstr this = QSTR_INIT(name, strlen(name));\n\tstruct path path;\n\tstruct file *file;\n\n\tpath.dentry = d_alloc_pseudo(mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!mnt->mnt_sb->s_d_op)\n\t\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(mnt);\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, flags, fops);\n\tif (IS_ERR(file)) {\n\t\tihold(inode);\n\t\tpath_put(&path);\n\t}\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,\n\t\t\t\tconst char *name, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstatic const struct dentry_operations anon_ops = {\n\t\t.d_dname = simple_dname\n\t};\n\tstruct qstr this = QSTR_INIT(name, strlen(name));\n\tstruct path path;\n\tstruct file *file;\n\n\tpath.dentry = d_alloc_pseudo(mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!mnt->mnt_sb->s_d_op)\n\t\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(mnt);\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, flags, fops);\n\tif (IS_ERR(file)) {\n\t\tihold(inode);\n\t\tpath_put(&path);\n\t}\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_inode",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "702-740",
          "snippet": "static struct inode * get_pipe_inode(void)\n{\n\tstruct inode *inode = new_inode_pseudo(pipe_mnt->mnt_sb);\n\tstruct pipe_inode_info *pipe;\n\n\tif (!inode)\n\t\tgoto fail_inode;\n\n\tinode->i_ino = get_next_ino();\n\n\tpipe = alloc_pipe_info();\n\tif (!pipe)\n\t\tgoto fail_iput;\n\n\tinode->i_pipe = pipe;\n\tpipe->files = 2;\n\tpipe->readers = pipe->writers = 1;\n\tinode->i_fop = &pipefifo_fops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because \"mark_inode_dirty()\" will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\n\treturn inode;\n\nfail_iput:\n\tiput(inode);\n\nfail_inode:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstatic struct inode * get_pipe_inode(void)\n{\n\tstruct inode *inode = new_inode_pseudo(pipe_mnt->mnt_sb);\n\tstruct pipe_inode_info *pipe;\n\n\tif (!inode)\n\t\tgoto fail_inode;\n\n\tinode->i_ino = get_next_ino();\n\n\tpipe = alloc_pipe_info();\n\tif (!pipe)\n\t\tgoto fail_iput;\n\n\tinode->i_pipe = pipe;\n\tpipe->files = 2;\n\tpipe->readers = pipe->writers = 1;\n\tinode->i_fop = &pipefifo_fops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because \"mark_inode_dirty()\" will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\n\treturn inode;\n\nfail_iput:\n\tiput(inode);\n\nfail_inode:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nint create_pipe_files(struct file **res, int flags)\n{\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\tf = alloc_file_pseudo(inode, pipe_mnt, \"\",\n\t\t\t\tO_WRONLY | (flags & (O_NONBLOCK | O_DIRECT)),\n\t\t\t\t&pipefifo_fops);\n\tif (IS_ERR(f)) {\n\t\tfree_pipe_info(inode->i_pipe);\n\t\tiput(inode);\n\t\treturn PTR_ERR(f);\n\t}\n\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file_clone(f, O_RDONLY | (flags & O_NONBLOCK),\n\t\t\t\t  &pipefifo_fops);\n\tif (IS_ERR(res[0])) {\n\t\tput_pipe_info(inode, inode->i_pipe);\n\t\tfput(f);\n\t\treturn PTR_ERR(res[0]);\n\t}\n\tres[0]->private_data = inode->i_pipe;\n\tres[1] = f;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_pipe_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "702-740",
    "snippet": "static struct inode * get_pipe_inode(void)\n{\n\tstruct inode *inode = new_inode_pseudo(pipe_mnt->mnt_sb);\n\tstruct pipe_inode_info *pipe;\n\n\tif (!inode)\n\t\tgoto fail_inode;\n\n\tinode->i_ino = get_next_ino();\n\n\tpipe = alloc_pipe_info();\n\tif (!pipe)\n\t\tgoto fail_iput;\n\n\tinode->i_pipe = pipe;\n\tpipe->files = 2;\n\tpipe->readers = pipe->writers = 1;\n\tinode->i_fop = &pipefifo_fops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because \"mark_inode_dirty()\" will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\n\treturn inode;\n\nfail_iput:\n\tiput(inode);\n\nfail_inode:\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pipe_info",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "625-668",
          "snippet": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\tstruct user_struct *user = get_current_user();\n\tunsigned long user_bufs;\n\tunsigned int max_size = READ_ONCE(pipe_max_size);\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n\tif (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))\n\t\tpipe_bufs = max_size >> PAGE_SHIFT;\n\n\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\n\n\tif (too_many_pipe_buffers_soft(user_bufs) && is_unprivileged_user()) {\n\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, 1);\n\t\tpipe_bufs = 1;\n\t}\n\n\tif (too_many_pipe_buffers_hard(user_bufs) && is_unprivileged_user())\n\t\tgoto out_revert_acct;\n\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->buffers = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\nout_revert_acct:\n\t(void) account_pipe_buffers(user, pipe_bufs, 0);\n\tkfree(pipe);\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int pipe_max_size = 1048576;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int pipe_max_size = 1048576;\n\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\tstruct user_struct *user = get_current_user();\n\tunsigned long user_bufs;\n\tunsigned int max_size = READ_ONCE(pipe_max_size);\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n\tif (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))\n\t\tpipe_bufs = max_size >> PAGE_SHIFT;\n\n\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\n\n\tif (too_many_pipe_buffers_soft(user_bufs) && is_unprivileged_user()) {\n\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, 1);\n\t\tpipe_bufs = 1;\n\t}\n\n\tif (too_many_pipe_buffers_hard(user_bufs) && is_unprivileged_user())\n\t\tgoto out_revert_acct;\n\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->buffers = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\nout_revert_acct:\n\t(void) account_pipe_buffers(user, pipe_bufs, 0);\n\tkfree(pipe);\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "870-891",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);",
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode_pseudo",
          "args": [
            "pipe_mnt->mnt_sb"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "904-915",
          "snippet": "struct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstatic struct inode * get_pipe_inode(void)\n{\n\tstruct inode *inode = new_inode_pseudo(pipe_mnt->mnt_sb);\n\tstruct pipe_inode_info *pipe;\n\n\tif (!inode)\n\t\tgoto fail_inode;\n\n\tinode->i_ino = get_next_ino();\n\n\tpipe = alloc_pipe_info();\n\tif (!pipe)\n\t\tgoto fail_iput;\n\n\tinode->i_pipe = pipe;\n\tpipe->files = 2;\n\tpipe->readers = pipe->writers = 1;\n\tinode->i_fop = &pipefifo_fops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because \"mark_inode_dirty()\" will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\n\treturn inode;\n\nfail_iput:\n\tiput(inode);\n\nfail_inode:\n\treturn NULL;\n}"
  },
  {
    "function_name": "pipefs_dname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "692-696",
    "snippet": "static char *pipefs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"pipe:[%lu]\",\n\t\t\t\td_inode(dentry)->i_ino);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dynamic_dname",
          "args": [
            "dentry",
            "buffer",
            "buflen",
            "\"pipe:[%lu]\"",
            "d_inode(dentry)->i_ino"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "dynamic_dname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "291-307",
          "snippet": "char *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic char *pipefs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"pipe:[%lu]\",\n\t\t\t\td_inode(dentry)->i_ino);\n}"
  },
  {
    "function_name": "free_pipe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "670-685",
    "snippet": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\t(void) account_pipe_buffers(pipe->user, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pipe"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pipe->tmp_page"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_buf_release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "generic_pipe_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "222-226",
          "snippet": "void generic_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t      struct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid generic_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t      struct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "pipe->user"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_pipe_buffers",
          "args": [
            "pipe->user",
            "pipe->buffers",
            "0"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "account_pipe_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "600-604",
          "snippet": "static unsigned long account_pipe_buffers(struct user_struct *user,\n                                 unsigned long old, unsigned long new)\n{\n\treturn atomic_long_add_return(new - old, &user->pipe_bufs);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic unsigned long account_pipe_buffers(struct user_struct *user,\n                                 unsigned long old, unsigned long new)\n{\n\treturn atomic_long_add_return(new - old, &user->pipe_bufs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\t(void) account_pipe_buffers(pipe->user, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}"
  },
  {
    "function_name": "alloc_pipe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "625-668",
    "snippet": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\tstruct user_struct *user = get_current_user();\n\tunsigned long user_bufs;\n\tunsigned int max_size = READ_ONCE(pipe_max_size);\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n\tif (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))\n\t\tpipe_bufs = max_size >> PAGE_SHIFT;\n\n\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\n\n\tif (too_many_pipe_buffers_soft(user_bufs) && is_unprivileged_user()) {\n\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, 1);\n\t\tpipe_bufs = 1;\n\t}\n\n\tif (too_many_pipe_buffers_hard(user_bufs) && is_unprivileged_user())\n\t\tgoto out_revert_acct;\n\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->buffers = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\nout_revert_acct:\n\t(void) account_pipe_buffers(user, pipe_bufs, 0);\n\tkfree(pipe);\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int pipe_max_size = 1048576;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pipe"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_pipe_buffers",
          "args": [
            "user",
            "pipe_bufs",
            "0"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "account_pipe_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "600-604",
          "snippet": "static unsigned long account_pipe_buffers(struct user_struct *user,\n                                 unsigned long old, unsigned long new)\n{\n\treturn atomic_long_add_return(new - old, &user->pipe_bufs);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic unsigned long account_pipe_buffers(struct user_struct *user,\n                                 unsigned long old, unsigned long new)\n{\n\treturn atomic_long_add_return(new - old, &user->pipe_bufs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&pipe->mutex"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&pipe->wait"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "pipe_bufs",
            "sizeof(struct pipe_buffer)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_unprivileged_user",
          "args": [],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "is_unprivileged_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "620-623",
          "snippet": "static bool is_unprivileged_user(void)\n{\n\treturn !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic bool is_unprivileged_user(void)\n{\n\treturn !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "too_many_pipe_buffers_hard",
          "args": [
            "user_bufs"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_pipe_buffers_hard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "613-618",
          "snippet": "static bool too_many_pipe_buffers_hard(unsigned long user_bufs)\n{\n\tunsigned long hard_limit = READ_ONCE(pipe_user_pages_hard);\n\n\treturn hard_limit && user_bufs > hard_limit;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long pipe_user_pages_hard;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned long pipe_user_pages_hard;\n\nstatic bool too_many_pipe_buffers_hard(unsigned long user_bufs)\n{\n\tunsigned long hard_limit = READ_ONCE(pipe_user_pages_hard);\n\n\treturn hard_limit && user_bufs > hard_limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "too_many_pipe_buffers_soft",
          "args": [
            "user_bufs"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_pipe_buffers_soft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "606-611",
          "snippet": "static bool too_many_pipe_buffers_soft(unsigned long user_bufs)\n{\n\tunsigned long soft_limit = READ_ONCE(pipe_user_pages_soft);\n\n\treturn soft_limit && user_bufs > soft_limit;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;\n\nstatic bool too_many_pipe_buffers_soft(unsigned long user_bufs)\n{\n\tunsigned long soft_limit = READ_ONCE(pipe_user_pages_soft);\n\n\treturn soft_limit && user_bufs > soft_limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pipe_inode_info)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pipe_max_size"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_user",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int pipe_max_size = 1048576;\n\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\tstruct user_struct *user = get_current_user();\n\tunsigned long user_bufs;\n\tunsigned int max_size = READ_ONCE(pipe_max_size);\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n\tif (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))\n\t\tpipe_bufs = max_size >> PAGE_SHIFT;\n\n\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\n\n\tif (too_many_pipe_buffers_soft(user_bufs) && is_unprivileged_user()) {\n\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, 1);\n\t\tpipe_bufs = 1;\n\t}\n\n\tif (too_many_pipe_buffers_hard(user_bufs) && is_unprivileged_user())\n\t\tgoto out_revert_acct;\n\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->buffers = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\nout_revert_acct:\n\t(void) account_pipe_buffers(user, pipe_bufs, 0);\n\tkfree(pipe);\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}"
  },
  {
    "function_name": "is_unprivileged_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "620-623",
    "snippet": "static bool is_unprivileged_user(void)\n{\n\treturn !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic bool is_unprivileged_user(void)\n{\n\treturn !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);\n}"
  },
  {
    "function_name": "too_many_pipe_buffers_hard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "613-618",
    "snippet": "static bool too_many_pipe_buffers_hard(unsigned long user_bufs)\n{\n\tunsigned long hard_limit = READ_ONCE(pipe_user_pages_hard);\n\n\treturn hard_limit && user_bufs > hard_limit;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long pipe_user_pages_hard;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pipe_user_pages_hard"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned long pipe_user_pages_hard;\n\nstatic bool too_many_pipe_buffers_hard(unsigned long user_bufs)\n{\n\tunsigned long hard_limit = READ_ONCE(pipe_user_pages_hard);\n\n\treturn hard_limit && user_bufs > hard_limit;\n}"
  },
  {
    "function_name": "too_many_pipe_buffers_soft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "606-611",
    "snippet": "static bool too_many_pipe_buffers_soft(unsigned long user_bufs)\n{\n\tunsigned long soft_limit = READ_ONCE(pipe_user_pages_soft);\n\n\treturn soft_limit && user_bufs > soft_limit;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pipe_user_pages_soft"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;\n\nstatic bool too_many_pipe_buffers_soft(unsigned long user_bufs)\n{\n\tunsigned long soft_limit = READ_ONCE(pipe_user_pages_soft);\n\n\treturn soft_limit && user_bufs > soft_limit;\n}"
  },
  {
    "function_name": "account_pipe_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "600-604",
    "snippet": "static unsigned long account_pipe_buffers(struct user_struct *user,\n                                 unsigned long old, unsigned long new)\n{\n\treturn atomic_long_add_return(new - old, &user->pipe_bufs);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "new - old",
            "&user->pipe_bufs"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic unsigned long account_pipe_buffers(struct user_struct *user,\n                                 unsigned long old, unsigned long new)\n{\n\treturn atomic_long_add_return(new - old, &user->pipe_bufs);\n}"
  },
  {
    "function_name": "pipe_fasync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "581-598",
    "snippet": "static int\npipe_fasync(int fd, struct file *filp, int on)\n{\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint retval = 0;\n\n\t__pipe_lock(pipe);\n\tif (filp->f_mode & FMODE_READ)\n\t\tretval = fasync_helper(fd, filp, on, &pipe->fasync_readers);\n\tif ((filp->f_mode & FMODE_WRITE) && retval >= 0) {\n\t\tretval = fasync_helper(fd, filp, on, &pipe->fasync_writers);\n\t\tif (retval < 0 && (filp->f_mode & FMODE_READ))\n\t\t\t/* this can happen only if on == T */\n\t\t\tfasync_helper(-1, filp, 0, &pipe->fasync_readers);\n\t}\n\t__pipe_unlock(pipe);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fasync_helper",
          "args": [
            "-1",
            "filp",
            "0",
            "&pipe->fasync_readers"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "978-983",
          "snippet": "int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nint fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int\npipe_fasync(int fd, struct file *filp, int on)\n{\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint retval = 0;\n\n\t__pipe_lock(pipe);\n\tif (filp->f_mode & FMODE_READ)\n\t\tretval = fasync_helper(fd, filp, on, &pipe->fasync_readers);\n\tif ((filp->f_mode & FMODE_WRITE) && retval >= 0) {\n\t\tretval = fasync_helper(fd, filp, on, &pipe->fasync_writers);\n\t\tif (retval < 0 && (filp->f_mode & FMODE_READ))\n\t\t\t/* this can happen only if on == T */\n\t\t\tfasync_helper(-1, filp, 0, &pipe->fasync_readers);\n\t}\n\t__pipe_unlock(pipe);\n\treturn retval;\n}"
  },
  {
    "function_name": "pipe_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "559-579",
    "snippet": "static int\npipe_release(struct inode *inode, struct file *file)\n{\n\tstruct pipe_inode_info *pipe = file->private_data;\n\n\t__pipe_lock(pipe);\n\tif (file->f_mode & FMODE_READ)\n\t\tpipe->readers--;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tpipe->writers--;\n\n\tif (pipe->readers || pipe->writers) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLIN | EPOLLOUT | EPOLLRDNORM | EPOLLWRNORM | EPOLLERR | EPOLLHUP);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t}\n\t__pipe_unlock(pipe);\n\n\tput_pipe_info(inode, pipe);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pipe_info",
          "args": [
            "inode",
            "pipe"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "put_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "544-557",
          "snippet": "static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_writers",
            "SIGIO",
            "POLL_OUT"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "1014-1024",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "EPOLLIN | EPOLLOUT | EPOLLRDNORM | EPOLLWRNORM | EPOLLERR | EPOLLHUP"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int\npipe_release(struct inode *inode, struct file *file)\n{\n\tstruct pipe_inode_info *pipe = file->private_data;\n\n\t__pipe_lock(pipe);\n\tif (file->f_mode & FMODE_READ)\n\t\tpipe->readers--;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tpipe->writers--;\n\n\tif (pipe->readers || pipe->writers) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLIN | EPOLLOUT | EPOLLRDNORM | EPOLLWRNORM | EPOLLERR | EPOLLHUP);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t}\n\t__pipe_unlock(pipe);\n\n\tput_pipe_info(inode, pipe);\n\treturn 0;\n}"
  },
  {
    "function_name": "put_pipe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "544-557",
    "snippet": "static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pipe_info",
          "args": [
            "pipe"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "free_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "670-685",
          "snippet": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\t(void) account_pipe_buffers(pipe->user, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\t(void) account_pipe_buffers(pipe->user, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}"
  },
  {
    "function_name": "pipe_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "513-542",
    "snippet": "static __poll_t\npipe_poll(struct file *filp, poll_table *wait)\n{\n\t__poll_t mask;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint nrbufs;\n\n\tpoll_wait(filp, &pipe->wait, wait);\n\n\t/* Reading only -- no need for acquiring the semaphore.  */\n\tnrbufs = pipe->nrbufs;\n\tmask = 0;\n\tif (filp->f_mode & FMODE_READ) {\n\t\tmask = (nrbufs > 0) ? EPOLLIN | EPOLLRDNORM : 0;\n\t\tif (!pipe->writers && filp->f_version != pipe->w_counter)\n\t\t\tmask |= EPOLLHUP;\n\t}\n\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tmask |= (nrbufs < pipe->buffers) ? EPOLLOUT | EPOLLWRNORM : 0;\n\t\t/*\n\t\t * Most Unices do not set EPOLLERR for FIFOs but on Linux they\n\t\t * behave exactly like pipes for poll().\n\t\t */\n\t\tif (!pipe->readers)\n\t\t\tmask |= EPOLLERR;\n\t}\n\n\treturn mask;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "filp",
            "&pipe->wait",
            "wait"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic __poll_t\npipe_poll(struct file *filp, poll_table *wait)\n{\n\t__poll_t mask;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint nrbufs;\n\n\tpoll_wait(filp, &pipe->wait, wait);\n\n\t/* Reading only -- no need for acquiring the semaphore.  */\n\tnrbufs = pipe->nrbufs;\n\tmask = 0;\n\tif (filp->f_mode & FMODE_READ) {\n\t\tmask = (nrbufs > 0) ? EPOLLIN | EPOLLRDNORM : 0;\n\t\tif (!pipe->writers && filp->f_version != pipe->w_counter)\n\t\t\tmask |= EPOLLHUP;\n\t}\n\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tmask |= (nrbufs < pipe->buffers) ? EPOLLOUT | EPOLLWRNORM : 0;\n\t\t/*\n\t\t * Most Unices do not set EPOLLERR for FIFOs but on Linux they\n\t\t * behave exactly like pipes for poll().\n\t\t */\n\t\tif (!pipe->readers)\n\t\t\tmask |= EPOLLERR;\n\t}\n\n\treturn mask;\n}"
  },
  {
    "function_name": "pipe_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "489-510",
    "snippet": "static long pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint count, buf, nrbufs;\n\n\tswitch (cmd) {\n\t\tcase FIONREAD:\n\t\t\t__pipe_lock(pipe);\n\t\t\tcount = 0;\n\t\t\tbuf = pipe->curbuf;\n\t\t\tnrbufs = pipe->nrbufs;\n\t\t\twhile (--nrbufs >= 0) {\n\t\t\t\tcount += pipe->bufs[buf].len;\n\t\t\t\tbuf = (buf+1) & (pipe->buffers - 1);\n\t\t\t}\n\t\t\t__pipe_unlock(pipe);\n\n\t\t\treturn put_user(count, (int __user *)arg);\n\t\tdefault:\n\t\t\treturn -ENOIOCTLCMD;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "count",
            "(int __user *)arg"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic long pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint count, buf, nrbufs;\n\n\tswitch (cmd) {\n\t\tcase FIONREAD:\n\t\t\t__pipe_lock(pipe);\n\t\t\tcount = 0;\n\t\t\tbuf = pipe->curbuf;\n\t\t\tnrbufs = pipe->nrbufs;\n\t\t\twhile (--nrbufs >= 0) {\n\t\t\t\tcount += pipe->bufs[buf].len;\n\t\t\t\tbuf = (buf+1) & (pipe->buffers - 1);\n\t\t\t}\n\t\t\t__pipe_unlock(pipe);\n\n\t\t\treturn put_user(count, (int __user *)arg);\n\t\tdefault:\n\t\t\treturn -ENOIOCTLCMD;\n\t}\n}"
  },
  {
    "function_name": "pipe_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "352-487",
    "snippet": "static ssize_t\npipe_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tssize_t ret = 0;\n\tint do_wakeup = 0;\n\tsize_t total_len = iov_iter_count(from);\n\tssize_t chars;\n\n\t/* Null write succeeds. */\n\tif (unlikely(total_len == 0))\n\t\treturn 0;\n\n\t__pipe_lock(pipe);\n\n\tif (!pipe->readers) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\t/* We try to merge small writes */\n\tchars = total_len & (PAGE_SIZE-1); /* size of the last buffer */\n\tif (pipe->nrbufs && chars != 0) {\n\t\tint lastbuf = (pipe->curbuf + pipe->nrbufs - 1) &\n\t\t\t\t\t\t\t(pipe->buffers - 1);\n\t\tstruct pipe_buffer *buf = pipe->bufs + lastbuf;\n\t\tint offset = buf->offset + buf->len;\n\n\t\tif (buf->ops->can_merge && offset + chars <= PAGE_SIZE) {\n\t\t\tret = pipe_buf_confirm(pipe, buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\n\t\t\tif (unlikely(ret < chars)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdo_wakeup = 1;\n\t\t\tbuf->len += ret;\n\t\t\tif (!iov_iter_count(from))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tint bufs;\n\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tbufs = pipe->nrbufs;\n\t\tif (bufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\t\t\tstruct page *page = pipe->tmp_page;\n\t\t\tint copied;\n\n\t\t\tif (!page) {\n\t\t\t\tpage = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);\n\t\t\t\tif (unlikely(!page)) {\n\t\t\t\t\tret = ret ? : -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpipe->tmp_page = page;\n\t\t\t}\n\t\t\t/* Always wake up, even if the copy fails. Otherwise\n\t\t\t * we lock up (O_NONBLOCK-)readers that sleep due to\n\t\t\t * syscall merging.\n\t\t\t * FIXME! Is this really true?\n\t\t\t */\n\t\t\tdo_wakeup = 1;\n\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\n\t\t\tif (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += copied;\n\n\t\t\t/* Insert it into the buffer array */\n\t\t\tbuf->page = page;\n\t\t\tbuf->ops = &anon_pipe_buf_ops;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = copied;\n\t\t\tbuf->flags = 0;\n\t\t\tif (is_packetized(filp)) {\n\t\t\t\tbuf->ops = &packet_pipe_buf_ops;\n\t\t\t\tbuf->flags = PIPE_BUF_FLAG_PACKET;\n\t\t\t}\n\t\t\tpipe->nrbufs = ++bufs;\n\t\t\tpipe->tmp_page = NULL;\n\n\t\t\tif (!iov_iter_count(from))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bufs < pipe->buffers)\n\t\t\tcontinue;\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (do_wakeup) {\n\t\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLIN | EPOLLRDNORM);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\tif (do_wakeup) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLIN | EPOLLRDNORM);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t}\n\tif (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {\n\t\tint err = file_update_time(filp);\n\t\tif (err)\n\t\t\tret = err;\n\t\tsb_end_write(file_inode(filp)->i_sb);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pipe_buf_operations anon_pipe_buf_ops = {\n\t.can_merge = 1,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = anon_pipe_buf_release,\n\t.steal = anon_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};",
      "static const struct pipe_buf_operations packet_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = anon_pipe_buf_release,\n\t.steal = anon_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "file_inode(filp)->i_sb"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "filp"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1852-1884",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec64 now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_time(inode);\n\tif (!timespec64_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec64_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode) && inode_iversion_need_inc(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec64 now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_time(inode);\n\tif (!timespec64_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec64_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode) && inode_iversion_need_inc(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_write_trylock",
          "args": [
            "file_inode(filp)->i_sb"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_readers",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "1014-1024",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "EPOLLIN | EPOLLRDNORM"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "106-119",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "EPOLLIN | EPOLLRDNORM"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_packetized",
          "args": [
            "filp"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "is_packetized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "347-350",
          "snippet": "static inline int is_packetized(struct file *file)\n{\n\treturn (file->f_flags & O_DIRECT) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline int is_packetized(struct file *file)\n{\n\treturn (file->f_flags & O_DIRECT) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < PAGE_SIZE && iov_iter_count(from)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_from_iter",
          "args": [
            "page",
            "0",
            "PAGE_SIZE",
            "from"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER | __GFP_ACCOUNT"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "87-106",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/sched/signal.h>\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "808-813",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < chars"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_from_iter",
          "args": [
            "buf->page",
            "offset",
            "chars",
            "from"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_buf_confirm",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "generic_pipe_buf_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "207-211",
          "snippet": "int generic_pipe_buf_confirm(struct pipe_inode_info *info,\n\t\t\t     struct pipe_buffer *buf)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint generic_pipe_buf_confirm(struct pipe_inode_info *info,\n\t\t\t     struct pipe_buffer *buf)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "total_len == 0"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic const struct pipe_buf_operations anon_pipe_buf_ops = {\n\t.can_merge = 1,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = anon_pipe_buf_release,\n\t.steal = anon_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\nstatic const struct pipe_buf_operations packet_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = anon_pipe_buf_release,\n\t.steal = anon_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\n\nstatic ssize_t\npipe_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tssize_t ret = 0;\n\tint do_wakeup = 0;\n\tsize_t total_len = iov_iter_count(from);\n\tssize_t chars;\n\n\t/* Null write succeeds. */\n\tif (unlikely(total_len == 0))\n\t\treturn 0;\n\n\t__pipe_lock(pipe);\n\n\tif (!pipe->readers) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\t/* We try to merge small writes */\n\tchars = total_len & (PAGE_SIZE-1); /* size of the last buffer */\n\tif (pipe->nrbufs && chars != 0) {\n\t\tint lastbuf = (pipe->curbuf + pipe->nrbufs - 1) &\n\t\t\t\t\t\t\t(pipe->buffers - 1);\n\t\tstruct pipe_buffer *buf = pipe->bufs + lastbuf;\n\t\tint offset = buf->offset + buf->len;\n\n\t\tif (buf->ops->can_merge && offset + chars <= PAGE_SIZE) {\n\t\t\tret = pipe_buf_confirm(pipe, buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\n\t\t\tif (unlikely(ret < chars)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdo_wakeup = 1;\n\t\t\tbuf->len += ret;\n\t\t\tif (!iov_iter_count(from))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tint bufs;\n\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tbufs = pipe->nrbufs;\n\t\tif (bufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\t\t\tstruct page *page = pipe->tmp_page;\n\t\t\tint copied;\n\n\t\t\tif (!page) {\n\t\t\t\tpage = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);\n\t\t\t\tif (unlikely(!page)) {\n\t\t\t\t\tret = ret ? : -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpipe->tmp_page = page;\n\t\t\t}\n\t\t\t/* Always wake up, even if the copy fails. Otherwise\n\t\t\t * we lock up (O_NONBLOCK-)readers that sleep due to\n\t\t\t * syscall merging.\n\t\t\t * FIXME! Is this really true?\n\t\t\t */\n\t\t\tdo_wakeup = 1;\n\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\n\t\t\tif (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += copied;\n\n\t\t\t/* Insert it into the buffer array */\n\t\t\tbuf->page = page;\n\t\t\tbuf->ops = &anon_pipe_buf_ops;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = copied;\n\t\t\tbuf->flags = 0;\n\t\t\tif (is_packetized(filp)) {\n\t\t\t\tbuf->ops = &packet_pipe_buf_ops;\n\t\t\t\tbuf->flags = PIPE_BUF_FLAG_PACKET;\n\t\t\t}\n\t\t\tpipe->nrbufs = ++bufs;\n\t\t\tpipe->tmp_page = NULL;\n\n\t\t\tif (!iov_iter_count(from))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bufs < pipe->buffers)\n\t\t\tcontinue;\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (do_wakeup) {\n\t\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLIN | EPOLLRDNORM);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\tif (do_wakeup) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLIN | EPOLLRDNORM);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t}\n\tif (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {\n\t\tint err = file_update_time(filp);\n\t\tif (err)\n\t\t\tret = err;\n\t\tsb_end_write(file_inode(filp)->i_sb);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "is_packetized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "347-350",
    "snippet": "static inline int is_packetized(struct file *file)\n{\n\treturn (file->f_flags & O_DIRECT) != 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline int is_packetized(struct file *file)\n{\n\treturn (file->f_flags & O_DIRECT) != 0;\n}"
  },
  {
    "function_name": "pipe_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "245-345",
    "snippet": "static ssize_t\npipe_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tsize_t total_len = iov_iter_count(to);\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint do_wakeup;\n\tssize_t ret;\n\n\t/* Null read succeeds. */\n\tif (unlikely(total_len == 0))\n\t\treturn 0;\n\n\tdo_wakeup = 0;\n\tret = 0;\n\t__pipe_lock(pipe);\n\tfor (;;) {\n\t\tint bufs = pipe->nrbufs;\n\t\tif (bufs) {\n\t\t\tint curbuf = pipe->curbuf;\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + curbuf;\n\t\t\tsize_t chars = buf->len;\n\t\t\tsize_t written;\n\t\t\tint error;\n\n\t\t\tif (chars > total_len)\n\t\t\t\tchars = total_len;\n\n\t\t\terror = pipe_buf_confirm(pipe, buf);\n\t\t\tif (error) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = error;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twritten = copy_page_to_iter(buf->page, buf->offset, chars, to);\n\t\t\tif (unlikely(written < chars)) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += chars;\n\t\t\tbuf->offset += chars;\n\t\t\tbuf->len -= chars;\n\n\t\t\t/* Was it a packet buffer? Clean up and exit */\n\t\t\tif (buf->flags & PIPE_BUF_FLAG_PACKET) {\n\t\t\t\ttotal_len = chars;\n\t\t\t\tbuf->len = 0;\n\t\t\t}\n\n\t\t\tif (!buf->len) {\n\t\t\t\tpipe_buf_release(pipe, buf);\n\t\t\t\tcurbuf = (curbuf + 1) & (pipe->buffers - 1);\n\t\t\t\tpipe->curbuf = curbuf;\n\t\t\t\tpipe->nrbufs = --bufs;\n\t\t\t\tdo_wakeup = 1;\n\t\t\t}\n\t\t\ttotal_len -= chars;\n\t\t\tif (!total_len)\n\t\t\t\tbreak;\t/* common path: read succeeded */\n\t\t}\n\t\tif (bufs)\t/* More to do? */\n\t\t\tcontinue;\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\t/* syscall merging: Usually we must not sleep\n\t\t\t * if O_NONBLOCK is set, or if we got some data.\n\t\t\t * But if a writer sleeps in kernel space, then\n\t\t\t * we can wait for that data without violating POSIX.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (do_wakeup) {\n\t\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLOUT | EPOLLWRNORM);\n \t\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\t__pipe_unlock(pipe);\n\n\t/* Signal writers asynchronously that there is more room. */\n\tif (do_wakeup) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLOUT | EPOLLWRNORM);\n\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t}\n\tif (ret > 0)\n\t\tfile_accessed(filp);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "filp"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_file_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/file.c",
          "lines": "155-175",
          "snippet": "static void ovl_file_accessed(struct file *file)\n{\n\tstruct inode *inode, *upperinode;\n\n\tif (file->f_flags & O_NOATIME)\n\t\treturn;\n\n\tinode = file_inode(file);\n\tupperinode = ovl_inode_upper(inode);\n\n\tif (!upperinode)\n\t\treturn;\n\n\tif ((!timespec64_equal(&inode->i_mtime, &upperinode->i_mtime) ||\n\t     !timespec64_equal(&inode->i_ctime, &upperinode->i_ctime))) {\n\t\tinode->i_mtime = upperinode->i_mtime;\n\t\tinode->i_ctime = upperinode->i_ctime;\n\t}\n\n\ttouch_atime(&file->f_path);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/uio.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/uio.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic void ovl_file_accessed(struct file *file)\n{\n\tstruct inode *inode, *upperinode;\n\n\tif (file->f_flags & O_NOATIME)\n\t\treturn;\n\n\tinode = file_inode(file);\n\tupperinode = ovl_inode_upper(inode);\n\n\tif (!upperinode)\n\t\treturn;\n\n\tif ((!timespec64_equal(&inode->i_mtime, &upperinode->i_mtime) ||\n\t     !timespec64_equal(&inode->i_ctime, &upperinode->i_ctime))) {\n\t\tinode->i_mtime = upperinode->i_mtime;\n\t\tinode->i_ctime = upperinode->i_ctime;\n\t}\n\n\ttouch_atime(&file->f_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_writers",
            "SIGIO",
            "POLL_OUT"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "1014-1024",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "EPOLLOUT | EPOLLWRNORM"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "106-119",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "EPOLLOUT | EPOLLWRNORM"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_buf_release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "generic_pipe_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "222-226",
          "snippet": "void generic_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t      struct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid generic_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t      struct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "written < chars"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_to_iter",
          "args": [
            "buf->page",
            "buf->offset",
            "chars",
            "to"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_buf_confirm",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "generic_pipe_buf_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "207-211",
          "snippet": "int generic_pipe_buf_confirm(struct pipe_inode_info *info,\n\t\t\t     struct pipe_buffer *buf)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint generic_pipe_buf_confirm(struct pipe_inode_info *info,\n\t\t\t     struct pipe_buffer *buf)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "total_len == 0"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "to"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic ssize_t\npipe_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tsize_t total_len = iov_iter_count(to);\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint do_wakeup;\n\tssize_t ret;\n\n\t/* Null read succeeds. */\n\tif (unlikely(total_len == 0))\n\t\treturn 0;\n\n\tdo_wakeup = 0;\n\tret = 0;\n\t__pipe_lock(pipe);\n\tfor (;;) {\n\t\tint bufs = pipe->nrbufs;\n\t\tif (bufs) {\n\t\t\tint curbuf = pipe->curbuf;\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + curbuf;\n\t\t\tsize_t chars = buf->len;\n\t\t\tsize_t written;\n\t\t\tint error;\n\n\t\t\tif (chars > total_len)\n\t\t\t\tchars = total_len;\n\n\t\t\terror = pipe_buf_confirm(pipe, buf);\n\t\t\tif (error) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = error;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twritten = copy_page_to_iter(buf->page, buf->offset, chars, to);\n\t\t\tif (unlikely(written < chars)) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += chars;\n\t\t\tbuf->offset += chars;\n\t\t\tbuf->len -= chars;\n\n\t\t\t/* Was it a packet buffer? Clean up and exit */\n\t\t\tif (buf->flags & PIPE_BUF_FLAG_PACKET) {\n\t\t\t\ttotal_len = chars;\n\t\t\t\tbuf->len = 0;\n\t\t\t}\n\n\t\t\tif (!buf->len) {\n\t\t\t\tpipe_buf_release(pipe, buf);\n\t\t\t\tcurbuf = (curbuf + 1) & (pipe->buffers - 1);\n\t\t\t\tpipe->curbuf = curbuf;\n\t\t\t\tpipe->nrbufs = --bufs;\n\t\t\t\tdo_wakeup = 1;\n\t\t\t}\n\t\t\ttotal_len -= chars;\n\t\t\tif (!total_len)\n\t\t\t\tbreak;\t/* common path: read succeeded */\n\t\t}\n\t\tif (bufs)\t/* More to do? */\n\t\t\tcontinue;\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\t/* syscall merging: Usually we must not sleep\n\t\t\t * if O_NONBLOCK is set, or if we got some data.\n\t\t\t * But if a writer sleeps in kernel space, then\n\t\t\t * we can wait for that data without violating POSIX.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (do_wakeup) {\n\t\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLOUT | EPOLLWRNORM);\n \t\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\t__pipe_unlock(pipe);\n\n\t/* Signal writers asynchronously that there is more room. */\n\tif (do_wakeup) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, EPOLLOUT | EPOLLWRNORM);\n\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t}\n\tif (ret > 0)\n\t\tfile_accessed(filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_pipe_buf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "222-226",
    "snippet": "void generic_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t      struct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "buf->page"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid generic_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t      struct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n}"
  },
  {
    "function_name": "generic_pipe_buf_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "207-211",
    "snippet": "int generic_pipe_buf_confirm(struct pipe_inode_info *info,\n\t\t\t     struct pipe_buffer *buf)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint generic_pipe_buf_confirm(struct pipe_inode_info *info,\n\t\t\t     struct pipe_buffer *buf)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "generic_pipe_buf_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "192-195",
    "snippet": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "buf->page"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}"
  },
  {
    "function_name": "generic_pipe_buf_steal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "163-179",
    "snippet": "int generic_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * A reference of one is golden, that means that the owner of this\n\t * page is the only one holding a reference to it. lock the page\n\t * and return OK.\n\t */\n\tif (page_count(page) == 1) {\n\t\tlock_page(page);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint generic_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * A reference of one is golden, that means that the owner of this\n\t * page is the only one holding a reference to it. lock the page\n\t * and return OK.\n\t */\n\tif (page_count(page) == 1) {\n\t\tlock_page(page);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "anon_pipe_buf_steal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "137-149",
    "snippet": "static int anon_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\tif (page_count(page) == 1) {\n\t\tif (memcg_kmem_enabled())\n\t\t\tmemcg_kmem_uncharge(page, 0);\n\t\t__SetPageLocked(page);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__SetPageLocked",
          "args": [
            "page"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_kmem_uncharge",
          "args": [
            "page",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int anon_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\tif (page_count(page) == 1) {\n\t\tif (memcg_kmem_enabled())\n\t\t\tmemcg_kmem_uncharge(page, 0);\n\t\t__SetPageLocked(page);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "anon_pipe_buf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "121-135",
    "snippet": "static void anon_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t  struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * If nobody else uses this page, and we don't already have a\n\t * temporary page, let's keep track of it as a one-deep\n\t * allocation cache. (Otherwise just release our reference to it)\n\t */\n\tif (page_count(page) == 1 && !pipe->tmp_page)\n\t\tpipe->tmp_page = page;\n\telse\n\t\tput_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void anon_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t  struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * If nobody else uses this page, and we don't already have a\n\t * temporary page, let's keep track of it as a one-deep\n\t * allocation cache. (Otherwise just release our reference to it)\n\t */\n\tif (page_count(page) == 1 && !pipe->tmp_page)\n\t\tpipe->tmp_page = page;\n\telse\n\t\tput_page(page);\n}"
  },
  {
    "function_name": "pipe_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "106-119",
    "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&pipe->wait",
            "&wait"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&pipe->wait",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
  },
  {
    "function_name": "pipe_double_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "91-103",
    "snippet": "void pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_lock_nested",
          "args": [
            "pipe1",
            "I_MUTEX_CHILD"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "59-63",
          "snippet": "static void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pipe1 == pipe2"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}"
  },
  {
    "function_name": "__pipe_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "86-89",
    "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pipe->mutex"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
  },
  {
    "function_name": "__pipe_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "81-84",
    "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&pipe->mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
  },
  {
    "function_name": "pipe_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "74-78",
    "snippet": "void pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tif (pipe->files)\n\t\tmutex_unlock(&pipe->mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pipe->mutex"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tif (pipe->files)\n\t\tmutex_unlock(&pipe->mutex);\n}"
  },
  {
    "function_name": "pipe_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "65-71",
    "snippet": "void pipe_lock(struct pipe_inode_info *pipe)\n{\n\t/*\n\t * pipe_lock() nests non-pipe inode locks (for writing to a file)\n\t */\n\tpipe_lock_nested(pipe, I_MUTEX_PARENT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_lock_nested",
          "args": [
            "pipe",
            "I_MUTEX_PARENT"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "59-63",
          "snippet": "static void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_lock(struct pipe_inode_info *pipe)\n{\n\t/*\n\t * pipe_lock() nests non-pipe inode locks (for writing to a file)\n\t */\n\tpipe_lock_nested(pipe, I_MUTEX_PARENT);\n}"
  },
  {
    "function_name": "pipe_lock_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "59-63",
    "snippet": "static void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&pipe->mutex",
            "subclass"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}"
  },
  {
    "function_name": "pipe2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "845-848",
    "snippet": "SYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)\n{\n\treturn do_pipe2(fildes, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)\n{\n\treturn do_pipe2(fildes, flags);\n}"
  },
  {
    "function_name": "pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
    "lines": "850-853",
    "snippet": "SYSCALL_DEFINE1(pipe, int __user *, fildes)\n{\n\treturn do_pipe2(fildes, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE1(pipe, int __user *, fildes)\n{\n\treturn do_pipe2(fildes, 0);\n}"
  }
]