[
  {
    "function_name": "do_compat_futimesat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "259-277",
    "snippet": "static long do_compat_futimesat(unsigned int dfd, const char __user *filename,\n\t\t\t\tstruct old_timeval32 __user *t)\n{\n\tstruct timespec64 tv[2];\n\n\tif (t) {\n\t\tif (get_user(tv[0].tv_sec, &t[0].tv_sec) ||\n\t\t    get_user(tv[0].tv_nsec, &t[0].tv_usec) ||\n\t\t    get_user(tv[1].tv_sec, &t[1].tv_sec) ||\n\t\t    get_user(tv[1].tv_nsec, &t[1].tv_usec))\n\t\t\treturn -EFAULT;\n\t\tif (tv[0].tv_nsec >= 1000000 || tv[0].tv_nsec < 0 ||\n\t\t    tv[1].tv_nsec >= 1000000 || tv[1].tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\t\ttv[0].tv_nsec *= 1000;\n\t\ttv[1].tv_nsec *= 1000;\n\t}\n\treturn do_utimes(dfd, filename, t ? tv : NULL, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_utimes",
          "args": [
            "dfd",
            "filename",
            "t ? tv : NULL",
            "0"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "do_utimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
          "lines": "90-137",
          "snippet": "long do_utimes(int dfd, const char __user *filename, struct timespec64 *times,\n\t       int flags)\n{\n\tint error = -EINVAL;\n\n\tif (times && (!nsec_valid(times[0].tv_nsec) ||\n\t\t      !nsec_valid(times[1].tv_nsec))) {\n\t\tgoto out;\n\t}\n\n\tif (flags & ~AT_SYMLINK_NOFOLLOW)\n\t\tgoto out;\n\n\tif (filename == NULL && dfd != AT_FDCWD) {\n\t\tstruct fd f;\n\n\t\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\t\tgoto out;\n\n\t\tf = fdget(dfd);\n\t\terror = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&f.file->f_path, times);\n\t\tfdput(f);\n\t} else {\n\t\tstruct path path;\n\t\tint lookup_flags = 0;\n\n\t\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\nretry:\n\t\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&path, times);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\nout:\n\treturn error;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/utime.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nlong do_utimes(int dfd, const char __user *filename, struct timespec64 *times,\n\t       int flags)\n{\n\tint error = -EINVAL;\n\n\tif (times && (!nsec_valid(times[0].tv_nsec) ||\n\t\t      !nsec_valid(times[1].tv_nsec))) {\n\t\tgoto out;\n\t}\n\n\tif (flags & ~AT_SYMLINK_NOFOLLOW)\n\t\tgoto out;\n\n\tif (filename == NULL && dfd != AT_FDCWD) {\n\t\tstruct fd f;\n\n\t\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\t\tgoto out;\n\n\t\tf = fdget(dfd);\n\t\terror = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&f.file->f_path, times);\n\t\tfdput(f);\n\t} else {\n\t\tstruct path path;\n\t\tint lookup_flags = 0;\n\n\t\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\nretry:\n\t\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&path, times);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "tv[1].tv_nsec",
            "&t[1].tv_usec"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nstatic long do_compat_futimesat(unsigned int dfd, const char __user *filename,\n\t\t\t\tstruct old_timeval32 __user *t)\n{\n\tstruct timespec64 tv[2];\n\n\tif (t) {\n\t\tif (get_user(tv[0].tv_sec, &t[0].tv_sec) ||\n\t\t    get_user(tv[0].tv_nsec, &t[0].tv_usec) ||\n\t\t    get_user(tv[1].tv_sec, &t[1].tv_sec) ||\n\t\t    get_user(tv[1].tv_nsec, &t[1].tv_usec))\n\t\t\treturn -EFAULT;\n\t\tif (tv[0].tv_nsec >= 1000000 || tv[0].tv_nsec < 0 ||\n\t\t    tv[1].tv_nsec >= 1000000 || tv[1].tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\t\ttv[0].tv_nsec *= 1000;\n\t\ttv[1].tv_nsec *= 1000;\n\t}\n\treturn do_utimes(dfd, filename, t ? tv : NULL, 0);\n}"
  },
  {
    "function_name": "do_futimesat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "165-191",
    "snippet": "static long do_futimesat(int dfd, const char __user *filename,\n\t\t\t struct timeval __user *utimes)\n{\n\tstruct timeval times[2];\n\tstruct timespec64 tstimes[2];\n\n\tif (utimes) {\n\t\tif (copy_from_user(&times, utimes, sizeof(times)))\n\t\t\treturn -EFAULT;\n\n\t\t/* This test is needed to catch all invalid values.  If we\n\t\t   would test only in do_utimes we would miss those invalid\n\t\t   values truncated by the multiplication with 1000.  Note\n\t\t   that we also catch UTIME_{NOW,OMIT} here which are only\n\t\t   valid for utimensat.  */\n\t\tif (times[0].tv_usec >= 1000000 || times[0].tv_usec < 0 ||\n\t\t    times[1].tv_usec >= 1000000 || times[1].tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\ttstimes[0].tv_sec = times[0].tv_sec;\n\t\ttstimes[0].tv_nsec = 1000 * times[0].tv_usec;\n\t\ttstimes[1].tv_sec = times[1].tv_sec;\n\t\ttstimes[1].tv_nsec = 1000 * times[1].tv_usec;\n\t}\n\n\treturn do_utimes(dfd, filename, utimes ? tstimes : NULL, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_utimes",
          "args": [
            "dfd",
            "filename",
            "utimes ? tstimes : NULL",
            "0"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "do_utimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
          "lines": "90-137",
          "snippet": "long do_utimes(int dfd, const char __user *filename, struct timespec64 *times,\n\t       int flags)\n{\n\tint error = -EINVAL;\n\n\tif (times && (!nsec_valid(times[0].tv_nsec) ||\n\t\t      !nsec_valid(times[1].tv_nsec))) {\n\t\tgoto out;\n\t}\n\n\tif (flags & ~AT_SYMLINK_NOFOLLOW)\n\t\tgoto out;\n\n\tif (filename == NULL && dfd != AT_FDCWD) {\n\t\tstruct fd f;\n\n\t\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\t\tgoto out;\n\n\t\tf = fdget(dfd);\n\t\terror = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&f.file->f_path, times);\n\t\tfdput(f);\n\t} else {\n\t\tstruct path path;\n\t\tint lookup_flags = 0;\n\n\t\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\nretry:\n\t\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&path, times);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\nout:\n\treturn error;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/utime.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nlong do_utimes(int dfd, const char __user *filename, struct timespec64 *times,\n\t       int flags)\n{\n\tint error = -EINVAL;\n\n\tif (times && (!nsec_valid(times[0].tv_nsec) ||\n\t\t      !nsec_valid(times[1].tv_nsec))) {\n\t\tgoto out;\n\t}\n\n\tif (flags & ~AT_SYMLINK_NOFOLLOW)\n\t\tgoto out;\n\n\tif (filename == NULL && dfd != AT_FDCWD) {\n\t\tstruct fd f;\n\n\t\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\t\tgoto out;\n\n\t\tf = fdget(dfd);\n\t\terror = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&f.file->f_path, times);\n\t\tfdput(f);\n\t} else {\n\t\tstruct path path;\n\t\tint lookup_flags = 0;\n\n\t\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\nretry:\n\t\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&path, times);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&times",
            "utimes",
            "sizeof(times)"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nstatic long do_futimesat(int dfd, const char __user *filename,\n\t\t\t struct timeval __user *utimes)\n{\n\tstruct timeval times[2];\n\tstruct timespec64 tstimes[2];\n\n\tif (utimes) {\n\t\tif (copy_from_user(&times, utimes, sizeof(times)))\n\t\t\treturn -EFAULT;\n\n\t\t/* This test is needed to catch all invalid values.  If we\n\t\t   would test only in do_utimes we would miss those invalid\n\t\t   values truncated by the multiplication with 1000.  Note\n\t\t   that we also catch UTIME_{NOW,OMIT} here which are only\n\t\t   valid for utimensat.  */\n\t\tif (times[0].tv_usec >= 1000000 || times[0].tv_usec < 0 ||\n\t\t    times[1].tv_usec >= 1000000 || times[1].tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\ttstimes[0].tv_sec = times[0].tv_sec;\n\t\ttstimes[0].tv_nsec = 1000 * times[0].tv_usec;\n\t\ttstimes[1].tv_sec = times[1].tv_sec;\n\t\ttstimes[1].tv_nsec = 1000 * times[1].tv_usec;\n\t}\n\n\treturn do_utimes(dfd, filename, utimes ? tstimes : NULL, 0);\n}"
  },
  {
    "function_name": "do_utimes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "90-137",
    "snippet": "long do_utimes(int dfd, const char __user *filename, struct timespec64 *times,\n\t       int flags)\n{\n\tint error = -EINVAL;\n\n\tif (times && (!nsec_valid(times[0].tv_nsec) ||\n\t\t      !nsec_valid(times[1].tv_nsec))) {\n\t\tgoto out;\n\t}\n\n\tif (flags & ~AT_SYMLINK_NOFOLLOW)\n\t\tgoto out;\n\n\tif (filename == NULL && dfd != AT_FDCWD) {\n\t\tstruct fd f;\n\n\t\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\t\tgoto out;\n\n\t\tf = fdget(dfd);\n\t\terror = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&f.file->f_path, times);\n\t\tfdput(f);\n\t} else {\n\t\tstruct path path;\n\t\tint lookup_flags = 0;\n\n\t\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\nretry:\n\t\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&path, times);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\nout:\n\treturn error;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utimes_common",
          "args": [
            "&path",
            "times"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "utimes_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
          "lines": "19-73",
          "snippet": "static int utimes_common(const struct path *path, struct timespec64 *times)\n{\n\tint error;\n\tstruct iattr newattrs;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tif (times && times[0].tv_nsec == UTIME_NOW &&\n\t\t     times[1].tv_nsec == UTIME_NOW)\n\t\ttimes = NULL;\n\n\tnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\n\tif (times) {\n\t\tif (times[0].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_ATIME;\n\t\telse if (times[0].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_atime.tv_sec = times[0].tv_sec;\n\t\t\tnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_ATIME_SET;\n\t\t}\n\n\t\tif (times[1].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_MTIME;\n\t\telse if (times[1].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\n\t\t\tnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_MTIME_SET;\n\t\t}\n\t\t/*\n\t\t * Tell setattr_prepare(), that this is an explicit time\n\t\t * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET\n\t\t * were used.\n\t\t */\n\t\tnewattrs.ia_valid |= ATTR_TIMES_SET;\n\t} else {\n\t\tnewattrs.ia_valid |= ATTR_TOUCH;\n\t}\nretry_deleg:\n\tinode_lock(inode);\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/utime.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nstatic int utimes_common(const struct path *path, struct timespec64 *times)\n{\n\tint error;\n\tstruct iattr newattrs;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tif (times && times[0].tv_nsec == UTIME_NOW &&\n\t\t     times[1].tv_nsec == UTIME_NOW)\n\t\ttimes = NULL;\n\n\tnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\n\tif (times) {\n\t\tif (times[0].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_ATIME;\n\t\telse if (times[0].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_atime.tv_sec = times[0].tv_sec;\n\t\t\tnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_ATIME_SET;\n\t\t}\n\n\t\tif (times[1].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_MTIME;\n\t\telse if (times[1].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\n\t\t\tnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_MTIME_SET;\n\t\t}\n\t\t/*\n\t\t * Tell setattr_prepare(), that this is an explicit time\n\t\t * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET\n\t\t * were used.\n\t\t */\n\t\tnewattrs.ia_valid |= ATTR_TIMES_SET;\n\t} else {\n\t\tnewattrs.ia_valid |= ATTR_TOUCH;\n\t}\nretry_deleg:\n\tinode_lock(inode);\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "dfd",
            "filename",
            "lookup_flags",
            "&path"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "dfd"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsec_valid",
          "args": [
            "times[1].tv_nsec"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
          "lines": "11-17",
          "snippet": "static bool nsec_valid(long nsec)\n{\n\tif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\n\t\treturn true;\n\n\treturn nsec >= 0 && nsec <= 999999999;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/utime.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nstatic bool nsec_valid(long nsec)\n{\n\tif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\n\t\treturn true;\n\n\treturn nsec >= 0 && nsec <= 999999999;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nlong do_utimes(int dfd, const char __user *filename, struct timespec64 *times,\n\t       int flags)\n{\n\tint error = -EINVAL;\n\n\tif (times && (!nsec_valid(times[0].tv_nsec) ||\n\t\t      !nsec_valid(times[1].tv_nsec))) {\n\t\tgoto out;\n\t}\n\n\tif (flags & ~AT_SYMLINK_NOFOLLOW)\n\t\tgoto out;\n\n\tif (filename == NULL && dfd != AT_FDCWD) {\n\t\tstruct fd f;\n\n\t\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\t\tgoto out;\n\n\t\tf = fdget(dfd);\n\t\terror = -EBADF;\n\t\tif (!f.file)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&f.file->f_path, times);\n\t\tfdput(f);\n\t} else {\n\t\tstruct path path;\n\t\tint lookup_flags = 0;\n\n\t\tif (!(flags & AT_SYMLINK_NOFOLLOW))\n\t\t\tlookup_flags |= LOOKUP_FOLLOW;\nretry:\n\t\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = utimes_common(&path, times);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "utimes_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "19-73",
    "snippet": "static int utimes_common(const struct path *path, struct timespec64 *times)\n{\n\tint error;\n\tstruct iattr newattrs;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tif (times && times[0].tv_nsec == UTIME_NOW &&\n\t\t     times[1].tv_nsec == UTIME_NOW)\n\t\ttimes = NULL;\n\n\tnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\n\tif (times) {\n\t\tif (times[0].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_ATIME;\n\t\telse if (times[0].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_atime.tv_sec = times[0].tv_sec;\n\t\t\tnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_ATIME_SET;\n\t\t}\n\n\t\tif (times[1].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_MTIME;\n\t\telse if (times[1].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\n\t\t\tnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_MTIME_SET;\n\t\t}\n\t\t/*\n\t\t * Tell setattr_prepare(), that this is an explicit time\n\t\t * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET\n\t\t * were used.\n\t\t */\n\t\tnewattrs.ia_valid |= ATTR_TIMES_SET;\n\t} else {\n\t\tnewattrs.ia_valid |= ATTR_TOUCH;\n\t}\nretry_deleg:\n\tinode_lock(inode);\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path->mnt"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "461-465",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "break_deleg_wait",
          "args": [
            "&delegated_inode"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "path->dentry",
            "&newattrs",
            "&delegated_inode"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "226-345",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path->mnt"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "414-423",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nstatic int utimes_common(const struct path *path, struct timespec64 *times)\n{\n\tint error;\n\tstruct iattr newattrs;\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\tif (times && times[0].tv_nsec == UTIME_NOW &&\n\t\t     times[1].tv_nsec == UTIME_NOW)\n\t\ttimes = NULL;\n\n\tnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\n\tif (times) {\n\t\tif (times[0].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_ATIME;\n\t\telse if (times[0].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_atime.tv_sec = times[0].tv_sec;\n\t\t\tnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_ATIME_SET;\n\t\t}\n\n\t\tif (times[1].tv_nsec == UTIME_OMIT)\n\t\t\tnewattrs.ia_valid &= ~ATTR_MTIME;\n\t\telse if (times[1].tv_nsec != UTIME_NOW) {\n\t\t\tnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\n\t\t\tnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\n\t\t\tnewattrs.ia_valid |= ATTR_MTIME_SET;\n\t\t}\n\t\t/*\n\t\t * Tell setattr_prepare(), that this is an explicit time\n\t\t * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET\n\t\t * were used.\n\t\t */\n\t\tnewattrs.ia_valid |= ATTR_TIMES_SET;\n\t} else {\n\t\tnewattrs.ia_valid |= ATTR_TOUCH;\n\t}\nretry_deleg:\n\tinode_lock(inode);\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "nsec_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "11-17",
    "snippet": "static bool nsec_valid(long nsec)\n{\n\tif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\n\t\treturn true;\n\n\treturn nsec >= 0 && nsec <= 999999999;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nstatic bool nsec_valid(long nsec)\n{\n\tif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\n\t\treturn true;\n\n\treturn nsec >= 0 && nsec <= 999999999;\n}"
  },
  {
    "function_name": "utimensat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "139-156",
    "snippet": "SYSCALL_DEFINE4(utimensat, int, dfd, const char __user *, filename,\n\t\tstruct __kernel_timespec __user *, utimes, int, flags)\n{\n\tstruct timespec64 tstimes[2];\n\n\tif (utimes) {\n\t\tif ((get_timespec64(&tstimes[0], &utimes[0]) ||\n\t\t\tget_timespec64(&tstimes[1], &utimes[1])))\n\t\t\treturn -EFAULT;\n\n\t\t/* Nothing to do, we must not even check the path.  */\n\t\tif (tstimes[0].tv_nsec == UTIME_OMIT &&\n\t\t    tstimes[1].tv_nsec == UTIME_OMIT)\n\t\t\treturn 0;\n\t}\n\n\treturn do_utimes(dfd, filename, utimes ? tstimes : NULL, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE4(utimensat, int, dfd, const char __user *, filename,\n\t\tstruct __kernel_timespec __user *, utimes, int, flags)\n{\n\tstruct timespec64 tstimes[2];\n\n\tif (utimes) {\n\t\tif ((get_timespec64(&tstimes[0], &utimes[0]) ||\n\t\t\tget_timespec64(&tstimes[1], &utimes[1])))\n\t\t\treturn -EFAULT;\n\n\t\t/* Nothing to do, we must not even check the path.  */\n\t\tif (tstimes[0].tv_nsec == UTIME_OMIT &&\n\t\t    tstimes[1].tv_nsec == UTIME_OMIT)\n\t\t\treturn 0;\n\t}\n\n\treturn do_utimes(dfd, filename, utimes ? tstimes : NULL, flags);\n}"
  },
  {
    "function_name": "futimesat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "194-198",
    "snippet": "SYSCALL_DEFINE3(futimesat, int, dfd, const char __user *, filename,\n\t\tstruct timeval __user *, utimes)\n{\n\treturn do_futimesat(dfd, filename, utimes);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE3(futimesat, int, dfd, const char __user *, filename,\n\t\tstruct timeval __user *, utimes)\n{\n\treturn do_futimesat(dfd, filename, utimes);\n}"
  },
  {
    "function_name": "utimes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "200-204",
    "snippet": "SYSCALL_DEFINE2(utimes, char __user *, filename,\n\t\tstruct timeval __user *, utimes)\n{\n\treturn do_futimesat(AT_FDCWD, filename, utimes);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE2(utimes, char __user *, filename,\n\t\tstruct timeval __user *, utimes)\n{\n\treturn do_futimesat(AT_FDCWD, filename, utimes);\n}"
  },
  {
    "function_name": "utime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "206-218",
    "snippet": "SYSCALL_DEFINE2(utime, char __user *, filename, struct utimbuf __user *, times)\n{\n\tstruct timespec64 tv[2];\n\n\tif (times) {\n\t\tif (get_user(tv[0].tv_sec, &times->actime) ||\n\t\t    get_user(tv[1].tv_sec, &times->modtime))\n\t\t\treturn -EFAULT;\n\t\ttv[0].tv_nsec = 0;\n\t\ttv[1].tv_nsec = 0;\n\t}\n\treturn do_utimes(AT_FDCWD, filename, times ? tv : NULL, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE2(utime, char __user *, filename, struct utimbuf __user *, times)\n{\n\tstruct timespec64 tv[2];\n\n\tif (times) {\n\t\tif (get_user(tv[0].tv_sec, &times->actime) ||\n\t\t    get_user(tv[1].tv_sec, &times->modtime))\n\t\t\treturn -EFAULT;\n\t\ttv[0].tv_nsec = 0;\n\t\ttv[1].tv_nsec = 0;\n\t}\n\treturn do_utimes(AT_FDCWD, filename, times ? tv : NULL, 0);\n}"
  },
  {
    "function_name": "utime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "227-240",
    "snippet": "SYSCALL_DEFINE2(utime, const char __user *, filename,\n\t\t       struct old_utimbuf32 __user *, t)\n{\n\tstruct timespec64 tv[2];\n\n\tif (t) {\n\t\tif (get_user(tv[0].tv_sec, &t->actime) ||\n\t\t    get_user(tv[1].tv_sec, &t->modtime))\n\t\t\treturn -EFAULT;\n\t\ttv[0].tv_nsec = 0;\n\t\ttv[1].tv_nsec = 0;\n\t}\n\treturn do_utimes(AT_FDCWD, filename, t ? tv : NULL, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE2(utime, const char __user *, filename,\n\t\t       struct old_utimbuf32 __user *, t)\n{\n\tstruct timespec64 tv[2];\n\n\tif (t) {\n\t\tif (get_user(tv[0].tv_sec, &t->actime) ||\n\t\t    get_user(tv[1].tv_sec, &t->modtime))\n\t\t\treturn -EFAULT;\n\t\ttv[0].tv_nsec = 0;\n\t\ttv[1].tv_nsec = 0;\n\t}\n\treturn do_utimes(AT_FDCWD, filename, t ? tv : NULL, 0);\n}"
  },
  {
    "function_name": "utimensat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "243-256",
    "snippet": "SYSCALL_DEFINE4(utimensat, unsigned int, dfd, const char __user *, filename, struct old_timespec32 __user *, t, int, flags)\n{\n\tstruct timespec64 tv[2];\n\n\tif  (t) {\n\t\tif (get_old_timespec32(&tv[0], &t[0]) ||\n\t\t    get_old_timespec32(&tv[1], &t[1]))\n\t\t\treturn -EFAULT;\n\n\t\tif (tv[0].tv_nsec == UTIME_OMIT && tv[1].tv_nsec == UTIME_OMIT)\n\t\t\treturn 0;\n\t}\n\treturn do_utimes(dfd, filename, t ? tv : NULL, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE4(utimensat, unsigned int, dfd, const char __user *, filename, struct old_timespec32 __user *, t, int, flags)\n{\n\tstruct timespec64 tv[2];\n\n\tif  (t) {\n\t\tif (get_old_timespec32(&tv[0], &t[0]) ||\n\t\t    get_old_timespec32(&tv[1], &t[1]))\n\t\t\treturn -EFAULT;\n\n\t\tif (tv[0].tv_nsec == UTIME_OMIT && tv[1].tv_nsec == UTIME_OMIT)\n\t\t\treturn 0;\n\t}\n\treturn do_utimes(dfd, filename, t ? tv : NULL, flags);\n}"
  },
  {
    "function_name": "futimesat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "279-284",
    "snippet": "SYSCALL_DEFINE3(futimesat, unsigned int, dfd,\n\t\t       const char __user *, filename,\n\t\t       struct old_timeval32 __user *, t)\n{\n\treturn do_compat_futimesat(dfd, filename, t);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE3(futimesat, unsigned int, dfd,\n\t\t       const char __user *, filename,\n\t\t       struct old_timeval32 __user *, t)\n{\n\treturn do_compat_futimesat(dfd, filename, t);\n}"
  },
  {
    "function_name": "utimes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/utimes.c",
    "lines": "286-289",
    "snippet": "SYSCALL_DEFINE2(utimes, const char __user *, filename, struct old_timeval32 __user *, t)\n{\n\treturn do_compat_futimesat(AT_FDCWD, filename, t);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/utime.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE2(utimes, const char __user *, filename, struct old_timeval32 __user *, t)\n{\n\treturn do_compat_futimesat(AT_FDCWD, filename, t);\n}"
  }
]