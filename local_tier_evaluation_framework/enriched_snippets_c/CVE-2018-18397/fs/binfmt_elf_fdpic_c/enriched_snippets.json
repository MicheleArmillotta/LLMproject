[
  {
    "function_name": "elf_fdpic_core_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1552-1815",
    "snippet": "static int elf_fdpic_core_dump(struct coredump_params *cprm)\n{\n#define\tNUM_NOTES\t6\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs;\n\tint i;\n\tstruct vm_area_struct *vma;\n\tstruct elfhdr *elf = NULL;\n\tloff_t offset = 0, dataoff;\n\tint numnote;\n\tstruct memelfnote *notes = NULL;\n\tstruct elf_prstatus *prstatus = NULL;\t/* NT_PRSTATUS */\n\tstruct elf_prpsinfo *psinfo = NULL;\t/* NT_PRPSINFO */\n \tLIST_HEAD(thread_list);\n \tstruct list_head *t;\n\telf_fpregset_t *fpu = NULL;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t *xfpu = NULL;\n#endif\n\tint thread_status_size = 0;\n\telf_addr_t *auxv;\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *tmp;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t *\n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n\n\t/* alloc memory for large data structures: too large to be on stack */\n\telf = kmalloc(sizeof(*elf), GFP_KERNEL);\n\tif (!elf)\n\t\tgoto cleanup;\n\tprstatus = kzalloc(sizeof(*prstatus), GFP_KERNEL);\n\tif (!prstatus)\n\t\tgoto cleanup;\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (!psinfo)\n\t\tgoto cleanup;\n\tnotes = kmalloc_array(NUM_NOTES, sizeof(struct memelfnote),\n\t\t\t      GFP_KERNEL);\n\tif (!notes)\n\t\tgoto cleanup;\n\tfpu = kmalloc(sizeof(*fpu), GFP_KERNEL);\n\tif (!fpu)\n\t\tgoto cleanup;\n#ifdef ELF_CORE_COPY_XFPREGS\n\txfpu = kmalloc(sizeof(*xfpu), GFP_KERNEL);\n\tif (!xfpu)\n\t\tgoto cleanup;\n#endif\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto cleanup;\n\n\t\ttmp->thread = ct->task;\n\t\tlist_add(&tmp->list, &thread_list);\n\t}\n\n\tlist_for_each(t, &thread_list) {\n\t\tstruct elf_thread_status *tmp;\n\t\tint sz;\n\n\t\ttmp = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(cprm->siginfo->si_signo, tmp);\n\t\tthread_status_size += sz;\n\t}\n\n\t/* now collect the dump for the current */\n\tfill_prstatus(prstatus, current, cprm->siginfo->si_signo);\n\telf_core_copy_regs(&prstatus->pr_reg, cprm->regs);\n\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/* Set up header */\n\tfill_elf_fdpic_header(elf, e_phnum);\n\n\thas_dumped = 1;\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(notes + 0, \"CORE\", NT_PRSTATUS, sizeof(*prstatus), prstatus);\n\tfill_psinfo(psinfo, current->group_leader, current->mm);\n\tfill_note(notes + 1, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\tnumnote = 2;\n\n\tauxv = (elf_addr_t *) current->mm->saved_auxv;\n\n\ti = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(&notes[numnote++], \"CORE\", NT_AUXV,\n\t\t  i * sizeof(elf_addr_t), auxv);\n\n  \t/* Try to dump the FPU. */\n\tif ((prstatus->pr_fpvalid =\n\t     elf_core_copy_task_fpregs(current, cprm->regs, fpu)))\n\t\tfill_note(notes + numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*fpu), fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, xfpu))\n\t\tfill_note(notes + numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE, sizeof(*xfpu), xfpu);\n#endif\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(*elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\n\t/* Write notes phdr entry */\n\t{\n\t\tint sz = 0;\n\n\t\tfor (i = 0; i < numnote; i++)\n\t\t\tsz += notesize(notes + i);\n\n\t\tsz += thread_status_size;\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\t/* Page-align dumped data */\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\toffset += elf_core_vma_data_size(cprm->mm_flags);\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, elf, sizeof(*elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* write program headers for segments dump */\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next) {\n\t\tstruct elf_phdr phdr;\n\t\tsize_t sz;\n\n\t\tsz = vma->vm_end - vma->vm_start;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = maydump(vma, cprm->mm_flags) ? sz : 0;\n\t\tphdr.p_memsz = sz;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tfor (i = 0; i < numnote; i++)\n\t\tif (!writenote(notes + i, cprm))\n\t\t\tgoto end_coredump;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\tgoto end_coredump;\n\t}\n\n\tif (!dump_skip(cprm, dataoff - cprm->pos))\n\t\tgoto end_coredump;\n\n\tif (!elf_fdpic_dump_segments(cprm))\n\t\tgoto end_coredump;\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (cprm->file->f_pos != offset) {\n\t\t/* Sanity check */\n\t\tprintk(KERN_WARNING\n\t\t       \"elf_core_dump: file->f_pos (%lld) != offset (%lld)\\n\",\n\t\t       cprm->file->f_pos, offset);\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\twhile (!list_empty(&thread_list)) {\n\t\tstruct list_head *tmp = thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\tkfree(phdr4note);\n\tkfree(elf);\n\tkfree(prstatus);\n\tkfree(psinfo);\n\tkfree(notes);\n\tkfree(fpu);\n\tkfree(shdr4extnum);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(xfpu);\n#endif\n\treturn has_dumped;\n#undef NUM_NOTES\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define\tNUM_NOTES\t6"
    ],
    "globals_used": [
      "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xfpu"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "tmp"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&thread_list"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "fs"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"elf_core_dump: file->f_pos (%lld) != offset (%lld)\\n\"",
            "cprm->file->f_pos",
            "offset"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "shdr4extnum",
            "sizeof(*shdr4extnum)"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "dump_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "783-802",
          "snippet": "int dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_write_extra_data",
          "args": [
            "cprm"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_fdpic_dump_segments",
          "args": [
            "cprm"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "elf_fdpic_dump_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1497-1532",
          "snippet": "static bool elf_fdpic_dump_segments(struct coredump_params *cprm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next) {\n#ifdef CONFIG_MMU\n\t\tunsigned long addr;\n#endif\n\n\t\tif (!maydump(vma, cprm->mm_flags))\n\t\t\tcontinue;\n\n#ifdef CONFIG_MMU\n\t\tfor (addr = vma->vm_start; addr < vma->vm_end;\n\t\t\t\t\t\t\taddr += PAGE_SIZE) {\n\t\t\tbool res;\n\t\t\tstruct page *page = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tres = dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tput_page(page);\n\t\t\t} else {\n\t\t\t\tres = dump_skip(cprm, PAGE_SIZE);\n\t\t\t}\n\t\t\tif (!res)\n\t\t\t\treturn false;\n\t\t}\n#else\n\t\tif (!dump_emit(cprm, (void *) vma->vm_start,\n\t\t\t\tvma->vm_end - vma->vm_start))\n\t\t\treturn false;\n#endif\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic bool elf_fdpic_dump_segments(struct coredump_params *cprm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next) {\n#ifdef CONFIG_MMU\n\t\tunsigned long addr;\n#endif\n\n\t\tif (!maydump(vma, cprm->mm_flags))\n\t\t\tcontinue;\n\n#ifdef CONFIG_MMU\n\t\tfor (addr = vma->vm_start; addr < vma->vm_end;\n\t\t\t\t\t\t\taddr += PAGE_SIZE) {\n\t\t\tbool res;\n\t\t\tstruct page *page = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tres = dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tput_page(page);\n\t\t\t} else {\n\t\t\t\tres = dump_skip(cprm, PAGE_SIZE);\n\t\t\t}\n\t\t\tif (!res)\n\t\t\t\treturn false;\n\t\t}\n#else\n\t\tif (!dump_emit(cprm, (void *) vma->vm_start,\n\t\t\t\tvma->vm_end - vma->vm_start))\n\t\t\treturn false;\n#endif\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_skip",
          "args": [
            "cprm",
            "dataoff - cprm->pos"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "dump_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "805-823",
          "snippet": "int dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "writenote",
          "args": [
            "&tmp->notes[i]",
            "cprm"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "writenote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1282-1292",
          "snippet": "static int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t\tdump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t\tdump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t\tdump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t\tdump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "t",
            "structelf_thread_status",
            "list"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "t",
            "&thread_list"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_write_extra_phdrs",
          "args": [
            "cprm",
            "offset"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maydump",
          "args": [
            "vma",
            "cprm->mm_flags"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "maydump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1197-1258",
          "snippet": "static int maydump(struct vm_area_struct *vma, unsigned long mm_flags)\n{\n\tint dump_ok;\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO) {\n\t\tkdcore(\"%08lx: %08lx: no (IO)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* If we may not read the contents, don't allow us to dump\n\t * them either. \"dump_write()\" can't handle it anyway.\n\t */\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\tkdcore(\"%08lx: %08lx: no (!read)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif (vma->vm_flags & VM_SHARED) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX shared)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_PRIVATE, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX private)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t}\n\t\treturn dump_ok;\n\t}\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t\treturn dump_ok;\n\t\t}\n\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_SHARED, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n\n#ifdef CONFIG_MMU\n\t/* By default, if it hasn't been written to, don't write it out */\n\tif (!vma->anon_vma) {\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_PRIVATE, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (!anon)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n#endif\n\n\tdump_ok = test_bit(MMF_DUMP_ANON_PRIVATE, &mm_flags);\n\tkdcore(\"%08lx: %08lx: %s\", vma->vm_start, vma->vm_flags,\n\t       dump_ok ? \"yes\" : \"no\");\n\treturn dump_ok;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\n\nstatic int maydump(struct vm_area_struct *vma, unsigned long mm_flags)\n{\n\tint dump_ok;\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO) {\n\t\tkdcore(\"%08lx: %08lx: no (IO)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* If we may not read the contents, don't allow us to dump\n\t * them either. \"dump_write()\" can't handle it anyway.\n\t */\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\tkdcore(\"%08lx: %08lx: no (!read)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif (vma->vm_flags & VM_SHARED) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX shared)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_PRIVATE, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX private)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t}\n\t\treturn dump_ok;\n\t}\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t\treturn dump_ok;\n\t\t}\n\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_SHARED, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n\n#ifdef CONFIG_MMU\n\t/* By default, if it hasn't been written to, don't write it out */\n\tif (!vma->anon_vma) {\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_PRIVATE, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (!anon)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n#endif\n\n\tdump_ok = test_bit(MMF_DUMP_ANON_PRIVATE, &mm_flags);\n\tkdcore(\"%08lx: %08lx: %s\", vma->vm_start, vma->vm_flags,\n\t       dump_ok ? \"yes\" : \"no\");\n\treturn dump_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_extnum_info",
          "args": [
            "elf",
            "shdr4extnum",
            "e_shoff",
            "segs"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "fill_extnum_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1478-1492",
          "snippet": "static void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*shdr4extnum)",
            "GFP_KERNEL"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_extra_data_size",
          "args": [],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_vma_data_size",
          "args": [
            "cprm->mm_flags"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "elf_core_vma_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1534-1543",
          "snippet": "static size_t elf_core_vma_data_size(unsigned long mm_flags)\n{\n\tstruct vm_area_struct *vma;\n\tsize_t size = 0;\n\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next)\n\t\tif (maydump(vma, mm_flags))\n\t\t\tsize += vma->vm_end - vma->vm_start;\n\treturn size;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic size_t elf_core_vma_data_size(unsigned long mm_flags)\n{\n\tstruct vm_area_struct *vma;\n\tsize_t size = 0;\n\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next)\n\t\tif (maydump(vma, mm_flags))\n\t\t\tsize += vma->vm_end - vma->vm_start;\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "offset",
            "ELF_EXEC_PAGESIZE"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xfs/xfs_linux.h",
          "lines": "210-215",
          "snippet": "static inline uint64_t roundup_64(uint64_t x, uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/rhashtable.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/uuid.h>\n#include <linux/types.h>\n\nstatic inline uint64_t roundup_64(uint64_t x, uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_elf_note_phdr",
          "args": [
            "phdr4note",
            "sz",
            "offset"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "fill_elf_note_phdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1319-1330",
          "snippet": "static inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "notes + i"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1269-1278",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "notes + numnote++",
            "\"LINUX\"",
            "ELF_CORE_XFPREG_TYPE",
            "sizeof(*xfpu)",
            "xfpu"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1332-1340",
          "snippet": "static inline void fill_note(struct memelfnote *note, const char *name, int type,\n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void fill_note(struct memelfnote *note, const char *name, int type,\n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_xfpregs",
          "args": [
            "current",
            "xfpu"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_fpregs",
          "args": [
            "current",
            "cprm->regs",
            "fpu"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_psinfo",
          "args": [
            "psinfo",
            "current->group_leader",
            "current->mm"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "fill_psinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1382-1423",
          "snippet": "static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ - 1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *) mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
            "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ - 1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *) mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_elf_fdpic_header",
          "args": [
            "elf",
            "e_phnum"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "fill_elf_fdpic_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1294-1317",
          "snippet": "static inline void fill_elf_fdpic_header(struct elfhdr *elf, int segs)\n{\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n\telf->e_flags = ELF_FDPIC_CORE_EFLAGS;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\treturn;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void fill_elf_fdpic_header(struct elfhdr *elf, int segs)\n{\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n\telf->e_flags = ELF_FDPIC_CORE_EFLAGS;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_extra_phdrs",
          "args": [],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_regs",
          "args": [
            "&prstatus->pr_reg",
            "cprm->regs"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_prstatus",
          "args": [
            "prstatus",
            "current",
            "cprm->siginfo->si_signo"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1346-1380",
          "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\t\t  struct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n\n\tprstatus->pr_exec_fdpic_loadmap = p->mm->context.exec_fdpic_loadmap;\n\tprstatus->pr_interp_fdpic_loadmap = p->mm->context.interp_fdpic_loadmap;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\t\t  struct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n\n\tprstatus->pr_exec_fdpic_loadmap = p->mm->context.exec_fdpic_loadmap;\n\tprstatus->pr_interp_fdpic_loadmap = p->mm->context.interp_fdpic_loadmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_dump_thread_status",
          "args": [
            "cprm->siginfo->si_signo",
            "tmp"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "elf_dump_thread_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1444-1476",
          "snippet": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tstruct task_struct *p = t->thread;\n\tint sz = 0;\n\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &t->prstatus);\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tt->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL, &t->fpu);\n\tif (t->prstatus.pr_fpvalid) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &t->fpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\n\treturn sz;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tstruct task_struct *p = t->thread;\n\tint sz = 0;\n\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &t->prstatus);\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tt->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL, &t->fpu);\n\tif (t->prstatus.pr_fpvalid) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &t->fpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "t",
            "structelf_thread_status",
            "list"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "t",
            "&thread_list"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tmp->list",
            "&thread_list"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tmp)",
            "GFP_KERNEL"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "NUM_NOTES",
            "sizeof(struct memelfnote)",
            "GFP_KERNEL"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*prstatus)",
            "GFP_KERNEL"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "thread_list"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define\tNUM_NOTES\t6\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\n\nstatic int elf_fdpic_core_dump(struct coredump_params *cprm)\n{\n#define\tNUM_NOTES\t6\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs;\n\tint i;\n\tstruct vm_area_struct *vma;\n\tstruct elfhdr *elf = NULL;\n\tloff_t offset = 0, dataoff;\n\tint numnote;\n\tstruct memelfnote *notes = NULL;\n\tstruct elf_prstatus *prstatus = NULL;\t/* NT_PRSTATUS */\n\tstruct elf_prpsinfo *psinfo = NULL;\t/* NT_PRPSINFO */\n \tLIST_HEAD(thread_list);\n \tstruct list_head *t;\n\telf_fpregset_t *fpu = NULL;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t *xfpu = NULL;\n#endif\n\tint thread_status_size = 0;\n\telf_addr_t *auxv;\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *tmp;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t *\n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n\n\t/* alloc memory for large data structures: too large to be on stack */\n\telf = kmalloc(sizeof(*elf), GFP_KERNEL);\n\tif (!elf)\n\t\tgoto cleanup;\n\tprstatus = kzalloc(sizeof(*prstatus), GFP_KERNEL);\n\tif (!prstatus)\n\t\tgoto cleanup;\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (!psinfo)\n\t\tgoto cleanup;\n\tnotes = kmalloc_array(NUM_NOTES, sizeof(struct memelfnote),\n\t\t\t      GFP_KERNEL);\n\tif (!notes)\n\t\tgoto cleanup;\n\tfpu = kmalloc(sizeof(*fpu), GFP_KERNEL);\n\tif (!fpu)\n\t\tgoto cleanup;\n#ifdef ELF_CORE_COPY_XFPREGS\n\txfpu = kmalloc(sizeof(*xfpu), GFP_KERNEL);\n\tif (!xfpu)\n\t\tgoto cleanup;\n#endif\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto cleanup;\n\n\t\ttmp->thread = ct->task;\n\t\tlist_add(&tmp->list, &thread_list);\n\t}\n\n\tlist_for_each(t, &thread_list) {\n\t\tstruct elf_thread_status *tmp;\n\t\tint sz;\n\n\t\ttmp = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(cprm->siginfo->si_signo, tmp);\n\t\tthread_status_size += sz;\n\t}\n\n\t/* now collect the dump for the current */\n\tfill_prstatus(prstatus, current, cprm->siginfo->si_signo);\n\telf_core_copy_regs(&prstatus->pr_reg, cprm->regs);\n\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/* Set up header */\n\tfill_elf_fdpic_header(elf, e_phnum);\n\n\thas_dumped = 1;\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(notes + 0, \"CORE\", NT_PRSTATUS, sizeof(*prstatus), prstatus);\n\tfill_psinfo(psinfo, current->group_leader, current->mm);\n\tfill_note(notes + 1, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\tnumnote = 2;\n\n\tauxv = (elf_addr_t *) current->mm->saved_auxv;\n\n\ti = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(&notes[numnote++], \"CORE\", NT_AUXV,\n\t\t  i * sizeof(elf_addr_t), auxv);\n\n  \t/* Try to dump the FPU. */\n\tif ((prstatus->pr_fpvalid =\n\t     elf_core_copy_task_fpregs(current, cprm->regs, fpu)))\n\t\tfill_note(notes + numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*fpu), fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, xfpu))\n\t\tfill_note(notes + numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE, sizeof(*xfpu), xfpu);\n#endif\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(*elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\n\t/* Write notes phdr entry */\n\t{\n\t\tint sz = 0;\n\n\t\tfor (i = 0; i < numnote; i++)\n\t\t\tsz += notesize(notes + i);\n\n\t\tsz += thread_status_size;\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\t/* Page-align dumped data */\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\toffset += elf_core_vma_data_size(cprm->mm_flags);\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, elf, sizeof(*elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* write program headers for segments dump */\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next) {\n\t\tstruct elf_phdr phdr;\n\t\tsize_t sz;\n\n\t\tsz = vma->vm_end - vma->vm_start;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = maydump(vma, cprm->mm_flags) ? sz : 0;\n\t\tphdr.p_memsz = sz;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tfor (i = 0; i < numnote; i++)\n\t\tif (!writenote(notes + i, cprm))\n\t\t\tgoto end_coredump;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\tgoto end_coredump;\n\t}\n\n\tif (!dump_skip(cprm, dataoff - cprm->pos))\n\t\tgoto end_coredump;\n\n\tif (!elf_fdpic_dump_segments(cprm))\n\t\tgoto end_coredump;\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (cprm->file->f_pos != offset) {\n\t\t/* Sanity check */\n\t\tprintk(KERN_WARNING\n\t\t       \"elf_core_dump: file->f_pos (%lld) != offset (%lld)\\n\",\n\t\t       cprm->file->f_pos, offset);\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\twhile (!list_empty(&thread_list)) {\n\t\tstruct list_head *tmp = thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\tkfree(phdr4note);\n\tkfree(elf);\n\tkfree(prstatus);\n\tkfree(psinfo);\n\tkfree(notes);\n\tkfree(fpu);\n\tkfree(shdr4extnum);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(xfpu);\n#endif\n\treturn has_dumped;\n#undef NUM_NOTES\n}"
  },
  {
    "function_name": "elf_core_vma_data_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1534-1543",
    "snippet": "static size_t elf_core_vma_data_size(unsigned long mm_flags)\n{\n\tstruct vm_area_struct *vma;\n\tsize_t size = 0;\n\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next)\n\t\tif (maydump(vma, mm_flags))\n\t\t\tsize += vma->vm_end - vma->vm_start;\n\treturn size;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maydump",
          "args": [
            "vma",
            "mm_flags"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "maydump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1197-1258",
          "snippet": "static int maydump(struct vm_area_struct *vma, unsigned long mm_flags)\n{\n\tint dump_ok;\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO) {\n\t\tkdcore(\"%08lx: %08lx: no (IO)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* If we may not read the contents, don't allow us to dump\n\t * them either. \"dump_write()\" can't handle it anyway.\n\t */\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\tkdcore(\"%08lx: %08lx: no (!read)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif (vma->vm_flags & VM_SHARED) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX shared)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_PRIVATE, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX private)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t}\n\t\treturn dump_ok;\n\t}\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t\treturn dump_ok;\n\t\t}\n\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_SHARED, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n\n#ifdef CONFIG_MMU\n\t/* By default, if it hasn't been written to, don't write it out */\n\tif (!vma->anon_vma) {\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_PRIVATE, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (!anon)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n#endif\n\n\tdump_ok = test_bit(MMF_DUMP_ANON_PRIVATE, &mm_flags);\n\tkdcore(\"%08lx: %08lx: %s\", vma->vm_start, vma->vm_flags,\n\t       dump_ok ? \"yes\" : \"no\");\n\treturn dump_ok;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\n\nstatic int maydump(struct vm_area_struct *vma, unsigned long mm_flags)\n{\n\tint dump_ok;\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO) {\n\t\tkdcore(\"%08lx: %08lx: no (IO)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* If we may not read the contents, don't allow us to dump\n\t * them either. \"dump_write()\" can't handle it anyway.\n\t */\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\tkdcore(\"%08lx: %08lx: no (!read)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif (vma->vm_flags & VM_SHARED) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX shared)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_PRIVATE, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX private)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t}\n\t\treturn dump_ok;\n\t}\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t\treturn dump_ok;\n\t\t}\n\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_SHARED, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n\n#ifdef CONFIG_MMU\n\t/* By default, if it hasn't been written to, don't write it out */\n\tif (!vma->anon_vma) {\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_PRIVATE, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (!anon)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n#endif\n\n\tdump_ok = test_bit(MMF_DUMP_ANON_PRIVATE, &mm_flags);\n\tkdcore(\"%08lx: %08lx: %s\", vma->vm_start, vma->vm_flags,\n\t       dump_ok ? \"yes\" : \"no\");\n\treturn dump_ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic size_t elf_core_vma_data_size(unsigned long mm_flags)\n{\n\tstruct vm_area_struct *vma;\n\tsize_t size = 0;\n\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next)\n\t\tif (maydump(vma, mm_flags))\n\t\t\tsize += vma->vm_end - vma->vm_start;\n\treturn size;\n}"
  },
  {
    "function_name": "elf_fdpic_dump_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1497-1532",
    "snippet": "static bool elf_fdpic_dump_segments(struct coredump_params *cprm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next) {\n#ifdef CONFIG_MMU\n\t\tunsigned long addr;\n#endif\n\n\t\tif (!maydump(vma, cprm->mm_flags))\n\t\t\tcontinue;\n\n#ifdef CONFIG_MMU\n\t\tfor (addr = vma->vm_start; addr < vma->vm_end;\n\t\t\t\t\t\t\taddr += PAGE_SIZE) {\n\t\t\tbool res;\n\t\t\tstruct page *page = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tres = dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tput_page(page);\n\t\t\t} else {\n\t\t\t\tres = dump_skip(cprm, PAGE_SIZE);\n\t\t\t}\n\t\t\tif (!res)\n\t\t\t\treturn false;\n\t\t}\n#else\n\t\tif (!dump_emit(cprm, (void *) vma->vm_start,\n\t\t\t\tvma->vm_end - vma->vm_start))\n\t\t\treturn false;\n#endif\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "(void *) vma->vm_start",
            "vma->vm_end - vma->vm_start"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "dump_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "783-802",
          "snippet": "int dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_skip",
          "args": [
            "cprm",
            "PAGE_SIZE"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "dump_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "805-823",
          "snippet": "int dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dump_page",
          "args": [
            "addr"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maydump",
          "args": [
            "vma",
            "cprm->mm_flags"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "maydump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1197-1258",
          "snippet": "static int maydump(struct vm_area_struct *vma, unsigned long mm_flags)\n{\n\tint dump_ok;\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO) {\n\t\tkdcore(\"%08lx: %08lx: no (IO)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* If we may not read the contents, don't allow us to dump\n\t * them either. \"dump_write()\" can't handle it anyway.\n\t */\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\tkdcore(\"%08lx: %08lx: no (!read)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif (vma->vm_flags & VM_SHARED) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX shared)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_PRIVATE, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX private)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t}\n\t\treturn dump_ok;\n\t}\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t\treturn dump_ok;\n\t\t}\n\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_SHARED, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n\n#ifdef CONFIG_MMU\n\t/* By default, if it hasn't been written to, don't write it out */\n\tif (!vma->anon_vma) {\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_PRIVATE, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (!anon)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n#endif\n\n\tdump_ok = test_bit(MMF_DUMP_ANON_PRIVATE, &mm_flags);\n\tkdcore(\"%08lx: %08lx: %s\", vma->vm_start, vma->vm_flags,\n\t       dump_ok ? \"yes\" : \"no\");\n\treturn dump_ok;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\n\nstatic int maydump(struct vm_area_struct *vma, unsigned long mm_flags)\n{\n\tint dump_ok;\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO) {\n\t\tkdcore(\"%08lx: %08lx: no (IO)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* If we may not read the contents, don't allow us to dump\n\t * them either. \"dump_write()\" can't handle it anyway.\n\t */\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\tkdcore(\"%08lx: %08lx: no (!read)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif (vma->vm_flags & VM_SHARED) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX shared)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_PRIVATE, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX private)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t}\n\t\treturn dump_ok;\n\t}\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t\treturn dump_ok;\n\t\t}\n\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_SHARED, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n\n#ifdef CONFIG_MMU\n\t/* By default, if it hasn't been written to, don't write it out */\n\tif (!vma->anon_vma) {\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_PRIVATE, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (!anon)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n#endif\n\n\tdump_ok = test_bit(MMF_DUMP_ANON_PRIVATE, &mm_flags);\n\tkdcore(\"%08lx: %08lx: %s\", vma->vm_start, vma->vm_flags,\n\t       dump_ok ? \"yes\" : \"no\");\n\treturn dump_ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic bool elf_fdpic_dump_segments(struct coredump_params *cprm)\n{\n\tstruct vm_area_struct *vma;\n\n\tfor (vma = current->mm->mmap; vma; vma = vma->vm_next) {\n#ifdef CONFIG_MMU\n\t\tunsigned long addr;\n#endif\n\n\t\tif (!maydump(vma, cprm->mm_flags))\n\t\t\tcontinue;\n\n#ifdef CONFIG_MMU\n\t\tfor (addr = vma->vm_start; addr < vma->vm_end;\n\t\t\t\t\t\t\taddr += PAGE_SIZE) {\n\t\t\tbool res;\n\t\t\tstruct page *page = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tres = dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tput_page(page);\n\t\t\t} else {\n\t\t\t\tres = dump_skip(cprm, PAGE_SIZE);\n\t\t\t}\n\t\t\tif (!res)\n\t\t\t\treturn false;\n\t\t}\n#else\n\t\tif (!dump_emit(cprm, (void *) vma->vm_start,\n\t\t\t\tvma->vm_end - vma->vm_start))\n\t\t\treturn false;\n#endif\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "fill_extnum_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1478-1492",
    "snippet": "static void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "shdr4extnum",
            "0",
            "sizeof(*shdr4extnum)"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}"
  },
  {
    "function_name": "elf_dump_thread_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1444-1476",
    "snippet": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tstruct task_struct *p = t->thread;\n\tint sz = 0;\n\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &t->prstatus);\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tt->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL, &t->fpu);\n\tif (t->prstatus.pr_fpvalid) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &t->fpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\n\treturn sz;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "&t->notes[2]"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1269-1278",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "&t->notes[2]",
            "\"LINUX\"",
            "ELF_CORE_XFPREG_TYPE",
            "sizeof(t->xfpu)",
            "&t->xfpu"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1332-1340",
          "snippet": "static inline void fill_note(struct memelfnote *note, const char *name, int type,\n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void fill_note(struct memelfnote *note, const char *name, int type,\n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_xfpregs",
          "args": [
            "p",
            "&t->xfpu"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_fpregs",
          "args": [
            "p",
            "NULL",
            "&t->fpu"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_regs",
          "args": [
            "p",
            "&t->prstatus.pr_reg"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_prstatus",
          "args": [
            "&t->prstatus",
            "p",
            "signr"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1346-1380",
          "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\t\t  struct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n\n\tprstatus->pr_exec_fdpic_loadmap = p->mm->context.exec_fdpic_loadmap;\n\tprstatus->pr_interp_fdpic_loadmap = p->mm->context.interp_fdpic_loadmap;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\t\t  struct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n\n\tprstatus->pr_exec_fdpic_loadmap = p->mm->context.exec_fdpic_loadmap;\n\tprstatus->pr_interp_fdpic_loadmap = p->mm->context.interp_fdpic_loadmap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tstruct task_struct *p = t->thread;\n\tint sz = 0;\n\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &t->prstatus);\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tt->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL, &t->fpu);\n\tif (t->prstatus.pr_fpvalid) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &t->fpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\n\treturn sz;\n}"
  },
  {
    "function_name": "fill_psinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1382-1423",
    "snippet": "static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ - 1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *) mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
      "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "psinfo->pr_fname",
            "p->comm",
            "sizeof(psinfo->pr_fname)"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_GID",
          "args": [
            "psinfo->pr_gid",
            "from_kgid_munged(cred->user_ns, cred->gid)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "cred->user_ns",
            "cred->gid"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_UID",
          "args": [
            "psinfo->pr_uid",
            "from_kuid_munged(cred->user_ns, cred->uid)"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "cred->user_ns",
            "cred->uid"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "p"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~p->state"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session_vnr",
          "args": [
            "p"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp_vnr",
          "args": [
            "p"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "rcu_dereference(p->real_parent)"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "p->real_parent"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&psinfo->pr_psargs",
            "(const char __user *) mm->arg_start",
            "len"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "psinfo",
            "0",
            "sizeof(struct elf_prpsinfo)"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ - 1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *) mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_prstatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1346-1380",
    "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\t\t  struct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n\n\tprstatus->pr_exec_fdpic_loadmap = p->mm->context.exec_fdpic_loadmap;\n\tprstatus->pr_interp_fdpic_loadmap = p->mm->context.interp_fdpic_loadmap;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "p->signal->cstime"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "p->signal->cutime"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "stime"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "utime"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "p",
            "&utime",
            "&stime"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "cputime.stime"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "cputime.utime"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "p",
            "&cputime"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "p"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session_vnr",
          "args": [
            "p"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp_vnr",
          "args": [
            "p"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "rcu_dereference(p->real_parent)"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "p->real_parent"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\t\t  struct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n\n\tprstatus->pr_exec_fdpic_loadmap = p->mm->context.exec_fdpic_loadmap;\n\tprstatus->pr_interp_fdpic_loadmap = p->mm->context.interp_fdpic_loadmap;\n}"
  },
  {
    "function_name": "fill_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1332-1340",
    "snippet": "static inline void fill_note(struct memelfnote *note, const char *name, int type,\n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void fill_note(struct memelfnote *note, const char *name, int type,\n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}"
  },
  {
    "function_name": "fill_elf_note_phdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1319-1330",
    "snippet": "static inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}"
  },
  {
    "function_name": "fill_elf_fdpic_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1294-1317",
    "snippet": "static inline void fill_elf_fdpic_header(struct elfhdr *elf, int segs)\n{\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n\telf->e_flags = ELF_FDPIC_CORE_EFLAGS;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\treturn;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "elf->e_ident+EI_PAD",
            "0",
            "EI_NIDENT-EI_PAD"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "elf->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void fill_elf_fdpic_header(struct elfhdr *elf, int segs)\n{\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n\telf->e_flags = ELF_FDPIC_CORE_EFLAGS;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\treturn;\n}"
  },
  {
    "function_name": "writenote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1282-1292",
    "snippet": "static int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t\tdump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t\tdump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_align",
          "args": [
            "cprm",
            "4"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "dump_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "826-832",
          "snippet": "int dump_align(struct coredump_params *cprm, int align)\n{\n\tunsigned mod = cprm->pos & (align - 1);\n\tif (align & (align - 1))\n\t\treturn 0;\n\treturn mod ? dump_skip(cprm, align - mod) : 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_align(struct coredump_params *cprm, int align)\n{\n\tunsigned mod = cprm->pos & (align - 1);\n\tif (align & (align - 1))\n\t\treturn 0;\n\treturn mod ? dump_skip(cprm, align - mod) : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "men->data",
            "men->datasz"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "dump_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "783-802",
          "snippet": "int dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "men->name"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t\tdump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t\tdump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}"
  },
  {
    "function_name": "notesize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1269-1278",
    "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "en->datasz",
            "4"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xfs/xfs_linux.h",
          "lines": "210-215",
          "snippet": "static inline uint64_t roundup_64(uint64_t x, uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/rhashtable.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/uuid.h>\n#include <linux/types.h>\n\nstatic inline uint64_t roundup_64(uint64_t x, uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "en->name"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
  },
  {
    "function_name": "maydump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1197-1258",
    "snippet": "static int maydump(struct vm_area_struct *vma, unsigned long mm_flags)\n{\n\tint dump_ok;\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO) {\n\t\tkdcore(\"%08lx: %08lx: no (IO)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* If we may not read the contents, don't allow us to dump\n\t * them either. \"dump_write()\" can't handle it anyway.\n\t */\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\tkdcore(\"%08lx: %08lx: no (!read)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif (vma->vm_flags & VM_SHARED) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX shared)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_PRIVATE, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX private)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t}\n\t\treturn dump_ok;\n\t}\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t\treturn dump_ok;\n\t\t}\n\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_SHARED, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n\n#ifdef CONFIG_MMU\n\t/* By default, if it hasn't been written to, don't write it out */\n\tif (!vma->anon_vma) {\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_PRIVATE, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (!anon)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n#endif\n\n\tdump_ok = test_bit(MMF_DUMP_ANON_PRIVATE, &mm_flags);\n\tkdcore(\"%08lx: %08lx: %s\", vma->vm_start, vma->vm_flags,\n\t       dump_ok ? \"yes\" : \"no\");\n\treturn dump_ok;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdcore",
          "args": [
            "\"%08lx: %08lx: %s\"",
            "vma->vm_start",
            "vma->vm_flags",
            "dump_ok ? \"yes\" : \"no\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_DUMP_ANON_PRIVATE",
            "&mm_flags"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdcore",
          "args": [
            "\"%08lx: %08lx: %s (!anon)\"",
            "vma->vm_start",
            "vma->vm_flags",
            "dump_ok ? \"yes\" : \"no\""
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdcore",
          "args": [
            "\"%08lx: %08lx: %s (share)\"",
            "vma->vm_start",
            "vma->vm_flags",
            "dump_ok ? \"yes\" : \"no\""
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdcore",
          "args": [
            "\"%08lx: %08lx: %s (share)\"",
            "vma->vm_start",
            "vma->vm_flags",
            "dump_ok ? \"yes\" : \"no\""
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdcore",
          "args": [
            "\"%08lx: %08lx: %s (DAX private)\"",
            "vma->vm_start",
            "vma->vm_flags",
            "dump_ok ? \"yes\" : \"no\""
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdcore",
          "args": [
            "\"%08lx: %08lx: %s (DAX shared)\"",
            "vma->vm_start",
            "vma->vm_flags",
            "dump_ok ? \"yes\" : \"no\""
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdcore",
          "args": [
            "\"%08lx: %08lx: no (!read)\"",
            "vma->vm_start",
            "vma->vm_flags"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdcore",
          "args": [
            "\"%08lx: %08lx: no (IO)\"",
            "vma->vm_start",
            "vma->vm_flags"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\n\nstatic int maydump(struct vm_area_struct *vma, unsigned long mm_flags)\n{\n\tint dump_ok;\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO) {\n\t\tkdcore(\"%08lx: %08lx: no (IO)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* If we may not read the contents, don't allow us to dump\n\t * them either. \"dump_write()\" can't handle it anyway.\n\t */\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\tkdcore(\"%08lx: %08lx: no (!read)\", vma->vm_start, vma->vm_flags);\n\t\treturn 0;\n\t}\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif (vma->vm_flags & VM_SHARED) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX shared)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t} else {\n\t\t\tdump_ok = test_bit(MMF_DUMP_DAX_PRIVATE, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (DAX private)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t}\n\t\treturn dump_ok;\n\t}\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0) {\n\t\t\tdump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);\n\t\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\t\treturn dump_ok;\n\t\t}\n\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_SHARED, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (share)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n\n#ifdef CONFIG_MMU\n\t/* By default, if it hasn't been written to, don't write it out */\n\tif (!vma->anon_vma) {\n\t\tdump_ok = test_bit(MMF_DUMP_MAPPED_PRIVATE, &mm_flags);\n\t\tkdcore(\"%08lx: %08lx: %s (!anon)\", vma->vm_start,\n\t\t       vma->vm_flags, dump_ok ? \"yes\" : \"no\");\n\t\treturn dump_ok;\n\t}\n#endif\n\n\tdump_ok = test_bit(MMF_DUMP_ANON_PRIVATE, &mm_flags);\n\tkdcore(\"%08lx: %08lx: %s\", vma->vm_start, vma->vm_flags,\n\t       dump_ok ? \"yes\" : \"no\");\n\treturn dump_ok;\n}"
  },
  {
    "function_name": "elf_fdpic_map_file_by_direct_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "1008-1177",
    "snippet": "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *params,\n\t\t\t\t\t     struct file *file,\n\t\t\t\t\t     struct mm_struct *mm)\n{\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, delta_vaddr;\n\tint loop, dvset;\n\n\tload_addr = params->load_addr;\n\tdelta_vaddr = 0;\n\tdvset = 0;\n\n\tseg = params->loadmap->segs;\n\n\t/* deal with each load segment separately */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tunsigned long maddr, disp, excess, excess1;\n\t\tint prot = 0, flags;\n\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tkdebug(\"[LOAD] va=%lx of=%lx fs=%lx ms=%lx\",\n\t\t       (unsigned long) phdr->p_vaddr,\n\t\t       (unsigned long) phdr->p_offset,\n\t\t       (unsigned long) phdr->p_filesz,\n\t\t       (unsigned long) phdr->p_memsz);\n\n\t\t/* determine the mapping parameters */\n\t\tif (phdr->p_flags & PF_R) prot |= PROT_READ;\n\t\tif (phdr->p_flags & PF_W) prot |= PROT_WRITE;\n\t\tif (phdr->p_flags & PF_X) prot |= PROT_EXEC;\n\n\t\tflags = MAP_PRIVATE | MAP_DENYWRITE;\n\t\tif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\n\t\t\tflags |= MAP_EXECUTABLE;\n\n\t\tmaddr = 0;\n\n\t\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\t\tcase ELF_FDPIC_FLAG_INDEPENDENT:\n\t\t\t/* PT_LOADs are independently locatable */\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_HONOURVADDR:\n\t\t\t/* the specified virtual address must be honoured */\n\t\t\tmaddr = phdr->p_vaddr;\n\t\t\tflags |= MAP_FIXED;\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\t\t\t/* constant displacement\n\t\t\t * - can be mapped anywhere, but must be mapped as a\n\t\t\t *   unit\n\t\t\t */\n\t\t\tif (!dvset) {\n\t\t\t\tmaddr = load_addr;\n\t\t\t\tdelta_vaddr = phdr->p_vaddr;\n\t\t\t\tdvset = 1;\n\t\t\t} else {\n\t\t\t\tmaddr = load_addr + phdr->p_vaddr - delta_vaddr;\n\t\t\t\tflags |= MAP_FIXED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n\t\t\t/* contiguity handled later */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tmaddr &= PAGE_MASK;\n\n\t\t/* create the mapping */\n\t\tdisp = phdr->p_vaddr & ~PAGE_MASK;\n\t\tmaddr = vm_mmap(file, maddr, phdr->p_memsz + disp, prot, flags,\n\t\t\t\tphdr->p_offset - disp);\n\n\t\tkdebug(\"mmap[%d] <file> sz=%lx pr=%x fl=%x of=%lx --> %08lx\",\n\t\t       loop, phdr->p_memsz + disp, prot, flags,\n\t\t       phdr->p_offset - disp, maddr);\n\n\t\tif (IS_ERR_VALUE(maddr))\n\t\t\treturn (int) maddr;\n\n\t\tif ((params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) ==\n\t\t    ELF_FDPIC_FLAG_CONTIGUOUS)\n\t\t\tload_addr += PAGE_ALIGN(phdr->p_memsz + disp);\n\n\t\tseg->addr = maddr + disp;\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\t/* map the ELF header address if in this segment */\n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t/* clear the bit between beginning of mapping and beginning of\n\t\t * PT_LOAD */\n\t\tif (prot & PROT_WRITE && disp > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\", loop, maddr, disp);\n\t\t\tif (clear_user((void __user *) maddr, disp))\n\t\t\t\treturn -EFAULT;\n\t\t\tmaddr += disp;\n\t\t}\n\n\t\t/* clear any space allocated but not loaded\n\t\t * - on uClinux we can just clear the lot\n\t\t * - on MMU linux we'll get a SIGBUS beyond the last page\n\t\t *   extant in the file\n\t\t */\n\t\texcess = phdr->p_memsz - phdr->p_filesz;\n\t\texcess1 = PAGE_SIZE - ((maddr + phdr->p_filesz) & ~PAGE_MASK);\n\n#ifdef CONFIG_MMU\n\t\tif (excess > excess1) {\n\t\t\tunsigned long xaddr = maddr + phdr->p_filesz + excess1;\n\t\t\tunsigned long xmaddr;\n\n\t\t\tflags |= MAP_FIXED | MAP_ANONYMOUS;\n\t\t\txmaddr = vm_mmap(NULL, xaddr, excess - excess1,\n\t\t\t\t\t prot, flags, 0);\n\n\t\t\tkdebug(\"mmap[%d] <anon>\"\n\t\t\t       \" ad=%lx sz=%lx pr=%x fl=%x of=0 --> %08lx\",\n\t\t\t       loop, xaddr, excess - excess1, prot, flags,\n\t\t\t       xmaddr);\n\n\t\t\tif (xmaddr != xaddr)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (prot & PROT_WRITE && excess1 > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess1);\n\t\t\tif (clear_user((void __user *) maddr + phdr->p_filesz,\n\t\t\t\t       excess1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n#else\n\t\tif (excess > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess);\n\t\t\tif (clear_user((void *) maddr + phdr->p_filesz, excess))\n\t\t\t\treturn -EFAULT;\n\t\t}\n#endif\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = maddr;\n\t\t\t\t\tmm->end_code = maddr + phdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = maddr;\n\t\t\t\tmm->end_data = maddr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);",
      "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
      "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);",
      "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(void *) maddr + phdr->p_filesz",
            "excess"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"clear[%d] ad=%lx sz=%lx\"",
            "loop",
            "maddr + phdr->p_filesz",
            "excess"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(void __user *) maddr + phdr->p_filesz",
            "excess1"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"clear[%d] ad=%lx sz=%lx\"",
            "loop",
            "maddr + phdr->p_filesz",
            "excess1"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"mmap[%d] <anon>\"\n\t\t\t       \" ad=%lx sz=%lx pr=%x fl=%x of=0 --> %08lx\"",
            "loop",
            "xaddr",
            "excess - excess1",
            "prot",
            "flags",
            "xmaddr"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "NULL",
            "xaddr",
            "excess - excess1",
            "prot",
            "flags",
            "0"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(void __user *) maddr",
            "disp"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"clear[%d] ad=%lx sz=%lx\"",
            "loop",
            "maddr",
            "disp"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "phdr->p_memsz + disp"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "maddr"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"mmap[%d] <file> sz=%lx pr=%x fl=%x of=%lx --> %08lx\"",
            "loop",
            "phdr->p_memsz + disp",
            "prot",
            "flags",
            "phdr->p_offset - disp",
            "maddr"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "file",
            "maddr",
            "phdr->p_memsz + disp",
            "prot",
            "flags",
            "phdr->p_offset - disp"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"[LOAD] va=%lx of=%lx fs=%lx ms=%lx\"",
            "(unsigned long) phdr->p_vaddr",
            "(unsigned long) phdr->p_offset",
            "(unsigned long) phdr->p_filesz",
            "(unsigned long) phdr->p_memsz"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *params,\n\t\t\t\t\t     struct file *file,\n\t\t\t\t\t     struct mm_struct *mm)\n{\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, delta_vaddr;\n\tint loop, dvset;\n\n\tload_addr = params->load_addr;\n\tdelta_vaddr = 0;\n\tdvset = 0;\n\n\tseg = params->loadmap->segs;\n\n\t/* deal with each load segment separately */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tunsigned long maddr, disp, excess, excess1;\n\t\tint prot = 0, flags;\n\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tkdebug(\"[LOAD] va=%lx of=%lx fs=%lx ms=%lx\",\n\t\t       (unsigned long) phdr->p_vaddr,\n\t\t       (unsigned long) phdr->p_offset,\n\t\t       (unsigned long) phdr->p_filesz,\n\t\t       (unsigned long) phdr->p_memsz);\n\n\t\t/* determine the mapping parameters */\n\t\tif (phdr->p_flags & PF_R) prot |= PROT_READ;\n\t\tif (phdr->p_flags & PF_W) prot |= PROT_WRITE;\n\t\tif (phdr->p_flags & PF_X) prot |= PROT_EXEC;\n\n\t\tflags = MAP_PRIVATE | MAP_DENYWRITE;\n\t\tif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\n\t\t\tflags |= MAP_EXECUTABLE;\n\n\t\tmaddr = 0;\n\n\t\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\t\tcase ELF_FDPIC_FLAG_INDEPENDENT:\n\t\t\t/* PT_LOADs are independently locatable */\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_HONOURVADDR:\n\t\t\t/* the specified virtual address must be honoured */\n\t\t\tmaddr = phdr->p_vaddr;\n\t\t\tflags |= MAP_FIXED;\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\t\t\t/* constant displacement\n\t\t\t * - can be mapped anywhere, but must be mapped as a\n\t\t\t *   unit\n\t\t\t */\n\t\t\tif (!dvset) {\n\t\t\t\tmaddr = load_addr;\n\t\t\t\tdelta_vaddr = phdr->p_vaddr;\n\t\t\t\tdvset = 1;\n\t\t\t} else {\n\t\t\t\tmaddr = load_addr + phdr->p_vaddr - delta_vaddr;\n\t\t\t\tflags |= MAP_FIXED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n\t\t\t/* contiguity handled later */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tmaddr &= PAGE_MASK;\n\n\t\t/* create the mapping */\n\t\tdisp = phdr->p_vaddr & ~PAGE_MASK;\n\t\tmaddr = vm_mmap(file, maddr, phdr->p_memsz + disp, prot, flags,\n\t\t\t\tphdr->p_offset - disp);\n\n\t\tkdebug(\"mmap[%d] <file> sz=%lx pr=%x fl=%x of=%lx --> %08lx\",\n\t\t       loop, phdr->p_memsz + disp, prot, flags,\n\t\t       phdr->p_offset - disp, maddr);\n\n\t\tif (IS_ERR_VALUE(maddr))\n\t\t\treturn (int) maddr;\n\n\t\tif ((params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) ==\n\t\t    ELF_FDPIC_FLAG_CONTIGUOUS)\n\t\t\tload_addr += PAGE_ALIGN(phdr->p_memsz + disp);\n\n\t\tseg->addr = maddr + disp;\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\t/* map the ELF header address if in this segment */\n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t/* clear the bit between beginning of mapping and beginning of\n\t\t * PT_LOAD */\n\t\tif (prot & PROT_WRITE && disp > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\", loop, maddr, disp);\n\t\t\tif (clear_user((void __user *) maddr, disp))\n\t\t\t\treturn -EFAULT;\n\t\t\tmaddr += disp;\n\t\t}\n\n\t\t/* clear any space allocated but not loaded\n\t\t * - on uClinux we can just clear the lot\n\t\t * - on MMU linux we'll get a SIGBUS beyond the last page\n\t\t *   extant in the file\n\t\t */\n\t\texcess = phdr->p_memsz - phdr->p_filesz;\n\t\texcess1 = PAGE_SIZE - ((maddr + phdr->p_filesz) & ~PAGE_MASK);\n\n#ifdef CONFIG_MMU\n\t\tif (excess > excess1) {\n\t\t\tunsigned long xaddr = maddr + phdr->p_filesz + excess1;\n\t\t\tunsigned long xmaddr;\n\n\t\t\tflags |= MAP_FIXED | MAP_ANONYMOUS;\n\t\t\txmaddr = vm_mmap(NULL, xaddr, excess - excess1,\n\t\t\t\t\t prot, flags, 0);\n\n\t\t\tkdebug(\"mmap[%d] <anon>\"\n\t\t\t       \" ad=%lx sz=%lx pr=%x fl=%x of=0 --> %08lx\",\n\t\t\t       loop, xaddr, excess - excess1, prot, flags,\n\t\t\t       xmaddr);\n\n\t\t\tif (xmaddr != xaddr)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (prot & PROT_WRITE && excess1 > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess1);\n\t\t\tif (clear_user((void __user *) maddr + phdr->p_filesz,\n\t\t\t\t       excess1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n#else\n\t\tif (excess > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess);\n\t\t\tif (clear_user((void *) maddr + phdr->p_filesz, excess))\n\t\t\t\treturn -EFAULT;\n\t\t}\n#endif\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = maddr;\n\t\t\t\t\tmm->end_code = maddr + phdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = maddr;\n\t\t\t\tmm->end_data = maddr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "elf_fdpic_map_file_constdisp_on_uclinux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "919-1001",
    "snippet": "static int elf_fdpic_map_file_constdisp_on_uclinux(\n\tstruct elf_fdpic_params *params,\n\tstruct file *file,\n\tstruct mm_struct *mm)\n{\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, base = ULONG_MAX, top = 0, maddr = 0, mflags;\n\tint loop, ret;\n\n\tload_addr = params->load_addr;\n\tseg = params->loadmap->segs;\n\n\t/* determine the bounds of the contiguous overall allocation we must\n\t * make */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (base > phdr->p_vaddr)\n\t\t\tbase = phdr->p_vaddr;\n\t\tif (top < phdr->p_vaddr + phdr->p_memsz)\n\t\t\ttop = phdr->p_vaddr + phdr->p_memsz;\n\t}\n\n\t/* allocate one big anon block for everything */\n\tmflags = MAP_PRIVATE;\n\tif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\n\t\tmflags |= MAP_EXECUTABLE;\n\n\tmaddr = vm_mmap(NULL, load_addr, top - base,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC, mflags, 0);\n\tif (IS_ERR_VALUE(maddr))\n\t\treturn (int) maddr;\n\n\tif (load_addr != 0)\n\t\tload_addr += PAGE_ALIGN(top - base);\n\n\t/* and then load the file segments into it */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tseg->addr = maddr + (phdr->p_vaddr - base);\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\tret = read_code(file, seg->addr, phdr->p_offset,\n\t\t\t\t       phdr->p_filesz);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t/* map the ELF header address if in this segment */\n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t/* clear any space allocated but not loaded */\n\t\tif (phdr->p_filesz < phdr->p_memsz) {\n\t\t\tif (clear_user((void *) (seg->addr + phdr->p_filesz),\n\t\t\t\t       phdr->p_memsz - phdr->p_filesz))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = seg->addr;\n\t\t\t\t\tmm->end_code = seg->addr +\n\t\t\t\t\t\tphdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = seg->addr;\n\t\t\t\tmm->end_data = seg->addr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);",
      "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
      "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);",
      "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(void *) (seg->addr + phdr->p_filesz)",
            "phdr->p_memsz - phdr->p_filesz"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_code",
          "args": [
            "file",
            "seg->addr",
            "phdr->p_offset",
            "phdr->p_filesz"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "read_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "998-1004",
          "snippet": "ssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "top - base"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "maddr"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "NULL",
            "load_addr",
            "top - base",
            "PROT_READ | PROT_WRITE | PROT_EXEC",
            "mflags",
            "0"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int elf_fdpic_map_file_constdisp_on_uclinux(\n\tstruct elf_fdpic_params *params,\n\tstruct file *file,\n\tstruct mm_struct *mm)\n{\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, base = ULONG_MAX, top = 0, maddr = 0, mflags;\n\tint loop, ret;\n\n\tload_addr = params->load_addr;\n\tseg = params->loadmap->segs;\n\n\t/* determine the bounds of the contiguous overall allocation we must\n\t * make */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (base > phdr->p_vaddr)\n\t\t\tbase = phdr->p_vaddr;\n\t\tif (top < phdr->p_vaddr + phdr->p_memsz)\n\t\t\ttop = phdr->p_vaddr + phdr->p_memsz;\n\t}\n\n\t/* allocate one big anon block for everything */\n\tmflags = MAP_PRIVATE;\n\tif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\n\t\tmflags |= MAP_EXECUTABLE;\n\n\tmaddr = vm_mmap(NULL, load_addr, top - base,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC, mflags, 0);\n\tif (IS_ERR_VALUE(maddr))\n\t\treturn (int) maddr;\n\n\tif (load_addr != 0)\n\t\tload_addr += PAGE_ALIGN(top - base);\n\n\t/* and then load the file segments into it */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tseg->addr = maddr + (phdr->p_vaddr - base);\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\tret = read_code(file, seg->addr, phdr->p_offset,\n\t\t\t\t       phdr->p_filesz);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t/* map the ELF header address if in this segment */\n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t/* clear any space allocated but not loaded */\n\t\tif (phdr->p_filesz < phdr->p_memsz) {\n\t\t\tif (clear_user((void *) (seg->addr + phdr->p_filesz),\n\t\t\t\t       phdr->p_memsz - phdr->p_filesz))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = seg->addr;\n\t\t\t\t\tmm->end_code = seg->addr +\n\t\t\t\t\t\tphdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = seg->addr;\n\t\t\t\tmm->end_data = seg->addr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "elf_fdpic_map_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "732-912",
    "snippet": "static int elf_fdpic_map_file(struct elf_fdpic_params *params,\n\t\t\t      struct file *file,\n\t\t\t      struct mm_struct *mm,\n\t\t\t      const char *what)\n{\n\tstruct elf32_fdpic_loadmap *loadmap;\n#ifdef CONFIG_MMU\n\tstruct elf32_fdpic_loadseg *mseg;\n#endif\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, stop;\n\tunsigned nloads, tmp;\n\tsize_t size;\n\tint loop, ret;\n\n\t/* allocate a load map table */\n\tnloads = 0;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++)\n\t\tif (params->phdrs[loop].p_type == PT_LOAD)\n\t\t\tnloads++;\n\n\tif (nloads == 0)\n\t\treturn -ELIBBAD;\n\n\tsize = sizeof(*loadmap) + nloads * sizeof(*seg);\n\tloadmap = kzalloc(size, GFP_KERNEL);\n\tif (!loadmap)\n\t\treturn -ENOMEM;\n\n\tparams->loadmap = loadmap;\n\n\tloadmap->version = ELF32_FDPIC_LOADMAP_VERSION;\n\tloadmap->nsegs = nloads;\n\n\tload_addr = params->load_addr;\n\tseg = loadmap->segs;\n\n\t/* map the requested LOADs into the memory space */\n\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n#ifndef CONFIG_MMU\n\t\tret = elf_fdpic_map_file_constdisp_on_uclinux(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = elf_fdpic_map_file_by_direct_mmap(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t/* map the entry point */\n\tif (params->hdr.e_entry) {\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (params->hdr.e_entry >= seg->p_vaddr &&\n\t\t\t    params->hdr.e_entry < seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->entry_addr =\n\t\t\t\t\t(params->hdr.e_entry - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* determine where the program header table has wound up if mapped */\n\tstop = params->hdr.e_phoff;\n\tstop += params->hdr.e_phnum * sizeof (struct elf_phdr);\n\tphdr = params->phdrs;\n\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_offset > params->hdr.e_phoff ||\n\t\t    phdr->p_offset + phdr->p_filesz < stop)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_filesz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->ph_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr +\n\t\t\t\t\tparams->hdr.e_phoff - phdr->p_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* determine where the dynamic section has wound up if there is one */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_DYNAMIC)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_memsz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tElf32_Dyn __user *dyn;\n\t\t\t\tElf32_Sword d_tag;\n\n\t\t\t\tparams->dynamic_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\n\t\t\t\t/* check the dynamic section contains at least\n\t\t\t\t * one item, and that the last item is a NULL\n\t\t\t\t * entry */\n\t\t\t\tif (phdr->p_memsz == 0 ||\n\t\t\t\t    phdr->p_memsz % sizeof(Elf32_Dyn) != 0)\n\t\t\t\t\tgoto dynamic_error;\n\n\t\t\t\ttmp = phdr->p_memsz / sizeof(Elf32_Dyn);\n\t\t\t\tdyn = (Elf32_Dyn __user *)params->dynamic_addr;\n\t\t\t\t__get_user(d_tag, &dyn[tmp - 1].d_tag);\n\t\t\t\tif (d_tag != 0)\n\t\t\t\t\tgoto dynamic_error;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* now elide adjacent segments in the load map on MMU linux\n\t * - on uClinux the holes between may actually be filled with system\n\t *   stuff or stuff from other processes\n\t */\n#ifdef CONFIG_MMU\n\tnloads = loadmap->nsegs;\n\tmseg = loadmap->segs;\n\tseg = mseg + 1;\n\tfor (loop = 1; loop < nloads; loop++) {\n\t\t/* see if we have a candidate for merging */\n\t\tif (seg->p_vaddr - mseg->p_vaddr == seg->addr - mseg->addr) {\n\t\t\tload_addr = PAGE_ALIGN(mseg->addr + mseg->p_memsz);\n\t\t\tif (load_addr == (seg->addr & PAGE_MASK)) {\n\t\t\t\tmseg->p_memsz +=\n\t\t\t\t\tload_addr -\n\t\t\t\t\t(mseg->addr + mseg->p_memsz);\n\t\t\t\tmseg->p_memsz += seg->addr & ~PAGE_MASK;\n\t\t\t\tmseg->p_memsz += seg->p_memsz;\n\t\t\t\tloadmap->nsegs--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmseg++;\n\t\tif (mseg != seg)\n\t\t\t*mseg = *seg;\n\t}\n#endif\n\n\tkdebug(\"Mapped Object [%s]:\", what);\n\tkdebug(\"- elfhdr   : %lx\", params->elfhdr_addr);\n\tkdebug(\"- entry    : %lx\", params->entry_addr);\n\tkdebug(\"- PHDR[]   : %lx\", params->ph_addr);\n\tkdebug(\"- DYNAMIC[]: %lx\", params->dynamic_addr);\n\tseg = loadmap->segs;\n\tfor (loop = 0; loop < loadmap->nsegs; loop++, seg++)\n\t\tkdebug(\"- LOAD[%d] : %08x-%08x [va=%x ms=%x]\",\n\t\t       loop,\n\t\t       seg->addr, seg->addr + seg->p_memsz - 1,\n\t\t       seg->p_vaddr, seg->p_memsz);\n\n\treturn 0;\n\ndynamic_error:\n\tprintk(\"ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\\n\",\n\t       what, file_inode(file)->i_ino);\n\treturn -ELIBBAD;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);",
      "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
      "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);",
      "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\\n\"",
            "what",
            "file_inode(file)->i_ino"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- LOAD[%d] : %08x-%08x [va=%x ms=%x]\"",
            "loop",
            "seg->addr",
            "seg->addr + seg->p_memsz - 1",
            "seg->p_vaddr",
            "seg->p_memsz"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- DYNAMIC[]: %lx\"",
            "params->dynamic_addr"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- PHDR[]   : %lx\"",
            "params->ph_addr"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- entry    : %lx\"",
            "params->entry_addr"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- elfhdr   : %lx\"",
            "params->elfhdr_addr"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"Mapped Object [%s]:\"",
            "what"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mseg->addr + mseg->p_memsz"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "d_tag",
            "&dyn[tmp - 1].d_tag"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_fdpic_map_file_by_direct_mmap",
          "args": [
            "params",
            "file",
            "mm"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "elf_fdpic_map_file_by_direct_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "1008-1177",
          "snippet": "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *params,\n\t\t\t\t\t     struct file *file,\n\t\t\t\t\t     struct mm_struct *mm)\n{\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, delta_vaddr;\n\tint loop, dvset;\n\n\tload_addr = params->load_addr;\n\tdelta_vaddr = 0;\n\tdvset = 0;\n\n\tseg = params->loadmap->segs;\n\n\t/* deal with each load segment separately */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tunsigned long maddr, disp, excess, excess1;\n\t\tint prot = 0, flags;\n\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tkdebug(\"[LOAD] va=%lx of=%lx fs=%lx ms=%lx\",\n\t\t       (unsigned long) phdr->p_vaddr,\n\t\t       (unsigned long) phdr->p_offset,\n\t\t       (unsigned long) phdr->p_filesz,\n\t\t       (unsigned long) phdr->p_memsz);\n\n\t\t/* determine the mapping parameters */\n\t\tif (phdr->p_flags & PF_R) prot |= PROT_READ;\n\t\tif (phdr->p_flags & PF_W) prot |= PROT_WRITE;\n\t\tif (phdr->p_flags & PF_X) prot |= PROT_EXEC;\n\n\t\tflags = MAP_PRIVATE | MAP_DENYWRITE;\n\t\tif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\n\t\t\tflags |= MAP_EXECUTABLE;\n\n\t\tmaddr = 0;\n\n\t\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\t\tcase ELF_FDPIC_FLAG_INDEPENDENT:\n\t\t\t/* PT_LOADs are independently locatable */\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_HONOURVADDR:\n\t\t\t/* the specified virtual address must be honoured */\n\t\t\tmaddr = phdr->p_vaddr;\n\t\t\tflags |= MAP_FIXED;\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\t\t\t/* constant displacement\n\t\t\t * - can be mapped anywhere, but must be mapped as a\n\t\t\t *   unit\n\t\t\t */\n\t\t\tif (!dvset) {\n\t\t\t\tmaddr = load_addr;\n\t\t\t\tdelta_vaddr = phdr->p_vaddr;\n\t\t\t\tdvset = 1;\n\t\t\t} else {\n\t\t\t\tmaddr = load_addr + phdr->p_vaddr - delta_vaddr;\n\t\t\t\tflags |= MAP_FIXED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n\t\t\t/* contiguity handled later */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tmaddr &= PAGE_MASK;\n\n\t\t/* create the mapping */\n\t\tdisp = phdr->p_vaddr & ~PAGE_MASK;\n\t\tmaddr = vm_mmap(file, maddr, phdr->p_memsz + disp, prot, flags,\n\t\t\t\tphdr->p_offset - disp);\n\n\t\tkdebug(\"mmap[%d] <file> sz=%lx pr=%x fl=%x of=%lx --> %08lx\",\n\t\t       loop, phdr->p_memsz + disp, prot, flags,\n\t\t       phdr->p_offset - disp, maddr);\n\n\t\tif (IS_ERR_VALUE(maddr))\n\t\t\treturn (int) maddr;\n\n\t\tif ((params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) ==\n\t\t    ELF_FDPIC_FLAG_CONTIGUOUS)\n\t\t\tload_addr += PAGE_ALIGN(phdr->p_memsz + disp);\n\n\t\tseg->addr = maddr + disp;\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\t/* map the ELF header address if in this segment */\n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t/* clear the bit between beginning of mapping and beginning of\n\t\t * PT_LOAD */\n\t\tif (prot & PROT_WRITE && disp > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\", loop, maddr, disp);\n\t\t\tif (clear_user((void __user *) maddr, disp))\n\t\t\t\treturn -EFAULT;\n\t\t\tmaddr += disp;\n\t\t}\n\n\t\t/* clear any space allocated but not loaded\n\t\t * - on uClinux we can just clear the lot\n\t\t * - on MMU linux we'll get a SIGBUS beyond the last page\n\t\t *   extant in the file\n\t\t */\n\t\texcess = phdr->p_memsz - phdr->p_filesz;\n\t\texcess1 = PAGE_SIZE - ((maddr + phdr->p_filesz) & ~PAGE_MASK);\n\n#ifdef CONFIG_MMU\n\t\tif (excess > excess1) {\n\t\t\tunsigned long xaddr = maddr + phdr->p_filesz + excess1;\n\t\t\tunsigned long xmaddr;\n\n\t\t\tflags |= MAP_FIXED | MAP_ANONYMOUS;\n\t\t\txmaddr = vm_mmap(NULL, xaddr, excess - excess1,\n\t\t\t\t\t prot, flags, 0);\n\n\t\t\tkdebug(\"mmap[%d] <anon>\"\n\t\t\t       \" ad=%lx sz=%lx pr=%x fl=%x of=0 --> %08lx\",\n\t\t\t       loop, xaddr, excess - excess1, prot, flags,\n\t\t\t       xmaddr);\n\n\t\t\tif (xmaddr != xaddr)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (prot & PROT_WRITE && excess1 > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess1);\n\t\t\tif (clear_user((void __user *) maddr + phdr->p_filesz,\n\t\t\t\t       excess1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n#else\n\t\tif (excess > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess);\n\t\t\tif (clear_user((void *) maddr + phdr->p_filesz, excess))\n\t\t\t\treturn -EFAULT;\n\t\t}\n#endif\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = maddr;\n\t\t\t\t\tmm->end_code = maddr + phdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = maddr;\n\t\t\t\tmm->end_data = maddr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);",
            "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
            "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);",
            "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *params,\n\t\t\t\t\t     struct file *file,\n\t\t\t\t\t     struct mm_struct *mm)\n{\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, delta_vaddr;\n\tint loop, dvset;\n\n\tload_addr = params->load_addr;\n\tdelta_vaddr = 0;\n\tdvset = 0;\n\n\tseg = params->loadmap->segs;\n\n\t/* deal with each load segment separately */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tunsigned long maddr, disp, excess, excess1;\n\t\tint prot = 0, flags;\n\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tkdebug(\"[LOAD] va=%lx of=%lx fs=%lx ms=%lx\",\n\t\t       (unsigned long) phdr->p_vaddr,\n\t\t       (unsigned long) phdr->p_offset,\n\t\t       (unsigned long) phdr->p_filesz,\n\t\t       (unsigned long) phdr->p_memsz);\n\n\t\t/* determine the mapping parameters */\n\t\tif (phdr->p_flags & PF_R) prot |= PROT_READ;\n\t\tif (phdr->p_flags & PF_W) prot |= PROT_WRITE;\n\t\tif (phdr->p_flags & PF_X) prot |= PROT_EXEC;\n\n\t\tflags = MAP_PRIVATE | MAP_DENYWRITE;\n\t\tif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\n\t\t\tflags |= MAP_EXECUTABLE;\n\n\t\tmaddr = 0;\n\n\t\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\t\tcase ELF_FDPIC_FLAG_INDEPENDENT:\n\t\t\t/* PT_LOADs are independently locatable */\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_HONOURVADDR:\n\t\t\t/* the specified virtual address must be honoured */\n\t\t\tmaddr = phdr->p_vaddr;\n\t\t\tflags |= MAP_FIXED;\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\t\t\t/* constant displacement\n\t\t\t * - can be mapped anywhere, but must be mapped as a\n\t\t\t *   unit\n\t\t\t */\n\t\t\tif (!dvset) {\n\t\t\t\tmaddr = load_addr;\n\t\t\t\tdelta_vaddr = phdr->p_vaddr;\n\t\t\t\tdvset = 1;\n\t\t\t} else {\n\t\t\t\tmaddr = load_addr + phdr->p_vaddr - delta_vaddr;\n\t\t\t\tflags |= MAP_FIXED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n\t\t\t/* contiguity handled later */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tmaddr &= PAGE_MASK;\n\n\t\t/* create the mapping */\n\t\tdisp = phdr->p_vaddr & ~PAGE_MASK;\n\t\tmaddr = vm_mmap(file, maddr, phdr->p_memsz + disp, prot, flags,\n\t\t\t\tphdr->p_offset - disp);\n\n\t\tkdebug(\"mmap[%d] <file> sz=%lx pr=%x fl=%x of=%lx --> %08lx\",\n\t\t       loop, phdr->p_memsz + disp, prot, flags,\n\t\t       phdr->p_offset - disp, maddr);\n\n\t\tif (IS_ERR_VALUE(maddr))\n\t\t\treturn (int) maddr;\n\n\t\tif ((params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) ==\n\t\t    ELF_FDPIC_FLAG_CONTIGUOUS)\n\t\t\tload_addr += PAGE_ALIGN(phdr->p_memsz + disp);\n\n\t\tseg->addr = maddr + disp;\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\t/* map the ELF header address if in this segment */\n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t/* clear the bit between beginning of mapping and beginning of\n\t\t * PT_LOAD */\n\t\tif (prot & PROT_WRITE && disp > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\", loop, maddr, disp);\n\t\t\tif (clear_user((void __user *) maddr, disp))\n\t\t\t\treturn -EFAULT;\n\t\t\tmaddr += disp;\n\t\t}\n\n\t\t/* clear any space allocated but not loaded\n\t\t * - on uClinux we can just clear the lot\n\t\t * - on MMU linux we'll get a SIGBUS beyond the last page\n\t\t *   extant in the file\n\t\t */\n\t\texcess = phdr->p_memsz - phdr->p_filesz;\n\t\texcess1 = PAGE_SIZE - ((maddr + phdr->p_filesz) & ~PAGE_MASK);\n\n#ifdef CONFIG_MMU\n\t\tif (excess > excess1) {\n\t\t\tunsigned long xaddr = maddr + phdr->p_filesz + excess1;\n\t\t\tunsigned long xmaddr;\n\n\t\t\tflags |= MAP_FIXED | MAP_ANONYMOUS;\n\t\t\txmaddr = vm_mmap(NULL, xaddr, excess - excess1,\n\t\t\t\t\t prot, flags, 0);\n\n\t\t\tkdebug(\"mmap[%d] <anon>\"\n\t\t\t       \" ad=%lx sz=%lx pr=%x fl=%x of=0 --> %08lx\",\n\t\t\t       loop, xaddr, excess - excess1, prot, flags,\n\t\t\t       xmaddr);\n\n\t\t\tif (xmaddr != xaddr)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (prot & PROT_WRITE && excess1 > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess1);\n\t\t\tif (clear_user((void __user *) maddr + phdr->p_filesz,\n\t\t\t\t       excess1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n#else\n\t\tif (excess > 0) {\n\t\t\tkdebug(\"clear[%d] ad=%lx sz=%lx\",\n\t\t\t       loop, maddr + phdr->p_filesz, excess);\n\t\t\tif (clear_user((void *) maddr + phdr->p_filesz, excess))\n\t\t\t\treturn -EFAULT;\n\t\t}\n#endif\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = maddr;\n\t\t\t\t\tmm->end_code = maddr + phdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = maddr;\n\t\t\t\tmm->end_data = maddr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_fdpic_map_file_constdisp_on_uclinux",
          "args": [
            "params",
            "file",
            "mm"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "elf_fdpic_map_file_constdisp_on_uclinux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "919-1001",
          "snippet": "static int elf_fdpic_map_file_constdisp_on_uclinux(\n\tstruct elf_fdpic_params *params,\n\tstruct file *file,\n\tstruct mm_struct *mm)\n{\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, base = ULONG_MAX, top = 0, maddr = 0, mflags;\n\tint loop, ret;\n\n\tload_addr = params->load_addr;\n\tseg = params->loadmap->segs;\n\n\t/* determine the bounds of the contiguous overall allocation we must\n\t * make */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (base > phdr->p_vaddr)\n\t\t\tbase = phdr->p_vaddr;\n\t\tif (top < phdr->p_vaddr + phdr->p_memsz)\n\t\t\ttop = phdr->p_vaddr + phdr->p_memsz;\n\t}\n\n\t/* allocate one big anon block for everything */\n\tmflags = MAP_PRIVATE;\n\tif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\n\t\tmflags |= MAP_EXECUTABLE;\n\n\tmaddr = vm_mmap(NULL, load_addr, top - base,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC, mflags, 0);\n\tif (IS_ERR_VALUE(maddr))\n\t\treturn (int) maddr;\n\n\tif (load_addr != 0)\n\t\tload_addr += PAGE_ALIGN(top - base);\n\n\t/* and then load the file segments into it */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tseg->addr = maddr + (phdr->p_vaddr - base);\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\tret = read_code(file, seg->addr, phdr->p_offset,\n\t\t\t\t       phdr->p_filesz);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t/* map the ELF header address if in this segment */\n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t/* clear any space allocated but not loaded */\n\t\tif (phdr->p_filesz < phdr->p_memsz) {\n\t\t\tif (clear_user((void *) (seg->addr + phdr->p_filesz),\n\t\t\t\t       phdr->p_memsz - phdr->p_filesz))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = seg->addr;\n\t\t\t\t\tmm->end_code = seg->addr +\n\t\t\t\t\t\tphdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = seg->addr;\n\t\t\t\tmm->end_data = seg->addr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);",
            "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
            "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);",
            "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int elf_fdpic_map_file_constdisp_on_uclinux(\n\tstruct elf_fdpic_params *params,\n\tstruct file *file,\n\tstruct mm_struct *mm)\n{\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, base = ULONG_MAX, top = 0, maddr = 0, mflags;\n\tint loop, ret;\n\n\tload_addr = params->load_addr;\n\tseg = params->loadmap->segs;\n\n\t/* determine the bounds of the contiguous overall allocation we must\n\t * make */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (base > phdr->p_vaddr)\n\t\t\tbase = phdr->p_vaddr;\n\t\tif (top < phdr->p_vaddr + phdr->p_memsz)\n\t\t\ttop = phdr->p_vaddr + phdr->p_memsz;\n\t}\n\n\t/* allocate one big anon block for everything */\n\tmflags = MAP_PRIVATE;\n\tif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\n\t\tmflags |= MAP_EXECUTABLE;\n\n\tmaddr = vm_mmap(NULL, load_addr, top - base,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC, mflags, 0);\n\tif (IS_ERR_VALUE(maddr))\n\t\treturn (int) maddr;\n\n\tif (load_addr != 0)\n\t\tload_addr += PAGE_ALIGN(top - base);\n\n\t/* and then load the file segments into it */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (params->phdrs[loop].p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tseg->addr = maddr + (phdr->p_vaddr - base);\n\t\tseg->p_vaddr = phdr->p_vaddr;\n\t\tseg->p_memsz = phdr->p_memsz;\n\n\t\tret = read_code(file, seg->addr, phdr->p_offset,\n\t\t\t\t       phdr->p_filesz);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t/* map the ELF header address if in this segment */\n\t\tif (phdr->p_offset == 0)\n\t\t\tparams->elfhdr_addr = seg->addr;\n\n\t\t/* clear any space allocated but not loaded */\n\t\tif (phdr->p_filesz < phdr->p_memsz) {\n\t\t\tif (clear_user((void *) (seg->addr + phdr->p_filesz),\n\t\t\t\t       phdr->p_memsz - phdr->p_filesz))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (mm) {\n\t\t\tif (phdr->p_flags & PF_X) {\n\t\t\t\tif (!mm->start_code) {\n\t\t\t\t\tmm->start_code = seg->addr;\n\t\t\t\t\tmm->end_code = seg->addr +\n\t\t\t\t\t\tphdr->p_memsz;\n\t\t\t\t}\n\t\t\t} else if (!mm->start_data) {\n\t\t\t\tmm->start_data = seg->addr;\n\t\t\t\tmm->end_data = seg->addr + phdr->p_memsz;\n\t\t\t}\n\t\t}\n\n\t\tseg++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *params,\n\t\t\t      struct file *file,\n\t\t\t      struct mm_struct *mm,\n\t\t\t      const char *what)\n{\n\tstruct elf32_fdpic_loadmap *loadmap;\n#ifdef CONFIG_MMU\n\tstruct elf32_fdpic_loadseg *mseg;\n#endif\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, stop;\n\tunsigned nloads, tmp;\n\tsize_t size;\n\tint loop, ret;\n\n\t/* allocate a load map table */\n\tnloads = 0;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++)\n\t\tif (params->phdrs[loop].p_type == PT_LOAD)\n\t\t\tnloads++;\n\n\tif (nloads == 0)\n\t\treturn -ELIBBAD;\n\n\tsize = sizeof(*loadmap) + nloads * sizeof(*seg);\n\tloadmap = kzalloc(size, GFP_KERNEL);\n\tif (!loadmap)\n\t\treturn -ENOMEM;\n\n\tparams->loadmap = loadmap;\n\n\tloadmap->version = ELF32_FDPIC_LOADMAP_VERSION;\n\tloadmap->nsegs = nloads;\n\n\tload_addr = params->load_addr;\n\tseg = loadmap->segs;\n\n\t/* map the requested LOADs into the memory space */\n\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n#ifndef CONFIG_MMU\n\t\tret = elf_fdpic_map_file_constdisp_on_uclinux(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = elf_fdpic_map_file_by_direct_mmap(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t/* map the entry point */\n\tif (params->hdr.e_entry) {\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (params->hdr.e_entry >= seg->p_vaddr &&\n\t\t\t    params->hdr.e_entry < seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->entry_addr =\n\t\t\t\t\t(params->hdr.e_entry - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* determine where the program header table has wound up if mapped */\n\tstop = params->hdr.e_phoff;\n\tstop += params->hdr.e_phnum * sizeof (struct elf_phdr);\n\tphdr = params->phdrs;\n\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_offset > params->hdr.e_phoff ||\n\t\t    phdr->p_offset + phdr->p_filesz < stop)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_filesz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->ph_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr +\n\t\t\t\t\tparams->hdr.e_phoff - phdr->p_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* determine where the dynamic section has wound up if there is one */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_DYNAMIC)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_memsz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tElf32_Dyn __user *dyn;\n\t\t\t\tElf32_Sword d_tag;\n\n\t\t\t\tparams->dynamic_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\n\t\t\t\t/* check the dynamic section contains at least\n\t\t\t\t * one item, and that the last item is a NULL\n\t\t\t\t * entry */\n\t\t\t\tif (phdr->p_memsz == 0 ||\n\t\t\t\t    phdr->p_memsz % sizeof(Elf32_Dyn) != 0)\n\t\t\t\t\tgoto dynamic_error;\n\n\t\t\t\ttmp = phdr->p_memsz / sizeof(Elf32_Dyn);\n\t\t\t\tdyn = (Elf32_Dyn __user *)params->dynamic_addr;\n\t\t\t\t__get_user(d_tag, &dyn[tmp - 1].d_tag);\n\t\t\t\tif (d_tag != 0)\n\t\t\t\t\tgoto dynamic_error;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* now elide adjacent segments in the load map on MMU linux\n\t * - on uClinux the holes between may actually be filled with system\n\t *   stuff or stuff from other processes\n\t */\n#ifdef CONFIG_MMU\n\tnloads = loadmap->nsegs;\n\tmseg = loadmap->segs;\n\tseg = mseg + 1;\n\tfor (loop = 1; loop < nloads; loop++) {\n\t\t/* see if we have a candidate for merging */\n\t\tif (seg->p_vaddr - mseg->p_vaddr == seg->addr - mseg->addr) {\n\t\t\tload_addr = PAGE_ALIGN(mseg->addr + mseg->p_memsz);\n\t\t\tif (load_addr == (seg->addr & PAGE_MASK)) {\n\t\t\t\tmseg->p_memsz +=\n\t\t\t\t\tload_addr -\n\t\t\t\t\t(mseg->addr + mseg->p_memsz);\n\t\t\t\tmseg->p_memsz += seg->addr & ~PAGE_MASK;\n\t\t\t\tmseg->p_memsz += seg->p_memsz;\n\t\t\t\tloadmap->nsegs--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmseg++;\n\t\tif (mseg != seg)\n\t\t\t*mseg = *seg;\n\t}\n#endif\n\n\tkdebug(\"Mapped Object [%s]:\", what);\n\tkdebug(\"- elfhdr   : %lx\", params->elfhdr_addr);\n\tkdebug(\"- entry    : %lx\", params->entry_addr);\n\tkdebug(\"- PHDR[]   : %lx\", params->ph_addr);\n\tkdebug(\"- DYNAMIC[]: %lx\", params->dynamic_addr);\n\tseg = loadmap->segs;\n\tfor (loop = 0; loop < loadmap->nsegs; loop++, seg++)\n\t\tkdebug(\"- LOAD[%d] : %08x-%08x [va=%x ms=%x]\",\n\t\t       loop,\n\t\t       seg->addr, seg->addr + seg->p_memsz - 1,\n\t\t       seg->p_vaddr, seg->p_memsz);\n\n\treturn 0;\n\ndynamic_error:\n\tprintk(\"ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\\n\",\n\t       what, file_inode(file)->i_ino);\n\treturn -ELIBBAD;\n}"
  },
  {
    "function_name": "create_elf_fdpic_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "501-719",
    "snippet": "static int create_elf_fdpic_tables(struct linux_binprm *bprm,\n\t\t\t\t   struct mm_struct *mm,\n\t\t\t\t   struct elf_fdpic_params *exec_params,\n\t\t\t\t   struct elf_fdpic_params *interp_params)\n{\n\tconst struct cred *cred = current_cred();\n\tunsigned long sp, csp, nitems;\n\telf_caddr_t __user *argv, *envp;\n\tsize_t platform_len = 0, len;\n\tchar *k_platform, *k_base_platform;\n\tchar __user *u_platform, *u_base_platform, *p;\n\tint loop;\n\tint nr;\t/* reset for each csp adjustment */\n\n#ifdef CONFIG_MMU\n\t/* In some cases (e.g. Hyper-Threading), we want to avoid L1 evictions\n\t * by the processes running on the same package. One thing we can do is\n\t * to shuffle the initial stack for them, so we give the architecture\n\t * an opportunity to do so here.\n\t */\n\tsp = arch_align_stack(bprm->p);\n#else\n\tsp = mm->start_stack;\n\n\t/* stack the program arguments and environment */\n\tif (transfer_args_to_stack(bprm, &sp) < 0)\n\t\treturn -EFAULT;\n\tsp &= ~15;\n#endif\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tk_platform = ELF_PLATFORM;\n\tu_platform = NULL;\n\n\tif (k_platform) {\n\t\tplatform_len = strlen(k_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_platform = (char __user *) sp;\n\t\tif (__copy_to_user(u_platform, k_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tk_base_platform = ELF_BASE_PLATFORM;\n\tu_base_platform = NULL;\n\n\tif (k_base_platform) {\n\t\tplatform_len = strlen(k_base_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_base_platform = (char __user *) sp;\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\tsp &= ~7UL;\n\n\t/* stack the load map(s) */\n\tlen = sizeof(struct elf32_fdpic_loadmap);\n\tlen += sizeof(struct elf32_fdpic_loadseg) * exec_params->loadmap->nsegs;\n\tsp = (sp - len) & ~7UL;\n\texec_params->map_addr = sp;\n\n\tif (copy_to_user((void __user *) sp, exec_params->loadmap, len) != 0)\n\t\treturn -EFAULT;\n\n\tcurrent->mm->context.exec_fdpic_loadmap = (unsigned long) sp;\n\n\tif (interp_params->loadmap) {\n\t\tlen = sizeof(struct elf32_fdpic_loadmap);\n\t\tlen += sizeof(struct elf32_fdpic_loadseg) *\n\t\t\tinterp_params->loadmap->nsegs;\n\t\tsp = (sp - len) & ~7UL;\n\t\tinterp_params->map_addr = sp;\n\n\t\tif (copy_to_user((void __user *) sp, interp_params->loadmap,\n\t\t\t\t len) != 0)\n\t\t\treturn -EFAULT;\n\n\t\tcurrent->mm->context.interp_fdpic_loadmap = (unsigned long) sp;\n\t}\n\n\t/* force 16 byte _final_ alignment here for generality */\n#define DLINFO_ITEMS 15\n\n\tnitems = 1 + DLINFO_ITEMS + (k_platform ? 1 : 0) +\n\t\t(k_base_platform ? 1 : 0) + AT_VECTOR_SIZE_ARCH;\n\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD)\n\t\tnitems++;\n\n\tcsp = sp;\n\tsp -= nitems * 2 * sizeof(unsigned long);\n\tsp -= (bprm->envc + 1) * sizeof(char *);\t/* envv[] */\n\tsp -= (bprm->argc + 1) * sizeof(char *);\t/* argv[] */\n\tsp -= 1 * sizeof(unsigned long);\t\t/* argc */\n\n\tcsp -= sp & 15UL;\n\tsp -= sp & 15UL;\n\n\t/* put the ELF interpreter info on the stack */\n#define NEW_AUX_ENT(id, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct { unsigned long _id, _val; } __user *ent;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tent = (void __user *) csp;\t\t\t\t\\\n\t\t__put_user((id), &ent[nr]._id);\t\t\t\t\\\n\t\t__put_user((val), &ent[nr]._val);\t\t\t\\\n\t\tnr++;\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tnr = 0;\n\tcsp -= 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_NULL, 0);\n\tif (k_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_platform);\n\t}\n\n\tif (k_base_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_base_platform);\n\t}\n\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n\n\tnr = 0;\n\tcsp -= DLINFO_ITEMS * 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_HWCAP,\tELF_HWCAP);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2,\tELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_PAGESZ,\tPAGE_SIZE);\n\tNEW_AUX_ENT(AT_CLKTCK,\tCLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR,\texec_params->ph_addr);\n\tNEW_AUX_ENT(AT_PHENT,\tsizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM,\texec_params->hdr.e_phnum);\n\tNEW_AUX_ENT(AT_BASE,\tinterp_params->elfhdr_addr);\n\tNEW_AUX_ENT(AT_FLAGS,\t0);\n\tNEW_AUX_ENT(AT_ENTRY,\texec_params->entry_addr);\n\tNEW_AUX_ENT(AT_UID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE,\tbprm->secureexec);\n\tNEW_AUX_ENT(AT_EXECFN,\tbprm->exec);\n\n#ifdef ARCH_DLINFO\n\tnr = 0;\n\tcsp -= AT_VECTOR_SIZE_ARCH * 2 * sizeof(unsigned long);\n\n\t/* ARCH_DLINFO must come last so platform specific code can enforce\n\t * special alignment requirements on the AUXV if necessary (eg. PPC).\n\t */\n\tARCH_DLINFO;\n#endif\n#undef NEW_AUX_ENT\n\n\t/* allocate room for argv[] and envv[] */\n\tcsp -= (bprm->envc + 1) * sizeof(elf_caddr_t);\n\tenvp = (elf_caddr_t __user *) csp;\n\tcsp -= (bprm->argc + 1) * sizeof(elf_caddr_t);\n\targv = (elf_caddr_t __user *) csp;\n\n\t/* stack argc */\n\tcsp -= sizeof(unsigned long);\n\t__put_user(bprm->argc, (unsigned long __user *) csp);\n\n\tBUG_ON(csp != sp);\n\n\t/* fill in the argv[] array */\n#ifdef CONFIG_MMU\n\tcurrent->mm->arg_start = bprm->p;\n#else\n\tcurrent->mm->arg_start = current->mm->start_stack -\n\t\t(MAX_ARG_PAGES * PAGE_SIZE - bprm->p);\n#endif\n\n\tp = (char __user *) current->mm->arg_start;\n\tfor (loop = bprm->argc; loop > 0; loop--) {\n\t\t__put_user((elf_caddr_t) p, argv++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(NULL, argv);\n\tcurrent->mm->arg_end = (unsigned long) p;\n\n\t/* fill in the envv[] array */\n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (loop = bprm->envc; loop > 0; loop--) {\n\t\t__put_user((elf_caddr_t)(unsigned long) p, envp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(NULL, envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\n\tmm->start_stack = (unsigned long) sp;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLINFO_ITEMS 15",
      "#define ELF_BASE_PLATFORM NULL"
    ],
    "globals_used": [
      "static int load_elf_fdpic_binary(struct linux_binprm *);",
      "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
      "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);",
      "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "NULL",
            "envp"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "p",
            "MAX_ARG_STRLEN"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(elf_caddr_t)(unsigned long) p",
            "envp++"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "NULL",
            "argv"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "p",
            "MAX_ARG_STRLEN"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(elf_caddr_t) p",
            "argv++"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "csp != sp"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "bprm->argc",
            "(unsigned long __user *) csp"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EXECFN",
            "bprm->exec"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_SECURE",
            "bprm->secureexec"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EGID",
            "(elf_addr_t) from_kgid_munged(cred->user_ns, cred->egid)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "cred->user_ns",
            "cred->egid"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_GID",
            "(elf_addr_t) from_kgid_munged(cred->user_ns, cred->gid)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "cred->user_ns",
            "cred->gid"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EUID",
            "(elf_addr_t) from_kuid_munged(cred->user_ns, cred->euid)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "cred->user_ns",
            "cred->euid"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_UID",
            "(elf_addr_t) from_kuid_munged(cred->user_ns, cred->uid)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "cred->user_ns",
            "cred->uid"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_ENTRY",
            "exec_params->entry_addr"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_FLAGS",
            "0"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_BASE",
            "interp_params->elfhdr_addr"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PHNUM",
            "exec_params->hdr.e_phnum"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PHENT",
            "sizeof(struct elf_phdr)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PHDR",
            "exec_params->ph_addr"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_CLKTCK",
            "CLOCKS_PER_SEC"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PAGESZ",
            "PAGE_SIZE"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_HWCAP2",
            "ELF_HWCAP2"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_HWCAP",
            "ELF_HWCAP"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EXECFD",
            "bprm->interp_data"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_BASE_PLATFORM",
            "(elf_addr_t) (unsigned long) u_base_platform"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PLATFORM",
            "(elf_addr_t) (unsigned long) u_platform"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_NULL",
            "0"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void __user *) sp",
            "interp_params->loadmap",
            "len"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void __user *) sp",
            "exec_params->loadmap",
            "len"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "u_base_platform",
            "k_base_platform",
            "platform_len"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "k_base_platform"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "u_platform",
            "k_platform",
            "platform_len"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transfer_args_to_stack",
          "args": [
            "bprm",
            "&sp"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "transfer_args_to_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "807-831",
          "snippet": "int transfer_args_to_stack(struct linux_binprm *bprm,\n\t\t\t   unsigned long *sp_location)\n{\n\tunsigned long index, stop, sp;\n\tint ret = 0;\n\n\tstop = bprm->p >> PAGE_SHIFT;\n\tsp = *sp_location;\n\n\tfor (index = MAX_ARG_PAGES - 1; index >= stop; index--) {\n\t\tunsigned int offset = index == stop ? bprm->p & ~PAGE_MASK : 0;\n\t\tchar *src = kmap(bprm->page[index]) + offset;\n\t\tsp -= PAGE_SIZE - offset;\n\t\tif (copy_to_user((void *) sp, src, PAGE_SIZE - offset) != 0)\n\t\t\tret = -EFAULT;\n\t\tkunmap(bprm->page[index]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t*sp_location = sp;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint transfer_args_to_stack(struct linux_binprm *bprm,\n\t\t\t   unsigned long *sp_location)\n{\n\tunsigned long index, stop, sp;\n\tint ret = 0;\n\n\tstop = bprm->p >> PAGE_SHIFT;\n\tsp = *sp_location;\n\n\tfor (index = MAX_ARG_PAGES - 1; index >= stop; index--) {\n\t\tunsigned int offset = index == stop ? bprm->p & ~PAGE_MASK : 0;\n\t\tchar *src = kmap(bprm->page[index]) + offset;\n\t\tsp -= PAGE_SIZE - offset;\n\t\tif (copy_to_user((void *) sp, src, PAGE_SIZE - offset) != 0)\n\t\t\tret = -EFAULT;\n\t\tkunmap(bprm->page[index]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t*sp_location = sp;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_align_stack",
          "args": [
            "bprm->p"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLINFO_ITEMS 15\n#define ELF_BASE_PLATFORM NULL\n\nstatic int load_elf_fdpic_binary(struct linux_binprm *);\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int create_elf_fdpic_tables(struct linux_binprm *bprm,\n\t\t\t\t   struct mm_struct *mm,\n\t\t\t\t   struct elf_fdpic_params *exec_params,\n\t\t\t\t   struct elf_fdpic_params *interp_params)\n{\n\tconst struct cred *cred = current_cred();\n\tunsigned long sp, csp, nitems;\n\telf_caddr_t __user *argv, *envp;\n\tsize_t platform_len = 0, len;\n\tchar *k_platform, *k_base_platform;\n\tchar __user *u_platform, *u_base_platform, *p;\n\tint loop;\n\tint nr;\t/* reset for each csp adjustment */\n\n#ifdef CONFIG_MMU\n\t/* In some cases (e.g. Hyper-Threading), we want to avoid L1 evictions\n\t * by the processes running on the same package. One thing we can do is\n\t * to shuffle the initial stack for them, so we give the architecture\n\t * an opportunity to do so here.\n\t */\n\tsp = arch_align_stack(bprm->p);\n#else\n\tsp = mm->start_stack;\n\n\t/* stack the program arguments and environment */\n\tif (transfer_args_to_stack(bprm, &sp) < 0)\n\t\treturn -EFAULT;\n\tsp &= ~15;\n#endif\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tk_platform = ELF_PLATFORM;\n\tu_platform = NULL;\n\n\tif (k_platform) {\n\t\tplatform_len = strlen(k_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_platform = (char __user *) sp;\n\t\tif (__copy_to_user(u_platform, k_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tk_base_platform = ELF_BASE_PLATFORM;\n\tu_base_platform = NULL;\n\n\tif (k_base_platform) {\n\t\tplatform_len = strlen(k_base_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_base_platform = (char __user *) sp;\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\tsp &= ~7UL;\n\n\t/* stack the load map(s) */\n\tlen = sizeof(struct elf32_fdpic_loadmap);\n\tlen += sizeof(struct elf32_fdpic_loadseg) * exec_params->loadmap->nsegs;\n\tsp = (sp - len) & ~7UL;\n\texec_params->map_addr = sp;\n\n\tif (copy_to_user((void __user *) sp, exec_params->loadmap, len) != 0)\n\t\treturn -EFAULT;\n\n\tcurrent->mm->context.exec_fdpic_loadmap = (unsigned long) sp;\n\n\tif (interp_params->loadmap) {\n\t\tlen = sizeof(struct elf32_fdpic_loadmap);\n\t\tlen += sizeof(struct elf32_fdpic_loadseg) *\n\t\t\tinterp_params->loadmap->nsegs;\n\t\tsp = (sp - len) & ~7UL;\n\t\tinterp_params->map_addr = sp;\n\n\t\tif (copy_to_user((void __user *) sp, interp_params->loadmap,\n\t\t\t\t len) != 0)\n\t\t\treturn -EFAULT;\n\n\t\tcurrent->mm->context.interp_fdpic_loadmap = (unsigned long) sp;\n\t}\n\n\t/* force 16 byte _final_ alignment here for generality */\n#define DLINFO_ITEMS 15\n\n\tnitems = 1 + DLINFO_ITEMS + (k_platform ? 1 : 0) +\n\t\t(k_base_platform ? 1 : 0) + AT_VECTOR_SIZE_ARCH;\n\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD)\n\t\tnitems++;\n\n\tcsp = sp;\n\tsp -= nitems * 2 * sizeof(unsigned long);\n\tsp -= (bprm->envc + 1) * sizeof(char *);\t/* envv[] */\n\tsp -= (bprm->argc + 1) * sizeof(char *);\t/* argv[] */\n\tsp -= 1 * sizeof(unsigned long);\t\t/* argc */\n\n\tcsp -= sp & 15UL;\n\tsp -= sp & 15UL;\n\n\t/* put the ELF interpreter info on the stack */\n#define NEW_AUX_ENT(id, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct { unsigned long _id, _val; } __user *ent;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tent = (void __user *) csp;\t\t\t\t\\\n\t\t__put_user((id), &ent[nr]._id);\t\t\t\t\\\n\t\t__put_user((val), &ent[nr]._val);\t\t\t\\\n\t\tnr++;\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tnr = 0;\n\tcsp -= 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_NULL, 0);\n\tif (k_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_platform);\n\t}\n\n\tif (k_base_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_base_platform);\n\t}\n\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n\n\tnr = 0;\n\tcsp -= DLINFO_ITEMS * 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_HWCAP,\tELF_HWCAP);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2,\tELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_PAGESZ,\tPAGE_SIZE);\n\tNEW_AUX_ENT(AT_CLKTCK,\tCLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR,\texec_params->ph_addr);\n\tNEW_AUX_ENT(AT_PHENT,\tsizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM,\texec_params->hdr.e_phnum);\n\tNEW_AUX_ENT(AT_BASE,\tinterp_params->elfhdr_addr);\n\tNEW_AUX_ENT(AT_FLAGS,\t0);\n\tNEW_AUX_ENT(AT_ENTRY,\texec_params->entry_addr);\n\tNEW_AUX_ENT(AT_UID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE,\tbprm->secureexec);\n\tNEW_AUX_ENT(AT_EXECFN,\tbprm->exec);\n\n#ifdef ARCH_DLINFO\n\tnr = 0;\n\tcsp -= AT_VECTOR_SIZE_ARCH * 2 * sizeof(unsigned long);\n\n\t/* ARCH_DLINFO must come last so platform specific code can enforce\n\t * special alignment requirements on the AUXV if necessary (eg. PPC).\n\t */\n\tARCH_DLINFO;\n#endif\n#undef NEW_AUX_ENT\n\n\t/* allocate room for argv[] and envv[] */\n\tcsp -= (bprm->envc + 1) * sizeof(elf_caddr_t);\n\tenvp = (elf_caddr_t __user *) csp;\n\tcsp -= (bprm->argc + 1) * sizeof(elf_caddr_t);\n\targv = (elf_caddr_t __user *) csp;\n\n\t/* stack argc */\n\tcsp -= sizeof(unsigned long);\n\t__put_user(bprm->argc, (unsigned long __user *) csp);\n\n\tBUG_ON(csp != sp);\n\n\t/* fill in the argv[] array */\n#ifdef CONFIG_MMU\n\tcurrent->mm->arg_start = bprm->p;\n#else\n\tcurrent->mm->arg_start = current->mm->start_stack -\n\t\t(MAX_ARG_PAGES * PAGE_SIZE - bprm->p);\n#endif\n\n\tp = (char __user *) current->mm->arg_start;\n\tfor (loop = bprm->argc; loop > 0; loop--) {\n\t\t__put_user((elf_caddr_t) p, argv++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(NULL, argv);\n\tcurrent->mm->arg_end = (unsigned long) p;\n\n\t/* fill in the envv[] array */\n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (loop = bprm->envc; loop > 0; loop--) {\n\t\t__put_user((elf_caddr_t)(unsigned long) p, envp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(NULL, envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\n\tmm->start_stack = (unsigned long) sp;\n\treturn 0;\n}"
  },
  {
    "function_name": "load_elf_fdpic_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "186-484",
    "snippet": "static int load_elf_fdpic_binary(struct linux_binprm *bprm)\n{\n\tstruct elf_fdpic_params exec_params, interp_params;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct elf_phdr *phdr;\n\tunsigned long stack_size, entryaddr;\n#ifdef ELF_FDPIC_PLAT_INIT\n\tunsigned long dynaddr;\n#endif\n#ifndef CONFIG_MMU\n\tunsigned long stack_prot;\n#endif\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n\tchar *interpreter_name = NULL;\n\tint executable_stack;\n\tint retval, i;\n\tloff_t pos;\n\n\tkdebug(\"____ LOAD %d ____\", current->pid);\n\n\tmemset(&exec_params, 0, sizeof(exec_params));\n\tmemset(&interp_params, 0, sizeof(interp_params));\n\n\texec_params.hdr = *(struct elfhdr *) bprm->buf;\n\texec_params.flags = ELF_FDPIC_FLAG_PRESENT | ELF_FDPIC_FLAG_EXECUTABLE;\n\n\t/* check that this is a binary we know how to deal with */\n\tretval = -ENOEXEC;\n\tif (!is_elf(&exec_params.hdr, bprm->file))\n\t\tgoto error;\n\tif (!elf_check_fdpic(&exec_params.hdr)) {\n#ifdef CONFIG_MMU\n\t\t/* binfmt_elf handles non-fdpic elf except on nommu */\n\t\tgoto error;\n#else\n\t\t/* nommu can only load ET_DYN (PIE) ELF */\n\t\tif (exec_params.hdr.e_type != ET_DYN)\n\t\t\tgoto error;\n#endif\n\t}\n\n\t/* read the program header table */\n\tretval = elf_fdpic_fetch_phdrs(&exec_params, bprm->file);\n\tif (retval < 0)\n\t\tgoto error;\n\n\t/* scan for a program header that specifies an interpreter */\n\tphdr = exec_params.phdrs;\n\n\tfor (i = 0; i < exec_params.hdr.e_phnum; i++, phdr++) {\n\t\tswitch (phdr->p_type) {\n\t\tcase PT_INTERP:\n\t\t\tretval = -ENOMEM;\n\t\t\tif (phdr->p_filesz > PATH_MAX)\n\t\t\t\tgoto error;\n\t\t\tretval = -ENOENT;\n\t\t\tif (phdr->p_filesz < 2)\n\t\t\t\tgoto error;\n\n\t\t\t/* read the name of the interpreter into memory */\n\t\t\tinterpreter_name = kmalloc(phdr->p_filesz, GFP_KERNEL);\n\t\t\tif (!interpreter_name)\n\t\t\t\tgoto error;\n\n\t\t\tpos = phdr->p_offset;\n\t\t\tretval = kernel_read(bprm->file, interpreter_name,\n\t\t\t\t\t     phdr->p_filesz, &pos);\n\t\t\tif (unlikely(retval != phdr->p_filesz)) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -ENOEXEC;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tretval = -ENOENT;\n\t\t\tif (interpreter_name[phdr->p_filesz - 1] != '\\0')\n\t\t\t\tgoto error;\n\n\t\t\tkdebug(\"Using ELF interpreter %s\", interpreter_name);\n\n\t\t\t/* replace the program with the interpreter */\n\t\t\tinterpreter = open_exec(interpreter_name);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter)) {\n\t\t\t\tinterpreter = NULL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tpos = 0;\n\t\t\tretval = kernel_read(interpreter, bprm->buf,\n\t\t\t\t\tBINPRM_BUF_SIZE, &pos);\n\t\t\tif (unlikely(retval != BINPRM_BUF_SIZE)) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -ENOEXEC;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tinterp_params.hdr = *((struct elfhdr *) bprm->buf);\n\t\t\tbreak;\n\n\t\tcase PT_LOAD:\n#ifdef CONFIG_MMU\n\t\t\tif (exec_params.load_addr == 0)\n\t\t\t\texec_params.load_addr = phdr->p_vaddr;\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (is_constdisp(&exec_params.hdr))\n\t\texec_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;\n\n\t/* perform insanity checks on the interpreter */\n\tif (interpreter_name) {\n\t\tretval = -ELIBBAD;\n\t\tif (!is_elf(&interp_params.hdr, interpreter))\n\t\t\tgoto error;\n\n\t\tinterp_params.flags = ELF_FDPIC_FLAG_PRESENT;\n\n\t\t/* read the interpreter's program header table */\n\t\tretval = elf_fdpic_fetch_phdrs(&interp_params, interpreter);\n\t\tif (retval < 0)\n\t\t\tgoto error;\n\t}\n\n\tstack_size = exec_params.stack_size;\n\tif (exec_params.flags & ELF_FDPIC_FLAG_EXEC_STACK)\n\t\texecutable_stack = EXSTACK_ENABLE_X;\n\telse if (exec_params.flags & ELF_FDPIC_FLAG_NOEXEC_STACK)\n\t\texecutable_stack = EXSTACK_DISABLE_X;\n\telse\n\t\texecutable_stack = EXSTACK_DEFAULT;\n\n\tif (stack_size == 0) {\n\t\tstack_size = interp_params.stack_size;\n\t\tif (interp_params.flags & ELF_FDPIC_FLAG_EXEC_STACK)\n\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\telse if (interp_params.flags & ELF_FDPIC_FLAG_NOEXEC_STACK)\n\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\telse\n\t\t\texecutable_stack = EXSTACK_DEFAULT;\n\t}\n\n\tretval = -ENOEXEC;\n\tif (stack_size == 0)\n\t\tstack_size = 131072UL; /* same as exec.c's default commit */\n\n\tif (is_constdisp(&interp_params.hdr))\n\t\tinterp_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;\n\n\t/* flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto error;\n\n\t/* there's now no turning back... the old userspace image is dead,\n\t * defunct, deceased, etc.\n\t */\n\tif (elf_check_fdpic(&exec_params.hdr))\n\t\tset_personality(PER_LINUX_FDPIC);\n\telse\n\t\tset_personality(PER_LINUX);\n\tif (elf_read_implies_exec(&exec_params.hdr, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tsetup_new_exec(bprm);\n\n\tset_binfmt(&elf_fdpic_format);\n\n\tcurrent->mm->start_code = 0;\n\tcurrent->mm->end_code = 0;\n\tcurrent->mm->start_stack = 0;\n\tcurrent->mm->start_data = 0;\n\tcurrent->mm->end_data = 0;\n\tcurrent->mm->context.exec_fdpic_loadmap = 0;\n\tcurrent->mm->context.interp_fdpic_loadmap = 0;\n\n#ifdef CONFIG_MMU\n\telf_fdpic_arch_lay_out_mm(&exec_params,\n\t\t\t\t  &interp_params,\n\t\t\t\t  &current->mm->start_stack,\n\t\t\t\t  &current->mm->start_brk);\n\n\tretval = setup_arg_pages(bprm, current->mm->start_stack,\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto error;\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!interpreter_name);\n\tif (retval < 0)\n\t\tgoto error;\n#endif\n#endif\n\n\t/* load the executable and interpreter into memory */\n\tretval = elf_fdpic_map_file(&exec_params, bprm->file, current->mm,\n\t\t\t\t    \"executable\");\n\tif (retval < 0)\n\t\tgoto error;\n\n\tif (interpreter_name) {\n\t\tretval = elf_fdpic_map_file(&interp_params, interpreter,\n\t\t\t\t\t    current->mm, \"interpreter\");\n\t\tif (retval < 0) {\n\t\t\tprintk(KERN_ERR \"Unable to load interpreter\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tinterpreter = NULL;\n\t}\n\n#ifdef CONFIG_MMU\n\tif (!current->mm->start_brk)\n\t\tcurrent->mm->start_brk = current->mm->end_data;\n\n\tcurrent->mm->brk = current->mm->start_brk =\n\t\tPAGE_ALIGN(current->mm->start_brk);\n\n#else\n\t/* create a stack area and zero-size brk area */\n\tstack_size = (stack_size + PAGE_SIZE - 1) & PAGE_MASK;\n\tif (stack_size < PAGE_SIZE * 2)\n\t\tstack_size = PAGE_SIZE * 2;\n\n\tstack_prot = PROT_READ | PROT_WRITE;\n\tif (executable_stack == EXSTACK_ENABLE_X ||\n\t    (executable_stack == EXSTACK_DEFAULT && VM_STACK_FLAGS & VM_EXEC))\n\t\tstack_prot |= PROT_EXEC;\n\n\tcurrent->mm->start_brk = vm_mmap(NULL, 0, stack_size, stack_prot,\n\t\t\t\t\t MAP_PRIVATE | MAP_ANONYMOUS |\n\t\t\t\t\t MAP_UNINITIALIZED | MAP_GROWSDOWN,\n\t\t\t\t\t 0);\n\n\tif (IS_ERR_VALUE(current->mm->start_brk)) {\n\t\tretval = current->mm->start_brk;\n\t\tcurrent->mm->start_brk = 0;\n\t\tgoto error;\n\t}\n\n\tcurrent->mm->brk = current->mm->start_brk;\n\tcurrent->mm->context.end_brk = current->mm->start_brk;\n\tcurrent->mm->start_stack = current->mm->start_brk + stack_size;\n#endif\n\n\tinstall_exec_creds(bprm);\n\tif (create_elf_fdpic_tables(bprm, current->mm,\n\t\t\t\t    &exec_params, &interp_params) < 0)\n\t\tgoto error;\n\n\tkdebug(\"- start_code  %lx\", current->mm->start_code);\n\tkdebug(\"- end_code    %lx\", current->mm->end_code);\n\tkdebug(\"- start_data  %lx\", current->mm->start_data);\n\tkdebug(\"- end_data    %lx\", current->mm->end_data);\n\tkdebug(\"- start_brk   %lx\", current->mm->start_brk);\n\tkdebug(\"- brk         %lx\", current->mm->brk);\n\tkdebug(\"- start_stack %lx\", current->mm->start_stack);\n\n#ifdef ELF_FDPIC_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  This macro performs whatever initialization to\n\t * the regs structure is required.\n\t */\n\tdynaddr = interp_params.dynamic_addr ?: exec_params.dynamic_addr;\n\tELF_FDPIC_PLAT_INIT(regs, exec_params.map_addr, interp_params.map_addr,\n\t\t\t    dynaddr);\n#endif\n\n\tfinalize_exec(bprm);\n\t/* everything is now ready... get the userspace context ready to roll */\n\tentryaddr = interp_params.entry_addr ?: exec_params.entry_addr;\n\tstart_thread(regs, entryaddr, current->mm->start_stack);\n\n\tretval = 0;\n\nerror:\n\tif (interpreter) {\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t}\n\tkfree(interpreter_name);\n\tkfree(exec_params.phdrs);\n\tkfree(exec_params.loadmap);\n\tkfree(interp_params.phdrs);\n\tkfree(interp_params.loadmap);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int load_elf_fdpic_binary(struct linux_binprm *);",
      "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);",
      "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);",
      "static struct linux_binfmt elf_fdpic_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_fdpic_binary,\n#ifdef CONFIG_ELF_CORE\n\t.core_dump\t= elf_fdpic_core_dump,\n#endif\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "interp_params.loadmap"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "interpreter"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "interpreter"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_thread",
          "args": [
            "regs",
            "entryaddr",
            "current->mm->start_stack"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finalize_exec",
          "args": [
            "bprm"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "finalize_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1388-1394",
          "snippet": "void finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ELF_FDPIC_PLAT_INIT",
          "args": [
            "regs",
            "exec_params.map_addr",
            "interp_params.map_addr",
            "dynaddr"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- start_stack %lx\"",
            "current->mm->start_stack"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- brk         %lx\"",
            "current->mm->brk"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- start_brk   %lx\"",
            "current->mm->start_brk"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- end_data    %lx\"",
            "current->mm->end_data"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- start_data  %lx\"",
            "current->mm->start_data"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- end_code    %lx\"",
            "current->mm->end_code"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- start_code  %lx\"",
            "current->mm->start_code"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_elf_fdpic_tables",
          "args": [
            "bprm",
            "current->mm",
            "&exec_params",
            "&interp_params"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "create_elf_fdpic_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "501-719",
          "snippet": "static int create_elf_fdpic_tables(struct linux_binprm *bprm,\n\t\t\t\t   struct mm_struct *mm,\n\t\t\t\t   struct elf_fdpic_params *exec_params,\n\t\t\t\t   struct elf_fdpic_params *interp_params)\n{\n\tconst struct cred *cred = current_cred();\n\tunsigned long sp, csp, nitems;\n\telf_caddr_t __user *argv, *envp;\n\tsize_t platform_len = 0, len;\n\tchar *k_platform, *k_base_platform;\n\tchar __user *u_platform, *u_base_platform, *p;\n\tint loop;\n\tint nr;\t/* reset for each csp adjustment */\n\n#ifdef CONFIG_MMU\n\t/* In some cases (e.g. Hyper-Threading), we want to avoid L1 evictions\n\t * by the processes running on the same package. One thing we can do is\n\t * to shuffle the initial stack for them, so we give the architecture\n\t * an opportunity to do so here.\n\t */\n\tsp = arch_align_stack(bprm->p);\n#else\n\tsp = mm->start_stack;\n\n\t/* stack the program arguments and environment */\n\tif (transfer_args_to_stack(bprm, &sp) < 0)\n\t\treturn -EFAULT;\n\tsp &= ~15;\n#endif\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tk_platform = ELF_PLATFORM;\n\tu_platform = NULL;\n\n\tif (k_platform) {\n\t\tplatform_len = strlen(k_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_platform = (char __user *) sp;\n\t\tif (__copy_to_user(u_platform, k_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tk_base_platform = ELF_BASE_PLATFORM;\n\tu_base_platform = NULL;\n\n\tif (k_base_platform) {\n\t\tplatform_len = strlen(k_base_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_base_platform = (char __user *) sp;\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\tsp &= ~7UL;\n\n\t/* stack the load map(s) */\n\tlen = sizeof(struct elf32_fdpic_loadmap);\n\tlen += sizeof(struct elf32_fdpic_loadseg) * exec_params->loadmap->nsegs;\n\tsp = (sp - len) & ~7UL;\n\texec_params->map_addr = sp;\n\n\tif (copy_to_user((void __user *) sp, exec_params->loadmap, len) != 0)\n\t\treturn -EFAULT;\n\n\tcurrent->mm->context.exec_fdpic_loadmap = (unsigned long) sp;\n\n\tif (interp_params->loadmap) {\n\t\tlen = sizeof(struct elf32_fdpic_loadmap);\n\t\tlen += sizeof(struct elf32_fdpic_loadseg) *\n\t\t\tinterp_params->loadmap->nsegs;\n\t\tsp = (sp - len) & ~7UL;\n\t\tinterp_params->map_addr = sp;\n\n\t\tif (copy_to_user((void __user *) sp, interp_params->loadmap,\n\t\t\t\t len) != 0)\n\t\t\treturn -EFAULT;\n\n\t\tcurrent->mm->context.interp_fdpic_loadmap = (unsigned long) sp;\n\t}\n\n\t/* force 16 byte _final_ alignment here for generality */\n#define DLINFO_ITEMS 15\n\n\tnitems = 1 + DLINFO_ITEMS + (k_platform ? 1 : 0) +\n\t\t(k_base_platform ? 1 : 0) + AT_VECTOR_SIZE_ARCH;\n\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD)\n\t\tnitems++;\n\n\tcsp = sp;\n\tsp -= nitems * 2 * sizeof(unsigned long);\n\tsp -= (bprm->envc + 1) * sizeof(char *);\t/* envv[] */\n\tsp -= (bprm->argc + 1) * sizeof(char *);\t/* argv[] */\n\tsp -= 1 * sizeof(unsigned long);\t\t/* argc */\n\n\tcsp -= sp & 15UL;\n\tsp -= sp & 15UL;\n\n\t/* put the ELF interpreter info on the stack */\n#define NEW_AUX_ENT(id, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct { unsigned long _id, _val; } __user *ent;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tent = (void __user *) csp;\t\t\t\t\\\n\t\t__put_user((id), &ent[nr]._id);\t\t\t\t\\\n\t\t__put_user((val), &ent[nr]._val);\t\t\t\\\n\t\tnr++;\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tnr = 0;\n\tcsp -= 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_NULL, 0);\n\tif (k_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_platform);\n\t}\n\n\tif (k_base_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_base_platform);\n\t}\n\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n\n\tnr = 0;\n\tcsp -= DLINFO_ITEMS * 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_HWCAP,\tELF_HWCAP);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2,\tELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_PAGESZ,\tPAGE_SIZE);\n\tNEW_AUX_ENT(AT_CLKTCK,\tCLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR,\texec_params->ph_addr);\n\tNEW_AUX_ENT(AT_PHENT,\tsizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM,\texec_params->hdr.e_phnum);\n\tNEW_AUX_ENT(AT_BASE,\tinterp_params->elfhdr_addr);\n\tNEW_AUX_ENT(AT_FLAGS,\t0);\n\tNEW_AUX_ENT(AT_ENTRY,\texec_params->entry_addr);\n\tNEW_AUX_ENT(AT_UID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE,\tbprm->secureexec);\n\tNEW_AUX_ENT(AT_EXECFN,\tbprm->exec);\n\n#ifdef ARCH_DLINFO\n\tnr = 0;\n\tcsp -= AT_VECTOR_SIZE_ARCH * 2 * sizeof(unsigned long);\n\n\t/* ARCH_DLINFO must come last so platform specific code can enforce\n\t * special alignment requirements on the AUXV if necessary (eg. PPC).\n\t */\n\tARCH_DLINFO;\n#endif\n#undef NEW_AUX_ENT\n\n\t/* allocate room for argv[] and envv[] */\n\tcsp -= (bprm->envc + 1) * sizeof(elf_caddr_t);\n\tenvp = (elf_caddr_t __user *) csp;\n\tcsp -= (bprm->argc + 1) * sizeof(elf_caddr_t);\n\targv = (elf_caddr_t __user *) csp;\n\n\t/* stack argc */\n\tcsp -= sizeof(unsigned long);\n\t__put_user(bprm->argc, (unsigned long __user *) csp);\n\n\tBUG_ON(csp != sp);\n\n\t/* fill in the argv[] array */\n#ifdef CONFIG_MMU\n\tcurrent->mm->arg_start = bprm->p;\n#else\n\tcurrent->mm->arg_start = current->mm->start_stack -\n\t\t(MAX_ARG_PAGES * PAGE_SIZE - bprm->p);\n#endif\n\n\tp = (char __user *) current->mm->arg_start;\n\tfor (loop = bprm->argc; loop > 0; loop--) {\n\t\t__put_user((elf_caddr_t) p, argv++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(NULL, argv);\n\tcurrent->mm->arg_end = (unsigned long) p;\n\n\t/* fill in the envv[] array */\n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (loop = bprm->envc; loop > 0; loop--) {\n\t\t__put_user((elf_caddr_t)(unsigned long) p, envp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(NULL, envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\n\tmm->start_stack = (unsigned long) sp;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLINFO_ITEMS 15",
            "#define ELF_BASE_PLATFORM NULL"
          ],
          "globals_used": [
            "static int load_elf_fdpic_binary(struct linux_binprm *);",
            "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
            "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);",
            "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLINFO_ITEMS 15\n#define ELF_BASE_PLATFORM NULL\n\nstatic int load_elf_fdpic_binary(struct linux_binprm *);\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int create_elf_fdpic_tables(struct linux_binprm *bprm,\n\t\t\t\t   struct mm_struct *mm,\n\t\t\t\t   struct elf_fdpic_params *exec_params,\n\t\t\t\t   struct elf_fdpic_params *interp_params)\n{\n\tconst struct cred *cred = current_cred();\n\tunsigned long sp, csp, nitems;\n\telf_caddr_t __user *argv, *envp;\n\tsize_t platform_len = 0, len;\n\tchar *k_platform, *k_base_platform;\n\tchar __user *u_platform, *u_base_platform, *p;\n\tint loop;\n\tint nr;\t/* reset for each csp adjustment */\n\n#ifdef CONFIG_MMU\n\t/* In some cases (e.g. Hyper-Threading), we want to avoid L1 evictions\n\t * by the processes running on the same package. One thing we can do is\n\t * to shuffle the initial stack for them, so we give the architecture\n\t * an opportunity to do so here.\n\t */\n\tsp = arch_align_stack(bprm->p);\n#else\n\tsp = mm->start_stack;\n\n\t/* stack the program arguments and environment */\n\tif (transfer_args_to_stack(bprm, &sp) < 0)\n\t\treturn -EFAULT;\n\tsp &= ~15;\n#endif\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tk_platform = ELF_PLATFORM;\n\tu_platform = NULL;\n\n\tif (k_platform) {\n\t\tplatform_len = strlen(k_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_platform = (char __user *) sp;\n\t\tif (__copy_to_user(u_platform, k_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tk_base_platform = ELF_BASE_PLATFORM;\n\tu_base_platform = NULL;\n\n\tif (k_base_platform) {\n\t\tplatform_len = strlen(k_base_platform) + 1;\n\t\tsp -= platform_len;\n\t\tu_base_platform = (char __user *) sp;\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, platform_len) != 0)\n\t\t\treturn -EFAULT;\n\t}\n\n\tsp &= ~7UL;\n\n\t/* stack the load map(s) */\n\tlen = sizeof(struct elf32_fdpic_loadmap);\n\tlen += sizeof(struct elf32_fdpic_loadseg) * exec_params->loadmap->nsegs;\n\tsp = (sp - len) & ~7UL;\n\texec_params->map_addr = sp;\n\n\tif (copy_to_user((void __user *) sp, exec_params->loadmap, len) != 0)\n\t\treturn -EFAULT;\n\n\tcurrent->mm->context.exec_fdpic_loadmap = (unsigned long) sp;\n\n\tif (interp_params->loadmap) {\n\t\tlen = sizeof(struct elf32_fdpic_loadmap);\n\t\tlen += sizeof(struct elf32_fdpic_loadseg) *\n\t\t\tinterp_params->loadmap->nsegs;\n\t\tsp = (sp - len) & ~7UL;\n\t\tinterp_params->map_addr = sp;\n\n\t\tif (copy_to_user((void __user *) sp, interp_params->loadmap,\n\t\t\t\t len) != 0)\n\t\t\treturn -EFAULT;\n\n\t\tcurrent->mm->context.interp_fdpic_loadmap = (unsigned long) sp;\n\t}\n\n\t/* force 16 byte _final_ alignment here for generality */\n#define DLINFO_ITEMS 15\n\n\tnitems = 1 + DLINFO_ITEMS + (k_platform ? 1 : 0) +\n\t\t(k_base_platform ? 1 : 0) + AT_VECTOR_SIZE_ARCH;\n\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD)\n\t\tnitems++;\n\n\tcsp = sp;\n\tsp -= nitems * 2 * sizeof(unsigned long);\n\tsp -= (bprm->envc + 1) * sizeof(char *);\t/* envv[] */\n\tsp -= (bprm->argc + 1) * sizeof(char *);\t/* argv[] */\n\tsp -= 1 * sizeof(unsigned long);\t\t/* argc */\n\n\tcsp -= sp & 15UL;\n\tsp -= sp & 15UL;\n\n\t/* put the ELF interpreter info on the stack */\n#define NEW_AUX_ENT(id, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct { unsigned long _id, _val; } __user *ent;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tent = (void __user *) csp;\t\t\t\t\\\n\t\t__put_user((id), &ent[nr]._id);\t\t\t\t\\\n\t\t__put_user((val), &ent[nr]._val);\t\t\t\\\n\t\tnr++;\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tnr = 0;\n\tcsp -= 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_NULL, 0);\n\tif (k_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_platform);\n\t}\n\n\tif (k_base_platform) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t) (unsigned long) u_base_platform);\n\t}\n\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tnr = 0;\n\t\tcsp -= 2 * sizeof(unsigned long);\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n\n\tnr = 0;\n\tcsp -= DLINFO_ITEMS * 2 * sizeof(unsigned long);\n\tNEW_AUX_ENT(AT_HWCAP,\tELF_HWCAP);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2,\tELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_PAGESZ,\tPAGE_SIZE);\n\tNEW_AUX_ENT(AT_CLKTCK,\tCLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR,\texec_params->ph_addr);\n\tNEW_AUX_ENT(AT_PHENT,\tsizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM,\texec_params->hdr.e_phnum);\n\tNEW_AUX_ENT(AT_BASE,\tinterp_params->elfhdr_addr);\n\tNEW_AUX_ENT(AT_FLAGS,\t0);\n\tNEW_AUX_ENT(AT_ENTRY,\texec_params->entry_addr);\n\tNEW_AUX_ENT(AT_UID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID,\t(elf_addr_t) from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID,\t(elf_addr_t) from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE,\tbprm->secureexec);\n\tNEW_AUX_ENT(AT_EXECFN,\tbprm->exec);\n\n#ifdef ARCH_DLINFO\n\tnr = 0;\n\tcsp -= AT_VECTOR_SIZE_ARCH * 2 * sizeof(unsigned long);\n\n\t/* ARCH_DLINFO must come last so platform specific code can enforce\n\t * special alignment requirements on the AUXV if necessary (eg. PPC).\n\t */\n\tARCH_DLINFO;\n#endif\n#undef NEW_AUX_ENT\n\n\t/* allocate room for argv[] and envv[] */\n\tcsp -= (bprm->envc + 1) * sizeof(elf_caddr_t);\n\tenvp = (elf_caddr_t __user *) csp;\n\tcsp -= (bprm->argc + 1) * sizeof(elf_caddr_t);\n\targv = (elf_caddr_t __user *) csp;\n\n\t/* stack argc */\n\tcsp -= sizeof(unsigned long);\n\t__put_user(bprm->argc, (unsigned long __user *) csp);\n\n\tBUG_ON(csp != sp);\n\n\t/* fill in the argv[] array */\n#ifdef CONFIG_MMU\n\tcurrent->mm->arg_start = bprm->p;\n#else\n\tcurrent->mm->arg_start = current->mm->start_stack -\n\t\t(MAX_ARG_PAGES * PAGE_SIZE - bprm->p);\n#endif\n\n\tp = (char __user *) current->mm->arg_start;\n\tfor (loop = bprm->argc; loop > 0; loop--) {\n\t\t__put_user((elf_caddr_t) p, argv++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(NULL, argv);\n\tcurrent->mm->arg_end = (unsigned long) p;\n\n\t/* fill in the envv[] array */\n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (loop = bprm->envc; loop > 0; loop--) {\n\t\t__put_user((elf_caddr_t)(unsigned long) p, envp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(NULL, envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\n\tmm->start_stack = (unsigned long) sp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_exec_creds",
          "args": [
            "bprm"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "install_exec_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1448-1470",
          "snippet": "void install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "current->mm->start_brk"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "NULL",
            "0",
            "stack_size",
            "stack_prot",
            "MAP_PRIVATE | MAP_ANONYMOUS |\n\t\t\t\t\t MAP_UNINITIALIZED | MAP_GROWSDOWN",
            "0"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "current->mm->start_brk"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "interpreter"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Unable to load interpreter\\n\""
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_fdpic_map_file",
          "args": [
            "&interp_params",
            "interpreter",
            "current->mm",
            "\"interpreter\""
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "elf_fdpic_map_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "732-912",
          "snippet": "static int elf_fdpic_map_file(struct elf_fdpic_params *params,\n\t\t\t      struct file *file,\n\t\t\t      struct mm_struct *mm,\n\t\t\t      const char *what)\n{\n\tstruct elf32_fdpic_loadmap *loadmap;\n#ifdef CONFIG_MMU\n\tstruct elf32_fdpic_loadseg *mseg;\n#endif\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, stop;\n\tunsigned nloads, tmp;\n\tsize_t size;\n\tint loop, ret;\n\n\t/* allocate a load map table */\n\tnloads = 0;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++)\n\t\tif (params->phdrs[loop].p_type == PT_LOAD)\n\t\t\tnloads++;\n\n\tif (nloads == 0)\n\t\treturn -ELIBBAD;\n\n\tsize = sizeof(*loadmap) + nloads * sizeof(*seg);\n\tloadmap = kzalloc(size, GFP_KERNEL);\n\tif (!loadmap)\n\t\treturn -ENOMEM;\n\n\tparams->loadmap = loadmap;\n\n\tloadmap->version = ELF32_FDPIC_LOADMAP_VERSION;\n\tloadmap->nsegs = nloads;\n\n\tload_addr = params->load_addr;\n\tseg = loadmap->segs;\n\n\t/* map the requested LOADs into the memory space */\n\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n#ifndef CONFIG_MMU\n\t\tret = elf_fdpic_map_file_constdisp_on_uclinux(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = elf_fdpic_map_file_by_direct_mmap(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t/* map the entry point */\n\tif (params->hdr.e_entry) {\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (params->hdr.e_entry >= seg->p_vaddr &&\n\t\t\t    params->hdr.e_entry < seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->entry_addr =\n\t\t\t\t\t(params->hdr.e_entry - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* determine where the program header table has wound up if mapped */\n\tstop = params->hdr.e_phoff;\n\tstop += params->hdr.e_phnum * sizeof (struct elf_phdr);\n\tphdr = params->phdrs;\n\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_offset > params->hdr.e_phoff ||\n\t\t    phdr->p_offset + phdr->p_filesz < stop)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_filesz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->ph_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr +\n\t\t\t\t\tparams->hdr.e_phoff - phdr->p_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* determine where the dynamic section has wound up if there is one */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_DYNAMIC)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_memsz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tElf32_Dyn __user *dyn;\n\t\t\t\tElf32_Sword d_tag;\n\n\t\t\t\tparams->dynamic_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\n\t\t\t\t/* check the dynamic section contains at least\n\t\t\t\t * one item, and that the last item is a NULL\n\t\t\t\t * entry */\n\t\t\t\tif (phdr->p_memsz == 0 ||\n\t\t\t\t    phdr->p_memsz % sizeof(Elf32_Dyn) != 0)\n\t\t\t\t\tgoto dynamic_error;\n\n\t\t\t\ttmp = phdr->p_memsz / sizeof(Elf32_Dyn);\n\t\t\t\tdyn = (Elf32_Dyn __user *)params->dynamic_addr;\n\t\t\t\t__get_user(d_tag, &dyn[tmp - 1].d_tag);\n\t\t\t\tif (d_tag != 0)\n\t\t\t\t\tgoto dynamic_error;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* now elide adjacent segments in the load map on MMU linux\n\t * - on uClinux the holes between may actually be filled with system\n\t *   stuff or stuff from other processes\n\t */\n#ifdef CONFIG_MMU\n\tnloads = loadmap->nsegs;\n\tmseg = loadmap->segs;\n\tseg = mseg + 1;\n\tfor (loop = 1; loop < nloads; loop++) {\n\t\t/* see if we have a candidate for merging */\n\t\tif (seg->p_vaddr - mseg->p_vaddr == seg->addr - mseg->addr) {\n\t\t\tload_addr = PAGE_ALIGN(mseg->addr + mseg->p_memsz);\n\t\t\tif (load_addr == (seg->addr & PAGE_MASK)) {\n\t\t\t\tmseg->p_memsz +=\n\t\t\t\t\tload_addr -\n\t\t\t\t\t(mseg->addr + mseg->p_memsz);\n\t\t\t\tmseg->p_memsz += seg->addr & ~PAGE_MASK;\n\t\t\t\tmseg->p_memsz += seg->p_memsz;\n\t\t\t\tloadmap->nsegs--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmseg++;\n\t\tif (mseg != seg)\n\t\t\t*mseg = *seg;\n\t}\n#endif\n\n\tkdebug(\"Mapped Object [%s]:\", what);\n\tkdebug(\"- elfhdr   : %lx\", params->elfhdr_addr);\n\tkdebug(\"- entry    : %lx\", params->entry_addr);\n\tkdebug(\"- PHDR[]   : %lx\", params->ph_addr);\n\tkdebug(\"- DYNAMIC[]: %lx\", params->dynamic_addr);\n\tseg = loadmap->segs;\n\tfor (loop = 0; loop < loadmap->nsegs; loop++, seg++)\n\t\tkdebug(\"- LOAD[%d] : %08x-%08x [va=%x ms=%x]\",\n\t\t       loop,\n\t\t       seg->addr, seg->addr + seg->p_memsz - 1,\n\t\t       seg->p_vaddr, seg->p_memsz);\n\n\treturn 0;\n\ndynamic_error:\n\tprintk(\"ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\\n\",\n\t       what, file_inode(file)->i_ino);\n\treturn -ELIBBAD;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);",
            "static int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);",
            "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);",
            "static int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *, struct file *,\n\t\t\t      struct mm_struct *, const char *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *,\n\t\t\t\t\t     struct file *, struct mm_struct *);\n\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *params,\n\t\t\t      struct file *file,\n\t\t\t      struct mm_struct *mm,\n\t\t\t      const char *what)\n{\n\tstruct elf32_fdpic_loadmap *loadmap;\n#ifdef CONFIG_MMU\n\tstruct elf32_fdpic_loadseg *mseg;\n#endif\n\tstruct elf32_fdpic_loadseg *seg;\n\tstruct elf32_phdr *phdr;\n\tunsigned long load_addr, stop;\n\tunsigned nloads, tmp;\n\tsize_t size;\n\tint loop, ret;\n\n\t/* allocate a load map table */\n\tnloads = 0;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++)\n\t\tif (params->phdrs[loop].p_type == PT_LOAD)\n\t\t\tnloads++;\n\n\tif (nloads == 0)\n\t\treturn -ELIBBAD;\n\n\tsize = sizeof(*loadmap) + nloads * sizeof(*seg);\n\tloadmap = kzalloc(size, GFP_KERNEL);\n\tif (!loadmap)\n\t\treturn -ENOMEM;\n\n\tparams->loadmap = loadmap;\n\n\tloadmap->version = ELF32_FDPIC_LOADMAP_VERSION;\n\tloadmap->nsegs = nloads;\n\n\tload_addr = params->load_addr;\n\tseg = loadmap->segs;\n\n\t/* map the requested LOADs into the memory space */\n\tswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\n\tcase ELF_FDPIC_FLAG_CONSTDISP:\n\tcase ELF_FDPIC_FLAG_CONTIGUOUS:\n#ifndef CONFIG_MMU\n\t\tret = elf_fdpic_map_file_constdisp_on_uclinux(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = elf_fdpic_map_file_by_direct_mmap(params, file, mm);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\t/* map the entry point */\n\tif (params->hdr.e_entry) {\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (params->hdr.e_entry >= seg->p_vaddr &&\n\t\t\t    params->hdr.e_entry < seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->entry_addr =\n\t\t\t\t\t(params->hdr.e_entry - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* determine where the program header table has wound up if mapped */\n\tstop = params->hdr.e_phoff;\n\tstop += params->hdr.e_phnum * sizeof (struct elf_phdr);\n\tphdr = params->phdrs;\n\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_offset > params->hdr.e_phoff ||\n\t\t    phdr->p_offset + phdr->p_filesz < stop)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_filesz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tparams->ph_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr +\n\t\t\t\t\tparams->hdr.e_phoff - phdr->p_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* determine where the dynamic section has wound up if there is one */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_DYNAMIC)\n\t\t\tcontinue;\n\n\t\tseg = loadmap->segs;\n\t\tfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\n\t\t\tif (phdr->p_vaddr >= seg->p_vaddr &&\n\t\t\t    phdr->p_vaddr + phdr->p_memsz <=\n\t\t\t    seg->p_vaddr + seg->p_memsz) {\n\t\t\t\tElf32_Dyn __user *dyn;\n\t\t\t\tElf32_Sword d_tag;\n\n\t\t\t\tparams->dynamic_addr =\n\t\t\t\t\t(phdr->p_vaddr - seg->p_vaddr) +\n\t\t\t\t\tseg->addr;\n\n\t\t\t\t/* check the dynamic section contains at least\n\t\t\t\t * one item, and that the last item is a NULL\n\t\t\t\t * entry */\n\t\t\t\tif (phdr->p_memsz == 0 ||\n\t\t\t\t    phdr->p_memsz % sizeof(Elf32_Dyn) != 0)\n\t\t\t\t\tgoto dynamic_error;\n\n\t\t\t\ttmp = phdr->p_memsz / sizeof(Elf32_Dyn);\n\t\t\t\tdyn = (Elf32_Dyn __user *)params->dynamic_addr;\n\t\t\t\t__get_user(d_tag, &dyn[tmp - 1].d_tag);\n\t\t\t\tif (d_tag != 0)\n\t\t\t\t\tgoto dynamic_error;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* now elide adjacent segments in the load map on MMU linux\n\t * - on uClinux the holes between may actually be filled with system\n\t *   stuff or stuff from other processes\n\t */\n#ifdef CONFIG_MMU\n\tnloads = loadmap->nsegs;\n\tmseg = loadmap->segs;\n\tseg = mseg + 1;\n\tfor (loop = 1; loop < nloads; loop++) {\n\t\t/* see if we have a candidate for merging */\n\t\tif (seg->p_vaddr - mseg->p_vaddr == seg->addr - mseg->addr) {\n\t\t\tload_addr = PAGE_ALIGN(mseg->addr + mseg->p_memsz);\n\t\t\tif (load_addr == (seg->addr & PAGE_MASK)) {\n\t\t\t\tmseg->p_memsz +=\n\t\t\t\t\tload_addr -\n\t\t\t\t\t(mseg->addr + mseg->p_memsz);\n\t\t\t\tmseg->p_memsz += seg->addr & ~PAGE_MASK;\n\t\t\t\tmseg->p_memsz += seg->p_memsz;\n\t\t\t\tloadmap->nsegs--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmseg++;\n\t\tif (mseg != seg)\n\t\t\t*mseg = *seg;\n\t}\n#endif\n\n\tkdebug(\"Mapped Object [%s]:\", what);\n\tkdebug(\"- elfhdr   : %lx\", params->elfhdr_addr);\n\tkdebug(\"- entry    : %lx\", params->entry_addr);\n\tkdebug(\"- PHDR[]   : %lx\", params->ph_addr);\n\tkdebug(\"- DYNAMIC[]: %lx\", params->dynamic_addr);\n\tseg = loadmap->segs;\n\tfor (loop = 0; loop < loadmap->nsegs; loop++, seg++)\n\t\tkdebug(\"- LOAD[%d] : %08x-%08x [va=%x ms=%x]\",\n\t\t       loop,\n\t\t       seg->addr, seg->addr + seg->p_memsz - 1,\n\t\t       seg->p_vaddr, seg->p_memsz);\n\n\treturn 0;\n\ndynamic_error:\n\tprintk(\"ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\\n\",\n\t       what, file_inode(file)->i_ino);\n\treturn -ELIBBAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_setup_additional_pages",
          "args": [
            "bprm",
            "!!interpreter_name"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_arg_pages",
          "args": [
            "bprm",
            "current->mm->start_stack",
            "executable_stack"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "setup_arg_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "688-798",
          "snippet": "int setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_fdpic_arch_lay_out_mm",
          "args": [
            "&exec_params",
            "&interp_params",
            "&current->mm->start_stack",
            "&current->mm->start_brk"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_binfmt",
          "args": [
            "&elf_fdpic_format"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "set_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1931-1941",
          "snippet": "void set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_new_exec",
          "args": [
            "bprm"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1330-1384",
          "snippet": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int suid_dumpable = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint suid_dumpable = 0;\n\nvoid setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_read_implies_exec",
          "args": [
            "&exec_params.hdr",
            "executable_stack"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_personality",
          "args": [
            "PER_LINUX"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_personality",
          "args": [
            "PER_LINUX_FDPIC"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_check_fdpic",
          "args": [
            "&exec_params.hdr"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_old_exec",
          "args": [
            "bprm"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "flush_old_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1254-1306",
          "snippet": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_constdisp",
          "args": [
            "&interp_params.hdr"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "is_constdisp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "129-136",
          "snippet": "static int is_constdisp(struct elfhdr *hdr)\n{\n\tif (!elf_check_fdpic(hdr))\n\t\treturn 1;\n\tif (elf_check_const_displacement(hdr))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int is_constdisp(struct elfhdr *hdr)\n{\n\tif (!elf_check_fdpic(hdr))\n\t\treturn 1;\n\tif (elf_check_const_displacement(hdr))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_fdpic_fetch_phdrs",
          "args": [
            "&interp_params",
            "interpreter"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "elf_fdpic_fetch_phdrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "142-180",
          "snippet": "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *params,\n\t\t\t\t struct file *file)\n{\n\tstruct elf32_phdr *phdr;\n\tunsigned long size;\n\tint retval, loop;\n\tloff_t pos = params->hdr.e_phoff;\n\n\tif (params->hdr.e_phentsize != sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\tif (params->hdr.e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\n\tsize = params->hdr.e_phnum * sizeof(struct elf_phdr);\n\tparams->phdrs = kmalloc(size, GFP_KERNEL);\n\tif (!params->phdrs)\n\t\treturn -ENOMEM;\n\n\tretval = kernel_read(file, params->phdrs, size, &pos);\n\tif (unlikely(retval != size))\n\t\treturn retval < 0 ? retval : -ENOEXEC;\n\n\t/* determine stack size for this binary */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_GNU_STACK)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_flags & PF_X)\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_EXEC_STACK;\n\t\telse\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_NOEXEC_STACK;\n\n\t\tparams->stack_size = phdr->p_memsz;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);",
            "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *params,\n\t\t\t\t struct file *file)\n{\n\tstruct elf32_phdr *phdr;\n\tunsigned long size;\n\tint retval, loop;\n\tloff_t pos = params->hdr.e_phoff;\n\n\tif (params->hdr.e_phentsize != sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\tif (params->hdr.e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\n\tsize = params->hdr.e_phnum * sizeof(struct elf_phdr);\n\tparams->phdrs = kmalloc(size, GFP_KERNEL);\n\tif (!params->phdrs)\n\t\treturn -ENOMEM;\n\n\tretval = kernel_read(file, params->phdrs, size, &pos);\n\tif (unlikely(retval != size))\n\t\treturn retval < 0 ? retval : -ENOEXEC;\n\n\t/* determine stack size for this binary */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_GNU_STACK)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_flags & PF_X)\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_EXEC_STACK;\n\t\telse\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_NOEXEC_STACK;\n\n\t\tparams->stack_size = phdr->p_memsz;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_elf",
          "args": [
            "&interp_params.hdr",
            "interpreter"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "is_elf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
          "lines": "108-119",
          "snippet": "static int is_elf(struct elfhdr *hdr, struct file *file)\n{\n\tif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\treturn 0;\n\tif (hdr->e_type != ET_EXEC && hdr->e_type != ET_DYN)\n\t\treturn 0;\n\tif (!elf_check_arch(hdr))\n\t\treturn 0;\n\tif (!file->f_op->mmap)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/pgalloc.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/coredump.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf-fdpic.h>",
            "#include <linux/elf.h>",
            "#include <linux/init.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\n\nstatic int is_elf(struct elfhdr *hdr, struct file *file)\n{\n\tif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\treturn 0;\n\tif (hdr->e_type != ET_EXEC && hdr->e_type != ET_DYN)\n\t\treturn 0;\n\tif (!elf_check_arch(hdr))\n\t\treturn 0;\n\tif (!file->f_op->mmap)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "retval != BINPRM_BUF_SIZE"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "interpreter",
            "bprm->buf",
            "BINPRM_BUF_SIZE",
            "&pos"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "would_dump",
          "args": [
            "bprm",
            "interpreter"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "would_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1309-1327",
          "snippet": "void would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "interpreter"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "interpreter"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_exec",
          "args": [
            "interpreter_name"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "open_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "880-890",
          "snippet": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"Using ELF interpreter %s\"",
            "interpreter_name"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "retval != phdr->p_filesz"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "phdr->p_filesz",
            "GFP_KERNEL"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_check_fdpic",
          "args": [
            "&exec_params.hdr"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&interp_params",
            "0",
            "sizeof(interp_params)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&exec_params",
            "0",
            "sizeof(exec_params)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"____ LOAD %d ____\"",
            "current->pid"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int load_elf_fdpic_binary(struct linux_binprm *);\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\nstatic struct linux_binfmt elf_fdpic_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_fdpic_binary,\n#ifdef CONFIG_ELF_CORE\n\t.core_dump\t= elf_fdpic_core_dump,\n#endif\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\nstatic int load_elf_fdpic_binary(struct linux_binprm *bprm)\n{\n\tstruct elf_fdpic_params exec_params, interp_params;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct elf_phdr *phdr;\n\tunsigned long stack_size, entryaddr;\n#ifdef ELF_FDPIC_PLAT_INIT\n\tunsigned long dynaddr;\n#endif\n#ifndef CONFIG_MMU\n\tunsigned long stack_prot;\n#endif\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n\tchar *interpreter_name = NULL;\n\tint executable_stack;\n\tint retval, i;\n\tloff_t pos;\n\n\tkdebug(\"____ LOAD %d ____\", current->pid);\n\n\tmemset(&exec_params, 0, sizeof(exec_params));\n\tmemset(&interp_params, 0, sizeof(interp_params));\n\n\texec_params.hdr = *(struct elfhdr *) bprm->buf;\n\texec_params.flags = ELF_FDPIC_FLAG_PRESENT | ELF_FDPIC_FLAG_EXECUTABLE;\n\n\t/* check that this is a binary we know how to deal with */\n\tretval = -ENOEXEC;\n\tif (!is_elf(&exec_params.hdr, bprm->file))\n\t\tgoto error;\n\tif (!elf_check_fdpic(&exec_params.hdr)) {\n#ifdef CONFIG_MMU\n\t\t/* binfmt_elf handles non-fdpic elf except on nommu */\n\t\tgoto error;\n#else\n\t\t/* nommu can only load ET_DYN (PIE) ELF */\n\t\tif (exec_params.hdr.e_type != ET_DYN)\n\t\t\tgoto error;\n#endif\n\t}\n\n\t/* read the program header table */\n\tretval = elf_fdpic_fetch_phdrs(&exec_params, bprm->file);\n\tif (retval < 0)\n\t\tgoto error;\n\n\t/* scan for a program header that specifies an interpreter */\n\tphdr = exec_params.phdrs;\n\n\tfor (i = 0; i < exec_params.hdr.e_phnum; i++, phdr++) {\n\t\tswitch (phdr->p_type) {\n\t\tcase PT_INTERP:\n\t\t\tretval = -ENOMEM;\n\t\t\tif (phdr->p_filesz > PATH_MAX)\n\t\t\t\tgoto error;\n\t\t\tretval = -ENOENT;\n\t\t\tif (phdr->p_filesz < 2)\n\t\t\t\tgoto error;\n\n\t\t\t/* read the name of the interpreter into memory */\n\t\t\tinterpreter_name = kmalloc(phdr->p_filesz, GFP_KERNEL);\n\t\t\tif (!interpreter_name)\n\t\t\t\tgoto error;\n\n\t\t\tpos = phdr->p_offset;\n\t\t\tretval = kernel_read(bprm->file, interpreter_name,\n\t\t\t\t\t     phdr->p_filesz, &pos);\n\t\t\tif (unlikely(retval != phdr->p_filesz)) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -ENOEXEC;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tretval = -ENOENT;\n\t\t\tif (interpreter_name[phdr->p_filesz - 1] != '\\0')\n\t\t\t\tgoto error;\n\n\t\t\tkdebug(\"Using ELF interpreter %s\", interpreter_name);\n\n\t\t\t/* replace the program with the interpreter */\n\t\t\tinterpreter = open_exec(interpreter_name);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter)) {\n\t\t\t\tinterpreter = NULL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tpos = 0;\n\t\t\tretval = kernel_read(interpreter, bprm->buf,\n\t\t\t\t\tBINPRM_BUF_SIZE, &pos);\n\t\t\tif (unlikely(retval != BINPRM_BUF_SIZE)) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -ENOEXEC;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tinterp_params.hdr = *((struct elfhdr *) bprm->buf);\n\t\t\tbreak;\n\n\t\tcase PT_LOAD:\n#ifdef CONFIG_MMU\n\t\t\tif (exec_params.load_addr == 0)\n\t\t\t\texec_params.load_addr = phdr->p_vaddr;\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (is_constdisp(&exec_params.hdr))\n\t\texec_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;\n\n\t/* perform insanity checks on the interpreter */\n\tif (interpreter_name) {\n\t\tretval = -ELIBBAD;\n\t\tif (!is_elf(&interp_params.hdr, interpreter))\n\t\t\tgoto error;\n\n\t\tinterp_params.flags = ELF_FDPIC_FLAG_PRESENT;\n\n\t\t/* read the interpreter's program header table */\n\t\tretval = elf_fdpic_fetch_phdrs(&interp_params, interpreter);\n\t\tif (retval < 0)\n\t\t\tgoto error;\n\t}\n\n\tstack_size = exec_params.stack_size;\n\tif (exec_params.flags & ELF_FDPIC_FLAG_EXEC_STACK)\n\t\texecutable_stack = EXSTACK_ENABLE_X;\n\telse if (exec_params.flags & ELF_FDPIC_FLAG_NOEXEC_STACK)\n\t\texecutable_stack = EXSTACK_DISABLE_X;\n\telse\n\t\texecutable_stack = EXSTACK_DEFAULT;\n\n\tif (stack_size == 0) {\n\t\tstack_size = interp_params.stack_size;\n\t\tif (interp_params.flags & ELF_FDPIC_FLAG_EXEC_STACK)\n\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\telse if (interp_params.flags & ELF_FDPIC_FLAG_NOEXEC_STACK)\n\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\telse\n\t\t\texecutable_stack = EXSTACK_DEFAULT;\n\t}\n\n\tretval = -ENOEXEC;\n\tif (stack_size == 0)\n\t\tstack_size = 131072UL; /* same as exec.c's default commit */\n\n\tif (is_constdisp(&interp_params.hdr))\n\t\tinterp_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;\n\n\t/* flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto error;\n\n\t/* there's now no turning back... the old userspace image is dead,\n\t * defunct, deceased, etc.\n\t */\n\tif (elf_check_fdpic(&exec_params.hdr))\n\t\tset_personality(PER_LINUX_FDPIC);\n\telse\n\t\tset_personality(PER_LINUX);\n\tif (elf_read_implies_exec(&exec_params.hdr, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tsetup_new_exec(bprm);\n\n\tset_binfmt(&elf_fdpic_format);\n\n\tcurrent->mm->start_code = 0;\n\tcurrent->mm->end_code = 0;\n\tcurrent->mm->start_stack = 0;\n\tcurrent->mm->start_data = 0;\n\tcurrent->mm->end_data = 0;\n\tcurrent->mm->context.exec_fdpic_loadmap = 0;\n\tcurrent->mm->context.interp_fdpic_loadmap = 0;\n\n#ifdef CONFIG_MMU\n\telf_fdpic_arch_lay_out_mm(&exec_params,\n\t\t\t\t  &interp_params,\n\t\t\t\t  &current->mm->start_stack,\n\t\t\t\t  &current->mm->start_brk);\n\n\tretval = setup_arg_pages(bprm, current->mm->start_stack,\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto error;\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!interpreter_name);\n\tif (retval < 0)\n\t\tgoto error;\n#endif\n#endif\n\n\t/* load the executable and interpreter into memory */\n\tretval = elf_fdpic_map_file(&exec_params, bprm->file, current->mm,\n\t\t\t\t    \"executable\");\n\tif (retval < 0)\n\t\tgoto error;\n\n\tif (interpreter_name) {\n\t\tretval = elf_fdpic_map_file(&interp_params, interpreter,\n\t\t\t\t\t    current->mm, \"interpreter\");\n\t\tif (retval < 0) {\n\t\t\tprintk(KERN_ERR \"Unable to load interpreter\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tinterpreter = NULL;\n\t}\n\n#ifdef CONFIG_MMU\n\tif (!current->mm->start_brk)\n\t\tcurrent->mm->start_brk = current->mm->end_data;\n\n\tcurrent->mm->brk = current->mm->start_brk =\n\t\tPAGE_ALIGN(current->mm->start_brk);\n\n#else\n\t/* create a stack area and zero-size brk area */\n\tstack_size = (stack_size + PAGE_SIZE - 1) & PAGE_MASK;\n\tif (stack_size < PAGE_SIZE * 2)\n\t\tstack_size = PAGE_SIZE * 2;\n\n\tstack_prot = PROT_READ | PROT_WRITE;\n\tif (executable_stack == EXSTACK_ENABLE_X ||\n\t    (executable_stack == EXSTACK_DEFAULT && VM_STACK_FLAGS & VM_EXEC))\n\t\tstack_prot |= PROT_EXEC;\n\n\tcurrent->mm->start_brk = vm_mmap(NULL, 0, stack_size, stack_prot,\n\t\t\t\t\t MAP_PRIVATE | MAP_ANONYMOUS |\n\t\t\t\t\t MAP_UNINITIALIZED | MAP_GROWSDOWN,\n\t\t\t\t\t 0);\n\n\tif (IS_ERR_VALUE(current->mm->start_brk)) {\n\t\tretval = current->mm->start_brk;\n\t\tcurrent->mm->start_brk = 0;\n\t\tgoto error;\n\t}\n\n\tcurrent->mm->brk = current->mm->start_brk;\n\tcurrent->mm->context.end_brk = current->mm->start_brk;\n\tcurrent->mm->start_stack = current->mm->start_brk + stack_size;\n#endif\n\n\tinstall_exec_creds(bprm);\n\tif (create_elf_fdpic_tables(bprm, current->mm,\n\t\t\t\t    &exec_params, &interp_params) < 0)\n\t\tgoto error;\n\n\tkdebug(\"- start_code  %lx\", current->mm->start_code);\n\tkdebug(\"- end_code    %lx\", current->mm->end_code);\n\tkdebug(\"- start_data  %lx\", current->mm->start_data);\n\tkdebug(\"- end_data    %lx\", current->mm->end_data);\n\tkdebug(\"- start_brk   %lx\", current->mm->start_brk);\n\tkdebug(\"- brk         %lx\", current->mm->brk);\n\tkdebug(\"- start_stack %lx\", current->mm->start_stack);\n\n#ifdef ELF_FDPIC_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  This macro performs whatever initialization to\n\t * the regs structure is required.\n\t */\n\tdynaddr = interp_params.dynamic_addr ?: exec_params.dynamic_addr;\n\tELF_FDPIC_PLAT_INIT(regs, exec_params.map_addr, interp_params.map_addr,\n\t\t\t    dynaddr);\n#endif\n\n\tfinalize_exec(bprm);\n\t/* everything is now ready... get the userspace context ready to roll */\n\tentryaddr = interp_params.entry_addr ?: exec_params.entry_addr;\n\tstart_thread(regs, entryaddr, current->mm->start_stack);\n\n\tretval = 0;\n\nerror:\n\tif (interpreter) {\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t}\n\tkfree(interpreter_name);\n\tkfree(exec_params.phdrs);\n\tkfree(exec_params.loadmap);\n\tkfree(interp_params.phdrs);\n\tkfree(interp_params.loadmap);\n\treturn retval;\n}"
  },
  {
    "function_name": "elf_fdpic_fetch_phdrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "142-180",
    "snippet": "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *params,\n\t\t\t\t struct file *file)\n{\n\tstruct elf32_phdr *phdr;\n\tunsigned long size;\n\tint retval, loop;\n\tloff_t pos = params->hdr.e_phoff;\n\n\tif (params->hdr.e_phentsize != sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\tif (params->hdr.e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\n\tsize = params->hdr.e_phnum * sizeof(struct elf_phdr);\n\tparams->phdrs = kmalloc(size, GFP_KERNEL);\n\tif (!params->phdrs)\n\t\treturn -ENOMEM;\n\n\tretval = kernel_read(file, params->phdrs, size, &pos);\n\tif (unlikely(retval != size))\n\t\treturn retval < 0 ? retval : -ENOEXEC;\n\n\t/* determine stack size for this binary */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_GNU_STACK)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_flags & PF_X)\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_EXEC_STACK;\n\t\telse\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_NOEXEC_STACK;\n\n\t\tparams->stack_size = phdr->p_memsz;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);",
      "static int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "retval != size"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "params->phdrs",
            "size",
            "&pos"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\nstatic int create_elf_fdpic_tables(struct linux_binprm *, struct mm_struct *,\n\t\t\t\t   struct elf_fdpic_params *,\n\t\t\t\t   struct elf_fdpic_params *);\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *params,\n\t\t\t\t struct file *file)\n{\n\tstruct elf32_phdr *phdr;\n\tunsigned long size;\n\tint retval, loop;\n\tloff_t pos = params->hdr.e_phoff;\n\n\tif (params->hdr.e_phentsize != sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\tif (params->hdr.e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\n\tsize = params->hdr.e_phnum * sizeof(struct elf_phdr);\n\tparams->phdrs = kmalloc(size, GFP_KERNEL);\n\tif (!params->phdrs)\n\t\treturn -ENOMEM;\n\n\tretval = kernel_read(file, params->phdrs, size, &pos);\n\tif (unlikely(retval != size))\n\t\treturn retval < 0 ? retval : -ENOEXEC;\n\n\t/* determine stack size for this binary */\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_GNU_STACK)\n\t\t\tcontinue;\n\n\t\tif (phdr->p_flags & PF_X)\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_EXEC_STACK;\n\t\telse\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_NOEXEC_STACK;\n\n\t\tparams->stack_size = phdr->p_memsz;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_constdisp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "129-136",
    "snippet": "static int is_constdisp(struct elfhdr *hdr)\n{\n\tif (!elf_check_fdpic(hdr))\n\t\treturn 1;\n\tif (elf_check_const_displacement(hdr))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elf_check_const_displacement",
          "args": [
            "hdr"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_check_fdpic",
          "args": [
            "hdr"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int is_constdisp(struct elfhdr *hdr)\n{\n\tif (!elf_check_fdpic(hdr))\n\t\treturn 1;\n\tif (elf_check_const_displacement(hdr))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "is_elf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "108-119",
    "snippet": "static int is_elf(struct elfhdr *hdr, struct file *file)\n{\n\tif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\treturn 0;\n\tif (hdr->e_type != ET_EXEC && hdr->e_type != ET_DYN)\n\t\treturn 0;\n\tif (!elf_check_arch(hdr))\n\t\treturn 0;\n\tif (!file->f_op->mmap)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "hdr"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "hdr->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *, struct file *);\n\nstatic int is_elf(struct elfhdr *hdr, struct file *file)\n{\n\tif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\treturn 0;\n\tif (hdr->e_type != ET_EXEC && hdr->e_type != ET_DYN)\n\t\treturn 0;\n\tif (!elf_check_arch(hdr))\n\t\treturn 0;\n\tif (!file->f_op->mmap)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "exit_elf_fdpic_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "100-103",
    "snippet": "static void __exit exit_elf_fdpic_binfmt(void)\n{\n\tunregister_binfmt(&elf_fdpic_format);\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt elf_fdpic_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_fdpic_binary,\n#ifdef CONFIG_ELF_CORE\n\t.core_dump\t= elf_fdpic_core_dump,\n#endif\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_binfmt",
          "args": [
            "&elf_fdpic_format"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "94-99",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct linux_binfmt elf_fdpic_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_fdpic_binary,\n#ifdef CONFIG_ELF_CORE\n\t.core_dump\t= elf_fdpic_core_dump,\n#endif\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\nstatic void __exit exit_elf_fdpic_binfmt(void)\n{\n\tunregister_binfmt(&elf_fdpic_format);\n}"
  },
  {
    "function_name": "init_elf_fdpic_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf_fdpic.c",
    "lines": "94-98",
    "snippet": "static int __init init_elf_fdpic_binfmt(void)\n{\n\tregister_binfmt(&elf_fdpic_format);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgalloc.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/coredump.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf-fdpic.h>",
      "#include <linux/elf.h>",
      "#include <linux/init.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/personality.h>",
      "#include <linux/highuid.h>",
      "#include <linux/highmem.h>",
      "#include <linux/security.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt elf_fdpic_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_fdpic_binary,\n#ifdef CONFIG_ELF_CORE\n\t.core_dump\t= elf_fdpic_core_dump,\n#endif\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_binfmt",
          "args": [
            "&elf_fdpic_format"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "94-99",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgalloc.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/coredump.h>\n#include <linux/elfcore.h>\n#include <linux/elf-fdpic.h>\n#include <linux/elf.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct linux_binfmt elf_fdpic_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_fdpic_binary,\n#ifdef CONFIG_ELF_CORE\n\t.core_dump\t= elf_fdpic_core_dump,\n#endif\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\nstatic int __init init_elf_fdpic_binfmt(void)\n{\n\tregister_binfmt(&elf_fdpic_format);\n\treturn 0;\n}"
  }
]