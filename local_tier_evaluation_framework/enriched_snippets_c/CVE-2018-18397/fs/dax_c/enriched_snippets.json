[
  {
    "function_name": "dax_finish_sync_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1676-1688",
    "snippet": "vm_fault_t dax_finish_sync_fault(struct vm_fault *vmf,\n\t\tenum page_entry_size pe_size, pfn_t pfn)\n{\n\tint err;\n\tloff_t start = ((loff_t)vmf->pgoff) << PAGE_SHIFT;\n\tunsigned int order = pe_order(pe_size);\n\tsize_t len = PAGE_SIZE << order;\n\n\terr = vfs_fsync_range(vmf->vma->vm_file, start, start + len - 1, 1);\n\tif (err)\n\t\treturn VM_FAULT_SIGBUS;\n\treturn dax_insert_pfn_mkwrite(vmf, pfn, order);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_insert_pfn_mkwrite",
          "args": [
            "vmf",
            "pfn",
            "order"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "dax_insert_pfn_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1629-1664",
          "snippet": "static vm_fault_t\ndax_insert_pfn_mkwrite(struct vm_fault *vmf, pfn_t pfn, unsigned int order)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tXA_STATE_ORDER(xas, &mapping->i_pages, vmf->pgoff, order);\n\tvoid *entry;\n\tvm_fault_t ret;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\t/* Did we race with someone splitting entry or so? */\n\tif (!entry ||\n\t    (order == 0 && !dax_is_pte_entry(entry)) ||\n\t    (order == PMD_ORDER && !dax_is_pmd_entry(entry))) {\n\t\tput_unlocked_entry(&xas, entry);\n\t\txas_unlock_irq(&xas);\n\t\ttrace_dax_insert_pfn_mkwrite_no_entry(mapping->host, vmf,\n\t\t\t\t\t\t      VM_FAULT_NOPAGE);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\txas_set_mark(&xas, PAGECACHE_TAG_DIRTY);\n\tdax_lock_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\tif (order == 0)\n\t\tret = vmf_insert_mixed_mkwrite(vmf->vma, vmf->address, pfn);\n#ifdef CONFIG_FS_DAX_PMD\n\telse if (order == PMD_ORDER)\n\t\tret = vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd,\n\t\t\tpfn, true);\n#endif\n\telse\n\t\tret = VM_FAULT_FALLBACK;\n\tdax_unlock_entry(&xas, entry);\n\ttrace_dax_insert_pfn_mkwrite(mapping->host, vmf, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)\n\nstatic vm_fault_t\ndax_insert_pfn_mkwrite(struct vm_fault *vmf, pfn_t pfn, unsigned int order)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tXA_STATE_ORDER(xas, &mapping->i_pages, vmf->pgoff, order);\n\tvoid *entry;\n\tvm_fault_t ret;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\t/* Did we race with someone splitting entry or so? */\n\tif (!entry ||\n\t    (order == 0 && !dax_is_pte_entry(entry)) ||\n\t    (order == PMD_ORDER && !dax_is_pmd_entry(entry))) {\n\t\tput_unlocked_entry(&xas, entry);\n\t\txas_unlock_irq(&xas);\n\t\ttrace_dax_insert_pfn_mkwrite_no_entry(mapping->host, vmf,\n\t\t\t\t\t\t      VM_FAULT_NOPAGE);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\txas_set_mark(&xas, PAGECACHE_TAG_DIRTY);\n\tdax_lock_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\tif (order == 0)\n\t\tret = vmf_insert_mixed_mkwrite(vmf->vma, vmf->address, pfn);\n#ifdef CONFIG_FS_DAX_PMD\n\telse if (order == PMD_ORDER)\n\t\tret = vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd,\n\t\t\tpfn, true);\n#endif\n\telse\n\t\tret = VM_FAULT_FALLBACK;\n\tdax_unlock_entry(&xas, entry);\n\ttrace_dax_insert_pfn_mkwrite(mapping->host, vmf, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_fsync_range",
          "args": [
            "vmf->vma->vm_file",
            "start",
            "start + len - 1",
            "1"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
          "lines": "189-198",
          "snippet": "int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME))\n\t\tmark_inode_dirty_sync(inode);\n\treturn file->f_op->fsync(file, start, end, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME))\n\t\tmark_inode_dirty_sync(inode);\n\treturn file->f_op->fsync(file, start, end, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pe_order",
          "args": [
            "pe_size"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "pe_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "41-50",
          "snippet": "static inline unsigned int pe_order(enum page_entry_size pe_size)\n{\n\tif (pe_size == PE_SIZE_PTE)\n\t\treturn PAGE_SHIFT - PAGE_SHIFT;\n\tif (pe_size == PE_SIZE_PMD)\n\t\treturn PMD_SHIFT - PAGE_SHIFT;\n\tif (pe_size == PE_SIZE_PUD)\n\t\treturn PUD_SHIFT - PAGE_SHIFT;\n\treturn ~0;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic inline unsigned int pe_order(enum page_entry_size pe_size)\n{\n\tif (pe_size == PE_SIZE_PTE)\n\t\treturn PAGE_SHIFT - PAGE_SHIFT;\n\tif (pe_size == PE_SIZE_PMD)\n\t\treturn PMD_SHIFT - PAGE_SHIFT;\n\tif (pe_size == PE_SIZE_PUD)\n\t\treturn PUD_SHIFT - PAGE_SHIFT;\n\treturn ~0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nvm_fault_t dax_finish_sync_fault(struct vm_fault *vmf,\n\t\tenum page_entry_size pe_size, pfn_t pfn)\n{\n\tint err;\n\tloff_t start = ((loff_t)vmf->pgoff) << PAGE_SHIFT;\n\tunsigned int order = pe_order(pe_size);\n\tsize_t len = PAGE_SIZE << order;\n\n\terr = vfs_fsync_range(vmf->vma->vm_file, start, start + len - 1, 1);\n\tif (err)\n\t\treturn VM_FAULT_SIGBUS;\n\treturn dax_insert_pfn_mkwrite(vmf, pfn, order);\n}"
  },
  {
    "function_name": "dax_insert_pfn_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1629-1664",
    "snippet": "static vm_fault_t\ndax_insert_pfn_mkwrite(struct vm_fault *vmf, pfn_t pfn, unsigned int order)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tXA_STATE_ORDER(xas, &mapping->i_pages, vmf->pgoff, order);\n\tvoid *entry;\n\tvm_fault_t ret;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\t/* Did we race with someone splitting entry or so? */\n\tif (!entry ||\n\t    (order == 0 && !dax_is_pte_entry(entry)) ||\n\t    (order == PMD_ORDER && !dax_is_pmd_entry(entry))) {\n\t\tput_unlocked_entry(&xas, entry);\n\t\txas_unlock_irq(&xas);\n\t\ttrace_dax_insert_pfn_mkwrite_no_entry(mapping->host, vmf,\n\t\t\t\t\t\t      VM_FAULT_NOPAGE);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\txas_set_mark(&xas, PAGECACHE_TAG_DIRTY);\n\tdax_lock_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\tif (order == 0)\n\t\tret = vmf_insert_mixed_mkwrite(vmf->vma, vmf->address, pfn);\n#ifdef CONFIG_FS_DAX_PMD\n\telse if (order == PMD_ORDER)\n\t\tret = vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd,\n\t\t\tpfn, true);\n#endif\n\telse\n\t\tret = VM_FAULT_FALLBACK;\n\tdax_unlock_entry(&xas, entry);\n\ttrace_dax_insert_pfn_mkwrite(mapping->host, vmf, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_dax_insert_pfn_mkwrite",
          "args": [
            "mapping->host",
            "vmf",
            "ret"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_unlock_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "dax_unlock_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "247-258",
          "snippet": "static void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmf_insert_pfn_pmd",
          "args": [
            "vmf->vma",
            "vmf->address",
            "vmf->pmd",
            "pfn",
            "true"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmf_insert_mixed_mkwrite",
          "args": [
            "vmf->vma",
            "vmf->address",
            "pfn"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_lock_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "dax_lock_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "263-267",
          "snippet": "static void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_set_mark",
          "args": [
            "&xas",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_dax_insert_pfn_mkwrite_no_entry",
          "args": [
            "mapping->host",
            "vmf",
            "VM_FAULT_NOPAGE"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unlocked_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "put_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "235-240",
          "snippet": "static void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_pmd_entry",
          "args": [
            "entry"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_pmd_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "113-116",
          "snippet": "static unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_PMD\t\t(1UL << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_pte_entry",
          "args": [
            "entry"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_pte_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "118-121",
          "snippet": "static bool dax_is_pte_entry(void *entry)\n{\n\treturn !(xa_to_value(entry) & DAX_PMD);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_PMD\t\t(1UL << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic bool dax_is_pte_entry(void *entry)\n{\n\treturn !(xa_to_value(entry) & DAX_PMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unlocked_entry",
          "args": [
            "&xas"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "get_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "209-233",
          "snippet": "static void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE_ORDER",
          "args": [
            "xas",
            "&mapping->i_pages",
            "vmf->pgoff",
            "order"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)\n\nstatic vm_fault_t\ndax_insert_pfn_mkwrite(struct vm_fault *vmf, pfn_t pfn, unsigned int order)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tXA_STATE_ORDER(xas, &mapping->i_pages, vmf->pgoff, order);\n\tvoid *entry;\n\tvm_fault_t ret;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\t/* Did we race with someone splitting entry or so? */\n\tif (!entry ||\n\t    (order == 0 && !dax_is_pte_entry(entry)) ||\n\t    (order == PMD_ORDER && !dax_is_pmd_entry(entry))) {\n\t\tput_unlocked_entry(&xas, entry);\n\t\txas_unlock_irq(&xas);\n\t\ttrace_dax_insert_pfn_mkwrite_no_entry(mapping->host, vmf,\n\t\t\t\t\t\t      VM_FAULT_NOPAGE);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\txas_set_mark(&xas, PAGECACHE_TAG_DIRTY);\n\tdax_lock_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\tif (order == 0)\n\t\tret = vmf_insert_mixed_mkwrite(vmf->vma, vmf->address, pfn);\n#ifdef CONFIG_FS_DAX_PMD\n\telse if (order == PMD_ORDER)\n\t\tret = vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd,\n\t\t\tpfn, true);\n#endif\n\telse\n\t\tret = VM_FAULT_FALLBACK;\n\tdax_unlock_entry(&xas, entry);\n\ttrace_dax_insert_pfn_mkwrite(mapping->host, vmf, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "dax_iomap_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1606-1617",
    "snippet": "vm_fault_t dax_iomap_fault(struct vm_fault *vmf, enum page_entry_size pe_size,\n\t\t    pfn_t *pfnp, int *iomap_errp, const struct iomap_ops *ops)\n{\n\tswitch (pe_size) {\n\tcase PE_SIZE_PTE:\n\t\treturn dax_iomap_pte_fault(vmf, pfnp, iomap_errp, ops);\n\tcase PE_SIZE_PMD:\n\t\treturn dax_iomap_pmd_fault(vmf, pfnp, ops);\n\tdefault:\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_iomap_pmd_fault",
          "args": [
            "vmf",
            "pfnp",
            "ops"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "dax_iomap_pmd_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1586-1590",
          "snippet": "static vm_fault_t dax_iomap_pmd_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       const struct iomap_ops *ops)\n{\n\treturn VM_FAULT_FALLBACK;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic vm_fault_t dax_iomap_pmd_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       const struct iomap_ops *ops)\n{\n\treturn VM_FAULT_FALLBACK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_iomap_pte_fault",
          "args": [
            "vmf",
            "pfnp",
            "iomap_errp",
            "ops"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "dax_iomap_pte_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1218-1384",
          "snippet": "static vm_fault_t dax_iomap_pte_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       int *iomap_errp, const struct iomap_ops *ops)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tXA_STATE(xas, &mapping->i_pages, vmf->pgoff);\n\tstruct inode *inode = mapping->host;\n\tunsigned long vaddr = vmf->address;\n\tloff_t pos = (loff_t)vmf->pgoff << PAGE_SHIFT;\n\tstruct iomap iomap = { 0 };\n\tunsigned flags = IOMAP_FAULT;\n\tint error, major = 0;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tbool sync;\n\tvm_fault_t ret = 0;\n\tvoid *entry;\n\tpfn_t pfn;\n\n\ttrace_dax_pte_fault(inode, vmf, ret);\n\t/*\n\t * Check whether offset isn't beyond end of file now. Caller is supposed\n\t * to hold locks serializing us with truncate / punch hole so this is\n\t * a reliable test.\n\t */\n\tif (pos >= i_size_read(inode)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\tif (write && !vmf->cow_page)\n\t\tflags |= IOMAP_WRITE;\n\n\tentry = grab_mapping_entry(&xas, mapping, 0);\n\tif (xa_is_internal(entry)) {\n\t\tret = xa_to_internal(entry);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is possible, particularly with mixed reads & writes to private\n\t * mappings, that we have raced with a PMD fault that overlaps with\n\t * the PTE we need to set up.  If so just return and the fault will be\n\t * retried.\n\t */\n\tif (pmd_trans_huge(*vmf->pmd) || pmd_devmap(*vmf->pmd)) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto unlock_entry;\n\t}\n\n\t/*\n\t * Note that we don't bother to use iomap_apply here: DAX required\n\t * the file system block size to be equal the page size, which means\n\t * that we never have to deal with more than a single extent here.\n\t */\n\terror = ops->iomap_begin(inode, pos, PAGE_SIZE, flags, &iomap);\n\tif (iomap_errp)\n\t\t*iomap_errp = error;\n\tif (error) {\n\t\tret = dax_fault_return(error);\n\t\tgoto unlock_entry;\n\t}\n\tif (WARN_ON_ONCE(iomap.offset + iomap.length < pos + PAGE_SIZE)) {\n\t\terror = -EIO;\t/* fs corruption? */\n\t\tgoto error_finish_iomap;\n\t}\n\n\tif (vmf->cow_page) {\n\t\tsector_t sector = dax_iomap_sector(&iomap, pos);\n\n\t\tswitch (iomap.type) {\n\t\tcase IOMAP_HOLE:\n\t\tcase IOMAP_UNWRITTEN:\n\t\t\tclear_user_highpage(vmf->cow_page, vaddr);\n\t\t\tbreak;\n\t\tcase IOMAP_MAPPED:\n\t\t\terror = copy_user_dax(iomap.bdev, iomap.dax_dev,\n\t\t\t\t\tsector, PAGE_SIZE, vmf->cow_page, vaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error_finish_iomap;\n\n\t\t__SetPageUptodate(vmf->cow_page);\n\t\tret = finish_fault(vmf);\n\t\tif (!ret)\n\t\t\tret = VM_FAULT_DONE_COW;\n\t\tgoto finish_iomap;\n\t}\n\n\tsync = dax_fault_is_synchronous(flags, vma, &iomap);\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\tif (iomap.flags & IOMAP_F_NEW) {\n\t\t\tcount_vm_event(PGMAJFAULT);\n\t\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t\t\tmajor = VM_FAULT_MAJOR;\n\t\t}\n\t\terror = dax_iomap_pfn(&iomap, pos, PAGE_SIZE, &pfn);\n\t\tif (error < 0)\n\t\t\tgoto error_finish_iomap;\n\n\t\tentry = dax_insert_entry(&xas, mapping, vmf, entry, pfn,\n\t\t\t\t\t\t 0, write && !sync);\n\n\t\t/*\n\t\t * If we are doing synchronous page fault and inode needs fsync,\n\t\t * we can insert PTE into page tables only after that happens.\n\t\t * Skip insertion for now and return the pfn so that caller can\n\t\t * insert it after fsync is done.\n\t\t */\n\t\tif (sync) {\n\t\t\tif (WARN_ON_ONCE(!pfnp)) {\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto error_finish_iomap;\n\t\t\t}\n\t\t\t*pfnp = pfn;\n\t\t\tret = VM_FAULT_NEEDDSYNC | major;\n\t\t\tgoto finish_iomap;\n\t\t}\n\t\ttrace_dax_insert_mapping(inode, vmf, entry);\n\t\tif (write)\n\t\t\tret = vmf_insert_mixed_mkwrite(vma, vaddr, pfn);\n\t\telse\n\t\t\tret = vmf_insert_mixed(vma, vaddr, pfn);\n\n\t\tgoto finish_iomap;\n\tcase IOMAP_UNWRITTEN:\n\tcase IOMAP_HOLE:\n\t\tif (!write) {\n\t\t\tret = dax_load_hole(&xas, mapping, &entry, vmf);\n\t\t\tgoto finish_iomap;\n\t\t}\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\terror = -EIO;\n\t\tbreak;\n\t}\n\n error_finish_iomap:\n\tret = dax_fault_return(error);\n finish_iomap:\n\tif (ops->iomap_end) {\n\t\tint copied = PAGE_SIZE;\n\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tcopied = 0;\n\t\t/*\n\t\t * The fault is done by now and there's no way back (other\n\t\t * thread may be already happily using PTE we have installed).\n\t\t * Just ignore error from ->iomap_end since we cannot do much\n\t\t * with it.\n\t\t */\n\t\tops->iomap_end(inode, pos, PAGE_SIZE, copied, flags, &iomap);\n\t}\n unlock_entry:\n\tdax_unlock_entry(&xas, entry);\n out:\n\ttrace_dax_pte_fault_done(inode, vmf, ret);\n\treturn ret | major;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic vm_fault_t dax_iomap_pte_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       int *iomap_errp, const struct iomap_ops *ops)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tXA_STATE(xas, &mapping->i_pages, vmf->pgoff);\n\tstruct inode *inode = mapping->host;\n\tunsigned long vaddr = vmf->address;\n\tloff_t pos = (loff_t)vmf->pgoff << PAGE_SHIFT;\n\tstruct iomap iomap = { 0 };\n\tunsigned flags = IOMAP_FAULT;\n\tint error, major = 0;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tbool sync;\n\tvm_fault_t ret = 0;\n\tvoid *entry;\n\tpfn_t pfn;\n\n\ttrace_dax_pte_fault(inode, vmf, ret);\n\t/*\n\t * Check whether offset isn't beyond end of file now. Caller is supposed\n\t * to hold locks serializing us with truncate / punch hole so this is\n\t * a reliable test.\n\t */\n\tif (pos >= i_size_read(inode)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\tif (write && !vmf->cow_page)\n\t\tflags |= IOMAP_WRITE;\n\n\tentry = grab_mapping_entry(&xas, mapping, 0);\n\tif (xa_is_internal(entry)) {\n\t\tret = xa_to_internal(entry);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is possible, particularly with mixed reads & writes to private\n\t * mappings, that we have raced with a PMD fault that overlaps with\n\t * the PTE we need to set up.  If so just return and the fault will be\n\t * retried.\n\t */\n\tif (pmd_trans_huge(*vmf->pmd) || pmd_devmap(*vmf->pmd)) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto unlock_entry;\n\t}\n\n\t/*\n\t * Note that we don't bother to use iomap_apply here: DAX required\n\t * the file system block size to be equal the page size, which means\n\t * that we never have to deal with more than a single extent here.\n\t */\n\terror = ops->iomap_begin(inode, pos, PAGE_SIZE, flags, &iomap);\n\tif (iomap_errp)\n\t\t*iomap_errp = error;\n\tif (error) {\n\t\tret = dax_fault_return(error);\n\t\tgoto unlock_entry;\n\t}\n\tif (WARN_ON_ONCE(iomap.offset + iomap.length < pos + PAGE_SIZE)) {\n\t\terror = -EIO;\t/* fs corruption? */\n\t\tgoto error_finish_iomap;\n\t}\n\n\tif (vmf->cow_page) {\n\t\tsector_t sector = dax_iomap_sector(&iomap, pos);\n\n\t\tswitch (iomap.type) {\n\t\tcase IOMAP_HOLE:\n\t\tcase IOMAP_UNWRITTEN:\n\t\t\tclear_user_highpage(vmf->cow_page, vaddr);\n\t\t\tbreak;\n\t\tcase IOMAP_MAPPED:\n\t\t\terror = copy_user_dax(iomap.bdev, iomap.dax_dev,\n\t\t\t\t\tsector, PAGE_SIZE, vmf->cow_page, vaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error_finish_iomap;\n\n\t\t__SetPageUptodate(vmf->cow_page);\n\t\tret = finish_fault(vmf);\n\t\tif (!ret)\n\t\t\tret = VM_FAULT_DONE_COW;\n\t\tgoto finish_iomap;\n\t}\n\n\tsync = dax_fault_is_synchronous(flags, vma, &iomap);\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\tif (iomap.flags & IOMAP_F_NEW) {\n\t\t\tcount_vm_event(PGMAJFAULT);\n\t\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t\t\tmajor = VM_FAULT_MAJOR;\n\t\t}\n\t\terror = dax_iomap_pfn(&iomap, pos, PAGE_SIZE, &pfn);\n\t\tif (error < 0)\n\t\t\tgoto error_finish_iomap;\n\n\t\tentry = dax_insert_entry(&xas, mapping, vmf, entry, pfn,\n\t\t\t\t\t\t 0, write && !sync);\n\n\t\t/*\n\t\t * If we are doing synchronous page fault and inode needs fsync,\n\t\t * we can insert PTE into page tables only after that happens.\n\t\t * Skip insertion for now and return the pfn so that caller can\n\t\t * insert it after fsync is done.\n\t\t */\n\t\tif (sync) {\n\t\t\tif (WARN_ON_ONCE(!pfnp)) {\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto error_finish_iomap;\n\t\t\t}\n\t\t\t*pfnp = pfn;\n\t\t\tret = VM_FAULT_NEEDDSYNC | major;\n\t\t\tgoto finish_iomap;\n\t\t}\n\t\ttrace_dax_insert_mapping(inode, vmf, entry);\n\t\tif (write)\n\t\t\tret = vmf_insert_mixed_mkwrite(vma, vaddr, pfn);\n\t\telse\n\t\t\tret = vmf_insert_mixed(vma, vaddr, pfn);\n\n\t\tgoto finish_iomap;\n\tcase IOMAP_UNWRITTEN:\n\tcase IOMAP_HOLE:\n\t\tif (!write) {\n\t\t\tret = dax_load_hole(&xas, mapping, &entry, vmf);\n\t\t\tgoto finish_iomap;\n\t\t}\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\terror = -EIO;\n\t\tbreak;\n\t}\n\n error_finish_iomap:\n\tret = dax_fault_return(error);\n finish_iomap:\n\tif (ops->iomap_end) {\n\t\tint copied = PAGE_SIZE;\n\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tcopied = 0;\n\t\t/*\n\t\t * The fault is done by now and there's no way back (other\n\t\t * thread may be already happily using PTE we have installed).\n\t\t * Just ignore error from ->iomap_end since we cannot do much\n\t\t * with it.\n\t\t */\n\t\tops->iomap_end(inode, pos, PAGE_SIZE, copied, flags, &iomap);\n\t}\n unlock_entry:\n\tdax_unlock_entry(&xas, entry);\n out:\n\ttrace_dax_pte_fault_done(inode, vmf, ret);\n\treturn ret | major;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nvm_fault_t dax_iomap_fault(struct vm_fault *vmf, enum page_entry_size pe_size,\n\t\t    pfn_t *pfnp, int *iomap_errp, const struct iomap_ops *ops)\n{\n\tswitch (pe_size) {\n\tcase PE_SIZE_PTE:\n\t\treturn dax_iomap_pte_fault(vmf, pfnp, iomap_errp, ops);\n\tcase PE_SIZE_PMD:\n\t\treturn dax_iomap_pmd_fault(vmf, pfnp, ops);\n\tdefault:\n\t\treturn VM_FAULT_FALLBACK;\n\t}\n}"
  },
  {
    "function_name": "dax_iomap_pmd_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1586-1590",
    "snippet": "static vm_fault_t dax_iomap_pmd_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       const struct iomap_ops *ops)\n{\n\treturn VM_FAULT_FALLBACK;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic vm_fault_t dax_iomap_pmd_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       const struct iomap_ops *ops)\n{\n\treturn VM_FAULT_FALLBACK;\n}"
  },
  {
    "function_name": "dax_iomap_pmd_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1425-1584",
    "snippet": "static vm_fault_t dax_iomap_pmd_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       const struct iomap_ops *ops)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tXA_STATE_ORDER(xas, &mapping->i_pages, vmf->pgoff, PMD_ORDER);\n\tunsigned long pmd_addr = vmf->address & PMD_MASK;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tbool sync;\n\tunsigned int iomap_flags = (write ? IOMAP_WRITE : 0) | IOMAP_FAULT;\n\tstruct inode *inode = mapping->host;\n\tvm_fault_t result = VM_FAULT_FALLBACK;\n\tstruct iomap iomap = { 0 };\n\tpgoff_t max_pgoff;\n\tvoid *entry;\n\tloff_t pos;\n\tint error;\n\tpfn_t pfn;\n\n\t/*\n\t * Check whether offset isn't beyond end of file now. Caller is\n\t * supposed to hold locks serializing us with truncate / punch hole so\n\t * this is a reliable test.\n\t */\n\tmax_pgoff = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\n\ttrace_dax_pmd_fault(inode, vmf, max_pgoff, 0);\n\n\t/*\n\t * Make sure that the faulting address's PMD offset (color) matches\n\t * the PMD offset from the start of the file.  This is necessary so\n\t * that a PMD range in the page table overlaps exactly with a PMD\n\t * range in the page cache.\n\t */\n\tif ((vmf->pgoff & PG_PMD_COLOUR) !=\n\t    ((vmf->address >> PAGE_SHIFT) & PG_PMD_COLOUR))\n\t\tgoto fallback;\n\n\t/* Fall back to PTEs if we're going to COW */\n\tif (write && !(vma->vm_flags & VM_SHARED))\n\t\tgoto fallback;\n\n\t/* If the PMD would extend outside the VMA */\n\tif (pmd_addr < vma->vm_start)\n\t\tgoto fallback;\n\tif ((pmd_addr + PMD_SIZE) > vma->vm_end)\n\t\tgoto fallback;\n\n\tif (xas.xa_index >= max_pgoff) {\n\t\tresult = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\t/* If the PMD would extend beyond the file size */\n\tif ((xas.xa_index | PG_PMD_COLOUR) >= max_pgoff)\n\t\tgoto fallback;\n\n\t/*\n\t * grab_mapping_entry() will make sure we get an empty PMD entry,\n\t * a zero PMD entry or a DAX PMD.  If it can't (because a PTE\n\t * entry is already in the array, for instance), it will return\n\t * VM_FAULT_FALLBACK.\n\t */\n\tentry = grab_mapping_entry(&xas, mapping, DAX_PMD);\n\tif (xa_is_internal(entry)) {\n\t\tresult = xa_to_internal(entry);\n\t\tgoto fallback;\n\t}\n\n\t/*\n\t * It is possible, particularly with mixed reads & writes to private\n\t * mappings, that we have raced with a PTE fault that overlaps with\n\t * the PMD we need to set up.  If so just return and the fault will be\n\t * retried.\n\t */\n\tif (!pmd_none(*vmf->pmd) && !pmd_trans_huge(*vmf->pmd) &&\n\t\t\t!pmd_devmap(*vmf->pmd)) {\n\t\tresult = 0;\n\t\tgoto unlock_entry;\n\t}\n\n\t/*\n\t * Note that we don't use iomap_apply here.  We aren't doing I/O, only\n\t * setting up a mapping, so really we're using iomap_begin() as a way\n\t * to look up our filesystem block.\n\t */\n\tpos = (loff_t)xas.xa_index << PAGE_SHIFT;\n\terror = ops->iomap_begin(inode, pos, PMD_SIZE, iomap_flags, &iomap);\n\tif (error)\n\t\tgoto unlock_entry;\n\n\tif (iomap.offset + iomap.length < pos + PMD_SIZE)\n\t\tgoto finish_iomap;\n\n\tsync = dax_fault_is_synchronous(iomap_flags, vma, &iomap);\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\terror = dax_iomap_pfn(&iomap, pos, PMD_SIZE, &pfn);\n\t\tif (error < 0)\n\t\t\tgoto finish_iomap;\n\n\t\tentry = dax_insert_entry(&xas, mapping, vmf, entry, pfn,\n\t\t\t\t\t\tDAX_PMD, write && !sync);\n\n\t\t/*\n\t\t * If we are doing synchronous page fault and inode needs fsync,\n\t\t * we can insert PMD into page tables only after that happens.\n\t\t * Skip insertion for now and return the pfn so that caller can\n\t\t * insert it after fsync is done.\n\t\t */\n\t\tif (sync) {\n\t\t\tif (WARN_ON_ONCE(!pfnp))\n\t\t\t\tgoto finish_iomap;\n\t\t\t*pfnp = pfn;\n\t\t\tresult = VM_FAULT_NEEDDSYNC;\n\t\t\tgoto finish_iomap;\n\t\t}\n\n\t\ttrace_dax_pmd_insert_mapping(inode, vmf, PMD_SIZE, pfn, entry);\n\t\tresult = vmf_insert_pfn_pmd(vma, vmf->address, vmf->pmd, pfn,\n\t\t\t\t\t    write);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\tcase IOMAP_HOLE:\n\t\tif (WARN_ON_ONCE(write))\n\t\t\tbreak;\n\t\tresult = dax_pmd_load_hole(&xas, vmf, &iomap, &entry);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n finish_iomap:\n\tif (ops->iomap_end) {\n\t\tint copied = PMD_SIZE;\n\n\t\tif (result == VM_FAULT_FALLBACK)\n\t\t\tcopied = 0;\n\t\t/*\n\t\t * The fault is done by now and there's no way back (other\n\t\t * thread may be already happily using PMD we have installed).\n\t\t * Just ignore error from ->iomap_end since we cannot do much\n\t\t * with it.\n\t\t */\n\t\tops->iomap_end(inode, pos, PMD_SIZE, copied, iomap_flags,\n\t\t\t\t&iomap);\n\t}\n unlock_entry:\n\tdax_unlock_entry(&xas, entry);\n fallback:\n\tif (result == VM_FAULT_FALLBACK) {\n\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t}\nout:\n\ttrace_dax_pmd_fault_done(inode, vmf, max_pgoff, result);\n\treturn result;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_PMD\t\t(1UL << 1)",
      "#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)",
      "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_dax_pmd_fault_done",
          "args": [
            "inode",
            "vmf",
            "max_pgoff",
            "result"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_FAULT_FALLBACK"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_pmd",
          "args": [
            "vma",
            "vmf->pmd",
            "vmf->address"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_unlock_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "dax_unlock_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "247-258",
          "snippet": "static void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->iomap_end",
          "args": [
            "inode",
            "pos",
            "PMD_SIZE",
            "copied",
            "iomap_flags",
            "&iomap"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_pmd_load_hole",
          "args": [
            "&xas",
            "vmf",
            "&iomap",
            "&entry"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "dax_pmd_load_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1387-1423",
          "snippet": "static vm_fault_t dax_pmd_load_hole(struct xa_state *xas, struct vm_fault *vmf,\n\t\tstruct iomap *iomap, void **entry)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tunsigned long pmd_addr = vmf->address & PMD_MASK;\n\tstruct inode *inode = mapping->host;\n\tstruct page *zero_page;\n\tspinlock_t *ptl;\n\tpmd_t pmd_entry;\n\tpfn_t pfn;\n\n\tzero_page = mm_get_huge_zero_page(vmf->vma->vm_mm);\n\n\tif (unlikely(!zero_page))\n\t\tgoto fallback;\n\n\tpfn = page_to_pfn_t(zero_page);\n\t*entry = dax_insert_entry(xas, mapping, vmf, *entry, pfn,\n\t\t\tDAX_PMD | DAX_ZERO_PAGE, false);\n\n\tptl = pmd_lock(vmf->vma->vm_mm, vmf->pmd);\n\tif (!pmd_none(*(vmf->pmd))) {\n\t\tspin_unlock(ptl);\n\t\tgoto fallback;\n\t}\n\n\tpmd_entry = mk_pmd(zero_page, vmf->vma->vm_page_prot);\n\tpmd_entry = pmd_mkhuge(pmd_entry);\n\tset_pmd_at(vmf->vma->vm_mm, pmd_addr, vmf->pmd, pmd_entry);\n\tspin_unlock(ptl);\n\ttrace_dax_pmd_load_hole(inode, vmf, zero_page, *entry);\n\treturn VM_FAULT_NOPAGE;\n\nfallback:\n\ttrace_dax_pmd_load_hole_fallback(inode, vmf, zero_page, *entry);\n\treturn VM_FAULT_FALLBACK;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)",
            "#define DAX_PMD\t\t(1UL << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic vm_fault_t dax_pmd_load_hole(struct xa_state *xas, struct vm_fault *vmf,\n\t\tstruct iomap *iomap, void **entry)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tunsigned long pmd_addr = vmf->address & PMD_MASK;\n\tstruct inode *inode = mapping->host;\n\tstruct page *zero_page;\n\tspinlock_t *ptl;\n\tpmd_t pmd_entry;\n\tpfn_t pfn;\n\n\tzero_page = mm_get_huge_zero_page(vmf->vma->vm_mm);\n\n\tif (unlikely(!zero_page))\n\t\tgoto fallback;\n\n\tpfn = page_to_pfn_t(zero_page);\n\t*entry = dax_insert_entry(xas, mapping, vmf, *entry, pfn,\n\t\t\tDAX_PMD | DAX_ZERO_PAGE, false);\n\n\tptl = pmd_lock(vmf->vma->vm_mm, vmf->pmd);\n\tif (!pmd_none(*(vmf->pmd))) {\n\t\tspin_unlock(ptl);\n\t\tgoto fallback;\n\t}\n\n\tpmd_entry = mk_pmd(zero_page, vmf->vma->vm_page_prot);\n\tpmd_entry = pmd_mkhuge(pmd_entry);\n\tset_pmd_at(vmf->vma->vm_mm, pmd_addr, vmf->pmd, pmd_entry);\n\tspin_unlock(ptl);\n\ttrace_dax_pmd_load_hole(inode, vmf, zero_page, *entry);\n\treturn VM_FAULT_NOPAGE;\n\nfallback:\n\ttrace_dax_pmd_load_hole_fallback(inode, vmf, zero_page, *entry);\n\treturn VM_FAULT_FALLBACK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "write"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmf_insert_pfn_pmd",
          "args": [
            "vma",
            "vmf->address",
            "vmf->pmd",
            "pfn",
            "write"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_dax_pmd_insert_mapping",
          "args": [
            "inode",
            "vmf",
            "PMD_SIZE",
            "pfn",
            "entry"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pfnp"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_insert_entry",
          "args": [
            "&xas",
            "mapping",
            "vmf",
            "entry",
            "pfn",
            "DAX_PMD",
            "write && !sync"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "dax_insert_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "690-738",
          "snippet": "static void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)",
            "#define DAX_LOCKED\t(1UL << 0)",
            "#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)",
            "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n#define DAX_LOCKED\t(1UL << 0)\n#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n\nstatic void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_iomap_pfn",
          "args": [
            "&iomap",
            "pos",
            "PMD_SIZE",
            "&pfn"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "dax_iomap_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "965-995",
          "snippet": "static int dax_iomap_pfn(struct iomap *iomap, loff_t pos, size_t size,\n\t\t\t pfn_t *pfnp)\n{\n\tconst sector_t sector = dax_iomap_sector(iomap, pos);\n\tpgoff_t pgoff;\n\tint id, rc;\n\tlong length;\n\n\trc = bdev_dax_pgoff(iomap->bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\tid = dax_read_lock();\n\tlength = dax_direct_access(iomap->dax_dev, pgoff, PHYS_PFN(size),\n\t\t\t\t   NULL, pfnp);\n\tif (length < 0) {\n\t\trc = length;\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\tif (PFN_PHYS(length) < size)\n\t\tgoto out;\n\tif (pfn_t_to_pfn(*pfnp) & (PHYS_PFN(size)-1))\n\t\tgoto out;\n\t/* For larger pages we need devmap */\n\tif (length > 1 && !pfn_t_devmap(*pfnp))\n\t\tgoto out;\n\trc = 0;\nout:\n\tdax_read_unlock(id);\n\treturn rc;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int dax_iomap_pfn(struct iomap *iomap, loff_t pos, size_t size,\n\t\t\t pfn_t *pfnp)\n{\n\tconst sector_t sector = dax_iomap_sector(iomap, pos);\n\tpgoff_t pgoff;\n\tint id, rc;\n\tlong length;\n\n\trc = bdev_dax_pgoff(iomap->bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\tid = dax_read_lock();\n\tlength = dax_direct_access(iomap->dax_dev, pgoff, PHYS_PFN(size),\n\t\t\t\t   NULL, pfnp);\n\tif (length < 0) {\n\t\trc = length;\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\tif (PFN_PHYS(length) < size)\n\t\tgoto out;\n\tif (pfn_t_to_pfn(*pfnp) & (PHYS_PFN(size)-1))\n\t\tgoto out;\n\t/* For larger pages we need devmap */\n\tif (length > 1 && !pfn_t_devmap(*pfnp))\n\t\tgoto out;\n\trc = 0;\nout:\n\tdax_read_unlock(id);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_fault_is_synchronous",
          "args": [
            "iomap_flags",
            "vma",
            "&iomap"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "dax_fault_is_synchronous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1211-1216",
          "snippet": "static bool dax_fault_is_synchronous(unsigned long flags,\n\t\tstruct vm_area_struct *vma, struct iomap *iomap)\n{\n\treturn (flags & IOMAP_WRITE) && (vma->vm_flags & VM_SYNC)\n\t\t&& (iomap->flags & IOMAP_F_DIRTY);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool dax_fault_is_synchronous(unsigned long flags,\n\t\tstruct vm_area_struct *vma, struct iomap *iomap)\n{\n\treturn (flags & IOMAP_WRITE) && (vma->vm_flags & VM_SYNC)\n\t\t&& (iomap->flags & IOMAP_F_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->iomap_begin",
          "args": [
            "inode",
            "pos",
            "PMD_SIZE",
            "iomap_flags",
            "&iomap"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*vmf->pmd"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*vmf->pmd"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*vmf->pmd"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_to_internal",
          "args": [
            "entry"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_internal",
          "args": [
            "entry"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_mapping_entry",
          "args": [
            "&xas",
            "mapping",
            "DAX_PMD"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "grab_mapping_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "451-533",
          "snippet": "static void *grab_mapping_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, unsigned long size_flag)\n{\n\tunsigned long index = xas->xa_index;\n\tbool pmd_downgrade = false; /* splitting PMD entry into PTE entries? */\n\tvoid *entry;\n\nretry:\n\txas_lock_irq(xas);\n\tentry = get_unlocked_entry(xas);\n\n\tif (entry) {\n\t\tif (!xa_is_value(entry)) {\n\t\t\txas_set_err(xas, EIO);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (size_flag & DAX_PMD) {\n\t\t\tif (dax_is_pte_entry(entry)) {\n\t\t\t\tput_unlocked_entry(xas, entry);\n\t\t\t\tgoto fallback;\n\t\t\t}\n\t\t} else { /* trying to grab a PTE entry */\n\t\t\tif (dax_is_pmd_entry(entry) &&\n\t\t\t    (dax_is_zero_entry(entry) ||\n\t\t\t     dax_is_empty_entry(entry))) {\n\t\t\t\tpmd_downgrade = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pmd_downgrade) {\n\t\t/*\n\t\t * Make sure 'entry' remains valid while we drop\n\t\t * the i_pages lock.\n\t\t */\n\t\tdax_lock_entry(xas, entry);\n\n\t\t/*\n\t\t * Besides huge zero pages the only other thing that gets\n\t\t * downgraded are empty entries which don't need to be\n\t\t * unmapped.\n\t\t */\n\t\tif (dax_is_zero_entry(entry)) {\n\t\t\txas_unlock_irq(xas);\n\t\t\tunmap_mapping_pages(mapping,\n\t\t\t\t\txas->xa_index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\t\txas_reset(xas);\n\t\t\txas_lock_irq(xas);\n\t\t}\n\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\txas_store(xas, NULL);\t/* undo the PMD join */\n\t\tdax_wake_entry(xas, entry, true);\n\t\tmapping->nrexceptional--;\n\t\tentry = NULL;\n\t\txas_set(xas, index);\n\t}\n\n\tif (entry) {\n\t\tdax_lock_entry(xas, entry);\n\t} else {\n\t\tentry = dax_make_entry(pfn_to_pfn_t(0), size_flag | DAX_EMPTY);\n\t\tdax_lock_entry(xas, entry);\n\t\tif (xas_error(xas))\n\t\t\tgoto out_unlock;\n\t\tmapping->nrexceptional++;\n\t}\n\nout_unlock:\n\txas_unlock_irq(xas);\n\tif (xas_nomem(xas, mapping_gfp_mask(mapping) & ~__GFP_HIGHMEM))\n\t\tgoto retry;\n\tif (xas->xa_node == XA_ERROR(-ENOMEM))\n\t\treturn xa_mk_internal(VM_FAULT_OOM);\n\tif (xas_error(xas))\n\t\treturn xa_mk_internal(VM_FAULT_SIGBUS);\n\treturn entry;\nfallback:\n\txas_unlock_irq(xas);\n\treturn xa_mk_internal(VM_FAULT_FALLBACK);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_EMPTY\t(1UL << 3)",
            "#define DAX_PMD\t\t(1UL << 1)",
            "#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)",
            "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_EMPTY\t(1UL << 3)\n#define DAX_PMD\t\t(1UL << 1)\n#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n\nstatic void *grab_mapping_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, unsigned long size_flag)\n{\n\tunsigned long index = xas->xa_index;\n\tbool pmd_downgrade = false; /* splitting PMD entry into PTE entries? */\n\tvoid *entry;\n\nretry:\n\txas_lock_irq(xas);\n\tentry = get_unlocked_entry(xas);\n\n\tif (entry) {\n\t\tif (!xa_is_value(entry)) {\n\t\t\txas_set_err(xas, EIO);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (size_flag & DAX_PMD) {\n\t\t\tif (dax_is_pte_entry(entry)) {\n\t\t\t\tput_unlocked_entry(xas, entry);\n\t\t\t\tgoto fallback;\n\t\t\t}\n\t\t} else { /* trying to grab a PTE entry */\n\t\t\tif (dax_is_pmd_entry(entry) &&\n\t\t\t    (dax_is_zero_entry(entry) ||\n\t\t\t     dax_is_empty_entry(entry))) {\n\t\t\t\tpmd_downgrade = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pmd_downgrade) {\n\t\t/*\n\t\t * Make sure 'entry' remains valid while we drop\n\t\t * the i_pages lock.\n\t\t */\n\t\tdax_lock_entry(xas, entry);\n\n\t\t/*\n\t\t * Besides huge zero pages the only other thing that gets\n\t\t * downgraded are empty entries which don't need to be\n\t\t * unmapped.\n\t\t */\n\t\tif (dax_is_zero_entry(entry)) {\n\t\t\txas_unlock_irq(xas);\n\t\t\tunmap_mapping_pages(mapping,\n\t\t\t\t\txas->xa_index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\t\txas_reset(xas);\n\t\t\txas_lock_irq(xas);\n\t\t}\n\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\txas_store(xas, NULL);\t/* undo the PMD join */\n\t\tdax_wake_entry(xas, entry, true);\n\t\tmapping->nrexceptional--;\n\t\tentry = NULL;\n\t\txas_set(xas, index);\n\t}\n\n\tif (entry) {\n\t\tdax_lock_entry(xas, entry);\n\t} else {\n\t\tentry = dax_make_entry(pfn_to_pfn_t(0), size_flag | DAX_EMPTY);\n\t\tdax_lock_entry(xas, entry);\n\t\tif (xas_error(xas))\n\t\t\tgoto out_unlock;\n\t\tmapping->nrexceptional++;\n\t}\n\nout_unlock:\n\txas_unlock_irq(xas);\n\tif (xas_nomem(xas, mapping_gfp_mask(mapping) & ~__GFP_HIGHMEM))\n\t\tgoto retry;\n\tif (xas->xa_node == XA_ERROR(-ENOMEM))\n\t\treturn xa_mk_internal(VM_FAULT_OOM);\n\tif (xas_error(xas))\n\t\treturn xa_mk_internal(VM_FAULT_SIGBUS);\n\treturn entry;\nfallback:\n\txas_unlock_irq(xas);\n\treturn xa_mk_internal(VM_FAULT_FALLBACK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_dax_pmd_fault",
          "args": [
            "inode",
            "vmf",
            "max_pgoff",
            "0"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "i_size_read(inode)",
            "PAGE_SIZE"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE_ORDER",
          "args": [
            "xas",
            "&mapping->i_pages",
            "vmf->pgoff",
            "PMD_ORDER"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n\nstatic vm_fault_t dax_iomap_pmd_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       const struct iomap_ops *ops)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tXA_STATE_ORDER(xas, &mapping->i_pages, vmf->pgoff, PMD_ORDER);\n\tunsigned long pmd_addr = vmf->address & PMD_MASK;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tbool sync;\n\tunsigned int iomap_flags = (write ? IOMAP_WRITE : 0) | IOMAP_FAULT;\n\tstruct inode *inode = mapping->host;\n\tvm_fault_t result = VM_FAULT_FALLBACK;\n\tstruct iomap iomap = { 0 };\n\tpgoff_t max_pgoff;\n\tvoid *entry;\n\tloff_t pos;\n\tint error;\n\tpfn_t pfn;\n\n\t/*\n\t * Check whether offset isn't beyond end of file now. Caller is\n\t * supposed to hold locks serializing us with truncate / punch hole so\n\t * this is a reliable test.\n\t */\n\tmax_pgoff = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);\n\n\ttrace_dax_pmd_fault(inode, vmf, max_pgoff, 0);\n\n\t/*\n\t * Make sure that the faulting address's PMD offset (color) matches\n\t * the PMD offset from the start of the file.  This is necessary so\n\t * that a PMD range in the page table overlaps exactly with a PMD\n\t * range in the page cache.\n\t */\n\tif ((vmf->pgoff & PG_PMD_COLOUR) !=\n\t    ((vmf->address >> PAGE_SHIFT) & PG_PMD_COLOUR))\n\t\tgoto fallback;\n\n\t/* Fall back to PTEs if we're going to COW */\n\tif (write && !(vma->vm_flags & VM_SHARED))\n\t\tgoto fallback;\n\n\t/* If the PMD would extend outside the VMA */\n\tif (pmd_addr < vma->vm_start)\n\t\tgoto fallback;\n\tif ((pmd_addr + PMD_SIZE) > vma->vm_end)\n\t\tgoto fallback;\n\n\tif (xas.xa_index >= max_pgoff) {\n\t\tresult = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\t/* If the PMD would extend beyond the file size */\n\tif ((xas.xa_index | PG_PMD_COLOUR) >= max_pgoff)\n\t\tgoto fallback;\n\n\t/*\n\t * grab_mapping_entry() will make sure we get an empty PMD entry,\n\t * a zero PMD entry or a DAX PMD.  If it can't (because a PTE\n\t * entry is already in the array, for instance), it will return\n\t * VM_FAULT_FALLBACK.\n\t */\n\tentry = grab_mapping_entry(&xas, mapping, DAX_PMD);\n\tif (xa_is_internal(entry)) {\n\t\tresult = xa_to_internal(entry);\n\t\tgoto fallback;\n\t}\n\n\t/*\n\t * It is possible, particularly with mixed reads & writes to private\n\t * mappings, that we have raced with a PTE fault that overlaps with\n\t * the PMD we need to set up.  If so just return and the fault will be\n\t * retried.\n\t */\n\tif (!pmd_none(*vmf->pmd) && !pmd_trans_huge(*vmf->pmd) &&\n\t\t\t!pmd_devmap(*vmf->pmd)) {\n\t\tresult = 0;\n\t\tgoto unlock_entry;\n\t}\n\n\t/*\n\t * Note that we don't use iomap_apply here.  We aren't doing I/O, only\n\t * setting up a mapping, so really we're using iomap_begin() as a way\n\t * to look up our filesystem block.\n\t */\n\tpos = (loff_t)xas.xa_index << PAGE_SHIFT;\n\terror = ops->iomap_begin(inode, pos, PMD_SIZE, iomap_flags, &iomap);\n\tif (error)\n\t\tgoto unlock_entry;\n\n\tif (iomap.offset + iomap.length < pos + PMD_SIZE)\n\t\tgoto finish_iomap;\n\n\tsync = dax_fault_is_synchronous(iomap_flags, vma, &iomap);\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\terror = dax_iomap_pfn(&iomap, pos, PMD_SIZE, &pfn);\n\t\tif (error < 0)\n\t\t\tgoto finish_iomap;\n\n\t\tentry = dax_insert_entry(&xas, mapping, vmf, entry, pfn,\n\t\t\t\t\t\tDAX_PMD, write && !sync);\n\n\t\t/*\n\t\t * If we are doing synchronous page fault and inode needs fsync,\n\t\t * we can insert PMD into page tables only after that happens.\n\t\t * Skip insertion for now and return the pfn so that caller can\n\t\t * insert it after fsync is done.\n\t\t */\n\t\tif (sync) {\n\t\t\tif (WARN_ON_ONCE(!pfnp))\n\t\t\t\tgoto finish_iomap;\n\t\t\t*pfnp = pfn;\n\t\t\tresult = VM_FAULT_NEEDDSYNC;\n\t\t\tgoto finish_iomap;\n\t\t}\n\n\t\ttrace_dax_pmd_insert_mapping(inode, vmf, PMD_SIZE, pfn, entry);\n\t\tresult = vmf_insert_pfn_pmd(vma, vmf->address, vmf->pmd, pfn,\n\t\t\t\t\t    write);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\tcase IOMAP_HOLE:\n\t\tif (WARN_ON_ONCE(write))\n\t\t\tbreak;\n\t\tresult = dax_pmd_load_hole(&xas, vmf, &iomap, &entry);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n finish_iomap:\n\tif (ops->iomap_end) {\n\t\tint copied = PMD_SIZE;\n\n\t\tif (result == VM_FAULT_FALLBACK)\n\t\t\tcopied = 0;\n\t\t/*\n\t\t * The fault is done by now and there's no way back (other\n\t\t * thread may be already happily using PMD we have installed).\n\t\t * Just ignore error from ->iomap_end since we cannot do much\n\t\t * with it.\n\t\t */\n\t\tops->iomap_end(inode, pos, PMD_SIZE, copied, iomap_flags,\n\t\t\t\t&iomap);\n\t}\n unlock_entry:\n\tdax_unlock_entry(&xas, entry);\n fallback:\n\tif (result == VM_FAULT_FALLBACK) {\n\t\tsplit_huge_pmd(vma, vmf->pmd, vmf->address);\n\t\tcount_vm_event(THP_FAULT_FALLBACK);\n\t}\nout:\n\ttrace_dax_pmd_fault_done(inode, vmf, max_pgoff, result);\n\treturn result;\n}"
  },
  {
    "function_name": "dax_pmd_load_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1387-1423",
    "snippet": "static vm_fault_t dax_pmd_load_hole(struct xa_state *xas, struct vm_fault *vmf,\n\t\tstruct iomap *iomap, void **entry)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tunsigned long pmd_addr = vmf->address & PMD_MASK;\n\tstruct inode *inode = mapping->host;\n\tstruct page *zero_page;\n\tspinlock_t *ptl;\n\tpmd_t pmd_entry;\n\tpfn_t pfn;\n\n\tzero_page = mm_get_huge_zero_page(vmf->vma->vm_mm);\n\n\tif (unlikely(!zero_page))\n\t\tgoto fallback;\n\n\tpfn = page_to_pfn_t(zero_page);\n\t*entry = dax_insert_entry(xas, mapping, vmf, *entry, pfn,\n\t\t\tDAX_PMD | DAX_ZERO_PAGE, false);\n\n\tptl = pmd_lock(vmf->vma->vm_mm, vmf->pmd);\n\tif (!pmd_none(*(vmf->pmd))) {\n\t\tspin_unlock(ptl);\n\t\tgoto fallback;\n\t}\n\n\tpmd_entry = mk_pmd(zero_page, vmf->vma->vm_page_prot);\n\tpmd_entry = pmd_mkhuge(pmd_entry);\n\tset_pmd_at(vmf->vma->vm_mm, pmd_addr, vmf->pmd, pmd_entry);\n\tspin_unlock(ptl);\n\ttrace_dax_pmd_load_hole(inode, vmf, zero_page, *entry);\n\treturn VM_FAULT_NOPAGE;\n\nfallback:\n\ttrace_dax_pmd_load_hole_fallback(inode, vmf, zero_page, *entry);\n\treturn VM_FAULT_FALLBACK;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_ZERO_PAGE\t(1UL << 2)",
      "#define DAX_PMD\t\t(1UL << 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_dax_pmd_load_hole_fallback",
          "args": [
            "inode",
            "vmf",
            "zero_page",
            "*entry"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_dax_pmd_load_hole",
          "args": [
            "inode",
            "vmf",
            "zero_page",
            "*entry"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "vmf->vma->vm_mm",
            "pmd_addr",
            "vmf->pmd",
            "pmd_entry"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkhuge",
          "args": [
            "pmd_entry"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pmd",
          "args": [
            "zero_page",
            "vmf->vma->vm_page_prot"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*(vmf->pmd)"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vmf->vma->vm_mm",
            "vmf->pmd"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_insert_entry",
          "args": [
            "xas",
            "mapping",
            "vmf",
            "*entry",
            "pfn",
            "DAX_PMD | DAX_ZERO_PAGE",
            "false"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "dax_insert_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "690-738",
          "snippet": "static void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)",
            "#define DAX_LOCKED\t(1UL << 0)",
            "#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)",
            "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n#define DAX_LOCKED\t(1UL << 0)\n#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n\nstatic void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn_t",
          "args": [
            "zero_page"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!zero_page"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_get_huge_zero_page",
          "args": [
            "vmf->vma->vm_mm"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic vm_fault_t dax_pmd_load_hole(struct xa_state *xas, struct vm_fault *vmf,\n\t\tstruct iomap *iomap, void **entry)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tunsigned long pmd_addr = vmf->address & PMD_MASK;\n\tstruct inode *inode = mapping->host;\n\tstruct page *zero_page;\n\tspinlock_t *ptl;\n\tpmd_t pmd_entry;\n\tpfn_t pfn;\n\n\tzero_page = mm_get_huge_zero_page(vmf->vma->vm_mm);\n\n\tif (unlikely(!zero_page))\n\t\tgoto fallback;\n\n\tpfn = page_to_pfn_t(zero_page);\n\t*entry = dax_insert_entry(xas, mapping, vmf, *entry, pfn,\n\t\t\tDAX_PMD | DAX_ZERO_PAGE, false);\n\n\tptl = pmd_lock(vmf->vma->vm_mm, vmf->pmd);\n\tif (!pmd_none(*(vmf->pmd))) {\n\t\tspin_unlock(ptl);\n\t\tgoto fallback;\n\t}\n\n\tpmd_entry = mk_pmd(zero_page, vmf->vma->vm_page_prot);\n\tpmd_entry = pmd_mkhuge(pmd_entry);\n\tset_pmd_at(vmf->vma->vm_mm, pmd_addr, vmf->pmd, pmd_entry);\n\tspin_unlock(ptl);\n\ttrace_dax_pmd_load_hole(inode, vmf, zero_page, *entry);\n\treturn VM_FAULT_NOPAGE;\n\nfallback:\n\ttrace_dax_pmd_load_hole_fallback(inode, vmf, zero_page, *entry);\n\treturn VM_FAULT_FALLBACK;\n}"
  },
  {
    "function_name": "dax_iomap_pte_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1218-1384",
    "snippet": "static vm_fault_t dax_iomap_pte_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       int *iomap_errp, const struct iomap_ops *ops)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tXA_STATE(xas, &mapping->i_pages, vmf->pgoff);\n\tstruct inode *inode = mapping->host;\n\tunsigned long vaddr = vmf->address;\n\tloff_t pos = (loff_t)vmf->pgoff << PAGE_SHIFT;\n\tstruct iomap iomap = { 0 };\n\tunsigned flags = IOMAP_FAULT;\n\tint error, major = 0;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tbool sync;\n\tvm_fault_t ret = 0;\n\tvoid *entry;\n\tpfn_t pfn;\n\n\ttrace_dax_pte_fault(inode, vmf, ret);\n\t/*\n\t * Check whether offset isn't beyond end of file now. Caller is supposed\n\t * to hold locks serializing us with truncate / punch hole so this is\n\t * a reliable test.\n\t */\n\tif (pos >= i_size_read(inode)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\tif (write && !vmf->cow_page)\n\t\tflags |= IOMAP_WRITE;\n\n\tentry = grab_mapping_entry(&xas, mapping, 0);\n\tif (xa_is_internal(entry)) {\n\t\tret = xa_to_internal(entry);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is possible, particularly with mixed reads & writes to private\n\t * mappings, that we have raced with a PMD fault that overlaps with\n\t * the PTE we need to set up.  If so just return and the fault will be\n\t * retried.\n\t */\n\tif (pmd_trans_huge(*vmf->pmd) || pmd_devmap(*vmf->pmd)) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto unlock_entry;\n\t}\n\n\t/*\n\t * Note that we don't bother to use iomap_apply here: DAX required\n\t * the file system block size to be equal the page size, which means\n\t * that we never have to deal with more than a single extent here.\n\t */\n\terror = ops->iomap_begin(inode, pos, PAGE_SIZE, flags, &iomap);\n\tif (iomap_errp)\n\t\t*iomap_errp = error;\n\tif (error) {\n\t\tret = dax_fault_return(error);\n\t\tgoto unlock_entry;\n\t}\n\tif (WARN_ON_ONCE(iomap.offset + iomap.length < pos + PAGE_SIZE)) {\n\t\terror = -EIO;\t/* fs corruption? */\n\t\tgoto error_finish_iomap;\n\t}\n\n\tif (vmf->cow_page) {\n\t\tsector_t sector = dax_iomap_sector(&iomap, pos);\n\n\t\tswitch (iomap.type) {\n\t\tcase IOMAP_HOLE:\n\t\tcase IOMAP_UNWRITTEN:\n\t\t\tclear_user_highpage(vmf->cow_page, vaddr);\n\t\t\tbreak;\n\t\tcase IOMAP_MAPPED:\n\t\t\terror = copy_user_dax(iomap.bdev, iomap.dax_dev,\n\t\t\t\t\tsector, PAGE_SIZE, vmf->cow_page, vaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error_finish_iomap;\n\n\t\t__SetPageUptodate(vmf->cow_page);\n\t\tret = finish_fault(vmf);\n\t\tif (!ret)\n\t\t\tret = VM_FAULT_DONE_COW;\n\t\tgoto finish_iomap;\n\t}\n\n\tsync = dax_fault_is_synchronous(flags, vma, &iomap);\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\tif (iomap.flags & IOMAP_F_NEW) {\n\t\t\tcount_vm_event(PGMAJFAULT);\n\t\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t\t\tmajor = VM_FAULT_MAJOR;\n\t\t}\n\t\terror = dax_iomap_pfn(&iomap, pos, PAGE_SIZE, &pfn);\n\t\tif (error < 0)\n\t\t\tgoto error_finish_iomap;\n\n\t\tentry = dax_insert_entry(&xas, mapping, vmf, entry, pfn,\n\t\t\t\t\t\t 0, write && !sync);\n\n\t\t/*\n\t\t * If we are doing synchronous page fault and inode needs fsync,\n\t\t * we can insert PTE into page tables only after that happens.\n\t\t * Skip insertion for now and return the pfn so that caller can\n\t\t * insert it after fsync is done.\n\t\t */\n\t\tif (sync) {\n\t\t\tif (WARN_ON_ONCE(!pfnp)) {\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto error_finish_iomap;\n\t\t\t}\n\t\t\t*pfnp = pfn;\n\t\t\tret = VM_FAULT_NEEDDSYNC | major;\n\t\t\tgoto finish_iomap;\n\t\t}\n\t\ttrace_dax_insert_mapping(inode, vmf, entry);\n\t\tif (write)\n\t\t\tret = vmf_insert_mixed_mkwrite(vma, vaddr, pfn);\n\t\telse\n\t\t\tret = vmf_insert_mixed(vma, vaddr, pfn);\n\n\t\tgoto finish_iomap;\n\tcase IOMAP_UNWRITTEN:\n\tcase IOMAP_HOLE:\n\t\tif (!write) {\n\t\t\tret = dax_load_hole(&xas, mapping, &entry, vmf);\n\t\t\tgoto finish_iomap;\n\t\t}\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\terror = -EIO;\n\t\tbreak;\n\t}\n\n error_finish_iomap:\n\tret = dax_fault_return(error);\n finish_iomap:\n\tif (ops->iomap_end) {\n\t\tint copied = PAGE_SIZE;\n\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tcopied = 0;\n\t\t/*\n\t\t * The fault is done by now and there's no way back (other\n\t\t * thread may be already happily using PTE we have installed).\n\t\t * Just ignore error from ->iomap_end since we cannot do much\n\t\t * with it.\n\t\t */\n\t\tops->iomap_end(inode, pos, PAGE_SIZE, copied, flags, &iomap);\n\t}\n unlock_entry:\n\tdax_unlock_entry(&xas, entry);\n out:\n\ttrace_dax_pte_fault_done(inode, vmf, ret);\n\treturn ret | major;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_dax_pte_fault_done",
          "args": [
            "inode",
            "vmf",
            "ret"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_unlock_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "dax_unlock_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "247-258",
          "snippet": "static void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->iomap_end",
          "args": [
            "inode",
            "pos",
            "PAGE_SIZE",
            "copied",
            "flags",
            "&iomap"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_fault_return",
          "args": [
            "error"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "dax_fault_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1198-1205",
          "snippet": "static vm_fault_t dax_fault_return(int error)\n{\n\tif (error == 0)\n\t\treturn VM_FAULT_NOPAGE;\n\tif (error == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\treturn VM_FAULT_SIGBUS;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic vm_fault_t dax_fault_return(int error)\n{\n\tif (error == 0)\n\t\treturn VM_FAULT_NOPAGE;\n\tif (error == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\treturn VM_FAULT_SIGBUS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_load_hole",
          "args": [
            "&xas",
            "mapping",
            "&entry",
            "vmf"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "dax_load_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1004-1019",
          "snippet": "static vm_fault_t dax_load_hole(struct xa_state *xas,\n\t\tstruct address_space *mapping, void **entry,\n\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned long vaddr = vmf->address;\n\tpfn_t pfn = pfn_to_pfn_t(my_zero_pfn(vaddr));\n\tvm_fault_t ret;\n\n\t*entry = dax_insert_entry(xas, mapping, vmf, *entry, pfn,\n\t\t\tDAX_ZERO_PAGE, false);\n\n\tret = vmf_insert_mixed(vmf->vma, vaddr, pfn);\n\ttrace_dax_load_hole(inode, vmf, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n\nstatic vm_fault_t dax_load_hole(struct xa_state *xas,\n\t\tstruct address_space *mapping, void **entry,\n\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned long vaddr = vmf->address;\n\tpfn_t pfn = pfn_to_pfn_t(my_zero_pfn(vaddr));\n\tvm_fault_t ret;\n\n\t*entry = dax_insert_entry(xas, mapping, vmf, *entry, pfn,\n\t\t\tDAX_ZERO_PAGE, false);\n\n\tret = vmf_insert_mixed(vmf->vma, vaddr, pfn);\n\ttrace_dax_load_hole(inode, vmf, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmf_insert_mixed",
          "args": [
            "vma",
            "vaddr",
            "pfn"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmf_insert_mixed_mkwrite",
          "args": [
            "vma",
            "vaddr",
            "pfn"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_dax_insert_mapping",
          "args": [
            "inode",
            "vmf",
            "entry"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pfnp"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_insert_entry",
          "args": [
            "&xas",
            "mapping",
            "vmf",
            "entry",
            "pfn",
            "0",
            "write && !sync"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "dax_insert_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "690-738",
          "snippet": "static void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)",
            "#define DAX_LOCKED\t(1UL << 0)",
            "#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)",
            "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n#define DAX_LOCKED\t(1UL << 0)\n#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n\nstatic void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_iomap_pfn",
          "args": [
            "&iomap",
            "pos",
            "PAGE_SIZE",
            "&pfn"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "dax_iomap_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "965-995",
          "snippet": "static int dax_iomap_pfn(struct iomap *iomap, loff_t pos, size_t size,\n\t\t\t pfn_t *pfnp)\n{\n\tconst sector_t sector = dax_iomap_sector(iomap, pos);\n\tpgoff_t pgoff;\n\tint id, rc;\n\tlong length;\n\n\trc = bdev_dax_pgoff(iomap->bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\tid = dax_read_lock();\n\tlength = dax_direct_access(iomap->dax_dev, pgoff, PHYS_PFN(size),\n\t\t\t\t   NULL, pfnp);\n\tif (length < 0) {\n\t\trc = length;\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\tif (PFN_PHYS(length) < size)\n\t\tgoto out;\n\tif (pfn_t_to_pfn(*pfnp) & (PHYS_PFN(size)-1))\n\t\tgoto out;\n\t/* For larger pages we need devmap */\n\tif (length > 1 && !pfn_t_devmap(*pfnp))\n\t\tgoto out;\n\trc = 0;\nout:\n\tdax_read_unlock(id);\n\treturn rc;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int dax_iomap_pfn(struct iomap *iomap, loff_t pos, size_t size,\n\t\t\t pfn_t *pfnp)\n{\n\tconst sector_t sector = dax_iomap_sector(iomap, pos);\n\tpgoff_t pgoff;\n\tint id, rc;\n\tlong length;\n\n\trc = bdev_dax_pgoff(iomap->bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\tid = dax_read_lock();\n\tlength = dax_direct_access(iomap->dax_dev, pgoff, PHYS_PFN(size),\n\t\t\t\t   NULL, pfnp);\n\tif (length < 0) {\n\t\trc = length;\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\tif (PFN_PHYS(length) < size)\n\t\tgoto out;\n\tif (pfn_t_to_pfn(*pfnp) & (PHYS_PFN(size)-1))\n\t\tgoto out;\n\t/* For larger pages we need devmap */\n\tif (length > 1 && !pfn_t_devmap(*pfnp))\n\t\tgoto out;\n\trc = 0;\nout:\n\tdax_read_unlock(id);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_memcg_event_mm",
          "args": [
            "vma->vm_mm",
            "PGMAJFAULT"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PGMAJFAULT"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_fault_is_synchronous",
          "args": [
            "flags",
            "vma",
            "&iomap"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "dax_fault_is_synchronous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1211-1216",
          "snippet": "static bool dax_fault_is_synchronous(unsigned long flags,\n\t\tstruct vm_area_struct *vma, struct iomap *iomap)\n{\n\treturn (flags & IOMAP_WRITE) && (vma->vm_flags & VM_SYNC)\n\t\t&& (iomap->flags & IOMAP_F_DIRTY);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool dax_fault_is_synchronous(unsigned long flags,\n\t\tstruct vm_area_struct *vma, struct iomap *iomap)\n{\n\treturn (flags & IOMAP_WRITE) && (vma->vm_flags & VM_SYNC)\n\t\t&& (iomap->flags & IOMAP_F_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_fault",
          "args": [
            "vmf"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "vmf->cow_page"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_user_dax",
          "args": [
            "iomap.bdev",
            "iomap.dax_dev",
            "sector",
            "PAGE_SIZE",
            "vmf->cow_page",
            "vaddr"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "copy_user_dax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "657-681",
          "snippet": "static int copy_user_dax(struct block_device *bdev, struct dax_device *dax_dev,\n\t\tsector_t sector, size_t size, struct page *to,\n\t\tunsigned long vaddr)\n{\n\tvoid *vto, *kaddr;\n\tpgoff_t pgoff;\n\tlong rc;\n\tint id;\n\n\trc = bdev_dax_pgoff(bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\n\tid = dax_read_lock();\n\trc = dax_direct_access(dax_dev, pgoff, PHYS_PFN(size), &kaddr, NULL);\n\tif (rc < 0) {\n\t\tdax_read_unlock(id);\n\t\treturn rc;\n\t}\n\tvto = kmap_atomic(to);\n\tcopy_user_page(vto, (void __force *)kaddr, vaddr, to);\n\tkunmap_atomic(vto);\n\tdax_read_unlock(id);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int copy_user_dax(struct block_device *bdev, struct dax_device *dax_dev,\n\t\tsector_t sector, size_t size, struct page *to,\n\t\tunsigned long vaddr)\n{\n\tvoid *vto, *kaddr;\n\tpgoff_t pgoff;\n\tlong rc;\n\tint id;\n\n\trc = bdev_dax_pgoff(bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\n\tid = dax_read_lock();\n\trc = dax_direct_access(dax_dev, pgoff, PHYS_PFN(size), &kaddr, NULL);\n\tif (rc < 0) {\n\t\tdax_read_unlock(id);\n\t\treturn rc;\n\t}\n\tvto = kmap_atomic(to);\n\tcopy_user_page(vto, (void __force *)kaddr, vaddr, to);\n\tkunmap_atomic(vto);\n\tdax_read_unlock(id);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_user_highpage",
          "args": [
            "vmf->cow_page",
            "vaddr"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_iomap_sector",
          "args": [
            "&iomap",
            "pos"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "dax_iomap_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "960-963",
          "snippet": "static sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + (pos & PAGE_MASK) - iomap->offset) >> 9;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + (pos & PAGE_MASK) - iomap->offset) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "iomap.offset + iomap.length < pos + PAGE_SIZE"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->iomap_begin",
          "args": [
            "inode",
            "pos",
            "PAGE_SIZE",
            "flags",
            "&iomap"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*vmf->pmd"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*vmf->pmd"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_to_internal",
          "args": [
            "entry"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_internal",
          "args": [
            "entry"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_mapping_entry",
          "args": [
            "&xas",
            "mapping",
            "0"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "grab_mapping_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "451-533",
          "snippet": "static void *grab_mapping_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, unsigned long size_flag)\n{\n\tunsigned long index = xas->xa_index;\n\tbool pmd_downgrade = false; /* splitting PMD entry into PTE entries? */\n\tvoid *entry;\n\nretry:\n\txas_lock_irq(xas);\n\tentry = get_unlocked_entry(xas);\n\n\tif (entry) {\n\t\tif (!xa_is_value(entry)) {\n\t\t\txas_set_err(xas, EIO);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (size_flag & DAX_PMD) {\n\t\t\tif (dax_is_pte_entry(entry)) {\n\t\t\t\tput_unlocked_entry(xas, entry);\n\t\t\t\tgoto fallback;\n\t\t\t}\n\t\t} else { /* trying to grab a PTE entry */\n\t\t\tif (dax_is_pmd_entry(entry) &&\n\t\t\t    (dax_is_zero_entry(entry) ||\n\t\t\t     dax_is_empty_entry(entry))) {\n\t\t\t\tpmd_downgrade = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pmd_downgrade) {\n\t\t/*\n\t\t * Make sure 'entry' remains valid while we drop\n\t\t * the i_pages lock.\n\t\t */\n\t\tdax_lock_entry(xas, entry);\n\n\t\t/*\n\t\t * Besides huge zero pages the only other thing that gets\n\t\t * downgraded are empty entries which don't need to be\n\t\t * unmapped.\n\t\t */\n\t\tif (dax_is_zero_entry(entry)) {\n\t\t\txas_unlock_irq(xas);\n\t\t\tunmap_mapping_pages(mapping,\n\t\t\t\t\txas->xa_index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\t\txas_reset(xas);\n\t\t\txas_lock_irq(xas);\n\t\t}\n\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\txas_store(xas, NULL);\t/* undo the PMD join */\n\t\tdax_wake_entry(xas, entry, true);\n\t\tmapping->nrexceptional--;\n\t\tentry = NULL;\n\t\txas_set(xas, index);\n\t}\n\n\tif (entry) {\n\t\tdax_lock_entry(xas, entry);\n\t} else {\n\t\tentry = dax_make_entry(pfn_to_pfn_t(0), size_flag | DAX_EMPTY);\n\t\tdax_lock_entry(xas, entry);\n\t\tif (xas_error(xas))\n\t\t\tgoto out_unlock;\n\t\tmapping->nrexceptional++;\n\t}\n\nout_unlock:\n\txas_unlock_irq(xas);\n\tif (xas_nomem(xas, mapping_gfp_mask(mapping) & ~__GFP_HIGHMEM))\n\t\tgoto retry;\n\tif (xas->xa_node == XA_ERROR(-ENOMEM))\n\t\treturn xa_mk_internal(VM_FAULT_OOM);\n\tif (xas_error(xas))\n\t\treturn xa_mk_internal(VM_FAULT_SIGBUS);\n\treturn entry;\nfallback:\n\txas_unlock_irq(xas);\n\treturn xa_mk_internal(VM_FAULT_FALLBACK);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_EMPTY\t(1UL << 3)",
            "#define DAX_PMD\t\t(1UL << 1)",
            "#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)",
            "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_EMPTY\t(1UL << 3)\n#define DAX_PMD\t\t(1UL << 1)\n#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n\nstatic void *grab_mapping_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, unsigned long size_flag)\n{\n\tunsigned long index = xas->xa_index;\n\tbool pmd_downgrade = false; /* splitting PMD entry into PTE entries? */\n\tvoid *entry;\n\nretry:\n\txas_lock_irq(xas);\n\tentry = get_unlocked_entry(xas);\n\n\tif (entry) {\n\t\tif (!xa_is_value(entry)) {\n\t\t\txas_set_err(xas, EIO);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (size_flag & DAX_PMD) {\n\t\t\tif (dax_is_pte_entry(entry)) {\n\t\t\t\tput_unlocked_entry(xas, entry);\n\t\t\t\tgoto fallback;\n\t\t\t}\n\t\t} else { /* trying to grab a PTE entry */\n\t\t\tif (dax_is_pmd_entry(entry) &&\n\t\t\t    (dax_is_zero_entry(entry) ||\n\t\t\t     dax_is_empty_entry(entry))) {\n\t\t\t\tpmd_downgrade = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pmd_downgrade) {\n\t\t/*\n\t\t * Make sure 'entry' remains valid while we drop\n\t\t * the i_pages lock.\n\t\t */\n\t\tdax_lock_entry(xas, entry);\n\n\t\t/*\n\t\t * Besides huge zero pages the only other thing that gets\n\t\t * downgraded are empty entries which don't need to be\n\t\t * unmapped.\n\t\t */\n\t\tif (dax_is_zero_entry(entry)) {\n\t\t\txas_unlock_irq(xas);\n\t\t\tunmap_mapping_pages(mapping,\n\t\t\t\t\txas->xa_index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\t\txas_reset(xas);\n\t\t\txas_lock_irq(xas);\n\t\t}\n\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\txas_store(xas, NULL);\t/* undo the PMD join */\n\t\tdax_wake_entry(xas, entry, true);\n\t\tmapping->nrexceptional--;\n\t\tentry = NULL;\n\t\txas_set(xas, index);\n\t}\n\n\tif (entry) {\n\t\tdax_lock_entry(xas, entry);\n\t} else {\n\t\tentry = dax_make_entry(pfn_to_pfn_t(0), size_flag | DAX_EMPTY);\n\t\tdax_lock_entry(xas, entry);\n\t\tif (xas_error(xas))\n\t\t\tgoto out_unlock;\n\t\tmapping->nrexceptional++;\n\t}\n\nout_unlock:\n\txas_unlock_irq(xas);\n\tif (xas_nomem(xas, mapping_gfp_mask(mapping) & ~__GFP_HIGHMEM))\n\t\tgoto retry;\n\tif (xas->xa_node == XA_ERROR(-ENOMEM))\n\t\treturn xa_mk_internal(VM_FAULT_OOM);\n\tif (xas_error(xas))\n\t\treturn xa_mk_internal(VM_FAULT_SIGBUS);\n\treturn entry;\nfallback:\n\txas_unlock_irq(xas);\n\treturn xa_mk_internal(VM_FAULT_FALLBACK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_dax_pte_fault",
          "args": [
            "inode",
            "vmf",
            "ret"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "vmf->pgoff"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic vm_fault_t dax_iomap_pte_fault(struct vm_fault *vmf, pfn_t *pfnp,\n\t\t\t       int *iomap_errp, const struct iomap_ops *ops)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tXA_STATE(xas, &mapping->i_pages, vmf->pgoff);\n\tstruct inode *inode = mapping->host;\n\tunsigned long vaddr = vmf->address;\n\tloff_t pos = (loff_t)vmf->pgoff << PAGE_SHIFT;\n\tstruct iomap iomap = { 0 };\n\tunsigned flags = IOMAP_FAULT;\n\tint error, major = 0;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tbool sync;\n\tvm_fault_t ret = 0;\n\tvoid *entry;\n\tpfn_t pfn;\n\n\ttrace_dax_pte_fault(inode, vmf, ret);\n\t/*\n\t * Check whether offset isn't beyond end of file now. Caller is supposed\n\t * to hold locks serializing us with truncate / punch hole so this is\n\t * a reliable test.\n\t */\n\tif (pos >= i_size_read(inode)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\n\tif (write && !vmf->cow_page)\n\t\tflags |= IOMAP_WRITE;\n\n\tentry = grab_mapping_entry(&xas, mapping, 0);\n\tif (xa_is_internal(entry)) {\n\t\tret = xa_to_internal(entry);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is possible, particularly with mixed reads & writes to private\n\t * mappings, that we have raced with a PMD fault that overlaps with\n\t * the PTE we need to set up.  If so just return and the fault will be\n\t * retried.\n\t */\n\tif (pmd_trans_huge(*vmf->pmd) || pmd_devmap(*vmf->pmd)) {\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto unlock_entry;\n\t}\n\n\t/*\n\t * Note that we don't bother to use iomap_apply here: DAX required\n\t * the file system block size to be equal the page size, which means\n\t * that we never have to deal with more than a single extent here.\n\t */\n\terror = ops->iomap_begin(inode, pos, PAGE_SIZE, flags, &iomap);\n\tif (iomap_errp)\n\t\t*iomap_errp = error;\n\tif (error) {\n\t\tret = dax_fault_return(error);\n\t\tgoto unlock_entry;\n\t}\n\tif (WARN_ON_ONCE(iomap.offset + iomap.length < pos + PAGE_SIZE)) {\n\t\terror = -EIO;\t/* fs corruption? */\n\t\tgoto error_finish_iomap;\n\t}\n\n\tif (vmf->cow_page) {\n\t\tsector_t sector = dax_iomap_sector(&iomap, pos);\n\n\t\tswitch (iomap.type) {\n\t\tcase IOMAP_HOLE:\n\t\tcase IOMAP_UNWRITTEN:\n\t\t\tclear_user_highpage(vmf->cow_page, vaddr);\n\t\t\tbreak;\n\t\tcase IOMAP_MAPPED:\n\t\t\terror = copy_user_dax(iomap.bdev, iomap.dax_dev,\n\t\t\t\t\tsector, PAGE_SIZE, vmf->cow_page, vaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto error_finish_iomap;\n\n\t\t__SetPageUptodate(vmf->cow_page);\n\t\tret = finish_fault(vmf);\n\t\tif (!ret)\n\t\t\tret = VM_FAULT_DONE_COW;\n\t\tgoto finish_iomap;\n\t}\n\n\tsync = dax_fault_is_synchronous(flags, vma, &iomap);\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\tif (iomap.flags & IOMAP_F_NEW) {\n\t\t\tcount_vm_event(PGMAJFAULT);\n\t\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t\t\tmajor = VM_FAULT_MAJOR;\n\t\t}\n\t\terror = dax_iomap_pfn(&iomap, pos, PAGE_SIZE, &pfn);\n\t\tif (error < 0)\n\t\t\tgoto error_finish_iomap;\n\n\t\tentry = dax_insert_entry(&xas, mapping, vmf, entry, pfn,\n\t\t\t\t\t\t 0, write && !sync);\n\n\t\t/*\n\t\t * If we are doing synchronous page fault and inode needs fsync,\n\t\t * we can insert PTE into page tables only after that happens.\n\t\t * Skip insertion for now and return the pfn so that caller can\n\t\t * insert it after fsync is done.\n\t\t */\n\t\tif (sync) {\n\t\t\tif (WARN_ON_ONCE(!pfnp)) {\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto error_finish_iomap;\n\t\t\t}\n\t\t\t*pfnp = pfn;\n\t\t\tret = VM_FAULT_NEEDDSYNC | major;\n\t\t\tgoto finish_iomap;\n\t\t}\n\t\ttrace_dax_insert_mapping(inode, vmf, entry);\n\t\tif (write)\n\t\t\tret = vmf_insert_mixed_mkwrite(vma, vaddr, pfn);\n\t\telse\n\t\t\tret = vmf_insert_mixed(vma, vaddr, pfn);\n\n\t\tgoto finish_iomap;\n\tcase IOMAP_UNWRITTEN:\n\tcase IOMAP_HOLE:\n\t\tif (!write) {\n\t\t\tret = dax_load_hole(&xas, mapping, &entry, vmf);\n\t\t\tgoto finish_iomap;\n\t\t}\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\terror = -EIO;\n\t\tbreak;\n\t}\n\n error_finish_iomap:\n\tret = dax_fault_return(error);\n finish_iomap:\n\tif (ops->iomap_end) {\n\t\tint copied = PAGE_SIZE;\n\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tcopied = 0;\n\t\t/*\n\t\t * The fault is done by now and there's no way back (other\n\t\t * thread may be already happily using PTE we have installed).\n\t\t * Just ignore error from ->iomap_end since we cannot do much\n\t\t * with it.\n\t\t */\n\t\tops->iomap_end(inode, pos, PAGE_SIZE, copied, flags, &iomap);\n\t}\n unlock_entry:\n\tdax_unlock_entry(&xas, entry);\n out:\n\ttrace_dax_pte_fault_done(inode, vmf, ret);\n\treturn ret | major;\n}"
  },
  {
    "function_name": "dax_fault_is_synchronous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1211-1216",
    "snippet": "static bool dax_fault_is_synchronous(unsigned long flags,\n\t\tstruct vm_area_struct *vma, struct iomap *iomap)\n{\n\treturn (flags & IOMAP_WRITE) && (vma->vm_flags & VM_SYNC)\n\t\t&& (iomap->flags & IOMAP_F_DIRTY);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool dax_fault_is_synchronous(unsigned long flags,\n\t\tstruct vm_area_struct *vma, struct iomap *iomap)\n{\n\treturn (flags & IOMAP_WRITE) && (vma->vm_flags & VM_SYNC)\n\t\t&& (iomap->flags & IOMAP_F_DIRTY);\n}"
  },
  {
    "function_name": "dax_fault_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1198-1205",
    "snippet": "static vm_fault_t dax_fault_return(int error)\n{\n\tif (error == 0)\n\t\treturn VM_FAULT_NOPAGE;\n\tif (error == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\treturn VM_FAULT_SIGBUS;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic vm_fault_t dax_fault_return(int error)\n{\n\tif (error == 0)\n\t\treturn VM_FAULT_NOPAGE;\n\tif (error == -ENOMEM)\n\t\treturn VM_FAULT_OOM;\n\treturn VM_FAULT_SIGBUS;\n}"
  },
  {
    "function_name": "dax_iomap_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1168-1195",
    "snippet": "ssize_t\ndax_iomap_rw(struct kiocb *iocb, struct iov_iter *iter,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tloff_t pos = iocb->ki_pos, ret = 0, done = 0;\n\tunsigned flags = 0;\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tlockdep_assert_held_exclusive(&inode->i_rwsem);\n\t\tflags |= IOMAP_WRITE;\n\t} else {\n\t\tlockdep_assert_held(&inode->i_rwsem);\n\t}\n\n\twhile (iov_iter_count(iter)) {\n\t\tret = iomap_apply(inode, pos, iov_iter_count(iter), flags, ops,\n\t\t\t\titer, dax_iomap_actor);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tpos += ret;\n\t\tdone += ret;\n\t}\n\n\tiocb->ki_pos += done;\n\treturn done ? done : ret;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "pos",
            "iov_iter_count(iter)",
            "flags",
            "ops",
            "iter",
            "dax_iomap_actor"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&inode->i_rwsem"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held_exclusive",
          "args": [
            "&inode->i_rwsem"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nssize_t\ndax_iomap_rw(struct kiocb *iocb, struct iov_iter *iter,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tloff_t pos = iocb->ki_pos, ret = 0, done = 0;\n\tunsigned flags = 0;\n\n\tif (iov_iter_rw(iter) == WRITE) {\n\t\tlockdep_assert_held_exclusive(&inode->i_rwsem);\n\t\tflags |= IOMAP_WRITE;\n\t} else {\n\t\tlockdep_assert_held(&inode->i_rwsem);\n\t}\n\n\twhile (iov_iter_count(iter)) {\n\t\tret = iomap_apply(inode, pos, iov_iter_count(iter), flags, ops,\n\t\t\t\titer, dax_iomap_actor);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tpos += ret;\n\t\tdone += ret;\n\t}\n\n\tiocb->ki_pos += done;\n\treturn done ? done : ret;\n}"
  },
  {
    "function_name": "dax_iomap_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1066-1156",
    "snippet": "static loff_t\ndax_iomap_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct block_device *bdev = iomap->bdev;\n\tstruct dax_device *dax_dev = iomap->dax_dev;\n\tstruct iov_iter *iter = data;\n\tloff_t end = pos + length, done = 0;\n\tssize_t ret = 0;\n\tsize_t xfer;\n\tint id;\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tend = min(end, i_size_read(inode));\n\t\tif (pos >= end)\n\t\t\treturn 0;\n\n\t\tif (iomap->type == IOMAP_HOLE || iomap->type == IOMAP_UNWRITTEN)\n\t\t\treturn iov_iter_zero(min(length, end - pos), iter);\n\t}\n\n\tif (WARN_ON_ONCE(iomap->type != IOMAP_MAPPED))\n\t\treturn -EIO;\n\n\t/*\n\t * Write can allocate block for an area which has a hole page mapped\n\t * into page tables. We have to tear down these mappings so that data\n\t * written by write(2) is visible in mmap.\n\t */\n\tif (iomap->flags & IOMAP_F_NEW) {\n\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t      pos >> PAGE_SHIFT,\n\t\t\t\t\t      (end - 1) >> PAGE_SHIFT);\n\t}\n\n\tid = dax_read_lock();\n\twhile (pos < end) {\n\t\tunsigned offset = pos & (PAGE_SIZE - 1);\n\t\tconst size_t size = ALIGN(length + offset, PAGE_SIZE);\n\t\tconst sector_t sector = dax_iomap_sector(iomap, pos);\n\t\tssize_t map_len;\n\t\tpgoff_t pgoff;\n\t\tvoid *kaddr;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = bdev_dax_pgoff(bdev, sector, size, &pgoff);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tmap_len = dax_direct_access(dax_dev, pgoff, PHYS_PFN(size),\n\t\t\t\t&kaddr, NULL);\n\t\tif (map_len < 0) {\n\t\t\tret = map_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tmap_len = PFN_PHYS(map_len);\n\t\tkaddr += offset;\n\t\tmap_len -= offset;\n\t\tif (map_len > end - pos)\n\t\t\tmap_len = end - pos;\n\n\t\t/*\n\t\t * The userspace address for the memory copy has already been\n\t\t * validated via access_ok() in either vfs_read() or\n\t\t * vfs_write(), depending on which operation we are doing.\n\t\t */\n\t\tif (iov_iter_rw(iter) == WRITE)\n\t\t\txfer = dax_copy_from_iter(dax_dev, pgoff, kaddr,\n\t\t\t\t\tmap_len, iter);\n\t\telse\n\t\t\txfer = dax_copy_to_iter(dax_dev, pgoff, kaddr,\n\t\t\t\t\tmap_len, iter);\n\n\t\tpos += xfer;\n\t\tlength -= xfer;\n\t\tdone += xfer;\n\n\t\tif (xfer == 0)\n\t\t\tret = -EFAULT;\n\t\tif (xfer < map_len)\n\t\t\tbreak;\n\t}\n\tdax_read_unlock(id);\n\n\treturn done ? done : ret;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_read_unlock",
          "args": [
            "id"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_copy_to_iter",
          "args": [
            "dax_dev",
            "pgoff",
            "kaddr",
            "map_len",
            "iter"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_copy_from_iter",
          "args": [
            "dax_dev",
            "pgoff",
            "kaddr",
            "map_len",
            "iter"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "map_len"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_direct_access",
          "args": [
            "dax_dev",
            "pgoff",
            "PHYS_PFN(size)",
            "&kaddr",
            "NULL"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "size"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_dax_pgoff",
          "args": [
            "bdev",
            "sector",
            "size",
            "&pgoff"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_iomap_sector",
          "args": [
            "iomap",
            "pos"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "dax_iomap_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "960-963",
          "snippet": "static sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + (pos & PAGE_MASK) - iomap->offset) >> 9;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + (pos & PAGE_MASK) - iomap->offset) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "length + offset",
            "PAGE_SIZE"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_read_lock",
          "args": [],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "inode->i_mapping",
            "pos >> PAGE_SHIFT",
            "(end - 1) >> PAGE_SHIFT"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "iomap->type != IOMAP_MAPPED"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_zero",
          "args": [
            "min(length, end - pos)",
            "iter"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "length",
            "end - pos"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic loff_t\ndax_iomap_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct block_device *bdev = iomap->bdev;\n\tstruct dax_device *dax_dev = iomap->dax_dev;\n\tstruct iov_iter *iter = data;\n\tloff_t end = pos + length, done = 0;\n\tssize_t ret = 0;\n\tsize_t xfer;\n\tint id;\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tend = min(end, i_size_read(inode));\n\t\tif (pos >= end)\n\t\t\treturn 0;\n\n\t\tif (iomap->type == IOMAP_HOLE || iomap->type == IOMAP_UNWRITTEN)\n\t\t\treturn iov_iter_zero(min(length, end - pos), iter);\n\t}\n\n\tif (WARN_ON_ONCE(iomap->type != IOMAP_MAPPED))\n\t\treturn -EIO;\n\n\t/*\n\t * Write can allocate block for an area which has a hole page mapped\n\t * into page tables. We have to tear down these mappings so that data\n\t * written by write(2) is visible in mmap.\n\t */\n\tif (iomap->flags & IOMAP_F_NEW) {\n\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t      pos >> PAGE_SHIFT,\n\t\t\t\t\t      (end - 1) >> PAGE_SHIFT);\n\t}\n\n\tid = dax_read_lock();\n\twhile (pos < end) {\n\t\tunsigned offset = pos & (PAGE_SIZE - 1);\n\t\tconst size_t size = ALIGN(length + offset, PAGE_SIZE);\n\t\tconst sector_t sector = dax_iomap_sector(iomap, pos);\n\t\tssize_t map_len;\n\t\tpgoff_t pgoff;\n\t\tvoid *kaddr;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = bdev_dax_pgoff(bdev, sector, size, &pgoff);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tmap_len = dax_direct_access(dax_dev, pgoff, PHYS_PFN(size),\n\t\t\t\t&kaddr, NULL);\n\t\tif (map_len < 0) {\n\t\t\tret = map_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tmap_len = PFN_PHYS(map_len);\n\t\tkaddr += offset;\n\t\tmap_len -= offset;\n\t\tif (map_len > end - pos)\n\t\t\tmap_len = end - pos;\n\n\t\t/*\n\t\t * The userspace address for the memory copy has already been\n\t\t * validated via access_ok() in either vfs_read() or\n\t\t * vfs_write(), depending on which operation we are doing.\n\t\t */\n\t\tif (iov_iter_rw(iter) == WRITE)\n\t\t\txfer = dax_copy_from_iter(dax_dev, pgoff, kaddr,\n\t\t\t\t\tmap_len, iter);\n\t\telse\n\t\t\txfer = dax_copy_to_iter(dax_dev, pgoff, kaddr,\n\t\t\t\t\tmap_len, iter);\n\n\t\tpos += xfer;\n\t\tlength -= xfer;\n\t\tdone += xfer;\n\n\t\tif (xfer == 0)\n\t\t\tret = -EFAULT;\n\t\tif (xfer < map_len)\n\t\t\tbreak;\n\t}\n\tdax_read_unlock(id);\n\n\treturn done ? done : ret;\n}"
  },
  {
    "function_name": "__dax_zero_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1034-1063",
    "snippet": "int __dax_zero_page_range(struct block_device *bdev,\n\t\tstruct dax_device *dax_dev, sector_t sector,\n\t\tunsigned int offset, unsigned int size)\n{\n\tif (dax_range_is_aligned(bdev, offset, size)) {\n\t\tsector_t start_sector = sector + (offset >> 9);\n\n\t\treturn blkdev_issue_zeroout(bdev, start_sector,\n\t\t\t\tsize >> 9, GFP_NOFS, 0);\n\t} else {\n\t\tpgoff_t pgoff;\n\t\tlong rc, id;\n\t\tvoid *kaddr;\n\n\t\trc = bdev_dax_pgoff(bdev, sector, PAGE_SIZE, &pgoff);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tid = dax_read_lock();\n\t\trc = dax_direct_access(dax_dev, pgoff, 1, &kaddr, NULL);\n\t\tif (rc < 0) {\n\t\t\tdax_read_unlock(id);\n\t\t\treturn rc;\n\t\t}\n\t\tmemset(kaddr + offset, 0, size);\n\t\tdax_flush(dax_dev, kaddr + offset, size);\n\t\tdax_read_unlock(id);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_read_unlock",
          "args": [
            "id"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_flush",
          "args": [
            "dax_dev",
            "kaddr + offset",
            "size"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + offset",
            "0",
            "size"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_read_unlock",
          "args": [
            "id"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_direct_access",
          "args": [
            "dax_dev",
            "pgoff",
            "1",
            "&kaddr",
            "NULL"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_read_lock",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_dax_pgoff",
          "args": [
            "bdev",
            "sector",
            "PAGE_SIZE",
            "&pgoff"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_zeroout",
          "args": [
            "bdev",
            "start_sector",
            "size >> 9",
            "GFP_NOFS",
            "0"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_range_is_aligned",
          "args": [
            "bdev",
            "offset",
            "size"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "dax_range_is_aligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1021-1032",
          "snippet": "static bool dax_range_is_aligned(struct block_device *bdev,\n\t\t\t\t unsigned int offset, unsigned int length)\n{\n\tunsigned short sector_size = bdev_logical_block_size(bdev);\n\n\tif (!IS_ALIGNED(offset, sector_size))\n\t\treturn false;\n\tif (!IS_ALIGNED(length, sector_size))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool dax_range_is_aligned(struct block_device *bdev,\n\t\t\t\t unsigned int offset, unsigned int length)\n{\n\tunsigned short sector_size = bdev_logical_block_size(bdev);\n\n\tif (!IS_ALIGNED(offset, sector_size))\n\t\treturn false;\n\tif (!IS_ALIGNED(length, sector_size))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint __dax_zero_page_range(struct block_device *bdev,\n\t\tstruct dax_device *dax_dev, sector_t sector,\n\t\tunsigned int offset, unsigned int size)\n{\n\tif (dax_range_is_aligned(bdev, offset, size)) {\n\t\tsector_t start_sector = sector + (offset >> 9);\n\n\t\treturn blkdev_issue_zeroout(bdev, start_sector,\n\t\t\t\tsize >> 9, GFP_NOFS, 0);\n\t} else {\n\t\tpgoff_t pgoff;\n\t\tlong rc, id;\n\t\tvoid *kaddr;\n\n\t\trc = bdev_dax_pgoff(bdev, sector, PAGE_SIZE, &pgoff);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tid = dax_read_lock();\n\t\trc = dax_direct_access(dax_dev, pgoff, 1, &kaddr, NULL);\n\t\tif (rc < 0) {\n\t\t\tdax_read_unlock(id);\n\t\t\treturn rc;\n\t\t}\n\t\tmemset(kaddr + offset, 0, size);\n\t\tdax_flush(dax_dev, kaddr + offset, size);\n\t\tdax_read_unlock(id);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dax_range_is_aligned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1021-1032",
    "snippet": "static bool dax_range_is_aligned(struct block_device *bdev,\n\t\t\t\t unsigned int offset, unsigned int length)\n{\n\tunsigned short sector_size = bdev_logical_block_size(bdev);\n\n\tif (!IS_ALIGNED(offset, sector_size))\n\t\treturn false;\n\tif (!IS_ALIGNED(length, sector_size))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "length",
            "sector_size"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "offset",
            "sector_size"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool dax_range_is_aligned(struct block_device *bdev,\n\t\t\t\t unsigned int offset, unsigned int length)\n{\n\tunsigned short sector_size = bdev_logical_block_size(bdev);\n\n\tif (!IS_ALIGNED(offset, sector_size))\n\t\treturn false;\n\tif (!IS_ALIGNED(length, sector_size))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "dax_load_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "1004-1019",
    "snippet": "static vm_fault_t dax_load_hole(struct xa_state *xas,\n\t\tstruct address_space *mapping, void **entry,\n\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned long vaddr = vmf->address;\n\tpfn_t pfn = pfn_to_pfn_t(my_zero_pfn(vaddr));\n\tvm_fault_t ret;\n\n\t*entry = dax_insert_entry(xas, mapping, vmf, *entry, pfn,\n\t\t\tDAX_ZERO_PAGE, false);\n\n\tret = vmf_insert_mixed(vmf->vma, vaddr, pfn);\n\ttrace_dax_load_hole(inode, vmf, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_ZERO_PAGE\t(1UL << 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_dax_load_hole",
          "args": [
            "inode",
            "vmf",
            "ret"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmf_insert_mixed",
          "args": [
            "vmf->vma",
            "vaddr",
            "pfn"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_insert_entry",
          "args": [
            "xas",
            "mapping",
            "vmf",
            "*entry",
            "pfn",
            "DAX_ZERO_PAGE",
            "false"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "dax_insert_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "690-738",
          "snippet": "static void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)",
            "#define DAX_LOCKED\t(1UL << 0)",
            "#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)",
            "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n#define DAX_LOCKED\t(1UL << 0)\n#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n\nstatic void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_pfn_t",
          "args": [
            "my_zero_pfn(vaddr)"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_zero_pfn",
          "args": [
            "vaddr"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n\nstatic vm_fault_t dax_load_hole(struct xa_state *xas,\n\t\tstruct address_space *mapping, void **entry,\n\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned long vaddr = vmf->address;\n\tpfn_t pfn = pfn_to_pfn_t(my_zero_pfn(vaddr));\n\tvm_fault_t ret;\n\n\t*entry = dax_insert_entry(xas, mapping, vmf, *entry, pfn,\n\t\t\tDAX_ZERO_PAGE, false);\n\n\tret = vmf_insert_mixed(vmf->vma, vaddr, pfn);\n\ttrace_dax_load_hole(inode, vmf, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "dax_iomap_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "965-995",
    "snippet": "static int dax_iomap_pfn(struct iomap *iomap, loff_t pos, size_t size,\n\t\t\t pfn_t *pfnp)\n{\n\tconst sector_t sector = dax_iomap_sector(iomap, pos);\n\tpgoff_t pgoff;\n\tint id, rc;\n\tlong length;\n\n\trc = bdev_dax_pgoff(iomap->bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\tid = dax_read_lock();\n\tlength = dax_direct_access(iomap->dax_dev, pgoff, PHYS_PFN(size),\n\t\t\t\t   NULL, pfnp);\n\tif (length < 0) {\n\t\trc = length;\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\tif (PFN_PHYS(length) < size)\n\t\tgoto out;\n\tif (pfn_t_to_pfn(*pfnp) & (PHYS_PFN(size)-1))\n\t\tgoto out;\n\t/* For larger pages we need devmap */\n\tif (length > 1 && !pfn_t_devmap(*pfnp))\n\t\tgoto out;\n\trc = 0;\nout:\n\tdax_read_unlock(id);\n\treturn rc;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_read_unlock",
          "args": [
            "id"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_devmap",
          "args": [
            "*pfnp"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "size"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_to_pfn",
          "args": [
            "*pfnp"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "length"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_direct_access",
          "args": [
            "iomap->dax_dev",
            "pgoff",
            "PHYS_PFN(size)",
            "NULL",
            "pfnp"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "size"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_read_lock",
          "args": [],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_dax_pgoff",
          "args": [
            "iomap->bdev",
            "sector",
            "size",
            "&pgoff"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_iomap_sector",
          "args": [
            "iomap",
            "pos"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "dax_iomap_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "960-963",
          "snippet": "static sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + (pos & PAGE_MASK) - iomap->offset) >> 9;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + (pos & PAGE_MASK) - iomap->offset) >> 9;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int dax_iomap_pfn(struct iomap *iomap, loff_t pos, size_t size,\n\t\t\t pfn_t *pfnp)\n{\n\tconst sector_t sector = dax_iomap_sector(iomap, pos);\n\tpgoff_t pgoff;\n\tint id, rc;\n\tlong length;\n\n\trc = bdev_dax_pgoff(iomap->bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\tid = dax_read_lock();\n\tlength = dax_direct_access(iomap->dax_dev, pgoff, PHYS_PFN(size),\n\t\t\t\t   NULL, pfnp);\n\tif (length < 0) {\n\t\trc = length;\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\tif (PFN_PHYS(length) < size)\n\t\tgoto out;\n\tif (pfn_t_to_pfn(*pfnp) & (PHYS_PFN(size)-1))\n\t\tgoto out;\n\t/* For larger pages we need devmap */\n\tif (length > 1 && !pfn_t_devmap(*pfnp))\n\t\tgoto out;\n\trc = 0;\nout:\n\tdax_read_unlock(id);\n\treturn rc;\n}"
  },
  {
    "function_name": "dax_iomap_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "960-963",
    "snippet": "static sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + (pos & PAGE_MASK) - iomap->offset) >> 9;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + (pos & PAGE_MASK) - iomap->offset) >> 9;\n}"
  },
  {
    "function_name": "dax_writeback_mapping_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "913-957",
    "snippet": "int dax_writeback_mapping_range(struct address_space *mapping,\n\t\tstruct block_device *bdev, struct writeback_control *wbc)\n{\n\tXA_STATE(xas, &mapping->i_pages, wbc->range_start >> PAGE_SHIFT);\n\tstruct inode *inode = mapping->host;\n\tpgoff_t end_index = wbc->range_end >> PAGE_SHIFT;\n\tstruct dax_device *dax_dev;\n\tvoid *entry;\n\tint ret = 0;\n\tunsigned int scanned = 0;\n\n\tif (WARN_ON_ONCE(inode->i_blkbits != PAGE_SHIFT))\n\t\treturn -EIO;\n\n\tif (!mapping->nrexceptional || wbc->sync_mode != WB_SYNC_ALL)\n\t\treturn 0;\n\n\tdax_dev = dax_get_by_host(bdev->bd_disk->disk_name);\n\tif (!dax_dev)\n\t\treturn -EIO;\n\n\ttrace_dax_writeback_range(inode, xas.xa_index, end_index);\n\n\ttag_pages_for_writeback(mapping, xas.xa_index, end_index);\n\n\txas_lock_irq(&xas);\n\txas_for_each_marked(&xas, entry, end_index, PAGECACHE_TAG_TOWRITE) {\n\t\tret = dax_writeback_one(&xas, dax_dev, mapping, entry);\n\t\tif (ret < 0) {\n\t\t\tmapping_set_error(mapping, ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (++scanned % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\tcond_resched();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n\tput_dax(dax_dev);\n\ttrace_dax_writeback_range_done(inode, xas.xa_index, end_index);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_dax_writeback_range_done",
          "args": [
            "inode",
            "xas.xa_index",
            "end_index"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dax",
          "args": [
            "dax_dev"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_pause",
          "args": [
            "&xas"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "ret"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_writeback_one",
          "args": [
            "&xas",
            "dax_dev",
            "mapping",
            "entry"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "dax_writeback_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "822-906",
          "snippet": "static int dax_writeback_one(struct xa_state *xas, struct dax_device *dax_dev,\n\t\tstruct address_space *mapping, void *entry)\n{\n\tunsigned long pfn;\n\tlong ret = 0;\n\tsize_t size;\n\n\t/*\n\t * A page got tagged dirty in DAX mapping? Something is seriously\n\t * wrong.\n\t */\n\tif (WARN_ON(!xa_is_value(entry)))\n\t\treturn -EIO;\n\n\tif (unlikely(dax_is_locked(entry))) {\n\t\tvoid *old_entry = entry;\n\n\t\tentry = get_unlocked_entry(xas);\n\n\t\t/* Entry got punched out / reallocated? */\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\t\tgoto put_unlocked;\n\t\t/*\n\t\t * Entry got reallocated elsewhere? No need to writeback.\n\t\t * We have to compare pfns as we must not bail out due to\n\t\t * difference in lockbit or entry type.\n\t\t */\n\t\tif (dax_to_pfn(old_entry) != dax_to_pfn(entry))\n\t\t\tgoto put_unlocked;\n\t\tif (WARN_ON_ONCE(dax_is_empty_entry(entry) ||\n\t\t\t\t\tdax_is_zero_entry(entry))) {\n\t\t\tret = -EIO;\n\t\t\tgoto put_unlocked;\n\t\t}\n\n\t\t/* Another fsync thread may have already done this entry */\n\t\tif (!xas_get_mark(xas, PAGECACHE_TAG_TOWRITE))\n\t\t\tgoto put_unlocked;\n\t}\n\n\t/* Lock the entry to serialize with page faults */\n\tdax_lock_entry(xas, entry);\n\n\t/*\n\t * We can clear the tag now but we have to be careful so that concurrent\n\t * dax_writeback_one() calls for the same index cannot finish before we\n\t * actually flush the caches. This is achieved as the calls will look\n\t * at the entry only under the i_pages lock and once they do that\n\t * they will see the entry locked and wait for it to unlock.\n\t */\n\txas_clear_mark(xas, PAGECACHE_TAG_TOWRITE);\n\txas_unlock_irq(xas);\n\n\t/*\n\t * Even if dax_writeback_mapping_range() was given a wbc->range_start\n\t * in the middle of a PMD, the 'index' we are given will be aligned to\n\t * the start index of the PMD, as will the pfn we pull from 'entry'.\n\t * This allows us to flush for PMD_SIZE and not have to worry about\n\t * partial PMD writebacks.\n\t */\n\tpfn = dax_to_pfn(entry);\n\tsize = PAGE_SIZE << dax_entry_order(entry);\n\n\tdax_entry_mkclean(mapping, xas->xa_index, pfn);\n\tdax_flush(dax_dev, page_address(pfn_to_page(pfn)), size);\n\t/*\n\t * After we have flushed the cache, we can clear the dirty tag. There\n\t * cannot be new dirty data in the pfn after the flush has completed as\n\t * the pfn mappings are writeprotected and fault waits for mapping\n\t * entry lock.\n\t */\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\txas_store(xas, entry);\n\txas_clear_mark(xas, PAGECACHE_TAG_DIRTY);\n\tdax_wake_entry(xas, entry, false);\n\n\ttrace_dax_writeback_one(mapping->host, xas->xa_index,\n\t\t\tsize >> PAGE_SHIFT);\n\treturn ret;\n\n put_unlocked:\n\tput_unlocked_entry(xas, entry);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int dax_writeback_one(struct xa_state *xas, struct dax_device *dax_dev,\n\t\tstruct address_space *mapping, void *entry)\n{\n\tunsigned long pfn;\n\tlong ret = 0;\n\tsize_t size;\n\n\t/*\n\t * A page got tagged dirty in DAX mapping? Something is seriously\n\t * wrong.\n\t */\n\tif (WARN_ON(!xa_is_value(entry)))\n\t\treturn -EIO;\n\n\tif (unlikely(dax_is_locked(entry))) {\n\t\tvoid *old_entry = entry;\n\n\t\tentry = get_unlocked_entry(xas);\n\n\t\t/* Entry got punched out / reallocated? */\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\t\tgoto put_unlocked;\n\t\t/*\n\t\t * Entry got reallocated elsewhere? No need to writeback.\n\t\t * We have to compare pfns as we must not bail out due to\n\t\t * difference in lockbit or entry type.\n\t\t */\n\t\tif (dax_to_pfn(old_entry) != dax_to_pfn(entry))\n\t\t\tgoto put_unlocked;\n\t\tif (WARN_ON_ONCE(dax_is_empty_entry(entry) ||\n\t\t\t\t\tdax_is_zero_entry(entry))) {\n\t\t\tret = -EIO;\n\t\t\tgoto put_unlocked;\n\t\t}\n\n\t\t/* Another fsync thread may have already done this entry */\n\t\tif (!xas_get_mark(xas, PAGECACHE_TAG_TOWRITE))\n\t\t\tgoto put_unlocked;\n\t}\n\n\t/* Lock the entry to serialize with page faults */\n\tdax_lock_entry(xas, entry);\n\n\t/*\n\t * We can clear the tag now but we have to be careful so that concurrent\n\t * dax_writeback_one() calls for the same index cannot finish before we\n\t * actually flush the caches. This is achieved as the calls will look\n\t * at the entry only under the i_pages lock and once they do that\n\t * they will see the entry locked and wait for it to unlock.\n\t */\n\txas_clear_mark(xas, PAGECACHE_TAG_TOWRITE);\n\txas_unlock_irq(xas);\n\n\t/*\n\t * Even if dax_writeback_mapping_range() was given a wbc->range_start\n\t * in the middle of a PMD, the 'index' we are given will be aligned to\n\t * the start index of the PMD, as will the pfn we pull from 'entry'.\n\t * This allows us to flush for PMD_SIZE and not have to worry about\n\t * partial PMD writebacks.\n\t */\n\tpfn = dax_to_pfn(entry);\n\tsize = PAGE_SIZE << dax_entry_order(entry);\n\n\tdax_entry_mkclean(mapping, xas->xa_index, pfn);\n\tdax_flush(dax_dev, page_address(pfn_to_page(pfn)), size);\n\t/*\n\t * After we have flushed the cache, we can clear the dirty tag. There\n\t * cannot be new dirty data in the pfn after the flush has completed as\n\t * the pfn mappings are writeprotected and fault waits for mapping\n\t * entry lock.\n\t */\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\txas_store(xas, entry);\n\txas_clear_mark(xas, PAGECACHE_TAG_DIRTY);\n\tdax_wake_entry(xas, entry, false);\n\n\ttrace_dax_writeback_one(mapping->host, xas->xa_index,\n\t\t\tsize >> PAGE_SHIFT);\n\treturn ret;\n\n put_unlocked:\n\tput_unlocked_entry(xas, entry);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_for_each_marked",
          "args": [
            "&xas",
            "entry",
            "end_index",
            "PAGECACHE_TAG_TOWRITE"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag_pages_for_writeback",
          "args": [
            "mapping",
            "xas.xa_index",
            "end_index"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_dax_writeback_range",
          "args": [
            "inode",
            "xas.xa_index",
            "end_index"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_get_by_host",
          "args": [
            "bdev->bd_disk->disk_name"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "inode->i_blkbits != PAGE_SHIFT"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "wbc->range_start >> PAGE_SHIFT"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_writeback_mapping_range(struct address_space *mapping,\n\t\tstruct block_device *bdev, struct writeback_control *wbc)\n{\n\tXA_STATE(xas, &mapping->i_pages, wbc->range_start >> PAGE_SHIFT);\n\tstruct inode *inode = mapping->host;\n\tpgoff_t end_index = wbc->range_end >> PAGE_SHIFT;\n\tstruct dax_device *dax_dev;\n\tvoid *entry;\n\tint ret = 0;\n\tunsigned int scanned = 0;\n\n\tif (WARN_ON_ONCE(inode->i_blkbits != PAGE_SHIFT))\n\t\treturn -EIO;\n\n\tif (!mapping->nrexceptional || wbc->sync_mode != WB_SYNC_ALL)\n\t\treturn 0;\n\n\tdax_dev = dax_get_by_host(bdev->bd_disk->disk_name);\n\tif (!dax_dev)\n\t\treturn -EIO;\n\n\ttrace_dax_writeback_range(inode, xas.xa_index, end_index);\n\n\ttag_pages_for_writeback(mapping, xas.xa_index, end_index);\n\n\txas_lock_irq(&xas);\n\txas_for_each_marked(&xas, entry, end_index, PAGECACHE_TAG_TOWRITE) {\n\t\tret = dax_writeback_one(&xas, dax_dev, mapping, entry);\n\t\tif (ret < 0) {\n\t\t\tmapping_set_error(mapping, ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (++scanned % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\tcond_resched();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n\tput_dax(dax_dev);\n\ttrace_dax_writeback_range_done(inode, xas.xa_index, end_index);\n\treturn ret;\n}"
  },
  {
    "function_name": "dax_writeback_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "822-906",
    "snippet": "static int dax_writeback_one(struct xa_state *xas, struct dax_device *dax_dev,\n\t\tstruct address_space *mapping, void *entry)\n{\n\tunsigned long pfn;\n\tlong ret = 0;\n\tsize_t size;\n\n\t/*\n\t * A page got tagged dirty in DAX mapping? Something is seriously\n\t * wrong.\n\t */\n\tif (WARN_ON(!xa_is_value(entry)))\n\t\treturn -EIO;\n\n\tif (unlikely(dax_is_locked(entry))) {\n\t\tvoid *old_entry = entry;\n\n\t\tentry = get_unlocked_entry(xas);\n\n\t\t/* Entry got punched out / reallocated? */\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\t\tgoto put_unlocked;\n\t\t/*\n\t\t * Entry got reallocated elsewhere? No need to writeback.\n\t\t * We have to compare pfns as we must not bail out due to\n\t\t * difference in lockbit or entry type.\n\t\t */\n\t\tif (dax_to_pfn(old_entry) != dax_to_pfn(entry))\n\t\t\tgoto put_unlocked;\n\t\tif (WARN_ON_ONCE(dax_is_empty_entry(entry) ||\n\t\t\t\t\tdax_is_zero_entry(entry))) {\n\t\t\tret = -EIO;\n\t\t\tgoto put_unlocked;\n\t\t}\n\n\t\t/* Another fsync thread may have already done this entry */\n\t\tif (!xas_get_mark(xas, PAGECACHE_TAG_TOWRITE))\n\t\t\tgoto put_unlocked;\n\t}\n\n\t/* Lock the entry to serialize with page faults */\n\tdax_lock_entry(xas, entry);\n\n\t/*\n\t * We can clear the tag now but we have to be careful so that concurrent\n\t * dax_writeback_one() calls for the same index cannot finish before we\n\t * actually flush the caches. This is achieved as the calls will look\n\t * at the entry only under the i_pages lock and once they do that\n\t * they will see the entry locked and wait for it to unlock.\n\t */\n\txas_clear_mark(xas, PAGECACHE_TAG_TOWRITE);\n\txas_unlock_irq(xas);\n\n\t/*\n\t * Even if dax_writeback_mapping_range() was given a wbc->range_start\n\t * in the middle of a PMD, the 'index' we are given will be aligned to\n\t * the start index of the PMD, as will the pfn we pull from 'entry'.\n\t * This allows us to flush for PMD_SIZE and not have to worry about\n\t * partial PMD writebacks.\n\t */\n\tpfn = dax_to_pfn(entry);\n\tsize = PAGE_SIZE << dax_entry_order(entry);\n\n\tdax_entry_mkclean(mapping, xas->xa_index, pfn);\n\tdax_flush(dax_dev, page_address(pfn_to_page(pfn)), size);\n\t/*\n\t * After we have flushed the cache, we can clear the dirty tag. There\n\t * cannot be new dirty data in the pfn after the flush has completed as\n\t * the pfn mappings are writeprotected and fault waits for mapping\n\t * entry lock.\n\t */\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\txas_store(xas, entry);\n\txas_clear_mark(xas, PAGECACHE_TAG_DIRTY);\n\tdax_wake_entry(xas, entry, false);\n\n\ttrace_dax_writeback_one(mapping->host, xas->xa_index,\n\t\t\tsize >> PAGE_SHIFT);\n\treturn ret;\n\n put_unlocked:\n\tput_unlocked_entry(xas, entry);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unlocked_entry",
          "args": [
            "xas",
            "entry"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "put_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "235-240",
          "snippet": "static void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_dax_writeback_one",
          "args": [
            "mapping->host",
            "xas->xa_index",
            "size >> PAGE_SHIFT"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_wake_entry",
          "args": [
            "xas",
            "entry",
            "false"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "dax_wake_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "184-199",
          "snippet": "static void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_clear_mark",
          "args": [
            "xas",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "xas",
            "entry"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "xas"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "xas"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_flush",
          "args": [
            "dax_dev",
            "page_address(pfn_to_page(pfn))",
            "size"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_entry_mkclean",
          "args": [
            "mapping",
            "xas->xa_index",
            "pfn"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "dax_entry_mkclean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "751-820",
          "snippet": "static void dax_entry_mkclean(struct address_space *mapping, pgoff_t index,\n\t\tunsigned long pfn)\n{\n\tstruct vm_area_struct *vma;\n\tpte_t pte, *ptep = NULL;\n\tpmd_t *pmdp = NULL;\n\tspinlock_t *ptl;\n\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, index, index) {\n\t\tunsigned long address, start, end;\n\n\t\tcond_resched();\n\n\t\tif (!(vma->vm_flags & VM_SHARED))\n\t\t\tcontinue;\n\n\t\taddress = pgoff_address(index, vma);\n\n\t\t/*\n\t\t * Note because we provide start/end to follow_pte_pmd it will\n\t\t * call mmu_notifier_invalidate_range_start() on our behalf\n\t\t * before taking any lock.\n\t\t */\n\t\tif (follow_pte_pmd(vma->vm_mm, address, &start, &end, &ptep, &pmdp, &ptl))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() as we are\n\t\t * downgrading page table protection not changing it to point\n\t\t * to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tif (pmdp) {\n#ifdef CONFIG_FS_DAX_PMD\n\t\t\tpmd_t pmd;\n\n\t\t\tif (pfn != pmd_pfn(*pmdp))\n\t\t\t\tgoto unlock_pmd;\n\t\t\tif (!pmd_dirty(*pmdp) && !pmd_write(*pmdp))\n\t\t\t\tgoto unlock_pmd;\n\n\t\t\tflush_cache_page(vma, address, pfn);\n\t\t\tpmd = pmdp_huge_clear_flush(vma, address, pmdp);\n\t\t\tpmd = pmd_wrprotect(pmd);\n\t\t\tpmd = pmd_mkclean(pmd);\n\t\t\tset_pmd_at(vma->vm_mm, address, pmdp, pmd);\nunlock_pmd:\n#endif\n\t\t\tspin_unlock(ptl);\n\t\t} else {\n\t\t\tif (pfn != pte_pfn(*ptep))\n\t\t\t\tgoto unlock_pte;\n\t\t\tif (!pte_dirty(*ptep) && !pte_write(*ptep))\n\t\t\t\tgoto unlock_pte;\n\n\t\t\tflush_cache_page(vma, address, pfn);\n\t\t\tpte = ptep_clear_flush(vma, address, ptep);\n\t\t\tpte = pte_wrprotect(pte);\n\t\t\tpte = pte_mkclean(pte);\n\t\t\tset_pte_at(vma->vm_mm, address, ptep, pte);\nunlock_pte:\n\t\t\tpte_unmap_unlock(ptep, ptl);\n\t\t}\n\n\t\tmmu_notifier_invalidate_range_end(vma->vm_mm, start, end);\n\t}\n\ti_mmap_unlock_read(mapping);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_entry_mkclean(struct address_space *mapping, pgoff_t index,\n\t\tunsigned long pfn)\n{\n\tstruct vm_area_struct *vma;\n\tpte_t pte, *ptep = NULL;\n\tpmd_t *pmdp = NULL;\n\tspinlock_t *ptl;\n\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, index, index) {\n\t\tunsigned long address, start, end;\n\n\t\tcond_resched();\n\n\t\tif (!(vma->vm_flags & VM_SHARED))\n\t\t\tcontinue;\n\n\t\taddress = pgoff_address(index, vma);\n\n\t\t/*\n\t\t * Note because we provide start/end to follow_pte_pmd it will\n\t\t * call mmu_notifier_invalidate_range_start() on our behalf\n\t\t * before taking any lock.\n\t\t */\n\t\tif (follow_pte_pmd(vma->vm_mm, address, &start, &end, &ptep, &pmdp, &ptl))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() as we are\n\t\t * downgrading page table protection not changing it to point\n\t\t * to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tif (pmdp) {\n#ifdef CONFIG_FS_DAX_PMD\n\t\t\tpmd_t pmd;\n\n\t\t\tif (pfn != pmd_pfn(*pmdp))\n\t\t\t\tgoto unlock_pmd;\n\t\t\tif (!pmd_dirty(*pmdp) && !pmd_write(*pmdp))\n\t\t\t\tgoto unlock_pmd;\n\n\t\t\tflush_cache_page(vma, address, pfn);\n\t\t\tpmd = pmdp_huge_clear_flush(vma, address, pmdp);\n\t\t\tpmd = pmd_wrprotect(pmd);\n\t\t\tpmd = pmd_mkclean(pmd);\n\t\t\tset_pmd_at(vma->vm_mm, address, pmdp, pmd);\nunlock_pmd:\n#endif\n\t\t\tspin_unlock(ptl);\n\t\t} else {\n\t\t\tif (pfn != pte_pfn(*ptep))\n\t\t\t\tgoto unlock_pte;\n\t\t\tif (!pte_dirty(*ptep) && !pte_write(*ptep))\n\t\t\t\tgoto unlock_pte;\n\n\t\t\tflush_cache_page(vma, address, pfn);\n\t\t\tpte = ptep_clear_flush(vma, address, ptep);\n\t\t\tpte = pte_wrprotect(pte);\n\t\t\tpte = pte_mkclean(pte);\n\t\t\tset_pte_at(vma->vm_mm, address, ptep, pte);\nunlock_pte:\n\t\t\tpte_unmap_unlock(ptep, ptl);\n\t\t}\n\n\t\tmmu_notifier_invalidate_range_end(vma->vm_mm, start, end);\n\t}\n\ti_mmap_unlock_read(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_entry_order",
          "args": [
            "entry"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "dax_entry_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "106-111",
          "snippet": "static unsigned int dax_entry_order(void *entry)\n{\n\tif (xa_to_value(entry) & DAX_PMD)\n\t\treturn PMD_ORDER;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_PMD\t\t(1UL << 1)",
            "#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)\n\nstatic unsigned int dax_entry_order(void *entry)\n{\n\tif (xa_to_value(entry) & DAX_PMD)\n\t\treturn PMD_ORDER;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_to_pfn",
          "args": [
            "entry"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "dax_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "91-94",
          "snippet": "static unsigned long dax_to_pfn(void *entry)\n{\n\treturn xa_to_value(entry) >> DAX_SHIFT;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_SHIFT\t(4)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_SHIFT\t(4)\n\nstatic unsigned long dax_to_pfn(void *entry)\n{\n\treturn xa_to_value(entry) >> DAX_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "xas"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_clear_mark",
          "args": [
            "xas",
            "PAGECACHE_TAG_TOWRITE"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_lock_entry",
          "args": [
            "xas",
            "entry"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "dax_lock_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "263-267",
          "snippet": "static void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_get_mark",
          "args": [
            "xas",
            "PAGECACHE_TAG_TOWRITE"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dax_is_empty_entry(entry) ||\n\t\t\t\t\tdax_is_zero_entry(entry)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_is_zero_entry",
          "args": [
            "entry"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_zero_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "123-126",
          "snippet": "static int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n\nstatic int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_empty_entry",
          "args": [
            "entry"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_empty_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "128-131",
          "snippet": "static int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_EMPTY\t(1UL << 3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_EMPTY\t(1UL << 3)\n\nstatic int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!xa_is_value(entry)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "entry"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unlocked_entry",
          "args": [
            "xas"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "get_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "209-233",
          "snippet": "static void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dax_is_locked(entry)"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_is_locked",
          "args": [
            "entry"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "101-104",
          "snippet": "static bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!xa_is_value(entry)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "entry"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int dax_writeback_one(struct xa_state *xas, struct dax_device *dax_dev,\n\t\tstruct address_space *mapping, void *entry)\n{\n\tunsigned long pfn;\n\tlong ret = 0;\n\tsize_t size;\n\n\t/*\n\t * A page got tagged dirty in DAX mapping? Something is seriously\n\t * wrong.\n\t */\n\tif (WARN_ON(!xa_is_value(entry)))\n\t\treturn -EIO;\n\n\tif (unlikely(dax_is_locked(entry))) {\n\t\tvoid *old_entry = entry;\n\n\t\tentry = get_unlocked_entry(xas);\n\n\t\t/* Entry got punched out / reallocated? */\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\t\tgoto put_unlocked;\n\t\t/*\n\t\t * Entry got reallocated elsewhere? No need to writeback.\n\t\t * We have to compare pfns as we must not bail out due to\n\t\t * difference in lockbit or entry type.\n\t\t */\n\t\tif (dax_to_pfn(old_entry) != dax_to_pfn(entry))\n\t\t\tgoto put_unlocked;\n\t\tif (WARN_ON_ONCE(dax_is_empty_entry(entry) ||\n\t\t\t\t\tdax_is_zero_entry(entry))) {\n\t\t\tret = -EIO;\n\t\t\tgoto put_unlocked;\n\t\t}\n\n\t\t/* Another fsync thread may have already done this entry */\n\t\tif (!xas_get_mark(xas, PAGECACHE_TAG_TOWRITE))\n\t\t\tgoto put_unlocked;\n\t}\n\n\t/* Lock the entry to serialize with page faults */\n\tdax_lock_entry(xas, entry);\n\n\t/*\n\t * We can clear the tag now but we have to be careful so that concurrent\n\t * dax_writeback_one() calls for the same index cannot finish before we\n\t * actually flush the caches. This is achieved as the calls will look\n\t * at the entry only under the i_pages lock and once they do that\n\t * they will see the entry locked and wait for it to unlock.\n\t */\n\txas_clear_mark(xas, PAGECACHE_TAG_TOWRITE);\n\txas_unlock_irq(xas);\n\n\t/*\n\t * Even if dax_writeback_mapping_range() was given a wbc->range_start\n\t * in the middle of a PMD, the 'index' we are given will be aligned to\n\t * the start index of the PMD, as will the pfn we pull from 'entry'.\n\t * This allows us to flush for PMD_SIZE and not have to worry about\n\t * partial PMD writebacks.\n\t */\n\tpfn = dax_to_pfn(entry);\n\tsize = PAGE_SIZE << dax_entry_order(entry);\n\n\tdax_entry_mkclean(mapping, xas->xa_index, pfn);\n\tdax_flush(dax_dev, page_address(pfn_to_page(pfn)), size);\n\t/*\n\t * After we have flushed the cache, we can clear the dirty tag. There\n\t * cannot be new dirty data in the pfn after the flush has completed as\n\t * the pfn mappings are writeprotected and fault waits for mapping\n\t * entry lock.\n\t */\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\txas_store(xas, entry);\n\txas_clear_mark(xas, PAGECACHE_TAG_DIRTY);\n\tdax_wake_entry(xas, entry, false);\n\n\ttrace_dax_writeback_one(mapping->host, xas->xa_index,\n\t\t\tsize >> PAGE_SHIFT);\n\treturn ret;\n\n put_unlocked:\n\tput_unlocked_entry(xas, entry);\n\treturn ret;\n}"
  },
  {
    "function_name": "dax_entry_mkclean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "751-820",
    "snippet": "static void dax_entry_mkclean(struct address_space *mapping, pgoff_t index,\n\t\tunsigned long pfn)\n{\n\tstruct vm_area_struct *vma;\n\tpte_t pte, *ptep = NULL;\n\tpmd_t *pmdp = NULL;\n\tspinlock_t *ptl;\n\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, index, index) {\n\t\tunsigned long address, start, end;\n\n\t\tcond_resched();\n\n\t\tif (!(vma->vm_flags & VM_SHARED))\n\t\t\tcontinue;\n\n\t\taddress = pgoff_address(index, vma);\n\n\t\t/*\n\t\t * Note because we provide start/end to follow_pte_pmd it will\n\t\t * call mmu_notifier_invalidate_range_start() on our behalf\n\t\t * before taking any lock.\n\t\t */\n\t\tif (follow_pte_pmd(vma->vm_mm, address, &start, &end, &ptep, &pmdp, &ptl))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() as we are\n\t\t * downgrading page table protection not changing it to point\n\t\t * to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tif (pmdp) {\n#ifdef CONFIG_FS_DAX_PMD\n\t\t\tpmd_t pmd;\n\n\t\t\tif (pfn != pmd_pfn(*pmdp))\n\t\t\t\tgoto unlock_pmd;\n\t\t\tif (!pmd_dirty(*pmdp) && !pmd_write(*pmdp))\n\t\t\t\tgoto unlock_pmd;\n\n\t\t\tflush_cache_page(vma, address, pfn);\n\t\t\tpmd = pmdp_huge_clear_flush(vma, address, pmdp);\n\t\t\tpmd = pmd_wrprotect(pmd);\n\t\t\tpmd = pmd_mkclean(pmd);\n\t\t\tset_pmd_at(vma->vm_mm, address, pmdp, pmd);\nunlock_pmd:\n#endif\n\t\t\tspin_unlock(ptl);\n\t\t} else {\n\t\t\tif (pfn != pte_pfn(*ptep))\n\t\t\t\tgoto unlock_pte;\n\t\t\tif (!pte_dirty(*ptep) && !pte_write(*ptep))\n\t\t\t\tgoto unlock_pte;\n\n\t\t\tflush_cache_page(vma, address, pfn);\n\t\t\tpte = ptep_clear_flush(vma, address, ptep);\n\t\t\tpte = pte_wrprotect(pte);\n\t\t\tpte = pte_mkclean(pte);\n\t\t\tset_pte_at(vma->vm_mm, address, ptep, pte);\nunlock_pte:\n\t\t\tpte_unmap_unlock(ptep, ptl);\n\t\t}\n\n\t\tmmu_notifier_invalidate_range_end(vma->vm_mm, start, end);\n\t}\n\ti_mmap_unlock_read(mapping);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_mmap_unlock_read",
          "args": [
            "mapping"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "vma->vm_mm",
            "start",
            "end"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "address",
            "ptep",
            "pte"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkclean",
          "args": [
            "pte"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_wrprotect",
          "args": [
            "pte"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush",
          "args": [
            "vma",
            "address",
            "ptep"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "address",
            "pfn"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "*ptep"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "*ptep"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*ptep"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "vma->vm_mm",
            "address",
            "pmdp",
            "pmd"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_mkclean",
          "args": [
            "pmd"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_wrprotect",
          "args": [
            "pmd"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_huge_clear_flush",
          "args": [
            "vma",
            "address",
            "pmdp"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "address",
            "pfn"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "*pmdp"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_dirty",
          "args": [
            "*pmdp"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_pfn",
          "args": [
            "*pmdp"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_pte_pmd",
          "args": [
            "vma->vm_mm",
            "address",
            "&start",
            "&end",
            "&ptep",
            "&pmdp",
            "&ptl"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgoff_address",
          "args": [
            "index",
            "vma"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "pgoff_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "740-748",
          "snippet": "static inline\nunsigned long pgoff_address(pgoff_t pgoff, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\n\taddress = vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\treturn address;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic inline\nunsigned long pgoff_address(pgoff_t pgoff, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\n\taddress = vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\treturn address;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "vma",
            "&mapping->i_mmap",
            "index",
            "index"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_read",
          "args": [
            "mapping"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_entry_mkclean(struct address_space *mapping, pgoff_t index,\n\t\tunsigned long pfn)\n{\n\tstruct vm_area_struct *vma;\n\tpte_t pte, *ptep = NULL;\n\tpmd_t *pmdp = NULL;\n\tspinlock_t *ptl;\n\n\ti_mmap_lock_read(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, index, index) {\n\t\tunsigned long address, start, end;\n\n\t\tcond_resched();\n\n\t\tif (!(vma->vm_flags & VM_SHARED))\n\t\t\tcontinue;\n\n\t\taddress = pgoff_address(index, vma);\n\n\t\t/*\n\t\t * Note because we provide start/end to follow_pte_pmd it will\n\t\t * call mmu_notifier_invalidate_range_start() on our behalf\n\t\t * before taking any lock.\n\t\t */\n\t\tif (follow_pte_pmd(vma->vm_mm, address, &start, &end, &ptep, &pmdp, &ptl))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need to call mmu_notifier_invalidate_range() as we are\n\t\t * downgrading page table protection not changing it to point\n\t\t * to a new page.\n\t\t *\n\t\t * See Documentation/vm/mmu_notifier.rst\n\t\t */\n\t\tif (pmdp) {\n#ifdef CONFIG_FS_DAX_PMD\n\t\t\tpmd_t pmd;\n\n\t\t\tif (pfn != pmd_pfn(*pmdp))\n\t\t\t\tgoto unlock_pmd;\n\t\t\tif (!pmd_dirty(*pmdp) && !pmd_write(*pmdp))\n\t\t\t\tgoto unlock_pmd;\n\n\t\t\tflush_cache_page(vma, address, pfn);\n\t\t\tpmd = pmdp_huge_clear_flush(vma, address, pmdp);\n\t\t\tpmd = pmd_wrprotect(pmd);\n\t\t\tpmd = pmd_mkclean(pmd);\n\t\t\tset_pmd_at(vma->vm_mm, address, pmdp, pmd);\nunlock_pmd:\n#endif\n\t\t\tspin_unlock(ptl);\n\t\t} else {\n\t\t\tif (pfn != pte_pfn(*ptep))\n\t\t\t\tgoto unlock_pte;\n\t\t\tif (!pte_dirty(*ptep) && !pte_write(*ptep))\n\t\t\t\tgoto unlock_pte;\n\n\t\t\tflush_cache_page(vma, address, pfn);\n\t\t\tpte = ptep_clear_flush(vma, address, ptep);\n\t\t\tpte = pte_wrprotect(pte);\n\t\t\tpte = pte_mkclean(pte);\n\t\t\tset_pte_at(vma->vm_mm, address, ptep, pte);\nunlock_pte:\n\t\t\tpte_unmap_unlock(ptep, ptl);\n\t\t}\n\n\t\tmmu_notifier_invalidate_range_end(vma->vm_mm, start, end);\n\t}\n\ti_mmap_unlock_read(mapping);\n}"
  },
  {
    "function_name": "pgoff_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "740-748",
    "snippet": "static inline\nunsigned long pgoff_address(pgoff_t pgoff, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\n\taddress = vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\treturn address;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "address < vma->vm_start || address >= vma->vm_end",
            "vma"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic inline\nunsigned long pgoff_address(pgoff_t pgoff, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\n\taddress = vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\treturn address;\n}"
  },
  {
    "function_name": "dax_insert_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "690-738",
    "snippet": "static void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_ZERO_PAGE\t(1UL << 2)",
      "#define DAX_LOCKED\t(1UL << 0)",
      "#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)",
      "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "xas"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set_mark",
          "args": [
            "xas",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "xas"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_mk_value",
          "args": [
            "xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "entry"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_lock_entry",
          "args": [
            "xas",
            "new_entry"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "dax_lock_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "263-267",
          "snippet": "static void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_empty_entry",
          "args": [
            "entry"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_empty_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "128-131",
          "snippet": "static int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_EMPTY\t(1UL << 3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_EMPTY\t(1UL << 3)\n\nstatic int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_zero_entry",
          "args": [
            "entry"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_zero_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "123-126",
          "snippet": "static int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n\nstatic int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_associate_entry",
          "args": [
            "new_entry",
            "mapping",
            "vmf->vma",
            "vmf->address"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "dax_associate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "299-316",
          "snippet": "static void dax_associate_entry(void *entry, struct address_space *mapping,\n\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tunsigned long size = dax_entry_size(entry), pfn, index;\n\tint i = 0;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tindex = linear_page_index(vma, address & ~(size - 1));\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(page->mapping);\n\t\tpage->mapping = mapping;\n\t\tpage->index = index + i++;\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_associate_entry(void *entry, struct address_space *mapping,\n\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tunsigned long size = dax_entry_size(entry), pfn, index;\n\tint i = 0;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tindex = linear_page_index(vma, address & ~(size - 1));\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(page->mapping);\n\t\tpage->mapping = mapping;\n\t\tpage->index = index + i++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_disassociate_entry",
          "args": [
            "entry",
            "mapping",
            "false"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "dax_disassociate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "318-334",
          "snippet": "static void dax_disassociate_entry(void *entry, struct address_space *mapping,\n\t\tbool trunc)\n{\n\tunsigned long pfn;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(trunc && page_ref_count(page) > 1);\n\t\tWARN_ON_ONCE(page->mapping && page->mapping != mapping);\n\t\tpage->mapping = NULL;\n\t\tpage->index = 0;\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_disassociate_entry(void *entry, struct address_space *mapping,\n\t\tbool trunc)\n{\n\tunsigned long pfn;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(trunc && page_ref_count(page) > 1);\n\t\tWARN_ON_ONCE(page->mapping && page->mapping != mapping);\n\t\tpage->mapping = NULL;\n\t\tpage->index = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_entry_size",
          "args": [
            "new_entry"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "dax_entry_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "269-279",
          "snippet": "static unsigned long dax_entry_size(void *entry)\n{\n\tif (dax_is_zero_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_empty_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_pmd_entry(entry))\n\t\treturn PMD_SIZE;\n\telse\n\t\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic unsigned long dax_entry_size(void *entry)\n{\n\tif (dax_is_zero_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_empty_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_pmd_entry(entry))\n\t\treturn PMD_SIZE;\n\telse\n\t\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "xas"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "xas"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_pages",
          "args": [
            "mapping",
            "index",
            "1",
            "false"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_pages",
          "args": [
            "mapping",
            "index & ~PG_PMD_COLOUR",
            "PG_PMD_NR",
            "false"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_is_pmd_entry",
          "args": [
            "entry"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_pmd_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "113-116",
          "snippet": "static unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_PMD\t\t(1UL << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "mapping->host",
            "I_DIRTY_PAGES"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2107-2217",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_make_entry",
          "args": [
            "pfn",
            "flags"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "dax_make_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "96-99",
          "snippet": "static void *dax_make_entry(pfn_t pfn, unsigned long flags)\n{\n\treturn xa_mk_value(flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT));\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_SHIFT\t(4)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_SHIFT\t(4)\n\nstatic void *dax_make_entry(pfn_t pfn, unsigned long flags)\n{\n\treturn xa_mk_value(flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n#define DAX_LOCKED\t(1UL << 0)\n#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n\nstatic void *dax_insert_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, struct vm_fault *vmf,\n\t\tvoid *entry, pfn_t pfn, unsigned long flags, bool dirty)\n{\n\tvoid *new_entry = dax_make_entry(pfn, flags);\n\n\tif (dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\tif (dax_is_zero_entry(entry) && !(flags & DAX_ZERO_PAGE)) {\n\t\tunsigned long index = xas->xa_index;\n\t\t/* we are replacing a zero page with block mapping */\n\t\tif (dax_is_pmd_entry(entry))\n\t\t\tunmap_mapping_pages(mapping, index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\telse /* pte entry */\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\t}\n\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\tif (dax_entry_size(entry) != dax_entry_size(new_entry)) {\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\tdax_associate_entry(new_entry, mapping, vmf->vma, vmf->address);\n\t}\n\n\tif (dax_is_zero_entry(entry) || dax_is_empty_entry(entry)) {\n\t\t/*\n\t\t * Only swap our new entry into the page cache if the current\n\t\t * entry is a zero page or an empty entry.  If a normal PTE or\n\t\t * PMD entry is already in the cache, we leave it alone.  This\n\t\t * means that if we are trying to insert a PTE and the\n\t\t * existing entry is a PMD, we will just leave the PMD in the\n\t\t * tree and dirty it if necessary.\n\t\t */\n\t\tvoid *old = dax_lock_entry(xas, new_entry);\n\t\tWARN_ON_ONCE(old != xa_mk_value(xa_to_value(entry) |\n\t\t\t\t\tDAX_LOCKED));\n\t\tentry = new_entry;\n\t} else {\n\t\txas_load(xas);\t/* Walk the xa_state */\n\t}\n\n\tif (dirty)\n\t\txas_set_mark(xas, PAGECACHE_TAG_DIRTY);\n\n\txas_unlock_irq(xas);\n\treturn entry;\n}"
  },
  {
    "function_name": "copy_user_dax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "657-681",
    "snippet": "static int copy_user_dax(struct block_device *bdev, struct dax_device *dax_dev,\n\t\tsector_t sector, size_t size, struct page *to,\n\t\tunsigned long vaddr)\n{\n\tvoid *vto, *kaddr;\n\tpgoff_t pgoff;\n\tlong rc;\n\tint id;\n\n\trc = bdev_dax_pgoff(bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\n\tid = dax_read_lock();\n\trc = dax_direct_access(dax_dev, pgoff, PHYS_PFN(size), &kaddr, NULL);\n\tif (rc < 0) {\n\t\tdax_read_unlock(id);\n\t\treturn rc;\n\t}\n\tvto = kmap_atomic(to);\n\tcopy_user_page(vto, (void __force *)kaddr, vaddr, to);\n\tkunmap_atomic(vto);\n\tdax_read_unlock(id);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_read_unlock",
          "args": [
            "id"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "vto"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_user_page",
          "args": [
            "vto",
            "(void __force *)kaddr",
            "vaddr",
            "to"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "to"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_read_unlock",
          "args": [
            "id"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_direct_access",
          "args": [
            "dax_dev",
            "pgoff",
            "PHYS_PFN(size)",
            "&kaddr",
            "NULL"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "size"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_read_lock",
          "args": [],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_dax_pgoff",
          "args": [
            "bdev",
            "sector",
            "size",
            "&pgoff"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int copy_user_dax(struct block_device *bdev, struct dax_device *dax_dev,\n\t\tsector_t sector, size_t size, struct page *to,\n\t\tunsigned long vaddr)\n{\n\tvoid *vto, *kaddr;\n\tpgoff_t pgoff;\n\tlong rc;\n\tint id;\n\n\trc = bdev_dax_pgoff(bdev, sector, size, &pgoff);\n\tif (rc)\n\t\treturn rc;\n\n\tid = dax_read_lock();\n\trc = dax_direct_access(dax_dev, pgoff, PHYS_PFN(size), &kaddr, NULL);\n\tif (rc < 0) {\n\t\tdax_read_unlock(id);\n\t\treturn rc;\n\t}\n\tvto = kmap_atomic(to);\n\tcopy_user_page(vto, (void __force *)kaddr, vaddr, to);\n\tkunmap_atomic(vto);\n\tdax_read_unlock(id);\n\treturn 0;\n}"
  },
  {
    "function_name": "dax_invalidate_mapping_entry_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "651-655",
    "snippet": "int dax_invalidate_mapping_entry_sync(struct address_space *mapping,\n\t\t\t\t      pgoff_t index)\n{\n\treturn __dax_invalidate_entry(mapping, index, false);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dax_invalidate_entry",
          "args": [
            "mapping",
            "index",
            "false"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "__dax_invalidate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "604-627",
          "snippet": "static int __dax_invalidate_entry(struct address_space *mapping,\n\t\t\t\t\t  pgoff_t index, bool trunc)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\tint ret = 0;\n\tvoid *entry;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\tgoto out;\n\tif (!trunc &&\n\t    (xas_get_mark(&xas, PAGECACHE_TAG_DIRTY) ||\n\t     xas_get_mark(&xas, PAGECACHE_TAG_TOWRITE)))\n\t\tgoto out;\n\tdax_disassociate_entry(entry, mapping, trunc);\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n\tret = 1;\nout:\n\tput_unlocked_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int __dax_invalidate_entry(struct address_space *mapping,\n\t\t\t\t\t  pgoff_t index, bool trunc)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\tint ret = 0;\n\tvoid *entry;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\tgoto out;\n\tif (!trunc &&\n\t    (xas_get_mark(&xas, PAGECACHE_TAG_DIRTY) ||\n\t     xas_get_mark(&xas, PAGECACHE_TAG_TOWRITE)))\n\t\tgoto out;\n\tdax_disassociate_entry(entry, mapping, trunc);\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n\tret = 1;\nout:\n\tput_unlocked_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_invalidate_mapping_entry_sync(struct address_space *mapping,\n\t\t\t\t      pgoff_t index)\n{\n\treturn __dax_invalidate_entry(mapping, index, false);\n}"
  },
  {
    "function_name": "dax_delete_mapping_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "633-646",
    "snippet": "int dax_delete_mapping_entry(struct address_space *mapping, pgoff_t index)\n{\n\tint ret = __dax_invalidate_entry(mapping, index, true);\n\n\t/*\n\t * This gets called from truncate / punch_hole path. As such, the caller\n\t * must hold locks protecting against concurrent modifications of the\n\t * page cache (usually fs-private i_mmap_sem for writing). Since the\n\t * caller has seen a DAX entry for this index, we better find it\n\t * at that index as well...\n\t */\n\tWARN_ON_ONCE(!ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!ret"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dax_invalidate_entry",
          "args": [
            "mapping",
            "index",
            "true"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "__dax_invalidate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "604-627",
          "snippet": "static int __dax_invalidate_entry(struct address_space *mapping,\n\t\t\t\t\t  pgoff_t index, bool trunc)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\tint ret = 0;\n\tvoid *entry;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\tgoto out;\n\tif (!trunc &&\n\t    (xas_get_mark(&xas, PAGECACHE_TAG_DIRTY) ||\n\t     xas_get_mark(&xas, PAGECACHE_TAG_TOWRITE)))\n\t\tgoto out;\n\tdax_disassociate_entry(entry, mapping, trunc);\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n\tret = 1;\nout:\n\tput_unlocked_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int __dax_invalidate_entry(struct address_space *mapping,\n\t\t\t\t\t  pgoff_t index, bool trunc)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\tint ret = 0;\n\tvoid *entry;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\tgoto out;\n\tif (!trunc &&\n\t    (xas_get_mark(&xas, PAGECACHE_TAG_DIRTY) ||\n\t     xas_get_mark(&xas, PAGECACHE_TAG_TOWRITE)))\n\t\tgoto out;\n\tdax_disassociate_entry(entry, mapping, trunc);\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n\tret = 1;\nout:\n\tput_unlocked_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_delete_mapping_entry(struct address_space *mapping, pgoff_t index)\n{\n\tint ret = __dax_invalidate_entry(mapping, index, true);\n\n\t/*\n\t * This gets called from truncate / punch_hole path. As such, the caller\n\t * must hold locks protecting against concurrent modifications of the\n\t * page cache (usually fs-private i_mmap_sem for writing). Since the\n\t * caller has seen a DAX entry for this index, we better find it\n\t * at that index as well...\n\t */\n\tWARN_ON_ONCE(!ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "__dax_invalidate_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "604-627",
    "snippet": "static int __dax_invalidate_entry(struct address_space *mapping,\n\t\t\t\t\t  pgoff_t index, bool trunc)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\tint ret = 0;\n\tvoid *entry;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\tgoto out;\n\tif (!trunc &&\n\t    (xas_get_mark(&xas, PAGECACHE_TAG_DIRTY) ||\n\t     xas_get_mark(&xas, PAGECACHE_TAG_TOWRITE)))\n\t\tgoto out;\n\tdax_disassociate_entry(entry, mapping, trunc);\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n\tret = 1;\nout:\n\tput_unlocked_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unlocked_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "put_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "235-240",
          "snippet": "static void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "NULL"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_disassociate_entry",
          "args": [
            "entry",
            "mapping",
            "trunc"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "dax_disassociate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "318-334",
          "snippet": "static void dax_disassociate_entry(void *entry, struct address_space *mapping,\n\t\tbool trunc)\n{\n\tunsigned long pfn;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(trunc && page_ref_count(page) > 1);\n\t\tWARN_ON_ONCE(page->mapping && page->mapping != mapping);\n\t\tpage->mapping = NULL;\n\t\tpage->index = 0;\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_disassociate_entry(void *entry, struct address_space *mapping,\n\t\tbool trunc)\n{\n\tunsigned long pfn;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(trunc && page_ref_count(page) > 1);\n\t\tWARN_ON_ONCE(page->mapping && page->mapping != mapping);\n\t\tpage->mapping = NULL;\n\t\tpage->index = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_get_mark",
          "args": [
            "&xas",
            "PAGECACHE_TAG_TOWRITE"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_get_mark",
          "args": [
            "&xas",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!xa_is_value(entry)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "entry"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unlocked_entry",
          "args": [
            "&xas"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "get_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "209-233",
          "snippet": "static void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "index"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int __dax_invalidate_entry(struct address_space *mapping,\n\t\t\t\t\t  pgoff_t index, bool trunc)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\tint ret = 0;\n\tvoid *entry;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)))\n\t\tgoto out;\n\tif (!trunc &&\n\t    (xas_get_mark(&xas, PAGECACHE_TAG_DIRTY) ||\n\t     xas_get_mark(&xas, PAGECACHE_TAG_TOWRITE)))\n\t\tgoto out;\n\tdax_disassociate_entry(entry, mapping, trunc);\n\txas_store(&xas, NULL);\n\tmapping->nrexceptional--;\n\tret = 1;\nout:\n\tput_unlocked_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\treturn ret;\n}"
  },
  {
    "function_name": "dax_layout_busy_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "550-601",
    "snippet": "struct page *dax_layout_busy_page(struct address_space *mapping)\n{\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\tvoid *entry;\n\tunsigned int scanned = 0;\n\tstruct page *page = NULL;\n\n\t/*\n\t * In the 'limited' case get_user_pages() for dax is disabled.\n\t */\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn NULL;\n\n\tif (!dax_mapping(mapping) || !mapping_mapped(mapping))\n\t\treturn NULL;\n\n\t/*\n\t * If we race get_user_pages_fast() here either we'll see the\n\t * elevated page count in the iteration and wait, or\n\t * get_user_pages_fast() will see that the page it took a reference\n\t * against is no longer mapped in the page tables and bail to the\n\t * get_user_pages() slow path.  The slow path is protected by\n\t * pte_lock() and pmd_lock(). New references are not taken without\n\t * holding those locks, and unmap_mapping_range() will not zero the\n\t * pte or pmd without holding the respective lock, so we are\n\t * guaranteed to either see new references or prevent new\n\t * references from being established.\n\t */\n\tunmap_mapping_range(mapping, 0, 0, 1);\n\n\txas_lock_irq(&xas);\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\tif (WARN_ON_ONCE(!xa_is_value(entry)))\n\t\t\tcontinue;\n\t\tif (unlikely(dax_is_locked(entry)))\n\t\t\tentry = get_unlocked_entry(&xas);\n\t\tif (entry)\n\t\t\tpage = dax_busy_page(entry);\n\t\tput_unlocked_entry(&xas, entry);\n\t\tif (page)\n\t\t\tbreak;\n\t\tif (++scanned % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\tcond_resched();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_pause",
          "args": [
            "&xas"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unlocked_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "put_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "235-240",
          "snippet": "static void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_busy_page",
          "args": [
            "entry"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "dax_busy_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "336-347",
          "snippet": "static struct page *dax_busy_page(void *entry)\n{\n\tunsigned long pfn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tif (page_ref_count(page) > 1)\n\t\t\treturn page;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic struct page *dax_busy_page(void *entry)\n{\n\tunsigned long pfn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tif (page_ref_count(page) > 1)\n\t\t\treturn page;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unlocked_entry",
          "args": [
            "&xas"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "get_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "209-233",
          "snippet": "static void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dax_is_locked(entry)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_is_locked",
          "args": [
            "entry"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "101-104",
          "snippet": "static bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!xa_is_value(entry)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "entry"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each",
          "args": [
            "&xas",
            "entry",
            "ULONG_MAX"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "mapping",
            "0",
            "0",
            "1"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_mapped",
          "args": [
            "mapping"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_mapping",
          "args": [
            "mapping"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_FS_DAX_LIMITED"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "0"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstruct page *dax_layout_busy_page(struct address_space *mapping)\n{\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\tvoid *entry;\n\tunsigned int scanned = 0;\n\tstruct page *page = NULL;\n\n\t/*\n\t * In the 'limited' case get_user_pages() for dax is disabled.\n\t */\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn NULL;\n\n\tif (!dax_mapping(mapping) || !mapping_mapped(mapping))\n\t\treturn NULL;\n\n\t/*\n\t * If we race get_user_pages_fast() here either we'll see the\n\t * elevated page count in the iteration and wait, or\n\t * get_user_pages_fast() will see that the page it took a reference\n\t * against is no longer mapped in the page tables and bail to the\n\t * get_user_pages() slow path.  The slow path is protected by\n\t * pte_lock() and pmd_lock(). New references are not taken without\n\t * holding those locks, and unmap_mapping_range() will not zero the\n\t * pte or pmd without holding the respective lock, so we are\n\t * guaranteed to either see new references or prevent new\n\t * references from being established.\n\t */\n\tunmap_mapping_range(mapping, 0, 0, 1);\n\n\txas_lock_irq(&xas);\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\tif (WARN_ON_ONCE(!xa_is_value(entry)))\n\t\t\tcontinue;\n\t\tif (unlikely(dax_is_locked(entry)))\n\t\t\tentry = get_unlocked_entry(&xas);\n\t\tif (entry)\n\t\t\tpage = dax_busy_page(entry);\n\t\tput_unlocked_entry(&xas, entry);\n\t\tif (page)\n\t\t\tbreak;\n\t\tif (++scanned % XA_CHECK_SCHED)\n\t\t\tcontinue;\n\n\t\txas_pause(&xas);\n\t\txas_unlock_irq(&xas);\n\t\tcond_resched();\n\t\txas_lock_irq(&xas);\n\t}\n\txas_unlock_irq(&xas);\n\treturn page;\n}"
  },
  {
    "function_name": "grab_mapping_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "451-533",
    "snippet": "static void *grab_mapping_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, unsigned long size_flag)\n{\n\tunsigned long index = xas->xa_index;\n\tbool pmd_downgrade = false; /* splitting PMD entry into PTE entries? */\n\tvoid *entry;\n\nretry:\n\txas_lock_irq(xas);\n\tentry = get_unlocked_entry(xas);\n\n\tif (entry) {\n\t\tif (!xa_is_value(entry)) {\n\t\t\txas_set_err(xas, EIO);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (size_flag & DAX_PMD) {\n\t\t\tif (dax_is_pte_entry(entry)) {\n\t\t\t\tput_unlocked_entry(xas, entry);\n\t\t\t\tgoto fallback;\n\t\t\t}\n\t\t} else { /* trying to grab a PTE entry */\n\t\t\tif (dax_is_pmd_entry(entry) &&\n\t\t\t    (dax_is_zero_entry(entry) ||\n\t\t\t     dax_is_empty_entry(entry))) {\n\t\t\t\tpmd_downgrade = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pmd_downgrade) {\n\t\t/*\n\t\t * Make sure 'entry' remains valid while we drop\n\t\t * the i_pages lock.\n\t\t */\n\t\tdax_lock_entry(xas, entry);\n\n\t\t/*\n\t\t * Besides huge zero pages the only other thing that gets\n\t\t * downgraded are empty entries which don't need to be\n\t\t * unmapped.\n\t\t */\n\t\tif (dax_is_zero_entry(entry)) {\n\t\t\txas_unlock_irq(xas);\n\t\t\tunmap_mapping_pages(mapping,\n\t\t\t\t\txas->xa_index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\t\txas_reset(xas);\n\t\t\txas_lock_irq(xas);\n\t\t}\n\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\txas_store(xas, NULL);\t/* undo the PMD join */\n\t\tdax_wake_entry(xas, entry, true);\n\t\tmapping->nrexceptional--;\n\t\tentry = NULL;\n\t\txas_set(xas, index);\n\t}\n\n\tif (entry) {\n\t\tdax_lock_entry(xas, entry);\n\t} else {\n\t\tentry = dax_make_entry(pfn_to_pfn_t(0), size_flag | DAX_EMPTY);\n\t\tdax_lock_entry(xas, entry);\n\t\tif (xas_error(xas))\n\t\t\tgoto out_unlock;\n\t\tmapping->nrexceptional++;\n\t}\n\nout_unlock:\n\txas_unlock_irq(xas);\n\tif (xas_nomem(xas, mapping_gfp_mask(mapping) & ~__GFP_HIGHMEM))\n\t\tgoto retry;\n\tif (xas->xa_node == XA_ERROR(-ENOMEM))\n\t\treturn xa_mk_internal(VM_FAULT_OOM);\n\tif (xas_error(xas))\n\t\treturn xa_mk_internal(VM_FAULT_SIGBUS);\n\treturn entry;\nfallback:\n\txas_unlock_irq(xas);\n\treturn xa_mk_internal(VM_FAULT_FALLBACK);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_EMPTY\t(1UL << 3)",
      "#define DAX_PMD\t\t(1UL << 1)",
      "#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)",
      "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_mk_internal",
          "args": [
            "VM_FAULT_FALLBACK"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "xas"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_mk_internal",
          "args": [
            "VM_FAULT_SIGBUS"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_error",
          "args": [
            "xas"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_mk_internal",
          "args": [
            "VM_FAULT_OOM"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_ERROR",
          "args": [
            "-ENOMEM"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_nomem",
          "args": [
            "xas",
            "mapping_gfp_mask(mapping) & ~__GFP_HIGHMEM"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "xas"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_error",
          "args": [
            "xas"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_lock_entry",
          "args": [
            "xas",
            "entry"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "dax_lock_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "263-267",
          "snippet": "static void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_make_entry",
          "args": [
            "pfn_to_pfn_t(0)",
            "size_flag | DAX_EMPTY"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "dax_make_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "96-99",
          "snippet": "static void *dax_make_entry(pfn_t pfn, unsigned long flags)\n{\n\treturn xa_mk_value(flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT));\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_SHIFT\t(4)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_SHIFT\t(4)\n\nstatic void *dax_make_entry(pfn_t pfn, unsigned long flags)\n{\n\treturn xa_mk_value(flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_pfn_t",
          "args": [
            "0"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set",
          "args": [
            "xas",
            "index"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_wake_entry",
          "args": [
            "xas",
            "entry",
            "true"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "dax_wake_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "184-199",
          "snippet": "static void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "xas",
            "NULL"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_disassociate_entry",
          "args": [
            "entry",
            "mapping",
            "false"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "dax_disassociate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "318-334",
          "snippet": "static void dax_disassociate_entry(void *entry, struct address_space *mapping,\n\t\tbool trunc)\n{\n\tunsigned long pfn;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(trunc && page_ref_count(page) > 1);\n\t\tWARN_ON_ONCE(page->mapping && page->mapping != mapping);\n\t\tpage->mapping = NULL;\n\t\tpage->index = 0;\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_disassociate_entry(void *entry, struct address_space *mapping,\n\t\tbool trunc)\n{\n\tunsigned long pfn;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(trunc && page_ref_count(page) > 1);\n\t\tWARN_ON_ONCE(page->mapping && page->mapping != mapping);\n\t\tpage->mapping = NULL;\n\t\tpage->index = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "xas"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "xas"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_pages",
          "args": [
            "mapping",
            "xas->xa_index & ~PG_PMD_COLOUR",
            "PG_PMD_NR",
            "false"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "xas"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_is_zero_entry",
          "args": [
            "entry"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_zero_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "123-126",
          "snippet": "static int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n\nstatic int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_empty_entry",
          "args": [
            "entry"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_empty_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "128-131",
          "snippet": "static int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_EMPTY\t(1UL << 3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_EMPTY\t(1UL << 3)\n\nstatic int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_pmd_entry",
          "args": [
            "entry"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_pmd_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "113-116",
          "snippet": "static unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_PMD\t\t(1UL << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unlocked_entry",
          "args": [
            "xas",
            "entry"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "put_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "235-240",
          "snippet": "static void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_pte_entry",
          "args": [
            "entry"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_pte_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "118-121",
          "snippet": "static bool dax_is_pte_entry(void *entry)\n{\n\treturn !(xa_to_value(entry) & DAX_PMD);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_PMD\t\t(1UL << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic bool dax_is_pte_entry(void *entry)\n{\n\treturn !(xa_to_value(entry) & DAX_PMD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_set_err",
          "args": [
            "xas",
            "EIO"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "entry"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unlocked_entry",
          "args": [
            "xas"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "get_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "209-233",
          "snippet": "static void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "xas"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_EMPTY\t(1UL << 3)\n#define DAX_PMD\t\t(1UL << 1)\n#define PG_PMD_NR\t(PMD_SIZE >> PAGE_SHIFT)\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n\nstatic void *grab_mapping_entry(struct xa_state *xas,\n\t\tstruct address_space *mapping, unsigned long size_flag)\n{\n\tunsigned long index = xas->xa_index;\n\tbool pmd_downgrade = false; /* splitting PMD entry into PTE entries? */\n\tvoid *entry;\n\nretry:\n\txas_lock_irq(xas);\n\tentry = get_unlocked_entry(xas);\n\n\tif (entry) {\n\t\tif (!xa_is_value(entry)) {\n\t\t\txas_set_err(xas, EIO);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (size_flag & DAX_PMD) {\n\t\t\tif (dax_is_pte_entry(entry)) {\n\t\t\t\tput_unlocked_entry(xas, entry);\n\t\t\t\tgoto fallback;\n\t\t\t}\n\t\t} else { /* trying to grab a PTE entry */\n\t\t\tif (dax_is_pmd_entry(entry) &&\n\t\t\t    (dax_is_zero_entry(entry) ||\n\t\t\t     dax_is_empty_entry(entry))) {\n\t\t\t\tpmd_downgrade = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pmd_downgrade) {\n\t\t/*\n\t\t * Make sure 'entry' remains valid while we drop\n\t\t * the i_pages lock.\n\t\t */\n\t\tdax_lock_entry(xas, entry);\n\n\t\t/*\n\t\t * Besides huge zero pages the only other thing that gets\n\t\t * downgraded are empty entries which don't need to be\n\t\t * unmapped.\n\t\t */\n\t\tif (dax_is_zero_entry(entry)) {\n\t\t\txas_unlock_irq(xas);\n\t\t\tunmap_mapping_pages(mapping,\n\t\t\t\t\txas->xa_index & ~PG_PMD_COLOUR,\n\t\t\t\t\tPG_PMD_NR, false);\n\t\t\txas_reset(xas);\n\t\t\txas_lock_irq(xas);\n\t\t}\n\n\t\tdax_disassociate_entry(entry, mapping, false);\n\t\txas_store(xas, NULL);\t/* undo the PMD join */\n\t\tdax_wake_entry(xas, entry, true);\n\t\tmapping->nrexceptional--;\n\t\tentry = NULL;\n\t\txas_set(xas, index);\n\t}\n\n\tif (entry) {\n\t\tdax_lock_entry(xas, entry);\n\t} else {\n\t\tentry = dax_make_entry(pfn_to_pfn_t(0), size_flag | DAX_EMPTY);\n\t\tdax_lock_entry(xas, entry);\n\t\tif (xas_error(xas))\n\t\t\tgoto out_unlock;\n\t\tmapping->nrexceptional++;\n\t}\n\nout_unlock:\n\txas_unlock_irq(xas);\n\tif (xas_nomem(xas, mapping_gfp_mask(mapping) & ~__GFP_HIGHMEM))\n\t\tgoto retry;\n\tif (xas->xa_node == XA_ERROR(-ENOMEM))\n\t\treturn xa_mk_internal(VM_FAULT_OOM);\n\tif (xas_error(xas))\n\t\treturn xa_mk_internal(VM_FAULT_SIGBUS);\n\treturn entry;\nfallback:\n\txas_unlock_irq(xas);\n\treturn xa_mk_internal(VM_FAULT_FALLBACK);\n}"
  },
  {
    "function_name": "dax_unlock_mapping_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "406-420",
    "snippet": "void dax_unlock_mapping_entry(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tXA_STATE(xas, &mapping->i_pages, page->index);\n\tvoid *entry;\n\n\tif (S_ISCHR(mapping->host->i_mode))\n\t\treturn;\n\n\trcu_read_lock();\n\tentry = xas_load(&xas);\n\trcu_read_unlock();\n\tentry = dax_make_entry(page_to_pfn_t(page), dax_is_pmd_entry(entry));\n\tdax_unlock_entry(&xas, entry);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_unlock_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "dax_unlock_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "247-258",
          "snippet": "static void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_make_entry",
          "args": [
            "page_to_pfn_t(page)",
            "dax_is_pmd_entry(entry)"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "dax_make_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "96-99",
          "snippet": "static void *dax_make_entry(pfn_t pfn, unsigned long flags)\n{\n\treturn xa_mk_value(flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT));\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_SHIFT\t(4)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_SHIFT\t(4)\n\nstatic void *dax_make_entry(pfn_t pfn, unsigned long flags)\n{\n\treturn xa_mk_value(flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_pmd_entry",
          "args": [
            "entry"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_pmd_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "113-116",
          "snippet": "static unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_PMD\t\t(1UL << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn_t",
          "args": [
            "page"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mapping->host->i_mode"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "page->index"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nvoid dax_unlock_mapping_entry(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tXA_STATE(xas, &mapping->i_pages, page->index);\n\tvoid *entry;\n\n\tif (S_ISCHR(mapping->host->i_mode))\n\t\treturn;\n\n\trcu_read_lock();\n\tentry = xas_load(&xas);\n\trcu_read_unlock();\n\tentry = dax_make_entry(page_to_pfn_t(page), dax_is_pmd_entry(entry));\n\tdax_unlock_entry(&xas, entry);\n}"
  },
  {
    "function_name": "dax_lock_mapping_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "356-404",
    "snippet": "bool dax_lock_mapping_entry(struct page *page)\n{\n\tXA_STATE(xas, NULL, 0);\n\tvoid *entry;\n\tbool locked;\n\n\t/* Ensure page->mapping isn't freed while we look at it */\n\trcu_read_lock();\n\tfor (;;) {\n\t\tstruct address_space *mapping = READ_ONCE(page->mapping);\n\n\t\tlocked = false;\n\t\tif (!dax_mapping(mapping))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * In the device-dax case there's no need to lock, a\n\t\t * struct dev_pagemap pin is sufficient to keep the\n\t\t * inode alive, and we assume we have dev_pagemap pin\n\t\t * otherwise we would not have a valid pfn_to_page()\n\t\t * translation.\n\t\t */\n\t\tlocked = true;\n\t\tif (S_ISCHR(mapping->host->i_mode))\n\t\t\tbreak;\n\n\t\txas.xa = &mapping->i_pages;\n\t\txas_lock_irq(&xas);\n\t\tif (mapping != page->mapping) {\n\t\t\txas_unlock_irq(&xas);\n\t\t\tcontinue;\n\t\t}\n\t\txas_set(&xas, page->index);\n\t\tentry = xas_load(&xas);\n\t\tif (dax_is_locked(entry)) {\n\t\t\trcu_read_unlock();\n\t\t\tentry = get_unlocked_entry(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tput_unlocked_entry(&xas, entry);\n\t\t\trcu_read_lock();\n\t\t\tcontinue;\n\t\t}\n\t\tdax_lock_entry(&xas, entry);\n\t\txas_unlock_irq(&xas);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn locked;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_lock_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "dax_lock_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "263-267",
          "snippet": "static void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unlocked_entry",
          "args": [
            "&xas",
            "entry"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "put_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "235-240",
          "snippet": "static void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unlocked_entry",
          "args": [
            "&xas"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "get_unlocked_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "209-233",
          "snippet": "static void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_is_locked",
          "args": [
            "entry"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "101-104",
          "snippet": "static bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set",
          "args": [
            "&xas",
            "page->index"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mapping->host->i_mode"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_mapping",
          "args": [
            "mapping"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page->mapping"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "NULL",
            "0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nbool dax_lock_mapping_entry(struct page *page)\n{\n\tXA_STATE(xas, NULL, 0);\n\tvoid *entry;\n\tbool locked;\n\n\t/* Ensure page->mapping isn't freed while we look at it */\n\trcu_read_lock();\n\tfor (;;) {\n\t\tstruct address_space *mapping = READ_ONCE(page->mapping);\n\n\t\tlocked = false;\n\t\tif (!dax_mapping(mapping))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * In the device-dax case there's no need to lock, a\n\t\t * struct dev_pagemap pin is sufficient to keep the\n\t\t * inode alive, and we assume we have dev_pagemap pin\n\t\t * otherwise we would not have a valid pfn_to_page()\n\t\t * translation.\n\t\t */\n\t\tlocked = true;\n\t\tif (S_ISCHR(mapping->host->i_mode))\n\t\t\tbreak;\n\n\t\txas.xa = &mapping->i_pages;\n\t\txas_lock_irq(&xas);\n\t\tif (mapping != page->mapping) {\n\t\t\txas_unlock_irq(&xas);\n\t\t\tcontinue;\n\t\t}\n\t\txas_set(&xas, page->index);\n\t\tentry = xas_load(&xas);\n\t\tif (dax_is_locked(entry)) {\n\t\t\trcu_read_unlock();\n\t\t\tentry = get_unlocked_entry(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tput_unlocked_entry(&xas, entry);\n\t\t\trcu_read_lock();\n\t\t\tcontinue;\n\t\t}\n\t\tdax_lock_entry(&xas, entry);\n\t\txas_unlock_irq(&xas);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn locked;\n}"
  },
  {
    "function_name": "dax_busy_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "336-347",
    "snippet": "static struct page *dax_busy_page(void *entry)\n{\n\tunsigned long pfn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tif (page_ref_count(page) > 1)\n\t\t\treturn page;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_ref_count",
          "args": [
            "page"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mapped_pfn",
          "args": [
            "entry",
            "pfn"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic struct page *dax_busy_page(void *entry)\n{\n\tunsigned long pfn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tif (page_ref_count(page) > 1)\n\t\t\treturn page;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "dax_disassociate_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "318-334",
    "snippet": "static void dax_disassociate_entry(void *entry, struct address_space *mapping,\n\t\tbool trunc)\n{\n\tunsigned long pfn;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(trunc && page_ref_count(page) > 1);\n\t\tWARN_ON_ONCE(page->mapping && page->mapping != mapping);\n\t\tpage->mapping = NULL;\n\t\tpage->index = 0;\n\t}\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "page->mapping && page->mapping != mapping"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "trunc && page_ref_count(page) > 1"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_count",
          "args": [
            "page"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mapped_pfn",
          "args": [
            "entry",
            "pfn"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_FS_DAX_LIMITED"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_disassociate_entry(void *entry, struct address_space *mapping,\n\t\tbool trunc)\n{\n\tunsigned long pfn;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(trunc && page_ref_count(page) > 1);\n\t\tWARN_ON_ONCE(page->mapping && page->mapping != mapping);\n\t\tpage->mapping = NULL;\n\t\tpage->index = 0;\n\t}\n}"
  },
  {
    "function_name": "dax_associate_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "299-316",
    "snippet": "static void dax_associate_entry(void *entry, struct address_space *mapping,\n\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tunsigned long size = dax_entry_size(entry), pfn, index;\n\tint i = 0;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tindex = linear_page_index(vma, address & ~(size - 1));\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(page->mapping);\n\t\tpage->mapping = mapping;\n\t\tpage->index = index + i++;\n\t}\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "page->mapping"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mapped_pfn",
          "args": [
            "entry",
            "pfn"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "address & ~(size - 1)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_FS_DAX_LIMITED"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_entry_size",
          "args": [
            "entry"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "dax_entry_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "269-279",
          "snippet": "static unsigned long dax_entry_size(void *entry)\n{\n\tif (dax_is_zero_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_empty_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_pmd_entry(entry))\n\t\treturn PMD_SIZE;\n\telse\n\t\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic unsigned long dax_entry_size(void *entry)\n{\n\tif (dax_is_zero_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_empty_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_pmd_entry(entry))\n\t\treturn PMD_SIZE;\n\telse\n\t\treturn PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_associate_entry(void *entry, struct address_space *mapping,\n\t\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tunsigned long size = dax_entry_size(entry), pfn, index;\n\tint i = 0;\n\n\tif (IS_ENABLED(CONFIG_FS_DAX_LIMITED))\n\t\treturn;\n\n\tindex = linear_page_index(vma, address & ~(size - 1));\n\tfor_each_mapped_pfn(entry, pfn) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tWARN_ON_ONCE(page->mapping);\n\t\tpage->mapping = mapping;\n\t\tpage->index = index + i++;\n\t}\n}"
  },
  {
    "function_name": "dax_end_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "281-284",
    "snippet": "static unsigned long dax_end_pfn(void *entry)\n{\n\treturn dax_to_pfn(entry) + dax_entry_size(entry) / PAGE_SIZE;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_entry_size",
          "args": [
            "entry"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "dax_entry_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "269-279",
          "snippet": "static unsigned long dax_entry_size(void *entry)\n{\n\tif (dax_is_zero_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_empty_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_pmd_entry(entry))\n\t\treturn PMD_SIZE;\n\telse\n\t\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic unsigned long dax_entry_size(void *entry)\n{\n\tif (dax_is_zero_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_empty_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_pmd_entry(entry))\n\t\treturn PMD_SIZE;\n\telse\n\t\treturn PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_to_pfn",
          "args": [
            "entry"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "dax_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "91-94",
          "snippet": "static unsigned long dax_to_pfn(void *entry)\n{\n\treturn xa_to_value(entry) >> DAX_SHIFT;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_SHIFT\t(4)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_SHIFT\t(4)\n\nstatic unsigned long dax_to_pfn(void *entry)\n{\n\treturn xa_to_value(entry) >> DAX_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic unsigned long dax_end_pfn(void *entry)\n{\n\treturn dax_to_pfn(entry) + dax_entry_size(entry) / PAGE_SIZE;\n}"
  },
  {
    "function_name": "dax_entry_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "269-279",
    "snippet": "static unsigned long dax_entry_size(void *entry)\n{\n\tif (dax_is_zero_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_empty_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_pmd_entry(entry))\n\t\treturn PMD_SIZE;\n\telse\n\t\treturn PAGE_SIZE;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_is_pmd_entry",
          "args": [
            "entry"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_pmd_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "113-116",
          "snippet": "static unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_PMD\t\t(1UL << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_empty_entry",
          "args": [
            "entry"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_empty_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "128-131",
          "snippet": "static int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_EMPTY\t(1UL << 3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_EMPTY\t(1UL << 3)\n\nstatic int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_zero_entry",
          "args": [
            "entry"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_zero_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "123-126",
          "snippet": "static int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_ZERO_PAGE\t(1UL << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n\nstatic int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic unsigned long dax_entry_size(void *entry)\n{\n\tif (dax_is_zero_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_empty_entry(entry))\n\t\treturn 0;\n\telse if (dax_is_pmd_entry(entry))\n\t\treturn PMD_SIZE;\n\telse\n\t\treturn PAGE_SIZE;\n}"
  },
  {
    "function_name": "dax_lock_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "263-267",
    "snippet": "static void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_LOCKED\t(1UL << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "xas",
            "xa_mk_value(v | DAX_LOCKED)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_mk_value",
          "args": [
            "v | DAX_LOCKED"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "entry"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic void *dax_lock_entry(struct xa_state *xas, void *entry)\n{\n\tunsigned long v = xa_to_value(entry);\n\treturn xas_store(xas, xa_mk_value(v | DAX_LOCKED));\n}"
  },
  {
    "function_name": "dax_unlock_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "247-258",
    "snippet": "static void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_wake_entry",
          "args": [
            "xas",
            "entry",
            "false"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "dax_wake_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "184-199",
          "snippet": "static void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dax_is_locked(old)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_is_locked",
          "args": [
            "old"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "101-104",
          "snippet": "static bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "xas"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "xas",
            "entry"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "xas"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "xas"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dax_is_locked(entry)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_unlock_entry(struct xa_state *xas, void *entry)\n{\n\tvoid *old;\n\n\tBUG_ON(dax_is_locked(entry));\n\txas_reset(xas);\n\txas_lock_irq(xas);\n\told = xas_store(xas, entry);\n\txas_unlock_irq(xas);\n\tBUG_ON(!dax_is_locked(old));\n\tdax_wake_entry(xas, entry, false);\n}"
  },
  {
    "function_name": "put_unlocked_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "235-240",
    "snippet": "static void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_wake_entry",
          "args": [
            "xas",
            "entry",
            "false"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "dax_wake_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "184-199",
          "snippet": "static void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void put_unlocked_entry(struct xa_state *xas, void *entry)\n{\n\t/* If we were the only waiter woken, wake the next one */\n\tif (entry)\n\t\tdax_wake_entry(xas, entry, false);\n}"
  },
  {
    "function_name": "get_unlocked_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "209-233",
    "snippet": "static void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "xas"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&ewait.wait"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_reset",
          "args": [
            "xas"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "xas"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait_exclusive",
          "args": [
            "wq",
            "&ewait.wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_entry_waitqueue",
          "args": [
            "xas",
            "entry",
            "&ewait.key"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "dax_entry_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "146-164",
          "snippet": "static wait_queue_head_t *dax_entry_waitqueue(struct xa_state *xas,\n\t\tvoid *entry, struct exceptional_entry_key *key)\n{\n\tunsigned long hash;\n\tunsigned long index = xas->xa_index;\n\n\t/*\n\t * If 'entry' is a PMD, align the 'index' that we use for the wait\n\t * queue to the start of that PMD.  This ensures that all offsets in\n\t * the range covered by the PMD map to the same bit lock.\n\t */\n\tif (dax_is_pmd_entry(entry))\n\t\tindex &= ~PG_PMD_COLOUR;\n\tkey->xa = xas->xa;\n\tkey->entry_start = index;\n\n\thash = hash_long((unsigned long)xas->xa ^ index, DAX_WAIT_TABLE_BITS);\n\treturn wait_table + hash;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)",
            "#define DAX_WAIT_TABLE_BITS 12"
          ],
          "globals_used": [
            "static wait_queue_head_t wait_table[DAX_WAIT_TABLE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n#define DAX_WAIT_TABLE_BITS 12\n\nstatic wait_queue_head_t wait_table[DAX_WAIT_TABLE_ENTRIES];\n\nstatic wait_queue_head_t *dax_entry_waitqueue(struct xa_state *xas,\n\t\tvoid *entry, struct exceptional_entry_key *key)\n{\n\tunsigned long hash;\n\tunsigned long index = xas->xa_index;\n\n\t/*\n\t * If 'entry' is a PMD, align the 'index' that we use for the wait\n\t * queue to the start of that PMD.  This ensures that all offsets in\n\t * the range covered by the PMD map to the same bit lock.\n\t */\n\tif (dax_is_pmd_entry(entry))\n\t\tindex &= ~PG_PMD_COLOUR;\n\tkey->xa = xas->xa;\n\tkey->entry_start = index;\n\n\thash = hash_long((unsigned long)xas->xa ^ index, DAX_WAIT_TABLE_BITS);\n\treturn wait_table + hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_is_locked",
          "args": [
            "entry"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "101-104",
          "snippet": "static bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_LOCKED\t(1UL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!xa_is_value(entry)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "entry"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_find_conflict",
          "args": [
            "xas"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_wait",
          "args": [
            "&ewait.wait"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void *get_unlocked_entry(struct xa_state *xas)\n{\n\tvoid *entry;\n\tstruct wait_exceptional_entry_queue ewait;\n\twait_queue_head_t *wq;\n\n\tinit_wait(&ewait.wait);\n\tewait.wait.func = wake_exceptional_entry_func;\n\n\tfor (;;) {\n\t\tentry = xas_find_conflict(xas);\n\t\tif (!entry || WARN_ON_ONCE(!xa_is_value(entry)) ||\n\t\t\t\t!dax_is_locked(entry))\n\t\t\treturn entry;\n\n\t\twq = dax_entry_waitqueue(xas, entry, &ewait.key);\n\t\tprepare_to_wait_exclusive(wq, &ewait.wait,\n\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\txas_unlock_irq(xas);\n\t\txas_reset(xas);\n\t\tschedule();\n\t\tfinish_wait(wq, &ewait.wait);\n\t\txas_lock_irq(xas);\n\t}\n}"
  },
  {
    "function_name": "dax_wake_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "184-199",
    "snippet": "static void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up",
          "args": [
            "wq",
            "TASK_NORMAL",
            "wake_all ? 0 : 1",
            "&key"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "wq"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_entry_waitqueue",
          "args": [
            "xas",
            "entry",
            "&key"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "dax_entry_waitqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "146-164",
          "snippet": "static wait_queue_head_t *dax_entry_waitqueue(struct xa_state *xas,\n\t\tvoid *entry, struct exceptional_entry_key *key)\n{\n\tunsigned long hash;\n\tunsigned long index = xas->xa_index;\n\n\t/*\n\t * If 'entry' is a PMD, align the 'index' that we use for the wait\n\t * queue to the start of that PMD.  This ensures that all offsets in\n\t * the range covered by the PMD map to the same bit lock.\n\t */\n\tif (dax_is_pmd_entry(entry))\n\t\tindex &= ~PG_PMD_COLOUR;\n\tkey->xa = xas->xa;\n\tkey->entry_start = index;\n\n\thash = hash_long((unsigned long)xas->xa ^ index, DAX_WAIT_TABLE_BITS);\n\treturn wait_table + hash;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)",
            "#define DAX_WAIT_TABLE_BITS 12"
          ],
          "globals_used": [
            "static wait_queue_head_t wait_table[DAX_WAIT_TABLE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n#define DAX_WAIT_TABLE_BITS 12\n\nstatic wait_queue_head_t wait_table[DAX_WAIT_TABLE_ENTRIES];\n\nstatic wait_queue_head_t *dax_entry_waitqueue(struct xa_state *xas,\n\t\tvoid *entry, struct exceptional_entry_key *key)\n{\n\tunsigned long hash;\n\tunsigned long index = xas->xa_index;\n\n\t/*\n\t * If 'entry' is a PMD, align the 'index' that we use for the wait\n\t * queue to the start of that PMD.  This ensures that all offsets in\n\t * the range covered by the PMD map to the same bit lock.\n\t */\n\tif (dax_is_pmd_entry(entry))\n\t\tindex &= ~PG_PMD_COLOUR;\n\tkey->xa = xas->xa;\n\tkey->entry_start = index;\n\n\thash = hash_long((unsigned long)xas->xa ^ index, DAX_WAIT_TABLE_BITS);\n\treturn wait_table + hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_wake_entry(struct xa_state *xas, void *entry, bool wake_all)\n{\n\tstruct exceptional_entry_key key;\n\twait_queue_head_t *wq;\n\n\twq = dax_entry_waitqueue(xas, entry, &key);\n\n\t/*\n\t * Checking for locked entry and prepare_to_wait_exclusive() happens\n\t * under the i_pages lock, ditto for entry handling in our callers.\n\t * So at this point all tasks that could have seen our entry locked\n\t * must be in the waitqueue and the following check will see them.\n\t */\n\tif (waitqueue_active(wq))\n\t\t__wake_up(wq, TASK_NORMAL, wake_all ? 0 : 1, &key);\n}"
  },
  {
    "function_name": "wake_exceptional_entry_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "166-177",
    "snippet": "static int wake_exceptional_entry_func(wait_queue_entry_t *wait,\n\t\tunsigned int mode, int sync, void *keyp)\n{\n\tstruct exceptional_entry_key *key = keyp;\n\tstruct wait_exceptional_entry_queue *ewait =\n\t\tcontainer_of(wait, struct wait_exceptional_entry_queue, wait);\n\n\tif (key->xa != ewait->key.xa ||\n\t    key->entry_start != ewait->key.entry_start)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, NULL);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autoremove_wake_function",
          "args": [
            "wait",
            "mode",
            "sync",
            "NULL"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structwait_exceptional_entry_queue",
            "wait"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int wake_exceptional_entry_func(wait_queue_entry_t *wait,\n\t\tunsigned int mode, int sync, void *keyp)\n{\n\tstruct exceptional_entry_key *key = keyp;\n\tstruct wait_exceptional_entry_queue *ewait =\n\t\tcontainer_of(wait, struct wait_exceptional_entry_queue, wait);\n\n\tif (key->xa != ewait->key.xa ||\n\t    key->entry_start != ewait->key.entry_start)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, NULL);\n}"
  },
  {
    "function_name": "dax_entry_waitqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "146-164",
    "snippet": "static wait_queue_head_t *dax_entry_waitqueue(struct xa_state *xas,\n\t\tvoid *entry, struct exceptional_entry_key *key)\n{\n\tunsigned long hash;\n\tunsigned long index = xas->xa_index;\n\n\t/*\n\t * If 'entry' is a PMD, align the 'index' that we use for the wait\n\t * queue to the start of that PMD.  This ensures that all offsets in\n\t * the range covered by the PMD map to the same bit lock.\n\t */\n\tif (dax_is_pmd_entry(entry))\n\t\tindex &= ~PG_PMD_COLOUR;\n\tkey->xa = xas->xa;\n\tkey->entry_start = index;\n\n\thash = hash_long((unsigned long)xas->xa ^ index, DAX_WAIT_TABLE_BITS);\n\treturn wait_table + hash;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)",
      "#define DAX_WAIT_TABLE_BITS 12"
    ],
    "globals_used": [
      "static wait_queue_head_t wait_table[DAX_WAIT_TABLE_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "(unsigned long)xas->xa ^ index",
            "DAX_WAIT_TABLE_BITS"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_is_pmd_entry",
          "args": [
            "entry"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "dax_is_pmd_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "113-116",
          "snippet": "static unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define DAX_PMD\t\t(1UL << 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define PG_PMD_COLOUR\t((PMD_SIZE >> PAGE_SHIFT) - 1)\n#define DAX_WAIT_TABLE_BITS 12\n\nstatic wait_queue_head_t wait_table[DAX_WAIT_TABLE_ENTRIES];\n\nstatic wait_queue_head_t *dax_entry_waitqueue(struct xa_state *xas,\n\t\tvoid *entry, struct exceptional_entry_key *key)\n{\n\tunsigned long hash;\n\tunsigned long index = xas->xa_index;\n\n\t/*\n\t * If 'entry' is a PMD, align the 'index' that we use for the wait\n\t * queue to the start of that PMD.  This ensures that all offsets in\n\t * the range covered by the PMD map to the same bit lock.\n\t */\n\tif (dax_is_pmd_entry(entry))\n\t\tindex &= ~PG_PMD_COLOUR;\n\tkey->xa = xas->xa;\n\tkey->entry_start = index;\n\n\thash = hash_long((unsigned long)xas->xa ^ index, DAX_WAIT_TABLE_BITS);\n\treturn wait_table + hash;\n}"
  },
  {
    "function_name": "dax_is_empty_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "128-131",
    "snippet": "static int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_EMPTY\t(1UL << 3)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "entry"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_EMPTY\t(1UL << 3)\n\nstatic int dax_is_empty_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_EMPTY;\n}"
  },
  {
    "function_name": "dax_is_zero_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "123-126",
    "snippet": "static int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_ZERO_PAGE\t(1UL << 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "entry"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_ZERO_PAGE\t(1UL << 2)\n\nstatic int dax_is_zero_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_ZERO_PAGE;\n}"
  },
  {
    "function_name": "dax_is_pte_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "118-121",
    "snippet": "static bool dax_is_pte_entry(void *entry)\n{\n\treturn !(xa_to_value(entry) & DAX_PMD);\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_PMD\t\t(1UL << 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "entry"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic bool dax_is_pte_entry(void *entry)\n{\n\treturn !(xa_to_value(entry) & DAX_PMD);\n}"
  },
  {
    "function_name": "dax_is_pmd_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "113-116",
    "snippet": "static unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_PMD\t\t(1UL << 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "entry"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n\nstatic unsigned long dax_is_pmd_entry(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_PMD;\n}"
  },
  {
    "function_name": "dax_entry_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "106-111",
    "snippet": "static unsigned int dax_entry_order(void *entry)\n{\n\tif (xa_to_value(entry) & DAX_PMD)\n\t\treturn PMD_ORDER;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_PMD\t\t(1UL << 1)",
      "#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "entry"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_PMD\t\t(1UL << 1)\n#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)\n\nstatic unsigned int dax_entry_order(void *entry)\n{\n\tif (xa_to_value(entry) & DAX_PMD)\n\t\treturn PMD_ORDER;\n\treturn 0;\n}"
  },
  {
    "function_name": "dax_is_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "101-104",
    "snippet": "static bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_LOCKED\t(1UL << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "entry"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_LOCKED\t(1UL << 0)\n\nstatic bool dax_is_locked(void *entry)\n{\n\treturn xa_to_value(entry) & DAX_LOCKED;\n}"
  },
  {
    "function_name": "dax_make_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "96-99",
    "snippet": "static void *dax_make_entry(pfn_t pfn, unsigned long flags)\n{\n\treturn xa_mk_value(flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT));\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_SHIFT\t(4)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_mk_value",
          "args": [
            "flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_t_to_pfn",
          "args": [
            "pfn"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_SHIFT\t(4)\n\nstatic void *dax_make_entry(pfn_t pfn, unsigned long flags)\n{\n\treturn xa_mk_value(flags | (pfn_t_to_pfn(pfn) << DAX_SHIFT));\n}"
  },
  {
    "function_name": "dax_to_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "91-94",
    "snippet": "static unsigned long dax_to_pfn(void *entry)\n{\n\treturn xa_to_value(entry) >> DAX_SHIFT;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_SHIFT\t(4)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "entry"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_SHIFT\t(4)\n\nstatic unsigned long dax_to_pfn(void *entry)\n{\n\treturn xa_to_value(entry) >> DAX_SHIFT;\n}"
  },
  {
    "function_name": "init_dax_wait_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "65-72",
    "snippet": "static int __init init_dax_wait_table(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DAX_WAIT_TABLE_ENTRIES; i++)\n\t\tinit_waitqueue_head(wait_table + i);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define DAX_WAIT_TABLE_ENTRIES (1 << DAX_WAIT_TABLE_BITS)"
    ],
    "globals_used": [
      "static wait_queue_head_t wait_table[DAX_WAIT_TABLE_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "wait_table + i"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define DAX_WAIT_TABLE_ENTRIES (1 << DAX_WAIT_TABLE_BITS)\n\nstatic wait_queue_head_t wait_table[DAX_WAIT_TABLE_ENTRIES];\n\nstatic int __init init_dax_wait_table(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DAX_WAIT_TABLE_ENTRIES; i++)\n\t\tinit_waitqueue_head(wait_table + i);\n\treturn 0;\n}"
  },
  {
    "function_name": "pe_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
    "lines": "41-50",
    "snippet": "static inline unsigned int pe_order(enum page_entry_size pe_size)\n{\n\tif (pe_size == PE_SIZE_PTE)\n\t\treturn PAGE_SHIFT - PAGE_SHIFT;\n\tif (pe_size == PE_SIZE_PMD)\n\t\treturn PMD_SHIFT - PAGE_SHIFT;\n\tif (pe_size == PE_SIZE_PUD)\n\t\treturn PUD_SHIFT - PAGE_SHIFT;\n\treturn ~0;\n}",
    "includes": [
      "#include <trace/events/fs_dax.h>",
      "#include \"internal.h\"",
      "#include <linux/iomap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sizes.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic inline unsigned int pe_order(enum page_entry_size pe_size)\n{\n\tif (pe_size == PE_SIZE_PTE)\n\t\treturn PAGE_SHIFT - PAGE_SHIFT;\n\tif (pe_size == PE_SIZE_PMD)\n\t\treturn PMD_SHIFT - PAGE_SHIFT;\n\tif (pe_size == PE_SIZE_PUD)\n\t\treturn PUD_SHIFT - PAGE_SHIFT;\n\treturn ~0;\n}"
  }
]