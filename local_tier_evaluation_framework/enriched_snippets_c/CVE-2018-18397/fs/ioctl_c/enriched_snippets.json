[
  {
    "function_name": "ksys_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "704-716",
    "snippet": "int ksys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)\n{\n\tint error;\n\tstruct fd f = fdget(fd);\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\terror = security_file_ioctl(f.file, cmd, arg);\n\tif (!error)\n\t\terror = do_vfs_ioctl(f.file, fd, cmd, arg);\n\tfdput(f);\n\treturn error;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_vfs_ioctl",
          "args": [
            "f.file",
            "fd",
            "cmd",
            "arg"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "do_vfs_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "634-702",
          "snippet": "int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,\n\t     unsigned long arg)\n{\n\tint error = 0;\n\tint __user *argp = (int __user *)arg;\n\tstruct inode *inode = file_inode(filp);\n\n\tswitch (cmd) {\n\tcase FIOCLEX:\n\t\tset_close_on_exec(fd, 1);\n\t\tbreak;\n\n\tcase FIONCLEX:\n\t\tset_close_on_exec(fd, 0);\n\t\tbreak;\n\n\tcase FIONBIO:\n\t\terror = ioctl_fionbio(filp, argp);\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\terror = ioctl_fioasync(fd, filp, argp);\n\t\tbreak;\n\n\tcase FIOQSIZE:\n\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||\n\t\t    S_ISLNK(inode->i_mode)) {\n\t\t\tloff_t res = inode_get_bytes(inode);\n\t\t\terror = copy_to_user(argp, &res, sizeof(res)) ?\n\t\t\t\t\t-EFAULT : 0;\n\t\t} else\n\t\t\terror = -ENOTTY;\n\t\tbreak;\n\n\tcase FIFREEZE:\n\t\terror = ioctl_fsfreeze(filp);\n\t\tbreak;\n\n\tcase FITHAW:\n\t\terror = ioctl_fsthaw(filp);\n\t\tbreak;\n\n\tcase FS_IOC_FIEMAP:\n\t\treturn ioctl_fiemap(filp, arg);\n\n\tcase FIGETBSZ:\n\t\t/* anon_bdev filesystems may not have a block size */\n\t\tif (!inode->i_sb->s_blocksize)\n\t\t\treturn -EINVAL;\n\t\treturn put_user(inode->i_sb->s_blocksize, argp);\n\n\tcase FICLONE:\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\n\n\tcase FICLONERANGE:\n\t\treturn ioctl_file_clone_range(filp, argp);\n\n\tcase FIDEDUPERANGE:\n\t\treturn ioctl_file_dedupe_range(filp, argp);\n\n\tdefault:\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\terror = file_ioctl(filp, cmd, arg);\n\t\telse\n\t\t\terror = vfs_ioctl(filp, cmd, arg);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,\n\t     unsigned long arg)\n{\n\tint error = 0;\n\tint __user *argp = (int __user *)arg;\n\tstruct inode *inode = file_inode(filp);\n\n\tswitch (cmd) {\n\tcase FIOCLEX:\n\t\tset_close_on_exec(fd, 1);\n\t\tbreak;\n\n\tcase FIONCLEX:\n\t\tset_close_on_exec(fd, 0);\n\t\tbreak;\n\n\tcase FIONBIO:\n\t\terror = ioctl_fionbio(filp, argp);\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\terror = ioctl_fioasync(fd, filp, argp);\n\t\tbreak;\n\n\tcase FIOQSIZE:\n\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||\n\t\t    S_ISLNK(inode->i_mode)) {\n\t\t\tloff_t res = inode_get_bytes(inode);\n\t\t\terror = copy_to_user(argp, &res, sizeof(res)) ?\n\t\t\t\t\t-EFAULT : 0;\n\t\t} else\n\t\t\terror = -ENOTTY;\n\t\tbreak;\n\n\tcase FIFREEZE:\n\t\terror = ioctl_fsfreeze(filp);\n\t\tbreak;\n\n\tcase FITHAW:\n\t\terror = ioctl_fsthaw(filp);\n\t\tbreak;\n\n\tcase FS_IOC_FIEMAP:\n\t\treturn ioctl_fiemap(filp, arg);\n\n\tcase FIGETBSZ:\n\t\t/* anon_bdev filesystems may not have a block size */\n\t\tif (!inode->i_sb->s_blocksize)\n\t\t\treturn -EINVAL;\n\t\treturn put_user(inode->i_sb->s_blocksize, argp);\n\n\tcase FICLONE:\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\n\n\tcase FICLONERANGE:\n\t\treturn ioctl_file_clone_range(filp, argp);\n\n\tcase FIDEDUPERANGE:\n\t\treturn ioctl_file_dedupe_range(filp, argp);\n\n\tdefault:\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\terror = file_ioctl(filp, cmd, arg);\n\t\telse\n\t\t\terror = vfs_ioctl(filp, cmd, arg);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_file_ioctl",
          "args": [
            "f.file",
            "cmd",
            "arg"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint ksys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)\n{\n\tint error;\n\tstruct fd f = fdget(fd);\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\terror = security_file_ioctl(f.file, cmd, arg);\n\tif (!error)\n\t\terror = do_vfs_ioctl(f.file, fd, cmd, arg);\n\tfdput(f);\n\treturn error;\n}"
  },
  {
    "function_name": "do_vfs_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "634-702",
    "snippet": "int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,\n\t     unsigned long arg)\n{\n\tint error = 0;\n\tint __user *argp = (int __user *)arg;\n\tstruct inode *inode = file_inode(filp);\n\n\tswitch (cmd) {\n\tcase FIOCLEX:\n\t\tset_close_on_exec(fd, 1);\n\t\tbreak;\n\n\tcase FIONCLEX:\n\t\tset_close_on_exec(fd, 0);\n\t\tbreak;\n\n\tcase FIONBIO:\n\t\terror = ioctl_fionbio(filp, argp);\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\terror = ioctl_fioasync(fd, filp, argp);\n\t\tbreak;\n\n\tcase FIOQSIZE:\n\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||\n\t\t    S_ISLNK(inode->i_mode)) {\n\t\t\tloff_t res = inode_get_bytes(inode);\n\t\t\terror = copy_to_user(argp, &res, sizeof(res)) ?\n\t\t\t\t\t-EFAULT : 0;\n\t\t} else\n\t\t\terror = -ENOTTY;\n\t\tbreak;\n\n\tcase FIFREEZE:\n\t\terror = ioctl_fsfreeze(filp);\n\t\tbreak;\n\n\tcase FITHAW:\n\t\terror = ioctl_fsthaw(filp);\n\t\tbreak;\n\n\tcase FS_IOC_FIEMAP:\n\t\treturn ioctl_fiemap(filp, arg);\n\n\tcase FIGETBSZ:\n\t\t/* anon_bdev filesystems may not have a block size */\n\t\tif (!inode->i_sb->s_blocksize)\n\t\t\treturn -EINVAL;\n\t\treturn put_user(inode->i_sb->s_blocksize, argp);\n\n\tcase FICLONE:\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\n\n\tcase FICLONERANGE:\n\t\treturn ioctl_file_clone_range(filp, argp);\n\n\tcase FIDEDUPERANGE:\n\t\treturn ioctl_file_dedupe_range(filp, argp);\n\n\tdefault:\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\terror = file_ioctl(filp, cmd, arg);\n\t\telse\n\t\t\terror = vfs_ioctl(filp, cmd, arg);\n\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_ioctl",
          "args": [
            "filp",
            "cmd",
            "arg"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "39-51",
          "snippet": "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint error = -ENOTTY;\n\n\tif (!filp->f_op->unlocked_ioctl)\n\t\tgoto out;\n\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = -ENOTTY;\n out:\n\treturn error;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nlong vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint error = -ENOTTY;\n\n\tif (!filp->f_op->unlocked_ioctl)\n\t\tgoto out;\n\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = -ENOTTY;\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ioctl",
          "args": [
            "filp",
            "cmd",
            "arg"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "file_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "493-510",
          "snippet": "static int file_ioctl(struct file *filp, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint __user *p = (int __user *)arg;\n\n\tswitch (cmd) {\n\tcase FIBMAP:\n\t\treturn ioctl_fibmap(filp, p);\n\tcase FIONREAD:\n\t\treturn put_user(i_size_read(inode) - filp->f_pos, p);\n\tcase FS_IOC_RESVSP:\n\tcase FS_IOC_RESVSP64:\n\t\treturn ioctl_preallocate(filp, p);\n\t}\n\n\treturn vfs_ioctl(filp, cmd, arg);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int file_ioctl(struct file *filp, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint __user *p = (int __user *)arg;\n\n\tswitch (cmd) {\n\tcase FIBMAP:\n\t\treturn ioctl_fibmap(filp, p);\n\tcase FIONREAD:\n\t\treturn put_user(i_size_read(inode) - filp->f_pos, p);\n\tcase FS_IOC_RESVSP:\n\tcase FS_IOC_RESVSP64:\n\t\treturn ioctl_preallocate(filp, p);\n\t}\n\n\treturn vfs_ioctl(filp, cmd, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl_file_dedupe_range",
          "args": [
            "filp",
            "argp"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_file_dedupe_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "587-625",
          "snippet": "static int ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tif (size > PAGE_SIZE) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tif (size > PAGE_SIZE) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl_file_clone_range",
          "args": [
            "filp",
            "argp"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_file_clone_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "247-255",
          "snippet": "static long ioctl_file_clone_range(struct file *file, void __user *argp)\n{\n\tstruct file_clone_range args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\n\t\t\t\targs.src_length, args.dest_offset);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic long ioctl_file_clone_range(struct file *file, void __user *argp)\n{\n\tstruct file_clone_range args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\n\t\t\t\targs.src_length, args.dest_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl_file_clone",
          "args": [
            "filp",
            "arg",
            "0",
            "0",
            "0"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_file_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "222-245",
          "snippet": "static long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tloff_t cloned;\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto fdput;\n\tcloned = vfs_clone_file_range(src_file.file, off, dst_file, destoff,\n\t\t\t\t      olen, 0);\n\tif (cloned < 0)\n\t\tret = cloned;\n\telse if (olen && cloned != olen)\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nfdput:\n\tfdput(src_file);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tloff_t cloned;\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto fdput;\n\tcloned = vfs_clone_file_range(src_file.file, off, dst_file, destoff,\n\t\t\t\t      olen, 0);\n\tif (cloned < 0)\n\t\tret = cloned;\n\telse if (olen && cloned != olen)\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nfdput:\n\tfdput(src_file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "inode->i_sb->s_blocksize",
            "argp"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl_fiemap",
          "args": [
            "filp",
            "arg"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "177-220",
          "snippet": "static int ioctl_fiemap(struct file *filp, unsigned long arg)\n{\n\tstruct fiemap fiemap;\n\tstruct fiemap __user *ufiemap = (struct fiemap __user *) arg;\n\tstruct fiemap_extent_info fieinfo = { 0, };\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tu64 len;\n\tint error;\n\n\tif (!inode->i_op->fiemap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&fiemap, ufiemap, sizeof(fiemap)))\n\t\treturn -EFAULT;\n\n\tif (fiemap.fm_extent_count > FIEMAP_MAX_EXTENTS)\n\t\treturn -EINVAL;\n\n\terror = fiemap_check_ranges(sb, fiemap.fm_start, fiemap.fm_length,\n\t\t\t\t    &len);\n\tif (error)\n\t\treturn error;\n\n\tfieinfo.fi_flags = fiemap.fm_flags;\n\tfieinfo.fi_extents_max = fiemap.fm_extent_count;\n\tfieinfo.fi_extents_start = ufiemap->fm_extents;\n\n\tif (fiemap.fm_extent_count != 0 &&\n\t    !access_ok(VERIFY_WRITE, fieinfo.fi_extents_start,\n\t\t       fieinfo.fi_extents_max * sizeof(struct fiemap_extent)))\n\t\treturn -EFAULT;\n\n\tif (fieinfo.fi_flags & FIEMAP_FLAG_SYNC)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\terror = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start, len);\n\tfiemap.fm_flags = fieinfo.fi_flags;\n\tfiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;\n\tif (copy_to_user(ufiemap, &fiemap, sizeof(fiemap)))\n\t\terror = -EFAULT;\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define FIEMAP_MAX_EXTENTS\t(UINT_MAX / sizeof(struct fiemap_extent))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define FIEMAP_MAX_EXTENTS\t(UINT_MAX / sizeof(struct fiemap_extent))\n\nstatic int ioctl_fiemap(struct file *filp, unsigned long arg)\n{\n\tstruct fiemap fiemap;\n\tstruct fiemap __user *ufiemap = (struct fiemap __user *) arg;\n\tstruct fiemap_extent_info fieinfo = { 0, };\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tu64 len;\n\tint error;\n\n\tif (!inode->i_op->fiemap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&fiemap, ufiemap, sizeof(fiemap)))\n\t\treturn -EFAULT;\n\n\tif (fiemap.fm_extent_count > FIEMAP_MAX_EXTENTS)\n\t\treturn -EINVAL;\n\n\terror = fiemap_check_ranges(sb, fiemap.fm_start, fiemap.fm_length,\n\t\t\t\t    &len);\n\tif (error)\n\t\treturn error;\n\n\tfieinfo.fi_flags = fiemap.fm_flags;\n\tfieinfo.fi_extents_max = fiemap.fm_extent_count;\n\tfieinfo.fi_extents_start = ufiemap->fm_extents;\n\n\tif (fiemap.fm_extent_count != 0 &&\n\t    !access_ok(VERIFY_WRITE, fieinfo.fi_extents_start,\n\t\t       fieinfo.fi_extents_max * sizeof(struct fiemap_extent)))\n\t\treturn -EFAULT;\n\n\tif (fieinfo.fi_flags & FIEMAP_FLAG_SYNC)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\terror = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start, len);\n\tfiemap.fm_flags = fieinfo.fi_flags;\n\tfiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;\n\tif (copy_to_user(ufiemap, &fiemap, sizeof(fiemap)))\n\t\terror = -EFAULT;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl_fsthaw",
          "args": [
            "filp"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_fsthaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "574-585",
          "snippet": "static int ioctl_fsthaw(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Thaw */\n\tif (sb->s_op->thaw_super)\n\t\treturn sb->s_op->thaw_super(sb);\n\treturn thaw_super(sb);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fsthaw(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Thaw */\n\tif (sb->s_op->thaw_super)\n\t\treturn sb->s_op->thaw_super(sb);\n\treturn thaw_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl_fsfreeze",
          "args": [
            "filp"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_fsfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "557-572",
          "snippet": "static int ioctl_fsfreeze(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* If filesystem doesn't support freeze feature, return. */\n\tif (sb->s_op->freeze_fs == NULL && sb->s_op->freeze_super == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Freeze */\n\tif (sb->s_op->freeze_super)\n\t\treturn sb->s_op->freeze_super(sb);\n\treturn freeze_super(sb);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fsfreeze(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* If filesystem doesn't support freeze feature, return. */\n\tif (sb->s_op->freeze_fs == NULL && sb->s_op->freeze_super == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Freeze */\n\tif (sb->s_op->freeze_super)\n\t\treturn sb->s_op->freeze_super(sb);\n\treturn freeze_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&res",
            "sizeof(res)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_get_bytes",
          "args": [
            "inode"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "inode_get_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/stat.c",
          "lines": "718-726",
          "snippet": "loff_t inode_get_bytes(struct inode *inode)\n{\n\tloff_t ret;\n\n\tspin_lock(&inode->i_lock);\n\tret = __inode_get_bytes(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nloff_t inode_get_bytes(struct inode *inode)\n{\n\tloff_t ret;\n\n\tspin_lock(&inode->i_lock);\n\tret = __inode_get_bytes(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl_fioasync",
          "args": [
            "fd",
            "filp",
            "argp"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_fioasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "535-555",
          "snippet": "static int ioctl_fioasync(unsigned int fd, struct file *filp,\n\t\t\t  int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = on ? FASYNC : 0;\n\n\t/* Did FASYNC state change ? */\n\tif ((flag ^ filp->f_flags) & FASYNC) {\n\t\tif (filp->f_op->fasync)\n\t\t\t/* fasync() adjusts filp->f_flags */\n\t\t\terror = filp->f_op->fasync(fd, filp, on);\n\t\telse\n\t\t\terror = -ENOTTY;\n\t}\n\treturn error < 0 ? error : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fioasync(unsigned int fd, struct file *filp,\n\t\t\t  int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = on ? FASYNC : 0;\n\n\t/* Did FASYNC state change ? */\n\tif ((flag ^ filp->f_flags) & FASYNC) {\n\t\tif (filp->f_op->fasync)\n\t\t\t/* fasync() adjusts filp->f_flags */\n\t\t\terror = filp->f_op->fasync(fd, filp, on);\n\t\telse\n\t\t\terror = -ENOTTY;\n\t}\n\treturn error < 0 ? error : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl_fionbio",
          "args": [
            "filp",
            "argp"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_fionbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "512-533",
          "snippet": "static int ioctl_fionbio(struct file *filp, int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = O_NONBLOCK;\n#ifdef __sparc__\n\t/* SunOS compatibility item. */\n\tif (O_NONBLOCK != O_NDELAY)\n\t\tflag |= O_NDELAY;\n#endif\n\tspin_lock(&filp->f_lock);\n\tif (on)\n\t\tfilp->f_flags |= flag;\n\telse\n\t\tfilp->f_flags &= ~flag;\n\tspin_unlock(&filp->f_lock);\n\treturn error;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fionbio(struct file *filp, int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = O_NONBLOCK;\n#ifdef __sparc__\n\t/* SunOS compatibility item. */\n\tif (O_NONBLOCK != O_NDELAY)\n\t\tflag |= O_NDELAY;\n#endif\n\tspin_lock(&filp->f_lock);\n\tif (on)\n\t\tfilp->f_flags |= flag;\n\telse\n\t\tfilp->f_flags &= ~flag;\n\tspin_unlock(&filp->f_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_close_on_exec",
          "args": [
            "fd",
            "0"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "783-794",
          "snippet": "void set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,\n\t     unsigned long arg)\n{\n\tint error = 0;\n\tint __user *argp = (int __user *)arg;\n\tstruct inode *inode = file_inode(filp);\n\n\tswitch (cmd) {\n\tcase FIOCLEX:\n\t\tset_close_on_exec(fd, 1);\n\t\tbreak;\n\n\tcase FIONCLEX:\n\t\tset_close_on_exec(fd, 0);\n\t\tbreak;\n\n\tcase FIONBIO:\n\t\terror = ioctl_fionbio(filp, argp);\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\terror = ioctl_fioasync(fd, filp, argp);\n\t\tbreak;\n\n\tcase FIOQSIZE:\n\t\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode) ||\n\t\t    S_ISLNK(inode->i_mode)) {\n\t\t\tloff_t res = inode_get_bytes(inode);\n\t\t\terror = copy_to_user(argp, &res, sizeof(res)) ?\n\t\t\t\t\t-EFAULT : 0;\n\t\t} else\n\t\t\terror = -ENOTTY;\n\t\tbreak;\n\n\tcase FIFREEZE:\n\t\terror = ioctl_fsfreeze(filp);\n\t\tbreak;\n\n\tcase FITHAW:\n\t\terror = ioctl_fsthaw(filp);\n\t\tbreak;\n\n\tcase FS_IOC_FIEMAP:\n\t\treturn ioctl_fiemap(filp, arg);\n\n\tcase FIGETBSZ:\n\t\t/* anon_bdev filesystems may not have a block size */\n\t\tif (!inode->i_sb->s_blocksize)\n\t\t\treturn -EINVAL;\n\t\treturn put_user(inode->i_sb->s_blocksize, argp);\n\n\tcase FICLONE:\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\n\n\tcase FICLONERANGE:\n\t\treturn ioctl_file_clone_range(filp, argp);\n\n\tcase FIDEDUPERANGE:\n\t\treturn ioctl_file_dedupe_range(filp, argp);\n\n\tdefault:\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\terror = file_ioctl(filp, cmd, arg);\n\t\telse\n\t\t\terror = vfs_ioctl(filp, cmd, arg);\n\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ioctl_file_dedupe_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "587-625",
    "snippet": "static int ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tif (size > PAGE_SIZE) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "same"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "same",
            "size"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_dedupe_file_range",
          "args": [
            "file",
            "same"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_dedupe_file_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "2077-2154",
          "snippet": "int vfs_dedupe_file_range(struct file *file, struct file_dedupe_range *same)\n{\n\tstruct file_dedupe_range_info *info;\n\tstruct inode *src = file_inode(file);\n\tu64 off;\n\tu64 len;\n\tint i;\n\tint ret;\n\tu16 count = same->dest_count;\n\tloff_t deduped;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EINVAL;\n\n\tif (same->reserved1 || same->reserved2)\n\t\treturn -EINVAL;\n\n\toff = same->src_offset;\n\tlen = same->src_length;\n\n\tif (S_ISDIR(src->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(src->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!file->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file, off, len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = 0;\n\n\tif (off + len > i_size_read(src))\n\t\treturn -EINVAL;\n\n\t/* Arbitrary 1G limit on a single dedupe request, can be raised. */\n\tlen = min_t(u64, len, 1 << 30);\n\n\t/* pre-format output fields to sane values */\n\tfor (i = 0; i < count; i++) {\n\t\tsame->info[i].bytes_deduped = 0ULL;\n\t\tsame->info[i].status = FILE_DEDUPE_RANGE_SAME;\n\t}\n\n\tfor (i = 0, info = same->info; i < count; i++, info++) {\n\t\tstruct fd dst_fd = fdget(info->dest_fd);\n\t\tstruct file *dst_file = dst_fd.file;\n\n\t\tif (!dst_file) {\n\t\t\tinfo->status = -EBADF;\n\t\t\tgoto next_loop;\n\t\t}\n\n\t\tif (info->reserved) {\n\t\t\tinfo->status = -EINVAL;\n\t\t\tgoto next_fdput;\n\t\t}\n\n\t\tdeduped = vfs_dedupe_file_range_one(file, off, dst_file,\n\t\t\t\t\t\t    info->dest_offset, len,\n\t\t\t\t\t\t    REMAP_FILE_CAN_SHORTEN);\n\t\tif (deduped == -EBADE)\n\t\t\tinfo->status = FILE_DEDUPE_RANGE_DIFFERS;\n\t\telse if (deduped < 0)\n\t\t\tinfo->status = deduped;\n\t\telse\n\t\t\tinfo->bytes_deduped = len;\n\nnext_fdput:\n\t\tfdput(dst_fd);\nnext_loop:\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint vfs_dedupe_file_range(struct file *file, struct file_dedupe_range *same)\n{\n\tstruct file_dedupe_range_info *info;\n\tstruct inode *src = file_inode(file);\n\tu64 off;\n\tu64 len;\n\tint i;\n\tint ret;\n\tu16 count = same->dest_count;\n\tloff_t deduped;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EINVAL;\n\n\tif (same->reserved1 || same->reserved2)\n\t\treturn -EINVAL;\n\n\toff = same->src_offset;\n\tlen = same->src_length;\n\n\tif (S_ISDIR(src->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(src->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!file->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file, off, len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = 0;\n\n\tif (off + len > i_size_read(src))\n\t\treturn -EINVAL;\n\n\t/* Arbitrary 1G limit on a single dedupe request, can be raised. */\n\tlen = min_t(u64, len, 1 << 30);\n\n\t/* pre-format output fields to sane values */\n\tfor (i = 0; i < count; i++) {\n\t\tsame->info[i].bytes_deduped = 0ULL;\n\t\tsame->info[i].status = FILE_DEDUPE_RANGE_SAME;\n\t}\n\n\tfor (i = 0, info = same->info; i < count; i++, info++) {\n\t\tstruct fd dst_fd = fdget(info->dest_fd);\n\t\tstruct file *dst_file = dst_fd.file;\n\n\t\tif (!dst_file) {\n\t\t\tinfo->status = -EBADF;\n\t\t\tgoto next_loop;\n\t\t}\n\n\t\tif (info->reserved) {\n\t\t\tinfo->status = -EINVAL;\n\t\t\tgoto next_fdput;\n\t\t}\n\n\t\tdeduped = vfs_dedupe_file_range_one(file, off, dst_file,\n\t\t\t\t\t\t    info->dest_offset, len,\n\t\t\t\t\t\t    REMAP_FILE_CAN_SHORTEN);\n\t\tif (deduped == -EBADE)\n\t\t\tinfo->status = FILE_DEDUPE_RANGE_DIFFERS;\n\t\telse if (deduped < 0)\n\t\t\tinfo->status = deduped;\n\t\telse\n\t\t\tinfo->bytes_deduped = len;\n\nnext_fdput:\n\t\tfdput(dst_fd);\nnext_loop:\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "same"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "same"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "argp",
            "size"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "count",
            "&argp->dest_count"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tif (size > PAGE_SIZE) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}"
  },
  {
    "function_name": "ioctl_fsthaw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "574-585",
    "snippet": "static int ioctl_fsthaw(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Thaw */\n\tif (sb->s_op->thaw_super)\n\t\treturn sb->s_op->thaw_super(sb);\n\treturn thaw_super(sb);\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thaw_super",
          "args": [
            "sb"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1577-1581",
          "snippet": "int thaw_super(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\treturn thaw_super_locked(sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint thaw_super(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\treturn thaw_super_locked(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "sb->s_user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fsthaw(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Thaw */\n\tif (sb->s_op->thaw_super)\n\t\treturn sb->s_op->thaw_super(sb);\n\treturn thaw_super(sb);\n}"
  },
  {
    "function_name": "ioctl_fsfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "557-572",
    "snippet": "static int ioctl_fsfreeze(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* If filesystem doesn't support freeze feature, return. */\n\tif (sb->s_op->freeze_fs == NULL && sb->s_op->freeze_super == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Freeze */\n\tif (sb->s_op->freeze_super)\n\t\treturn sb->s_op->freeze_super(sb);\n\treturn freeze_super(sb);\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeze_super",
          "args": [
            "sb"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1473-1533",
          "snippet": "int freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & SB_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\tdown_write(&sb->s_umount);\n\n\t/* Now we go and block page faults... */\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsb_freeze_unlock(sb);\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * For debugging purposes so that fs can warn if it sees write activity\n\t * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tlockdep_sb_freeze_release(sb);\n\tup_write(&sb->s_umount);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & SB_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\tdown_write(&sb->s_umount);\n\n\t/* Now we go and block page faults... */\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsb_freeze_unlock(sb);\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * For debugging purposes so that fs can warn if it sees write activity\n\t * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tlockdep_sb_freeze_release(sb);\n\tup_write(&sb->s_umount);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "sb->s_user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fsfreeze(struct file *filp)\n{\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!ns_capable(sb->s_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* If filesystem doesn't support freeze feature, return. */\n\tif (sb->s_op->freeze_fs == NULL && sb->s_op->freeze_super == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Freeze */\n\tif (sb->s_op->freeze_super)\n\t\treturn sb->s_op->freeze_super(sb);\n\treturn freeze_super(sb);\n}"
  },
  {
    "function_name": "ioctl_fioasync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "535-555",
    "snippet": "static int ioctl_fioasync(unsigned int fd, struct file *filp,\n\t\t\t  int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = on ? FASYNC : 0;\n\n\t/* Did FASYNC state change ? */\n\tif ((flag ^ filp->f_flags) & FASYNC) {\n\t\tif (filp->f_op->fasync)\n\t\t\t/* fasync() adjusts filp->f_flags */\n\t\t\terror = filp->f_op->fasync(fd, filp, on);\n\t\telse\n\t\t\terror = -ENOTTY;\n\t}\n\treturn error < 0 ? error : 0;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filp->f_op->fasync",
          "args": [
            "fd",
            "filp",
            "on"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "on",
            "argp"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fioasync(unsigned int fd, struct file *filp,\n\t\t\t  int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = on ? FASYNC : 0;\n\n\t/* Did FASYNC state change ? */\n\tif ((flag ^ filp->f_flags) & FASYNC) {\n\t\tif (filp->f_op->fasync)\n\t\t\t/* fasync() adjusts filp->f_flags */\n\t\t\terror = filp->f_op->fasync(fd, filp, on);\n\t\telse\n\t\t\terror = -ENOTTY;\n\t}\n\treturn error < 0 ? error : 0;\n}"
  },
  {
    "function_name": "ioctl_fionbio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "512-533",
    "snippet": "static int ioctl_fionbio(struct file *filp, int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = O_NONBLOCK;\n#ifdef __sparc__\n\t/* SunOS compatibility item. */\n\tif (O_NONBLOCK != O_NDELAY)\n\t\tflag |= O_NDELAY;\n#endif\n\tspin_lock(&filp->f_lock);\n\tif (on)\n\t\tfilp->f_flags |= flag;\n\telse\n\t\tfilp->f_flags &= ~flag;\n\tspin_unlock(&filp->f_lock);\n\treturn error;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&filp->f_lock"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&filp->f_lock"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "on",
            "argp"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fionbio(struct file *filp, int __user *argp)\n{\n\tunsigned int flag;\n\tint on, error;\n\n\terror = get_user(on, argp);\n\tif (error)\n\t\treturn error;\n\tflag = O_NONBLOCK;\n#ifdef __sparc__\n\t/* SunOS compatibility item. */\n\tif (O_NONBLOCK != O_NDELAY)\n\t\tflag |= O_NDELAY;\n#endif\n\tspin_lock(&filp->f_lock);\n\tif (on)\n\t\tfilp->f_flags |= flag;\n\telse\n\t\tfilp->f_flags &= ~flag;\n\tspin_unlock(&filp->f_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "file_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "493-510",
    "snippet": "static int file_ioctl(struct file *filp, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint __user *p = (int __user *)arg;\n\n\tswitch (cmd) {\n\tcase FIBMAP:\n\t\treturn ioctl_fibmap(filp, p);\n\tcase FIONREAD:\n\t\treturn put_user(i_size_read(inode) - filp->f_pos, p);\n\tcase FS_IOC_RESVSP:\n\tcase FS_IOC_RESVSP64:\n\t\treturn ioctl_preallocate(filp, p);\n\t}\n\n\treturn vfs_ioctl(filp, cmd, arg);\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_ioctl",
          "args": [
            "filp",
            "cmd",
            "arg"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "39-51",
          "snippet": "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint error = -ENOTTY;\n\n\tif (!filp->f_op->unlocked_ioctl)\n\t\tgoto out;\n\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = -ENOTTY;\n out:\n\treturn error;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nlong vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint error = -ENOTTY;\n\n\tif (!filp->f_op->unlocked_ioctl)\n\t\tgoto out;\n\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = -ENOTTY;\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl_preallocate",
          "args": [
            "filp",
            "p"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_preallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "469-491",
          "snippet": "int ioctl_preallocate(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct space_resv sr;\n\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\treturn -EFAULT;\n\n\tswitch (sr.l_whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tsr.l_start += filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tsr.l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vfs_fallocate(filp, FALLOC_FL_KEEP_SIZE, sr.l_start, sr.l_len);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint ioctl_preallocate(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct space_resv sr;\n\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\treturn -EFAULT;\n\n\tswitch (sr.l_whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tsr.l_start += filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tsr.l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vfs_fallocate(filp, FALLOC_FL_KEEP_SIZE, sr.l_start, sr.l_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "i_size_read(inode) - filp->f_pos",
            "p"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl_fibmap",
          "args": [
            "filp",
            "p"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_fibmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "54-69",
          "snippet": "static int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int file_ioctl(struct file *filp, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint __user *p = (int __user *)arg;\n\n\tswitch (cmd) {\n\tcase FIBMAP:\n\t\treturn ioctl_fibmap(filp, p);\n\tcase FIONREAD:\n\t\treturn put_user(i_size_read(inode) - filp->f_pos, p);\n\tcase FS_IOC_RESVSP:\n\tcase FS_IOC_RESVSP64:\n\t\treturn ioctl_preallocate(filp, p);\n\t}\n\n\treturn vfs_ioctl(filp, cmd, arg);\n}"
  },
  {
    "function_name": "ioctl_preallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "469-491",
    "snippet": "int ioctl_preallocate(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct space_resv sr;\n\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\treturn -EFAULT;\n\n\tswitch (sr.l_whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tsr.l_start += filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tsr.l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vfs_fallocate(filp, FALLOC_FL_KEEP_SIZE, sr.l_start, sr.l_len);\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_fallocate",
          "args": [
            "filp",
            "FALLOC_FL_KEEP_SIZE",
            "sr.l_start",
            "sr.l_len"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "228-322",
          "snippet": "int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Unshare range should only be used with allocate mode. */\n\tif ((mode & FALLOC_FL_UNSHARE_RANGE) &&\n\t    (mode & ~(FALLOC_FL_UNSHARE_RANGE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(file);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tfile_end_write(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Unshare range should only be used with allocate mode. */\n\tif ((mode & FALLOC_FL_UNSHARE_RANGE) &&\n\t    (mode & ~(FALLOC_FL_UNSHARE_RANGE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(file);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tfile_end_write(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&sr",
            "argp",
            "sizeof(sr)"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint ioctl_preallocate(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct space_resv sr;\n\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\treturn -EFAULT;\n\n\tswitch (sr.l_whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tsr.l_start += filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tsr.l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vfs_fallocate(filp, FALLOC_FL_KEEP_SIZE, sr.l_start, sr.l_len);\n}"
  },
  {
    "function_name": "generic_block_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "448-457",
    "snippet": "int generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tinode_lock(inode);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tinode_unlock(inode);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__generic_block_fiemap",
          "args": [
            "inode",
            "fieinfo",
            "start",
            "len",
            "get_block"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "__generic_block_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "289-433",
          "snippet": "int __generic_block_fiemap(struct inode *inode,\n\t\t\t   struct fiemap_extent_info *fieinfo, loff_t start,\n\t\t\t   loff_t len, get_block_t *get_block)\n{\n\tstruct buffer_head map_bh;\n\tsector_t start_blk, last_blk;\n\tloff_t isize = i_size_read(inode);\n\tu64 logical = 0, phys = 0, size = 0;\n\tu32 flags = FIEMAP_EXTENT_MERGED;\n\tbool past_eof = false, whole_file = false;\n\tint ret = 0;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Either the i_mutex or other appropriate locking needs to be held\n\t * since we expect isize to not change at all through the duration of\n\t * this call.\n\t */\n\tif (len >= isize) {\n\t\twhole_file = true;\n\t\tlen = isize;\n\t}\n\n\t/*\n\t * Some filesystems can't deal with being asked to map less than\n\t * blocksize, so make sure our len is at least block length.\n\t */\n\tif (logical_to_blk(inode, len) == 0)\n\t\tlen = blk_to_logical(inode, 1);\n\n\tstart_blk = logical_to_blk(inode, start);\n\tlast_blk = logical_to_blk(inode, start + len - 1);\n\n\tdo {\n\t\t/*\n\t\t * we set b_size to the total size we want so it will map as\n\t\t * many contiguous blocks as possible at once\n\t\t */\n\t\tmemset(&map_bh, 0, sizeof(struct buffer_head));\n\t\tmap_bh.b_size = len;\n\n\t\tret = get_block(inode, start_blk, &map_bh, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* HOLE */\n\t\tif (!buffer_mapped(&map_bh)) {\n\t\t\tstart_blk++;\n\n\t\t\t/*\n\t\t\t * We want to handle the case where there is an\n\t\t\t * allocated block at the front of the file, and then\n\t\t\t * nothing but holes up to the end of the file properly,\n\t\t\t * to make sure that extent at the front gets properly\n\t\t\t * marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof &&\n\t\t\t    blk_to_logical(inode, start_blk) >= isize)\n\t\t\t\tpast_eof = 1;\n\n\t\t\t/*\n\t\t\t * First hole after going past the EOF, this is our\n\t\t\t * last extent\n\t\t\t */\n\t\t\tif (past_eof && size) {\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED|FIEMAP_EXTENT_LAST;\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t} else if (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size, flags);\n\t\t\t\tsize = 0;\n\t\t\t}\n\n\t\t\t/* if we have holes up to/past EOF then we're done */\n\t\t\tif (start_blk > last_blk || past_eof || ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We have gone over the length of what we wanted to\n\t\t\t * map, and it wasn't the entire file, so add the extent\n\t\t\t * we got last time and exit.\n\t\t\t *\n\t\t\t * This is for the case where say we want to map all the\n\t\t\t * way up to the second to the last block in a file, but\n\t\t\t * the last block is a hole, making the second to last\n\t\t\t * block FIEMAP_EXTENT_LAST.  In this case we want to\n\t\t\t * see if there is a hole after the second to last block\n\t\t\t * so we can mark it properly.  If we found data after\n\t\t\t * we exceeded the length we were requesting, then we\n\t\t\t * are good to go, just add the extent to the fieinfo\n\t\t\t * and break\n\t\t\t */\n\t\t\tif (start_blk > last_blk && !whole_file) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if size != 0 then we know we already have an extent\n\t\t\t * to add, so add it.\n\t\t\t */\n\t\t\tif (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlogical = blk_to_logical(inode, start_blk);\n\t\t\tphys = blk_to_logical(inode, map_bh.b_blocknr);\n\t\t\tsize = map_bh.b_size;\n\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\n\t\t\tstart_blk += logical_to_blk(inode, size);\n\n\t\t\t/*\n\t\t\t * If we are past the EOF, then we need to make sure as\n\t\t\t * soon as we find a hole that the last extent we found\n\t\t\t * is marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof && logical + size >= isize)\n\t\t\t\tpast_eof = true;\n\t\t}\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t} while (1);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint __generic_block_fiemap(struct inode *inode,\n\t\t\t   struct fiemap_extent_info *fieinfo, loff_t start,\n\t\t\t   loff_t len, get_block_t *get_block)\n{\n\tstruct buffer_head map_bh;\n\tsector_t start_blk, last_blk;\n\tloff_t isize = i_size_read(inode);\n\tu64 logical = 0, phys = 0, size = 0;\n\tu32 flags = FIEMAP_EXTENT_MERGED;\n\tbool past_eof = false, whole_file = false;\n\tint ret = 0;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Either the i_mutex or other appropriate locking needs to be held\n\t * since we expect isize to not change at all through the duration of\n\t * this call.\n\t */\n\tif (len >= isize) {\n\t\twhole_file = true;\n\t\tlen = isize;\n\t}\n\n\t/*\n\t * Some filesystems can't deal with being asked to map less than\n\t * blocksize, so make sure our len is at least block length.\n\t */\n\tif (logical_to_blk(inode, len) == 0)\n\t\tlen = blk_to_logical(inode, 1);\n\n\tstart_blk = logical_to_blk(inode, start);\n\tlast_blk = logical_to_blk(inode, start + len - 1);\n\n\tdo {\n\t\t/*\n\t\t * we set b_size to the total size we want so it will map as\n\t\t * many contiguous blocks as possible at once\n\t\t */\n\t\tmemset(&map_bh, 0, sizeof(struct buffer_head));\n\t\tmap_bh.b_size = len;\n\n\t\tret = get_block(inode, start_blk, &map_bh, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* HOLE */\n\t\tif (!buffer_mapped(&map_bh)) {\n\t\t\tstart_blk++;\n\n\t\t\t/*\n\t\t\t * We want to handle the case where there is an\n\t\t\t * allocated block at the front of the file, and then\n\t\t\t * nothing but holes up to the end of the file properly,\n\t\t\t * to make sure that extent at the front gets properly\n\t\t\t * marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof &&\n\t\t\t    blk_to_logical(inode, start_blk) >= isize)\n\t\t\t\tpast_eof = 1;\n\n\t\t\t/*\n\t\t\t * First hole after going past the EOF, this is our\n\t\t\t * last extent\n\t\t\t */\n\t\t\tif (past_eof && size) {\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED|FIEMAP_EXTENT_LAST;\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t} else if (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size, flags);\n\t\t\t\tsize = 0;\n\t\t\t}\n\n\t\t\t/* if we have holes up to/past EOF then we're done */\n\t\t\tif (start_blk > last_blk || past_eof || ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We have gone over the length of what we wanted to\n\t\t\t * map, and it wasn't the entire file, so add the extent\n\t\t\t * we got last time and exit.\n\t\t\t *\n\t\t\t * This is for the case where say we want to map all the\n\t\t\t * way up to the second to the last block in a file, but\n\t\t\t * the last block is a hole, making the second to last\n\t\t\t * block FIEMAP_EXTENT_LAST.  In this case we want to\n\t\t\t * see if there is a hole after the second to last block\n\t\t\t * so we can mark it properly.  If we found data after\n\t\t\t * we exceeded the length we were requesting, then we\n\t\t\t * are good to go, just add the extent to the fieinfo\n\t\t\t * and break\n\t\t\t */\n\t\t\tif (start_blk > last_blk && !whole_file) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if size != 0 then we know we already have an extent\n\t\t\t * to add, so add it.\n\t\t\t */\n\t\t\tif (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlogical = blk_to_logical(inode, start_blk);\n\t\t\tphys = blk_to_logical(inode, map_bh.b_blocknr);\n\t\t\tsize = map_bh.b_size;\n\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\n\t\t\tstart_blk += logical_to_blk(inode, size);\n\n\t\t\t/*\n\t\t\t * If we are past the EOF, then we need to make sure as\n\t\t\t * soon as we find a hole that the last extent we found\n\t\t\t * is marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof && logical + size >= isize)\n\t\t\t\tpast_eof = true;\n\t\t}\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t} while (1);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint generic_block_fiemap(struct inode *inode,\n\t\t\t struct fiemap_extent_info *fieinfo, u64 start,\n\t\t\t u64 len, get_block_t *get_block)\n{\n\tint ret;\n\tinode_lock(inode);\n\tret = __generic_block_fiemap(inode, fieinfo, start, len, get_block);\n\tinode_unlock(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "__generic_block_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "289-433",
    "snippet": "int __generic_block_fiemap(struct inode *inode,\n\t\t\t   struct fiemap_extent_info *fieinfo, loff_t start,\n\t\t\t   loff_t len, get_block_t *get_block)\n{\n\tstruct buffer_head map_bh;\n\tsector_t start_blk, last_blk;\n\tloff_t isize = i_size_read(inode);\n\tu64 logical = 0, phys = 0, size = 0;\n\tu32 flags = FIEMAP_EXTENT_MERGED;\n\tbool past_eof = false, whole_file = false;\n\tint ret = 0;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Either the i_mutex or other appropriate locking needs to be held\n\t * since we expect isize to not change at all through the duration of\n\t * this call.\n\t */\n\tif (len >= isize) {\n\t\twhole_file = true;\n\t\tlen = isize;\n\t}\n\n\t/*\n\t * Some filesystems can't deal with being asked to map less than\n\t * blocksize, so make sure our len is at least block length.\n\t */\n\tif (logical_to_blk(inode, len) == 0)\n\t\tlen = blk_to_logical(inode, 1);\n\n\tstart_blk = logical_to_blk(inode, start);\n\tlast_blk = logical_to_blk(inode, start + len - 1);\n\n\tdo {\n\t\t/*\n\t\t * we set b_size to the total size we want so it will map as\n\t\t * many contiguous blocks as possible at once\n\t\t */\n\t\tmemset(&map_bh, 0, sizeof(struct buffer_head));\n\t\tmap_bh.b_size = len;\n\n\t\tret = get_block(inode, start_blk, &map_bh, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* HOLE */\n\t\tif (!buffer_mapped(&map_bh)) {\n\t\t\tstart_blk++;\n\n\t\t\t/*\n\t\t\t * We want to handle the case where there is an\n\t\t\t * allocated block at the front of the file, and then\n\t\t\t * nothing but holes up to the end of the file properly,\n\t\t\t * to make sure that extent at the front gets properly\n\t\t\t * marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof &&\n\t\t\t    blk_to_logical(inode, start_blk) >= isize)\n\t\t\t\tpast_eof = 1;\n\n\t\t\t/*\n\t\t\t * First hole after going past the EOF, this is our\n\t\t\t * last extent\n\t\t\t */\n\t\t\tif (past_eof && size) {\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED|FIEMAP_EXTENT_LAST;\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t} else if (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size, flags);\n\t\t\t\tsize = 0;\n\t\t\t}\n\n\t\t\t/* if we have holes up to/past EOF then we're done */\n\t\t\tif (start_blk > last_blk || past_eof || ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We have gone over the length of what we wanted to\n\t\t\t * map, and it wasn't the entire file, so add the extent\n\t\t\t * we got last time and exit.\n\t\t\t *\n\t\t\t * This is for the case where say we want to map all the\n\t\t\t * way up to the second to the last block in a file, but\n\t\t\t * the last block is a hole, making the second to last\n\t\t\t * block FIEMAP_EXTENT_LAST.  In this case we want to\n\t\t\t * see if there is a hole after the second to last block\n\t\t\t * so we can mark it properly.  If we found data after\n\t\t\t * we exceeded the length we were requesting, then we\n\t\t\t * are good to go, just add the extent to the fieinfo\n\t\t\t * and break\n\t\t\t */\n\t\t\tif (start_blk > last_blk && !whole_file) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if size != 0 then we know we already have an extent\n\t\t\t * to add, so add it.\n\t\t\t */\n\t\t\tif (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlogical = blk_to_logical(inode, start_blk);\n\t\t\tphys = blk_to_logical(inode, map_bh.b_blocknr);\n\t\t\tsize = map_bh.b_size;\n\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\n\t\t\tstart_blk += logical_to_blk(inode, size);\n\n\t\t\t/*\n\t\t\t * If we are past the EOF, then we need to make sure as\n\t\t\t * soon as we find a hole that the last extent we found\n\t\t\t * is marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof && logical + size >= isize)\n\t\t\t\tpast_eof = true;\n\t\t}\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t} while (1);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logical_to_blk",
          "args": [
            "inode",
            "size"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "logical_to_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "259-262",
          "snippet": "static inline sector_t logical_to_blk(struct inode *inode, loff_t offset)\n{\n\treturn (offset >> inode->i_blkbits);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic inline sector_t logical_to_blk(struct inode *inode, loff_t offset)\n{\n\treturn (offset >> inode->i_blkbits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_to_logical",
          "args": [
            "inode",
            "map_bh.b_blocknr"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "blk_to_logical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "264-267",
          "snippet": "static inline loff_t blk_to_logical(struct inode *inode, sector_t blk)\n{\n\treturn (blk << inode->i_blkbits);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic inline loff_t blk_to_logical(struct inode *inode, sector_t blk)\n{\n\treturn (blk << inode->i_blkbits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fiemap_fill_next_extent",
          "args": [
            "fieinfo",
            "logical",
            "phys",
            "size",
            "flags"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_fill_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "89-125",
          "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
            "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
            "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&map_bh"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "start_blk",
            "&map_bh",
            "0"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "152-160",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&map_bh",
            "0",
            "sizeof(struct buffer_head)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fiemap_check_flags",
          "args": [
            "fieinfo",
            "FIEMAP_FLAG_SYNC"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "142-152",
          "snippet": "int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint __generic_block_fiemap(struct inode *inode,\n\t\t\t   struct fiemap_extent_info *fieinfo, loff_t start,\n\t\t\t   loff_t len, get_block_t *get_block)\n{\n\tstruct buffer_head map_bh;\n\tsector_t start_blk, last_blk;\n\tloff_t isize = i_size_read(inode);\n\tu64 logical = 0, phys = 0, size = 0;\n\tu32 flags = FIEMAP_EXTENT_MERGED;\n\tbool past_eof = false, whole_file = false;\n\tint ret = 0;\n\n\tret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Either the i_mutex or other appropriate locking needs to be held\n\t * since we expect isize to not change at all through the duration of\n\t * this call.\n\t */\n\tif (len >= isize) {\n\t\twhole_file = true;\n\t\tlen = isize;\n\t}\n\n\t/*\n\t * Some filesystems can't deal with being asked to map less than\n\t * blocksize, so make sure our len is at least block length.\n\t */\n\tif (logical_to_blk(inode, len) == 0)\n\t\tlen = blk_to_logical(inode, 1);\n\n\tstart_blk = logical_to_blk(inode, start);\n\tlast_blk = logical_to_blk(inode, start + len - 1);\n\n\tdo {\n\t\t/*\n\t\t * we set b_size to the total size we want so it will map as\n\t\t * many contiguous blocks as possible at once\n\t\t */\n\t\tmemset(&map_bh, 0, sizeof(struct buffer_head));\n\t\tmap_bh.b_size = len;\n\n\t\tret = get_block(inode, start_blk, &map_bh, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* HOLE */\n\t\tif (!buffer_mapped(&map_bh)) {\n\t\t\tstart_blk++;\n\n\t\t\t/*\n\t\t\t * We want to handle the case where there is an\n\t\t\t * allocated block at the front of the file, and then\n\t\t\t * nothing but holes up to the end of the file properly,\n\t\t\t * to make sure that extent at the front gets properly\n\t\t\t * marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof &&\n\t\t\t    blk_to_logical(inode, start_blk) >= isize)\n\t\t\t\tpast_eof = 1;\n\n\t\t\t/*\n\t\t\t * First hole after going past the EOF, this is our\n\t\t\t * last extent\n\t\t\t */\n\t\t\tif (past_eof && size) {\n\t\t\t\tflags = FIEMAP_EXTENT_MERGED|FIEMAP_EXTENT_LAST;\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t} else if (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size, flags);\n\t\t\t\tsize = 0;\n\t\t\t}\n\n\t\t\t/* if we have holes up to/past EOF then we're done */\n\t\t\tif (start_blk > last_blk || past_eof || ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We have gone over the length of what we wanted to\n\t\t\t * map, and it wasn't the entire file, so add the extent\n\t\t\t * we got last time and exit.\n\t\t\t *\n\t\t\t * This is for the case where say we want to map all the\n\t\t\t * way up to the second to the last block in a file, but\n\t\t\t * the last block is a hole, making the second to last\n\t\t\t * block FIEMAP_EXTENT_LAST.  In this case we want to\n\t\t\t * see if there is a hole after the second to last block\n\t\t\t * so we can mark it properly.  If we found data after\n\t\t\t * we exceeded the length we were requesting, then we\n\t\t\t * are good to go, just add the extent to the fieinfo\n\t\t\t * and break\n\t\t\t */\n\t\t\tif (start_blk > last_blk && !whole_file) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if size != 0 then we know we already have an extent\n\t\t\t * to add, so add it.\n\t\t\t */\n\t\t\tif (size) {\n\t\t\t\tret = fiemap_fill_next_extent(fieinfo, logical,\n\t\t\t\t\t\t\t      phys, size,\n\t\t\t\t\t\t\t      flags);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlogical = blk_to_logical(inode, start_blk);\n\t\t\tphys = blk_to_logical(inode, map_bh.b_blocknr);\n\t\t\tsize = map_bh.b_size;\n\t\t\tflags = FIEMAP_EXTENT_MERGED;\n\n\t\t\tstart_blk += logical_to_blk(inode, size);\n\n\t\t\t/*\n\t\t\t * If we are past the EOF, then we need to make sure as\n\t\t\t * soon as we find a hole that the last extent we found\n\t\t\t * is marked with FIEMAP_EXTENT_LAST\n\t\t\t */\n\t\t\tif (!past_eof && logical + size >= isize)\n\t\t\t\tpast_eof = true;\n\t\t}\n\t\tcond_resched();\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t} while (1);\n\n\t/* If ret is 1 then we just hit the end of the extent array */\n\tif (ret == 1)\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "blk_to_logical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "264-267",
    "snippet": "static inline loff_t blk_to_logical(struct inode *inode, sector_t blk)\n{\n\treturn (blk << inode->i_blkbits);\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic inline loff_t blk_to_logical(struct inode *inode, sector_t blk)\n{\n\treturn (blk << inode->i_blkbits);\n}"
  },
  {
    "function_name": "logical_to_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "259-262",
    "snippet": "static inline sector_t logical_to_blk(struct inode *inode, loff_t offset)\n{\n\treturn (offset >> inode->i_blkbits);\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic inline sector_t logical_to_blk(struct inode *inode, loff_t offset)\n{\n\treturn (offset >> inode->i_blkbits);\n}"
  },
  {
    "function_name": "ioctl_file_clone_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "247-255",
    "snippet": "static long ioctl_file_clone_range(struct file *file, void __user *argp)\n{\n\tstruct file_clone_range args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\n\t\t\t\targs.src_length, args.dest_offset);\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioctl_file_clone",
          "args": [
            "file",
            "args.src_fd",
            "args.src_offset",
            "args.src_length",
            "args.dest_offset"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_file_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "222-245",
          "snippet": "static long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tloff_t cloned;\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto fdput;\n\tcloned = vfs_clone_file_range(src_file.file, off, dst_file, destoff,\n\t\t\t\t      olen, 0);\n\tif (cloned < 0)\n\t\tret = cloned;\n\telse if (olen && cloned != olen)\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nfdput:\n\tfdput(src_file);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tloff_t cloned;\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto fdput;\n\tcloned = vfs_clone_file_range(src_file.file, off, dst_file, destoff,\n\t\t\t\t      olen, 0);\n\tif (cloned < 0)\n\t\tret = cloned;\n\telse if (olen && cloned != olen)\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nfdput:\n\tfdput(src_file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&args",
            "argp",
            "sizeof(args)"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic long ioctl_file_clone_range(struct file *file, void __user *argp)\n{\n\tstruct file_clone_range args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn ioctl_file_clone(file, args.src_fd, args.src_offset,\n\t\t\t\targs.src_length, args.dest_offset);\n}"
  },
  {
    "function_name": "ioctl_file_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "222-245",
    "snippet": "static long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tloff_t cloned;\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto fdput;\n\tcloned = vfs_clone_file_range(src_file.file, off, dst_file, destoff,\n\t\t\t\t      olen, 0);\n\tif (cloned < 0)\n\t\tret = cloned;\n\telse if (olen && cloned != olen)\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nfdput:\n\tfdput(src_file);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "src_file"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_clone_file_range",
          "args": [
            "src_file.file",
            "off",
            "dst_file",
            "destoff",
            "olen",
            "0"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_clone_file_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "2001-2013",
          "snippet": "loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t    loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tfile_start_write(file_out);\n\tret = do_clone_file_range(file_in, pos_in, file_out, pos_out, len,\n\t\t\t\t  remap_flags);\n\tfile_end_write(file_out);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t    loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tfile_start_write(file_out);\n\tret = do_clone_file_range(file_in, pos_in, file_out, pos_out, len,\n\t\t\t\t  remap_flags);\n\tfile_end_write(file_out);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "srcfd"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic long ioctl_file_clone(struct file *dst_file, unsigned long srcfd,\n\t\t\t     u64 off, u64 olen, u64 destoff)\n{\n\tstruct fd src_file = fdget(srcfd);\n\tloff_t cloned;\n\tint ret;\n\n\tif (!src_file.file)\n\t\treturn -EBADF;\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto fdput;\n\tcloned = vfs_clone_file_range(src_file.file, off, dst_file, destoff,\n\t\t\t\t      olen, 0);\n\tif (cloned < 0)\n\t\tret = cloned;\n\telse if (olen && cloned != olen)\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nfdput:\n\tfdput(src_file);\n\treturn ret;\n}"
  },
  {
    "function_name": "ioctl_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "177-220",
    "snippet": "static int ioctl_fiemap(struct file *filp, unsigned long arg)\n{\n\tstruct fiemap fiemap;\n\tstruct fiemap __user *ufiemap = (struct fiemap __user *) arg;\n\tstruct fiemap_extent_info fieinfo = { 0, };\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tu64 len;\n\tint error;\n\n\tif (!inode->i_op->fiemap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&fiemap, ufiemap, sizeof(fiemap)))\n\t\treturn -EFAULT;\n\n\tif (fiemap.fm_extent_count > FIEMAP_MAX_EXTENTS)\n\t\treturn -EINVAL;\n\n\terror = fiemap_check_ranges(sb, fiemap.fm_start, fiemap.fm_length,\n\t\t\t\t    &len);\n\tif (error)\n\t\treturn error;\n\n\tfieinfo.fi_flags = fiemap.fm_flags;\n\tfieinfo.fi_extents_max = fiemap.fm_extent_count;\n\tfieinfo.fi_extents_start = ufiemap->fm_extents;\n\n\tif (fiemap.fm_extent_count != 0 &&\n\t    !access_ok(VERIFY_WRITE, fieinfo.fi_extents_start,\n\t\t       fieinfo.fi_extents_max * sizeof(struct fiemap_extent)))\n\t\treturn -EFAULT;\n\n\tif (fieinfo.fi_flags & FIEMAP_FLAG_SYNC)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\terror = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start, len);\n\tfiemap.fm_flags = fieinfo.fi_flags;\n\tfiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;\n\tif (copy_to_user(ufiemap, &fiemap, sizeof(fiemap)))\n\t\terror = -EFAULT;\n\n\treturn error;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [
      "#define FIEMAP_MAX_EXTENTS\t(UINT_MAX / sizeof(struct fiemap_extent))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ufiemap",
            "&fiemap",
            "sizeof(fiemap)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->fiemap",
          "args": [
            "inode",
            "&fieinfo",
            "fiemap.fm_start",
            "len"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "fieinfo.fi_extents_start",
            "fieinfo.fi_extents_max * sizeof(struct fiemap_extent)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fiemap_check_ranges",
          "args": [
            "sb",
            "fiemap.fm_start",
            "fiemap.fm_length",
            "&len"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_check_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "155-175",
          "snippet": "static int fiemap_check_ranges(struct super_block *sb,\n\t\t\t       u64 start, u64 len, u64 *new_len)\n{\n\tu64 maxbytes = (u64) sb->s_maxbytes;\n\n\t*new_len = len;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\t/*\n\t * Shrink request scope to what the fs can actually handle.\n\t */\n\tif (len > maxbytes || (maxbytes - len) < start)\n\t\t*new_len = maxbytes - start;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int fiemap_check_ranges(struct super_block *sb,\n\t\t\t       u64 start, u64 len, u64 *new_len)\n{\n\tu64 maxbytes = (u64) sb->s_maxbytes;\n\n\t*new_len = len;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\t/*\n\t * Shrink request scope to what the fs can actually handle.\n\t */\n\tif (len > maxbytes || (maxbytes - len) < start)\n\t\t*new_len = maxbytes - start;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&fiemap",
            "ufiemap",
            "sizeof(fiemap)"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define FIEMAP_MAX_EXTENTS\t(UINT_MAX / sizeof(struct fiemap_extent))\n\nstatic int ioctl_fiemap(struct file *filp, unsigned long arg)\n{\n\tstruct fiemap fiemap;\n\tstruct fiemap __user *ufiemap = (struct fiemap __user *) arg;\n\tstruct fiemap_extent_info fieinfo = { 0, };\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tu64 len;\n\tint error;\n\n\tif (!inode->i_op->fiemap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&fiemap, ufiemap, sizeof(fiemap)))\n\t\treturn -EFAULT;\n\n\tif (fiemap.fm_extent_count > FIEMAP_MAX_EXTENTS)\n\t\treturn -EINVAL;\n\n\terror = fiemap_check_ranges(sb, fiemap.fm_start, fiemap.fm_length,\n\t\t\t\t    &len);\n\tif (error)\n\t\treturn error;\n\n\tfieinfo.fi_flags = fiemap.fm_flags;\n\tfieinfo.fi_extents_max = fiemap.fm_extent_count;\n\tfieinfo.fi_extents_start = ufiemap->fm_extents;\n\n\tif (fiemap.fm_extent_count != 0 &&\n\t    !access_ok(VERIFY_WRITE, fieinfo.fi_extents_start,\n\t\t       fieinfo.fi_extents_max * sizeof(struct fiemap_extent)))\n\t\treturn -EFAULT;\n\n\tif (fieinfo.fi_flags & FIEMAP_FLAG_SYNC)\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\terror = inode->i_op->fiemap(inode, &fieinfo, fiemap.fm_start, len);\n\tfiemap.fm_flags = fieinfo.fi_flags;\n\tfiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;\n\tif (copy_to_user(ufiemap, &fiemap, sizeof(fiemap)))\n\t\terror = -EFAULT;\n\n\treturn error;\n}"
  },
  {
    "function_name": "fiemap_check_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "155-175",
    "snippet": "static int fiemap_check_ranges(struct super_block *sb,\n\t\t\t       u64 start, u64 len, u64 *new_len)\n{\n\tu64 maxbytes = (u64) sb->s_maxbytes;\n\n\t*new_len = len;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\t/*\n\t * Shrink request scope to what the fs can actually handle.\n\t */\n\tif (len > maxbytes || (maxbytes - len) < start)\n\t\t*new_len = maxbytes - start;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int fiemap_check_ranges(struct super_block *sb,\n\t\t\t       u64 start, u64 len, u64 *new_len)\n{\n\tu64 maxbytes = (u64) sb->s_maxbytes;\n\n\t*new_len = len;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tif (start > maxbytes)\n\t\treturn -EFBIG;\n\n\t/*\n\t * Shrink request scope to what the fs can actually handle.\n\t */\n\tif (len > maxbytes || (maxbytes - len) < start)\n\t\t*new_len = maxbytes - start;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fiemap_check_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "142-152",
    "snippet": "int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fiemap_fill_next_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "89-125",
    "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [
      "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
      "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
      "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "dest",
            "&extent",
            "sizeof(extent)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&extent",
            "0",
            "sizeof(extent)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
  },
  {
    "function_name": "ioctl_fibmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "54-69",
    "snippet": "static int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "res",
            "p"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->bmap",
          "args": [
            "mapping",
            "block"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1592-1598",
          "snippet": "sector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nsector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "block",
            "p"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RAWIO"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}"
  },
  {
    "function_name": "vfs_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "39-51",
    "snippet": "long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint error = -ENOTTY;\n\n\tif (!filp->f_op->unlocked_ioctl)\n\t\tgoto out;\n\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = -ENOTTY;\n out:\n\treturn error;\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filp->f_op->unlocked_ioctl",
          "args": [
            "filp",
            "cmd",
            "arg"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nlong vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tint error = -ENOTTY;\n\n\tif (!filp->f_op->unlocked_ioctl)\n\t\tgoto out;\n\n\terror = filp->f_op->unlocked_ioctl(filp, cmd, arg);\n\tif (error == -ENOIOCTLCMD)\n\t\terror = -ENOTTY;\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
    "lines": "718-721",
    "snippet": "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)\n{\n\treturn ksys_ioctl(fd, cmd, arg);\n}",
    "includes": [
      "#include <asm/ioctls.h>",
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/falloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/mm.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)\n{\n\treturn ksys_ioctl(fd, cmd, arg);\n}"
  }
]