[
  {
    "function_name": "is_empty_dir_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1252-1256",
    "snippet": "bool is_empty_dir_inode(struct inode *inode)\n{\n\treturn (inode->i_fop == &empty_dir_operations) &&\n\t\t(inode->i_op == &empty_dir_inode_operations);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations empty_dir_inode_operations = {\n\t.lookup\t\t= empty_dir_lookup,\n\t.permission\t= generic_permission,\n\t.setattr\t= empty_dir_setattr,\n\t.getattr\t= empty_dir_getattr,\n\t.listxattr\t= empty_dir_listxattr,\n};",
      "static const struct file_operations empty_dir_operations = {\n\t.llseek\t\t= empty_dir_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= empty_dir_readdir,\n\t.fsync\t\t= noop_fsync,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic const struct inode_operations empty_dir_inode_operations = {\n\t.lookup\t\t= empty_dir_lookup,\n\t.permission\t= generic_permission,\n\t.setattr\t= empty_dir_setattr,\n\t.getattr\t= empty_dir_getattr,\n\t.listxattr\t= empty_dir_listxattr,\n};\nstatic const struct file_operations empty_dir_operations = {\n\t.llseek\t\t= empty_dir_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= empty_dir_readdir,\n\t.fsync\t\t= noop_fsync,\n};\n\nbool is_empty_dir_inode(struct inode *inode)\n{\n\treturn (inode->i_fop == &empty_dir_operations) &&\n\t\t(inode->i_op == &empty_dir_inode_operations);\n}"
  },
  {
    "function_name": "make_empty_dir_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1236-1250",
    "snippet": "void make_empty_dir_inode(struct inode *inode)\n{\n\tset_nlink(inode, 2);\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tinode->i_uid = GLOBAL_ROOT_UID;\n\tinode->i_gid = GLOBAL_ROOT_GID;\n\tinode->i_rdev = 0;\n\tinode->i_size = 0;\n\tinode->i_blkbits = PAGE_SHIFT;\n\tinode->i_blocks = 0;\n\n\tinode->i_op = &empty_dir_inode_operations;\n\tinode->i_opflags &= ~IOP_XATTR;\n\tinode->i_fop = &empty_dir_operations;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations empty_dir_inode_operations = {\n\t.lookup\t\t= empty_dir_lookup,\n\t.permission\t= generic_permission,\n\t.setattr\t= empty_dir_setattr,\n\t.getattr\t= empty_dir_getattr,\n\t.listxattr\t= empty_dir_listxattr,\n};",
      "static const struct file_operations empty_dir_operations = {\n\t.llseek\t\t= empty_dir_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= empty_dir_readdir,\n\t.fsync\t\t= noop_fsync,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "317-328",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic const struct inode_operations empty_dir_inode_operations = {\n\t.lookup\t\t= empty_dir_lookup,\n\t.permission\t= generic_permission,\n\t.setattr\t= empty_dir_setattr,\n\t.getattr\t= empty_dir_getattr,\n\t.listxattr\t= empty_dir_listxattr,\n};\nstatic const struct file_operations empty_dir_operations = {\n\t.llseek\t\t= empty_dir_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= empty_dir_readdir,\n\t.fsync\t\t= noop_fsync,\n};\n\nvoid make_empty_dir_inode(struct inode *inode)\n{\n\tset_nlink(inode, 2);\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tinode->i_uid = GLOBAL_ROOT_UID;\n\tinode->i_gid = GLOBAL_ROOT_GID;\n\tinode->i_rdev = 0;\n\tinode->i_size = 0;\n\tinode->i_blkbits = PAGE_SHIFT;\n\tinode->i_blocks = 0;\n\n\tinode->i_op = &empty_dir_inode_operations;\n\tinode->i_opflags &= ~IOP_XATTR;\n\tinode->i_fop = &empty_dir_operations;\n}"
  },
  {
    "function_name": "empty_dir_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1222-1226",
    "snippet": "static int empty_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\tdir_emit_dots(file, ctx);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int empty_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\tdir_emit_dots(file, ctx);\n\treturn 0;\n}"
  },
  {
    "function_name": "empty_dir_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1216-1220",
    "snippet": "static loff_t empty_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\t/* An empty directory has two entries . and .. at offsets 0 and 1 */\n\treturn generic_file_llseek_size(file, offset, whence, 2, 2);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "2",
            "2"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "85-131",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic loff_t empty_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\t/* An empty directory has two entries . and .. at offsets 0 and 1 */\n\treturn generic_file_llseek_size(file, offset, whence, 2, 2);\n}"
  },
  {
    "function_name": "empty_dir_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1203-1206",
    "snippet": "static ssize_t empty_dir_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic ssize_t empty_dir_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "empty_dir_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1198-1201",
    "snippet": "static int empty_dir_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\treturn -EPERM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int empty_dir_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\treturn -EPERM;\n}"
  },
  {
    "function_name": "empty_dir_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1190-1196",
    "snippet": "static int empty_dir_getattr(const struct path *path, struct kstat *stat,\n\t\t\t     u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tgeneric_fillattr(inode, stat);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/stat.c",
          "lines": "33-53",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = i_blocksize(inode);\n\tstat->blocks = inode->i_blocks;\n\n\tif (IS_NOATIME(inode))\n\t\tstat->result_mask &= ~STATX_ATIME;\n\tif (IS_AUTOMOUNT(inode))\n\t\tstat->attributes |= STATX_ATTR_AUTOMOUNT;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = i_blocksize(inode);\n\tstat->blocks = inode->i_blocks;\n\n\tif (IS_NOATIME(inode))\n\t\tstat->result_mask &= ~STATX_ATIME;\n\tif (IS_AUTOMOUNT(inode))\n\t\tstat->attributes |= STATX_ATTR_AUTOMOUNT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "path->dentry"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int empty_dir_getattr(const struct path *path, struct kstat *stat,\n\t\t\t     u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tgeneric_fillattr(inode, stat);\n\treturn 0;\n}"
  },
  {
    "function_name": "empty_dir_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1185-1188",
    "snippet": "static struct dentry *empty_dir_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn ERR_PTR(-ENOENT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic struct dentry *empty_dir_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn ERR_PTR(-ENOENT);\n}"
  },
  {
    "function_name": "simple_get_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1170-1174",
    "snippet": "const char *simple_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct delayed_call *done)\n{\n\treturn inode->i_link;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nconst char *simple_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct delayed_call *done)\n{\n\treturn inode->i_link;\n}"
  },
  {
    "function_name": "simple_nosetlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1162-1167",
    "snippet": "int\nsimple_nosetlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t  void **priv)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint\nsimple_nosetlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t  void **priv)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "alloc_anon_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1123-1149",
    "snippet": "struct inode *alloc_anon_inode(struct super_block *s)\n{\n\tstatic const struct address_space_operations anon_aops = {\n\t\t.set_page_dirty = anon_set_page_dirty,\n\t};\n\tstruct inode *inode = new_inode_pseudo(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mapping->a_ops = &anon_aops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because mark_inode_dirty() will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_flags |= S_PRIVATE;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "870-891",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);",
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode_pseudo",
          "args": [
            "s"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "904-915",
          "snippet": "struct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct inode *alloc_anon_inode(struct super_block *s)\n{\n\tstatic const struct address_space_operations anon_aops = {\n\t\t.set_page_dirty = anon_set_page_dirty,\n\t};\n\tstruct inode *inode = new_inode_pseudo(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mapping->a_ops = &anon_aops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because mark_inode_dirty() will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_flags |= S_PRIVATE;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "anon_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1113-1116",
    "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kfree_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1103-1106",
    "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
  },
  {
    "function_name": "noop_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1090-1099",
    "snippet": "ssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\t/*\n\t * iomap based filesystems support direct I/O without need for\n\t * this callback. However, it still needs to be set in\n\t * inode->a_ops so that open/fcntl know that direct I/O is\n\t * generally supported.\n\t */\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\t/*\n\t * iomap based filesystems support direct I/O without need for\n\t * this callback. However, it still needs to be set in\n\t * inode->a_ops so that open/fcntl know that direct I/O is\n\t * generally supported.\n\t */\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "noop_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1079-1087",
    "snippet": "void noop_invalidatepage(struct page *page, unsigned int offset,\n\t\tunsigned int length)\n{\n\t/*\n\t * There is no page cache to invalidate in the dax case, however\n\t * we need this callback defined to prevent falling back to\n\t * block_invalidatepage() in do_invalidatepage().\n\t */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid noop_invalidatepage(struct page *page, unsigned int offset,\n\t\tunsigned int length)\n{\n\t/*\n\t * There is no page cache to invalidate in the dax case, however\n\t * we need this callback defined to prevent falling back to\n\t * block_invalidatepage() in do_invalidatepage().\n\t */\n}"
  },
  {
    "function_name": "noop_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1063-1076",
    "snippet": "int noop_set_page_dirty(struct page *page)\n{\n\t/*\n\t * Unlike __set_page_dirty_no_writeback that handles dirty page\n\t * tracking in the page object, dax does all dirty tracking in\n\t * the inode address_space in response to mkwrite faults. In the\n\t * dax case we only need to worry about potentially dirty CPU\n\t * caches, not dirty page cache pages to write back.\n\t *\n\t * This callback is defined to prevent fallback to\n\t * __set_page_dirty_buffers() in set_page_dirty().\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint noop_set_page_dirty(struct page *page)\n{\n\t/*\n\t * Unlike __set_page_dirty_no_writeback that handles dirty page\n\t * tracking in the page object, dax does all dirty tracking in\n\t * the inode address_space in response to mkwrite faults. In the\n\t * dax case we only need to worry about potentially dirty CPU\n\t * caches, not dirty page cache pages to write back.\n\t *\n\t * This callback is defined to prevent fallback to\n\t * __set_page_dirty_buffers() in set_page_dirty().\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "noop_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1057-1060",
    "snippet": "int noop_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint noop_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "generic_check_addressable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1034-1051",
    "snippet": "int generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\n{\n\tu64 last_fs_block = num_blocks - 1;\n\tu64 last_fs_page =\n\t\tlast_fs_block >> (PAGE_SHIFT - blocksize_bits);\n\n\tif (unlikely(num_blocks == 0))\n\t\treturn 0;\n\n\tif ((blocksize_bits < 9) || (blocksize_bits > PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "~0ULL"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "~0ULL"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "num_blocks == 0"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\n{\n\tu64 last_fs_block = num_blocks - 1;\n\tu64 last_fs_page =\n\t\tlast_fs_block >> (PAGE_SHIFT - blocksize_bits);\n\n\tif (unlikely(num_blocks == 0))\n\t\treturn 0;\n\n\tif ((blocksize_bits < 9) || (blocksize_bits > PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "generic_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "1012-1022",
    "snippet": "int generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t       int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\n\terr = __generic_file_fsync(file, start, end, datasync);\n\tif (err)\n\t\treturn err;\n\treturn blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "inode->i_sb->s_bdev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_file_fsync",
          "args": [
            "file",
            "start",
            "end",
            "datasync"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "__generic_file_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "970-999",
          "snippet": "int __generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t\t int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\tint ret;\n\n\terr = file_write_and_wait_range(file, start, end);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\tret = sync_mapping_buffers(inode->i_mapping);\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tgoto out;\n\tif (datasync && !(inode->i_state & I_DIRTY_DATASYNC))\n\t\tgoto out;\n\n\terr = sync_inode_metadata(inode, 1);\n\tif (ret == 0)\n\t\tret = err;\n\nout:\n\tinode_unlock(inode);\n\t/* check and advance again to catch errors after syncing out buffers */\n\terr = file_check_and_advance_wb_err(file);\n\tif (ret == 0)\n\t\tret = err;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint __generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t\t int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\tint ret;\n\n\terr = file_write_and_wait_range(file, start, end);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\tret = sync_mapping_buffers(inode->i_mapping);\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tgoto out;\n\tif (datasync && !(inode->i_state & I_DIRTY_DATASYNC))\n\t\tgoto out;\n\n\terr = sync_inode_metadata(inode, 1);\n\tif (ret == 0)\n\t\tret = err;\n\nout:\n\tinode_unlock(inode);\n\t/* check and advance again to catch errors after syncing out buffers */\n\terr = file_check_and_advance_wb_err(file);\n\tif (ret == 0)\n\t\tret = err;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t       int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\n\terr = __generic_file_fsync(file, start, end, datasync);\n\tif (err)\n\t\treturn err;\n\treturn blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n}"
  },
  {
    "function_name": "__generic_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "970-999",
    "snippet": "int __generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t\t int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\tint ret;\n\n\terr = file_write_and_wait_range(file, start, end);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\tret = sync_mapping_buffers(inode->i_mapping);\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tgoto out;\n\tif (datasync && !(inode->i_state & I_DIRTY_DATASYNC))\n\t\tgoto out;\n\n\terr = sync_inode_metadata(inode, 1);\n\tif (ret == 0)\n\t\tret = err;\n\nout:\n\tinode_unlock(inode);\n\t/* check and advance again to catch errors after syncing out buffers */\n\terr = file_check_and_advance_wb_err(file);\n\tif (ret == 0)\n\t\tret = err;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_check_and_advance_wb_err",
          "args": [
            "file"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_metadata",
          "args": [
            "inode",
            "1"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2476-2484",
          "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_mapping_buffers",
          "args": [
            "inode->i_mapping"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mapping_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "514-523",
          "snippet": "int sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_write_and_wait_range",
          "args": [
            "file",
            "start",
            "end"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint __generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t\t int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\tint ret;\n\n\terr = file_write_and_wait_range(file, start, end);\n\tif (err)\n\t\treturn err;\n\n\tinode_lock(inode);\n\tret = sync_mapping_buffers(inode->i_mapping);\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tgoto out;\n\tif (datasync && !(inode->i_state & I_DIRTY_DATASYNC))\n\t\tgoto out;\n\n\terr = sync_inode_metadata(inode, 1);\n\tif (ret == 0)\n\t\tret = err;\n\nout:\n\tinode_unlock(inode);\n\t/* check and advance again to catch errors after syncing out buffers */\n\terr = file_check_and_advance_wb_err(file);\n\tif (ret == 0)\n\t\tret = err;\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "938-955",
    "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1988-1991",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, true);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode",
          "args": [
            "sb",
            "fid->i32.parent_ino",
            "(fh_len > 3 ? fid->i32.parent_gen : 0)"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "dlmfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmfs/dlmfs.c",
          "lines": "411-460",
          "snippet": "static struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations dlmfs_file_operations;",
            "static const struct inode_operations dlmfs_dir_inode_operations;",
            "static const struct inode_operations dlmfs_file_inode_operations;",
            "static const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};",
            "static const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct file_operations dlmfs_file_operations;\nstatic const struct inode_operations dlmfs_dir_inode_operations;\nstatic const struct inode_operations dlmfs_file_inode_operations;\nstatic const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};\nstatic const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};\n\nstatic struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "generic_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "905-922",
    "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1988-1991",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, true);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode",
          "args": [
            "sb",
            "fid->i32.ino",
            "fid->i32.gen"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "dlmfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmfs/dlmfs.c",
          "lines": "411-460",
          "snippet": "static struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations dlmfs_file_operations;",
            "static const struct inode_operations dlmfs_dir_inode_operations;",
            "static const struct inode_operations dlmfs_file_inode_operations;",
            "static const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};",
            "static const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct file_operations dlmfs_file_operations;\nstatic const struct inode_operations dlmfs_dir_inode_operations;\nstatic const struct inode_operations dlmfs_file_inode_operations;\nstatic const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};\nstatic const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};\n\nstatic struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "simple_attr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "861-890",
    "snippet": "ssize_t simple_attr_write(struct file *file, const char __user *buf,\n\t\t\t  size_t len, loff_t *ppos)\n{\n\tstruct simple_attr *attr;\n\tu64 val;\n\tsize_t size;\n\tssize_t ret;\n\n\tattr = file->private_data;\n\tif (!attr->set)\n\t\treturn -EACCES;\n\n\tret = mutex_lock_interruptible(&attr->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tsize = min(sizeof(attr->set_buf) - 1, len);\n\tif (copy_from_user(attr->set_buf, buf, size))\n\t\tgoto out;\n\n\tattr->set_buf[size] = '\\0';\n\tval = simple_strtoll(attr->set_buf, NULL, 0);\n\tret = attr->set(attr->data, val);\n\tif (ret == 0)\n\t\tret = len; /* on success, claim we got the whole input */\nout:\n\tmutex_unlock(&attr->mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&attr->mutex"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attr->set",
          "args": [
            "attr->data",
            "val"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoll",
          "args": [
            "attr->set_buf",
            "NULL",
            "0"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "attr->set_buf",
            "buf",
            "size"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sizeof(attr->set_buf) - 1",
            "len"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&attr->mutex"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_attr_write(struct file *file, const char __user *buf,\n\t\t\t  size_t len, loff_t *ppos)\n{\n\tstruct simple_attr *attr;\n\tu64 val;\n\tsize_t size;\n\tssize_t ret;\n\n\tattr = file->private_data;\n\tif (!attr->set)\n\t\treturn -EACCES;\n\n\tret = mutex_lock_interruptible(&attr->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EFAULT;\n\tsize = min(sizeof(attr->set_buf) - 1, len);\n\tif (copy_from_user(attr->set_buf, buf, size))\n\t\tgoto out;\n\n\tattr->set_buf[size] = '\\0';\n\tval = simple_strtoll(attr->set_buf, NULL, 0);\n\tret = attr->set(attr->data, val);\n\tif (ret == 0)\n\t\tret = len; /* on success, claim we got the whole input */\nout:\n\tmutex_unlock(&attr->mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "simple_attr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "825-857",
    "snippet": "ssize_t simple_attr_read(struct file *file, char __user *buf,\n\t\t\t size_t len, loff_t *ppos)\n{\n\tstruct simple_attr *attr;\n\tsize_t size;\n\tssize_t ret;\n\n\tattr = file->private_data;\n\n\tif (!attr->get)\n\t\treturn -EACCES;\n\n\tret = mutex_lock_interruptible(&attr->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*ppos) {\t\t/* continued read */\n\t\tsize = strlen(attr->get_buf);\n\t} else {\t\t/* first read */\n\t\tu64 val;\n\t\tret = attr->get(attr->data, &val);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tsize = scnprintf(attr->get_buf, sizeof(attr->get_buf),\n\t\t\t\t attr->fmt, (unsigned long long)val);\n\t}\n\n\tret = simple_read_from_buffer(buf, len, ppos, attr->get_buf, size);\nout:\n\tmutex_unlock(&attr->mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&attr->mutex"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "len",
            "ppos",
            "attr->get_buf",
            "size"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "622-640",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "attr->get_buf",
            "sizeof(attr->get_buf)",
            "attr->fmt",
            "(unsigned long long)val"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attr->get",
          "args": [
            "attr->data",
            "&val"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "attr->get_buf"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&attr->mutex"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_attr_read(struct file *file, char __user *buf,\n\t\t\t size_t len, loff_t *ppos)\n{\n\tstruct simple_attr *attr;\n\tsize_t size;\n\tssize_t ret;\n\n\tattr = file->private_data;\n\n\tif (!attr->get)\n\t\treturn -EACCES;\n\n\tret = mutex_lock_interruptible(&attr->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*ppos) {\t\t/* continued read */\n\t\tsize = strlen(attr->get_buf);\n\t} else {\t\t/* first read */\n\t\tu64 val;\n\t\tret = attr->get(attr->data, &val);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tsize = scnprintf(attr->get_buf, sizeof(attr->get_buf),\n\t\t\t\t attr->fmt, (unsigned long long)val);\n\t}\n\n\tret = simple_read_from_buffer(buf, len, ppos, attr->get_buf, size);\nout:\n\tmutex_unlock(&attr->mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "simple_attr_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "817-821",
    "snippet": "int simple_attr_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "file->private_data"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_attr_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_attr_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "795-814",
    "snippet": "int simple_attr_open(struct inode *inode, struct file *file,\n\t\t     int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t     const char *fmt)\n{\n\tstruct simple_attr *attr;\n\n\tattr = kmalloc(sizeof(*attr), GFP_KERNEL);\n\tif (!attr)\n\t\treturn -ENOMEM;\n\n\tattr->get = get;\n\tattr->set = set;\n\tattr->data = inode->i_private;\n\tattr->fmt = fmt;\n\tmutex_init(&attr->mutex);\n\n\tfile->private_data = attr;\n\n\treturn nonseekable_open(inode, file);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nonseekable_open",
          "args": [
            "inode",
            "file"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "nonseekable_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1205-1209",
          "snippet": "int nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&attr->mutex"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*attr)",
            "GFP_KERNEL"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_attr_open(struct inode *inode, struct file *file,\n\t\t     int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t     const char *fmt)\n{\n\tstruct simple_attr *attr;\n\n\tattr = kmalloc(sizeof(*attr), GFP_KERNEL);\n\tif (!attr)\n\t\treturn -ENOMEM;\n\n\tattr->get = get;\n\tattr->set = set;\n\tattr->data = inode->i_private;\n\tattr->fmt = fmt;\n\tmutex_init(&attr->mutex);\n\n\tfile->private_data = attr;\n\n\treturn nonseekable_open(inode, file);\n}"
  },
  {
    "function_name": "simple_transaction_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "774-778",
    "snippet": "int simple_transaction_release(struct inode *inode, struct file *file)\n{\n\tfree_page((unsigned long)file->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)file->private_data"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xfs/xfs_buf.c",
          "lines": "305-313",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_errortag.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_transaction_release(struct inode *inode, struct file *file)\n{\n\tfree_page((unsigned long)file->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_transaction_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "764-771",
    "snippet": "ssize_t simple_transaction_read(struct file *file, char __user *buf, size_t size, loff_t *pos)\n{\n\tstruct simple_transaction_argresp *ar = file->private_data;\n\n\tif (!ar)\n\t\treturn 0;\n\treturn simple_read_from_buffer(buf, size, pos, ar->data, ar->size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "size",
            "pos",
            "ar->data",
            "ar->size"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "622-640",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_transaction_read(struct file *file, char __user *buf, size_t size, loff_t *pos)\n{\n\tstruct simple_transaction_argresp *ar = file->private_data;\n\n\tif (!ar)\n\t\treturn 0;\n\treturn simple_read_from_buffer(buf, size, pos, ar->data, ar->size);\n}"
  },
  {
    "function_name": "simple_transaction_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "732-761",
    "snippet": "char *simple_transaction_get(struct file *file, const char __user *buf, size_t size)\n{\n\tstruct simple_transaction_argresp *ar;\n\tstatic DEFINE_SPINLOCK(simple_transaction_lock);\n\n\tif (size > SIMPLE_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tar = (struct simple_transaction_argresp *)get_zeroed_page(GFP_KERNEL);\n\tif (!ar)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&simple_transaction_lock);\n\n\t/* only one write allowed per open */\n\tif (file->private_data) {\n\t\tspin_unlock(&simple_transaction_lock);\n\t\tfree_page((unsigned long)ar);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tfile->private_data = ar;\n\n\tspin_unlock(&simple_transaction_lock);\n\n\tif (copy_from_user(ar->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn ar->data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "ar->data",
            "buf",
            "size"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&simple_transaction_lock"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)ar"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xfs/xfs_buf.c",
          "lines": "305-313",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_errortag.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&simple_transaction_lock"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFBIG"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nchar *simple_transaction_get(struct file *file, const char __user *buf, size_t size)\n{\n\tstruct simple_transaction_argresp *ar;\n\tstatic DEFINE_SPINLOCK(simple_transaction_lock);\n\n\tif (size > SIMPLE_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tar = (struct simple_transaction_argresp *)get_zeroed_page(GFP_KERNEL);\n\tif (!ar)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&simple_transaction_lock);\n\n\t/* only one write allowed per open */\n\tif (file->private_data) {\n\t\tspin_unlock(&simple_transaction_lock);\n\t\tfree_page((unsigned long)ar);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tfile->private_data = ar;\n\n\tspin_unlock(&simple_transaction_lock);\n\n\tif (copy_from_user(ar->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn ar->data;\n}"
  },
  {
    "function_name": "simple_transaction_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "717-729",
    "snippet": "void simple_transaction_set(struct file *file, size_t n)\n{\n\tstruct simple_transaction_argresp *ar = file->private_data;\n\n\tBUG_ON(n > SIMPLE_TRANSACTION_LIMIT);\n\n\t/*\n\t * The barrier ensures that ar->size will really remain zero until\n\t * ar->data is ready for reading.\n\t */\n\tsmp_mb();\n\tar->size = n;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "n > SIMPLE_TRANSACTION_LIMIT"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid simple_transaction_set(struct file *file, size_t n)\n{\n\tstruct simple_transaction_argresp *ar = file->private_data;\n\n\tBUG_ON(n > SIMPLE_TRANSACTION_LIMIT);\n\n\t/*\n\t * The barrier ensures that ar->size will really remain zero until\n\t * ar->data is ready for reading.\n\t */\n\tsmp_mb();\n\tar->size = n;\n}"
  },
  {
    "function_name": "memory_read_from_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "692-707",
    "snippet": "ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tmemcpy(to, from + pos, count);\n\t*ppos = pos + count;\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to",
            "from + pos",
            "count"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tmemcpy(to, from + pos, count);\n\t*ppos = pos + count;\n\n\treturn count;\n}"
  },
  {
    "function_name": "simple_write_to_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "657-675",
    "snippet": "ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,\n\t\tconst void __user *from, size_t count)\n{\n\tloff_t pos = *ppos;\n\tsize_t res;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tres = copy_from_user(to + pos, from, count);\n\tif (res == count)\n\t\treturn -EFAULT;\n\tcount -= res;\n\t*ppos = pos + count;\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "to + pos",
            "from",
            "count"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,\n\t\tconst void __user *from, size_t count)\n{\n\tloff_t pos = *ppos;\n\tsize_t res;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tres = copy_from_user(to + pos, from, count);\n\tif (res == count)\n\t\treturn -EFAULT;\n\tcount -= res;\n\t*ppos = pos + count;\n\treturn count;\n}"
  },
  {
    "function_name": "simple_read_from_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "622-640",
    "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "to",
            "from + pos",
            "count"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
  },
  {
    "function_name": "simple_release_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "596-605",
    "snippet": "void simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(pin_fs_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "mnt"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1180-1189",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pin_fs_lock"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pin_fs_lock"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nvoid simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}"
  },
  {
    "function_name": "simple_pin_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "575-593",
    "snippet": "int simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt = NULL;\n\tspin_lock(&pin_fs_lock);\n\tif (unlikely(!*mount)) {\n\t\tspin_unlock(&pin_fs_lock);\n\t\tmnt = vfs_kern_mount(type, SB_KERNMOUNT, type->name, NULL);\n\t\tif (IS_ERR(mnt))\n\t\t\treturn PTR_ERR(mnt);\n\t\tspin_lock(&pin_fs_lock);\n\t\tif (!*mount)\n\t\t\t*mount = mnt;\n\t}\n\tmntget(*mount);\n\t++*count;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(pin_fs_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "mnt"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1180-1189",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pin_fs_lock"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "*mount"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1192-1197",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pin_fs_lock"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_kern_mount",
          "args": [
            "type",
            "SB_KERNMOUNT",
            "type->name",
            "NULL"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_kern_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "945-976",
          "snippet": "struct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & SB_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nstruct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & SB_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*mount"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nint simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt = NULL;\n\tspin_lock(&pin_fs_lock);\n\tif (unlikely(!*mount)) {\n\t\tspin_unlock(&pin_fs_lock);\n\t\tmnt = vfs_kern_mount(type, SB_KERNMOUNT, type->name, NULL);\n\t\tif (IS_ERR(mnt))\n\t\t\treturn PTR_ERR(mnt);\n\t\tspin_lock(&pin_fs_lock);\n\t\tif (!*mount)\n\t\t\t*mount = mnt;\n\t}\n\tmntget(*mount);\n\t++*count;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "509-570",
    "snippet": "int simple_fill_super(struct super_block *s, unsigned long magic,\n\t\t      const struct tree_descr *files)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct dentry *dentry;\n\tint i;\n\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = &simple_super_operations;\n\ts->s_time_gran = 1;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\t/*\n\t * because the root inode is 1, the files array must not contain an\n\t * entry at index 1\n\t */\n\tinode->i_ino = 1;\n\tinode->i_mode = S_IFDIR | 0755;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\troot = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tfor (i = 0; !files->name || files->name[0]; i++, files++) {\n\t\tif (!files->name)\n\t\t\tcontinue;\n\n\t\t/* warn if it tries to conflict with the root inode */\n\t\tif (unlikely(i == 1))\n\t\t\tprintk(KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\", __func__,\n\t\t\t\ts->s_type->name);\n\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = new_inode(s);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_mode = S_IFREG | files->mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_ino = i;\n\t\td_add(dentry, inode);\n\t}\n\ts->s_root = root;\n\treturn 0;\nout:\n\td_genocide(root);\n\tshrink_dcache_parent(root);\n\tdput(root);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations simple_dir_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= dcache_readdir,\n\t.fsync\t\t= noop_fsync,\n};",
      "const struct inode_operations simple_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n};",
      "static const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "root"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "root"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1464-1484",
          "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect);\n\n\t\tif (!list_empty(&data.dispose)) {\n\t\t\tshrink_dentry_list(&data.dispose);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!data.found)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect);\n\n\t\tif (!list_empty(&data.dispose)) {\n\t\t\tshrink_dentry_list(&data.dispose);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!data.found)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_genocide",
          "args": [
            "root"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "d_genocide",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "3010-3013",
          "snippet": "void d_genocide(struct dentry *parent)\n{\n\td_walk(parent, parent, d_genocide_kill);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_genocide(struct dentry *parent)\n{\n\td_walk(parent, parent, d_genocide_kill);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "d_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2576-2583",
          "snippet": "void d_add(struct dentry *entry, struct inode *inode)\n{\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t}\n\t__d_add(entry, inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_add(struct dentry *entry, struct inode *inode)\n{\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t}\n\t__d_add(entry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "s"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "discard_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "982-992",
          "snippet": "void discard_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n\tiput(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid discard_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "root",
            "files->name"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1726-1733",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\"",
            "__func__",
            "s->s_type->name"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i == 1"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1880-1894",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tres = d_alloc_anon(root_inode->i_sb);\n\t\tif (res) {\n\t\t\tres->d_flags |= DCACHE_RCUACCESS;\n\t\t\td_instantiate(res, root_inode);\n\t\t} else {\n\t\t\tiput(root_inode);\n\t\t}\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tres = d_alloc_anon(root_inode->i_sb);\n\t\tif (res) {\n\t\t\tres->d_flags |= DCACHE_RCUACCESS;\n\t\t\td_instantiate(res, root_inode);\n\t\t} else {\n\t\t\tiput(root_inode);\n\t\t}\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "317-328",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nconst struct file_operations simple_dir_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate_shared\t= dcache_readdir,\n\t.fsync\t\t= noop_fsync,\n};\nconst struct inode_operations simple_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n};\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nint simple_fill_super(struct super_block *s, unsigned long magic,\n\t\t      const struct tree_descr *files)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct dentry *dentry;\n\tint i;\n\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = &simple_super_operations;\n\ts->s_time_gran = 1;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\t/*\n\t * because the root inode is 1, the files array must not contain an\n\t * entry at index 1\n\t */\n\tinode->i_ino = 1;\n\tinode->i_mode = S_IFDIR | 0755;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\troot = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tfor (i = 0; !files->name || files->name[0]; i++, files++) {\n\t\tif (!files->name)\n\t\t\tcontinue;\n\n\t\t/* warn if it tries to conflict with the root inode */\n\t\tif (unlikely(i == 1))\n\t\t\tprintk(KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\", __func__,\n\t\t\t\ts->s_type->name);\n\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = new_inode(s);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_mode = S_IFREG | files->mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_ino = i;\n\t\td_add(dentry, inode);\n\t}\n\ts->s_root = root;\n\treturn 0;\nout:\n\td_genocide(root);\n\tshrink_dcache_parent(root);\n\tdput(root);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "simple_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "473-501",
    "snippet": "int simple_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t last_pos = pos + copied;\n\n\t/* zero the stale part of the page if we did a short copy */\n\tif (!PageUptodate(page)) {\n\t\tif (copied < len) {\n\t\t\tunsigned from = pos & (PAGE_SIZE - 1);\n\n\t\t\tzero_user(page, from + copied, len - copied);\n\t\t}\n\t\tSetPageUptodate(page);\n\t}\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold the i_mutex.\n\t */\n\tif (last_pos > inode->i_size)\n\t\ti_size_write(inode, last_pos);\n\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn copied;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1113-1116",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "last_pos"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2436-2448",
          "snippet": "static inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "from + copied",
            "len - copied"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t last_pos = pos + copied;\n\n\t/* zero the stale part of the page if we did a short copy */\n\tif (!PageUptodate(page)) {\n\t\tif (copied < len) {\n\t\t\tunsigned from = pos & (PAGE_SIZE - 1);\n\n\t\t\tzero_user(page, from + copied, len - copied);\n\t\t}\n\t\tSetPageUptodate(page);\n\t}\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold the i_mutex.\n\t */\n\tif (last_pos > inode->i_size)\n\t\ti_size_write(inode, last_pos);\n\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn copied;\n}"
  },
  {
    "function_name": "simple_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "426-447",
    "snippet": "int simple_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct page *page;\n\tpgoff_t index;\n\n\tindex = pos >> PAGE_SHIFT;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t*pagep = page;\n\n\tif (!PageUptodate(page) && (len != PAGE_SIZE)) {\n\t\tunsigned from = pos & (PAGE_SIZE - 1);\n\n\t\tzero_user_segments(page, 0, from, from + len, PAGE_SIZE);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "0",
            "from",
            "from + len",
            "PAGE_SIZE"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct page *page;\n\tpgoff_t index;\n\n\tindex = pos >> PAGE_SHIFT;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t*pagep = page;\n\n\tif (!PageUptodate(page) && (len != PAGE_SIZE)) {\n\t\tunsigned from = pos & (PAGE_SIZE - 1);\n\n\t\tzero_user_segments(page, 0, from, from + len, PAGE_SIZE);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "416-423",
    "snippet": "int simple_readpage(struct file *file, struct page *page)\n{\n\tclear_highpage(page);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_highpage",
          "args": [
            "page"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_readpage(struct file *file, struct page *page)\n{\n\tclear_highpage(page);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "399-413",
    "snippet": "int simple_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\terror = setattr_prepare(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2059-2079",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "178-203",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec64_trunc(attr->ia_atime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec64_trunc(attr->ia_mtime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec64_trunc(attr->ia_ctime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec64_trunc(attr->ia_atime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec64_trunc(attr->ia_mtime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec64_trunc(attr->ia_ctime,\n\t\t\t\t\t\t  inode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "iattr->ia_size"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setattr_prepare",
          "args": [
            "dentry",
            "iattr"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "61-116",
          "snippet": "int setattr_prepare(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\tgoto kill_priv;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) && !chown_ok(inode, attr->ia_uid))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) && !chgrp_ok(inode, attr->ia_gid))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\nkill_priv:\n\t/* User has permission for the change */\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tint error;\n\n\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint setattr_prepare(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\tgoto kill_priv;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) && !chown_ok(inode, attr->ia_uid))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) && !chgrp_ok(inode, attr->ia_gid))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\nkill_priv:\n\t/* User has permission for the change */\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tint error;\n\n\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error;\n\n\terror = setattr_prepare(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "354-382",
    "snippet": "int simple_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t  struct inode *new_dir, struct dentry *new_dentry,\n\t\t  unsigned int flags)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tint they_are_dirs = d_is_dir(old_dentry);\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tif (!simple_empty(new_dentry))\n\t\treturn -ENOTEMPTY;\n\n\tif (d_really_is_positive(new_dentry)) {\n\t\tsimple_unlink(new_dir, new_dentry);\n\t\tif (they_are_dirs) {\n\t\t\tdrop_nlink(d_inode(new_dentry));\n\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t} else if (they_are_dirs) {\n\t\tdrop_nlink(old_dir);\n\t\tinc_nlink(new_dir);\n\t}\n\n\told_dir->i_ctime = old_dir->i_mtime = new_dir->i_ctime =\n\t\tnew_dir->i_mtime = inode->i_ctime = current_time(old_dir);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "old_dir"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "339-347",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "old_dir"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "283-289",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "new_dentry"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_unlink",
          "args": [
            "new_dir",
            "new_dentry"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "simple_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "331-339",
          "snippet": "int simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_really_is_positive",
          "args": [
            "new_dentry"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_empty",
          "args": [
            "new_dentry"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "simple_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "310-328",
          "snippet": "int simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "old_dentry"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t  struct inode *new_dir, struct dentry *new_dentry,\n\t\t  unsigned int flags)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\tint they_are_dirs = d_is_dir(old_dentry);\n\n\tif (flags & ~RENAME_NOREPLACE)\n\t\treturn -EINVAL;\n\n\tif (!simple_empty(new_dentry))\n\t\treturn -ENOTEMPTY;\n\n\tif (d_really_is_positive(new_dentry)) {\n\t\tsimple_unlink(new_dir, new_dentry);\n\t\tif (they_are_dirs) {\n\t\t\tdrop_nlink(d_inode(new_dentry));\n\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t} else if (they_are_dirs) {\n\t\tdrop_nlink(old_dir);\n\t\tinc_nlink(new_dir);\n\t}\n\n\told_dir->i_ctime = old_dir->i_mtime = new_dir->i_ctime =\n\t\tnew_dir->i_mtime = inode->i_ctime = current_time(old_dir);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "342-351",
    "snippet": "int simple_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tif (!simple_empty(dentry))\n\t\treturn -ENOTEMPTY;\n\n\tdrop_nlink(d_inode(dentry));\n\tsimple_unlink(dir, dentry);\n\tdrop_nlink(dir);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "dir"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "283-289",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "simple_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "331-339",
          "snippet": "int simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_empty",
          "args": [
            "dentry"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "simple_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "310-328",
          "snippet": "int simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tif (!simple_empty(dentry))\n\t\treturn -ENOTEMPTY;\n\n\tdrop_nlink(d_inode(dentry));\n\tsimple_unlink(dir, dentry);\n\tdrop_nlink(dir);\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "331-339",
    "snippet": "int simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "283-289",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "310-328",
    "snippet": "int simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_positive",
          "args": [
            "child"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&child->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&dentry->d_subdirs",
            "d_child"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "simple_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "297-307",
    "snippet": "int simple_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\n\tinc_nlink(inode);\n\tihold(inode);\n\tdget(dentry);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1937-1940",
          "snippet": "struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "402-405",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "339-347",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "old_dentry"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(old_dentry);\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = current_time(inode);\n\tinc_nlink(inode);\n\tihold(inode);\n\tdget(dentry);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "289-294",
    "snippet": "int simple_open(struct inode *inode, struct file *file)\n{\n\tif (inode->i_private)\n\t\tfile->private_data = inode->i_private;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_open(struct inode *inode, struct file *file)\n{\n\tif (inode->i_private)\n\t\tfile->private_data = inode->i_private;\n\treturn 0;\n}"
  },
  {
    "function_name": "mount_pseudo_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "240-286",
    "snippet": "struct dentry *mount_pseudo_xattr(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops, const struct xattr_handler **xattr,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget_userns(fs_type, NULL, set_anon_super, SB_KERNMOUNT|SB_NOUSER,\n\t\t\t&init_user_ns, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_xattr = xattr;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = current_time(root);\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= SB_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_locked_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "323-344",
          "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "s->s_root"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "root"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1937-1940",
          "snippet": "struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "root"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_alloc",
          "args": [
            "s",
            "&d_name"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1593-1665",
          "snippet": "struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dentry_cache",
            "const struct qstr slash_name = QSTR_INIT(\"/\", 1);",
            "static DEFINE_PER_CPU(long, nr_dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\nconst struct qstr slash_name = QSTR_INIT(\"/\", 1);\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstruct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "root"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "s"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "discard_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "982-992",
          "snippet": "void discard_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n\tiput(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid discard_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "s"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget_userns",
          "args": [
            "fs_type",
            "NULL",
            "set_anon_super",
            "SB_KERNMOUNT|SB_NOUSER",
            "&init_user_ns",
            "NULL"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "sget_userns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "486-539",
          "snippet": "struct super_block *sget_userns(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, struct user_namespace *user_ns,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&\n\t    !(type->fs_flags & FS_USERNS_MOUNT) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (user_ns != old->s_user_ns) {\n\t\t\t\tspin_unlock(&sb_lock);\n\t\t\t\tdestroy_unused_super(s);\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t\t}\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tdestroy_unused_super(s);\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, (flags & ~SB_SUBMOUNT), user_ns);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tdestroy_unused_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker_prepared(&s->s_shrink);\n\treturn s;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *sget_userns(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, struct user_namespace *user_ns,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&\n\t    !(type->fs_flags & FS_USERNS_MOUNT) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (user_ns != old->s_user_ns) {\n\t\t\t\tspin_unlock(&sb_lock);\n\t\t\t\tdestroy_unused_super(s);\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t\t}\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tdestroy_unused_super(s);\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, (flags & ~SB_SUBMOUNT), user_ns);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tdestroy_unused_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker_prepared(&s->s_shrink);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "name",
            "strlen(name)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nstruct dentry *mount_pseudo_xattr(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops, const struct xattr_handler **xattr,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget_userns(fs_type, NULL, set_anon_super, SB_KERNMOUNT|SB_NOUSER,\n\t\t\t&init_user_ns, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_xattr = xattr;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = current_time(root);\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= SB_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "generic_read_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "211-214",
    "snippet": "ssize_t generic_read_dir(struct file *filp, char __user *buf, size_t siz, loff_t *ppos)\n{\n\treturn -EISDIR;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t generic_read_dir(struct file *filp, char __user *buf, size_t siz, loff_t *ppos)\n{\n\treturn -EISDIR;\n}"
  },
  {
    "function_name": "dcache_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "184-208",
    "snippet": "int dcache_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct dentry *cursor = file->private_data;\n\tstruct list_head *p = &cursor->d_child;\n\tstruct dentry *next;\n\tbool moved = false;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tif (ctx->pos == 2)\n\t\tp = &dentry->d_subdirs;\n\twhile ((next = next_positive(dentry, p, 1)) != NULL) {\n\t\tif (!dir_emit(ctx, next->d_name.name, next->d_name.len,\n\t\t\t      d_inode(next)->i_ino, dt_type(d_inode(next))))\n\t\t\tbreak;\n\t\tmoved = true;\n\t\tp = &next->d_child;\n\t\tctx->pos++;\n\t}\n\tif (moved)\n\t\tmove_cursor(cursor, p);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_cursor",
          "args": [
            "cursor",
            "p"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "move_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "123-141",
          "snippet": "static void move_cursor(struct dentry *cursor, struct list_head *after)\n{\n\tstruct dentry *parent = cursor->d_parent;\n\tunsigned n, *seq = &parent->d_inode->i_dir_seq;\n\tspin_lock(&parent->d_lock);\n\tfor (;;) {\n\t\tn = *seq;\n\t\tif (!(n & 1) && cmpxchg(seq, n, n + 1) == n)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\t__list_del(cursor->d_child.prev, cursor->d_child.next);\n\tif (after)\n\t\tlist_add(&cursor->d_child, after);\n\telse\n\t\tlist_add_tail(&cursor->d_child, &parent->d_subdirs);\n\tsmp_store_release(seq, n + 2);\n\tspin_unlock(&parent->d_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic void move_cursor(struct dentry *cursor, struct list_head *after)\n{\n\tstruct dentry *parent = cursor->d_parent;\n\tunsigned n, *seq = &parent->d_inode->i_dir_seq;\n\tspin_lock(&parent->d_lock);\n\tfor (;;) {\n\t\tn = *seq;\n\t\tif (!(n & 1) && cmpxchg(seq, n, n + 1) == n)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\t__list_del(cursor->d_child.prev, cursor->d_child.next);\n\tif (after)\n\t\tlist_add(&cursor->d_child, after);\n\telse\n\t\tlist_add_tail(&cursor->d_child, &parent->d_subdirs);\n\tsmp_store_release(seq, n + 2);\n\tspin_unlock(&parent->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "next->d_name.name",
            "next->d_name.len",
            "d_inode(next)->i_ino",
            "dt_type(d_inode(next))"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_type",
          "args": [
            "d_inode(next)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "dt_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "173-176",
          "snippet": "static inline unsigned char dt_type(struct inode *inode)\n{\n\treturn (inode->i_mode >> 12) & 15;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic inline unsigned char dt_type(struct inode *inode)\n{\n\treturn (inode->i_mode >> 12) & 15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "next"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_positive",
          "args": [
            "dentry",
            "p",
            "1"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "next_positive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "89-121",
          "snippet": "static struct dentry *next_positive(struct dentry *parent,\n\t\t\t\t    struct list_head *from,\n\t\t\t\t    int count)\n{\n\tunsigned *seq = &parent->d_inode->i_dir_seq, n;\n\tstruct dentry *res;\n\tstruct list_head *p;\n\tbool skipped;\n\tint i;\n\nretry:\n\ti = count;\n\tskipped = false;\n\tn = smp_load_acquire(seq) & ~1;\n\tres = NULL;\n\trcu_read_lock();\n\tfor (p = from->next; p != &parent->d_subdirs; p = p->next) {\n\t\tstruct dentry *d = list_entry(p, struct dentry, d_child);\n\t\tif (!simple_positive(d)) {\n\t\t\tskipped = true;\n\t\t} else if (!--i) {\n\t\t\tres = d;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (skipped) {\n\t\tsmp_rmb();\n\t\tif (unlikely(*seq != n))\n\t\t\tgoto retry;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic struct dentry *next_positive(struct dentry *parent,\n\t\t\t\t    struct list_head *from,\n\t\t\t\t    int count)\n{\n\tunsigned *seq = &parent->d_inode->i_dir_seq, n;\n\tstruct dentry *res;\n\tstruct list_head *p;\n\tbool skipped;\n\tint i;\n\nretry:\n\ti = count;\n\tskipped = false;\n\tn = smp_load_acquire(seq) & ~1;\n\tres = NULL;\n\trcu_read_lock();\n\tfor (p = from->next; p != &parent->d_subdirs; p = p->next) {\n\t\tstruct dentry *d = list_entry(p, struct dentry, d_child);\n\t\tif (!simple_positive(d)) {\n\t\t\tskipped = true;\n\t\t} else if (!--i) {\n\t\t\tres = d;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (skipped) {\n\t\tsmp_rmb();\n\t\tif (unlikely(*seq != n))\n\t\t\tgoto retry;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint dcache_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct dentry *cursor = file->private_data;\n\tstruct list_head *p = &cursor->d_child;\n\tstruct dentry *next;\n\tbool moved = false;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tif (ctx->pos == 2)\n\t\tp = &dentry->d_subdirs;\n\twhile ((next = next_positive(dentry, p, 1)) != NULL) {\n\t\tif (!dir_emit(ctx, next->d_name.name, next->d_name.len,\n\t\t\t      d_inode(next)->i_ino, dt_type(d_inode(next))))\n\t\t\tbreak;\n\t\tmoved = true;\n\t\tp = &next->d_child;\n\t\tctx->pos++;\n\t}\n\tif (moved)\n\t\tmove_cursor(cursor, p);\n\treturn 0;\n}"
  },
  {
    "function_name": "dt_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "173-176",
    "snippet": "static inline unsigned char dt_type(struct inode *inode)\n{\n\treturn (inode->i_mode >> 12) & 15;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic inline unsigned char dt_type(struct inode *inode)\n{\n\treturn (inode->i_mode >> 12) & 15;\n}"
  },
  {
    "function_name": "dcache_dir_lseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "143-169",
    "snippet": "loff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tswitch (whence) {\n\t\tcase 1:\n\t\t\toffset += file->f_pos;\n\t\tcase 0:\n\t\t\tif (offset >= 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tif (file->f_pos >= 2) {\n\t\t\tstruct dentry *cursor = file->private_data;\n\t\t\tstruct dentry *to;\n\t\t\tloff_t n = file->f_pos - 2;\n\n\t\t\tinode_lock_shared(dentry->d_inode);\n\t\t\tto = next_positive(dentry, &dentry->d_subdirs, n);\n\t\t\tmove_cursor(cursor, to ? &to->d_child : NULL);\n\t\t\tinode_unlock_shared(dentry->d_inode);\n\t\t}\n\t}\n\treturn offset;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock_shared",
          "args": [
            "dentry->d_inode"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_cursor",
          "args": [
            "cursor",
            "to ? &to->d_child : NULL"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "move_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "123-141",
          "snippet": "static void move_cursor(struct dentry *cursor, struct list_head *after)\n{\n\tstruct dentry *parent = cursor->d_parent;\n\tunsigned n, *seq = &parent->d_inode->i_dir_seq;\n\tspin_lock(&parent->d_lock);\n\tfor (;;) {\n\t\tn = *seq;\n\t\tif (!(n & 1) && cmpxchg(seq, n, n + 1) == n)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\t__list_del(cursor->d_child.prev, cursor->d_child.next);\n\tif (after)\n\t\tlist_add(&cursor->d_child, after);\n\telse\n\t\tlist_add_tail(&cursor->d_child, &parent->d_subdirs);\n\tsmp_store_release(seq, n + 2);\n\tspin_unlock(&parent->d_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic void move_cursor(struct dentry *cursor, struct list_head *after)\n{\n\tstruct dentry *parent = cursor->d_parent;\n\tunsigned n, *seq = &parent->d_inode->i_dir_seq;\n\tspin_lock(&parent->d_lock);\n\tfor (;;) {\n\t\tn = *seq;\n\t\tif (!(n & 1) && cmpxchg(seq, n, n + 1) == n)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\t__list_del(cursor->d_child.prev, cursor->d_child.next);\n\tif (after)\n\t\tlist_add(&cursor->d_child, after);\n\telse\n\t\tlist_add_tail(&cursor->d_child, &parent->d_subdirs);\n\tsmp_store_release(seq, n + 2);\n\tspin_unlock(&parent->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_positive",
          "args": [
            "dentry",
            "&dentry->d_subdirs",
            "n"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "next_positive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "89-121",
          "snippet": "static struct dentry *next_positive(struct dentry *parent,\n\t\t\t\t    struct list_head *from,\n\t\t\t\t    int count)\n{\n\tunsigned *seq = &parent->d_inode->i_dir_seq, n;\n\tstruct dentry *res;\n\tstruct list_head *p;\n\tbool skipped;\n\tint i;\n\nretry:\n\ti = count;\n\tskipped = false;\n\tn = smp_load_acquire(seq) & ~1;\n\tres = NULL;\n\trcu_read_lock();\n\tfor (p = from->next; p != &parent->d_subdirs; p = p->next) {\n\t\tstruct dentry *d = list_entry(p, struct dentry, d_child);\n\t\tif (!simple_positive(d)) {\n\t\t\tskipped = true;\n\t\t} else if (!--i) {\n\t\t\tres = d;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (skipped) {\n\t\tsmp_rmb();\n\t\tif (unlikely(*seq != n))\n\t\t\tgoto retry;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic struct dentry *next_positive(struct dentry *parent,\n\t\t\t\t    struct list_head *from,\n\t\t\t\t    int count)\n{\n\tunsigned *seq = &parent->d_inode->i_dir_seq, n;\n\tstruct dentry *res;\n\tstruct list_head *p;\n\tbool skipped;\n\tint i;\n\nretry:\n\ti = count;\n\tskipped = false;\n\tn = smp_load_acquire(seq) & ~1;\n\tres = NULL;\n\trcu_read_lock();\n\tfor (p = from->next; p != &parent->d_subdirs; p = p->next) {\n\t\tstruct dentry *d = list_entry(p, struct dentry, d_child);\n\t\tif (!simple_positive(d)) {\n\t\t\tskipped = true;\n\t\t} else if (!--i) {\n\t\t\tres = d;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (skipped) {\n\t\tsmp_rmb();\n\t\tif (unlikely(*seq != n))\n\t\t\tgoto retry;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock_shared",
          "args": [
            "dentry->d_inode"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nloff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tswitch (whence) {\n\t\tcase 1:\n\t\t\toffset += file->f_pos;\n\t\tcase 0:\n\t\t\tif (offset >= 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tif (file->f_pos >= 2) {\n\t\t\tstruct dentry *cursor = file->private_data;\n\t\t\tstruct dentry *to;\n\t\t\tloff_t n = file->f_pos - 2;\n\n\t\t\tinode_lock_shared(dentry->d_inode);\n\t\t\tto = next_positive(dentry, &dentry->d_subdirs, n);\n\t\t\tmove_cursor(cursor, to ? &to->d_child : NULL);\n\t\t\tinode_unlock_shared(dentry->d_inode);\n\t\t}\n\t}\n\treturn offset;\n}"
  },
  {
    "function_name": "move_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "123-141",
    "snippet": "static void move_cursor(struct dentry *cursor, struct list_head *after)\n{\n\tstruct dentry *parent = cursor->d_parent;\n\tunsigned n, *seq = &parent->d_inode->i_dir_seq;\n\tspin_lock(&parent->d_lock);\n\tfor (;;) {\n\t\tn = *seq;\n\t\tif (!(n & 1) && cmpxchg(seq, n, n + 1) == n)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\t__list_del(cursor->d_child.prev, cursor->d_child.next);\n\tif (after)\n\t\tlist_add(&cursor->d_child, after);\n\telse\n\t\tlist_add_tail(&cursor->d_child, &parent->d_subdirs);\n\tsmp_store_release(seq, n + 2);\n\tspin_unlock(&parent->d_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "seq",
            "n + 2"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cursor->d_child",
            "&parent->d_subdirs"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cursor->d_child",
            "after"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__list_del",
          "args": [
            "cursor->d_child.prev",
            "cursor->d_child.next"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "seq",
            "n",
            "n + 1"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic void move_cursor(struct dentry *cursor, struct list_head *after)\n{\n\tstruct dentry *parent = cursor->d_parent;\n\tunsigned n, *seq = &parent->d_inode->i_dir_seq;\n\tspin_lock(&parent->d_lock);\n\tfor (;;) {\n\t\tn = *seq;\n\t\tif (!(n & 1) && cmpxchg(seq, n, n + 1) == n)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\t__list_del(cursor->d_child.prev, cursor->d_child.next);\n\tif (after)\n\t\tlist_add(&cursor->d_child, after);\n\telse\n\t\tlist_add_tail(&cursor->d_child, &parent->d_subdirs);\n\tsmp_store_release(seq, n + 2);\n\tspin_unlock(&parent->d_lock);\n}"
  },
  {
    "function_name": "next_positive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "89-121",
    "snippet": "static struct dentry *next_positive(struct dentry *parent,\n\t\t\t\t    struct list_head *from,\n\t\t\t\t    int count)\n{\n\tunsigned *seq = &parent->d_inode->i_dir_seq, n;\n\tstruct dentry *res;\n\tstruct list_head *p;\n\tbool skipped;\n\tint i;\n\nretry:\n\ti = count;\n\tskipped = false;\n\tn = smp_load_acquire(seq) & ~1;\n\tres = NULL;\n\trcu_read_lock();\n\tfor (p = from->next; p != &parent->d_subdirs; p = p->next) {\n\t\tstruct dentry *d = list_entry(p, struct dentry, d_child);\n\t\tif (!simple_positive(d)) {\n\t\t\tskipped = true;\n\t\t} else if (!--i) {\n\t\t\tres = d;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (skipped) {\n\t\tsmp_rmb();\n\t\tif (unlikely(*seq != n))\n\t\t\tgoto retry;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*seq != n"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_positive",
          "args": [
            "d"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structdentry",
            "d_child"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "seq"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic struct dentry *next_positive(struct dentry *parent,\n\t\t\t\t    struct list_head *from,\n\t\t\t\t    int count)\n{\n\tunsigned *seq = &parent->d_inode->i_dir_seq, n;\n\tstruct dentry *res;\n\tstruct list_head *p;\n\tbool skipped;\n\tint i;\n\nretry:\n\ti = count;\n\tskipped = false;\n\tn = smp_load_acquire(seq) & ~1;\n\tres = NULL;\n\trcu_read_lock();\n\tfor (p = from->next; p != &parent->d_subdirs; p = p->next) {\n\t\tstruct dentry *d = list_entry(p, struct dentry, d_child);\n\t\tif (!simple_positive(d)) {\n\t\t\tskipped = true;\n\t\t} else if (!--i) {\n\t\t\tres = d;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (skipped) {\n\t\tsmp_rmb();\n\t\tif (unlikely(*seq != n))\n\t\t\tgoto retry;\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "dcache_dir_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "81-85",
    "snippet": "int dcache_dir_close(struct inode *inode, struct file *file)\n{\n\tdput(file->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "file->private_data"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint dcache_dir_close(struct inode *inode, struct file *file)\n{\n\tdput(file->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "dcache_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "73-78",
    "snippet": "int dcache_dir_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = d_alloc_cursor(file->f_path.dentry);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_alloc_cursor",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1702-1710",
          "snippet": "struct dentry *d_alloc_cursor(struct dentry * parent)\n{\n\tstruct dentry *dentry = d_alloc_anon(parent->d_sb);\n\tif (dentry) {\n\t\tdentry->d_flags |= DCACHE_RCUACCESS | DCACHE_DENTRY_CURSOR;\n\t\tdentry->d_parent = dget(parent);\n\t}\n\treturn dentry;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_cursor(struct dentry * parent)\n{\n\tstruct dentry *dentry = d_alloc_anon(parent->d_sb);\n\tif (dentry) {\n\t\tdentry->d_flags |= DCACHE_RCUACCESS | DCACHE_DENTRY_CURSOR;\n\t\tdentry->d_parent = dget(parent);\n\t}\n\treturn dentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint dcache_dir_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = d_alloc_cursor(file->f_path.dentry);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "simple_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "62-70",
    "snippet": "struct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\tif (!dentry->d_sb->s_d_op)\n\t\td_set_d_op(dentry, &simple_dentry_operations);\n\td_add(dentry, NULL);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct dentry_operations simple_dentry_operations = {\n\t.d_delete = always_delete_dentry,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "d_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2576-2583",
          "snippet": "void d_add(struct dentry *entry, struct inode *inode)\n{\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t}\n\t__d_add(entry, inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_add(struct dentry *entry, struct inode *inode)\n{\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t}\n\t__d_add(entry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&simple_dentry_operations"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1736-1763",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\tif (op->d_real)\n\t\tdentry->d_flags |= DCACHE_OP_REAL;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\tif (op->d_real)\n\t\tdentry->d_flags |= DCACHE_OP_REAL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nconst struct dentry_operations simple_dentry_operations = {\n\t.d_delete = always_delete_dentry,\n};\n\nstruct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\tif (!dentry->d_sb->s_d_op)\n\t\td_set_d_op(dentry, &simple_dentry_operations);\n\td_add(dentry, NULL);\n\treturn NULL;\n}"
  },
  {
    "function_name": "always_delete_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "47-50",
    "snippet": "int always_delete_dentry(const struct dentry *dentry)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint always_delete_dentry(const struct dentry *dentry)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "simple_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "34-40",
    "snippet": "int simple_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tbuf->f_type = dentry->d_sb->s_magic;\n\tbuf->f_bsize = PAGE_SIZE;\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tbuf->f_type = dentry->d_sb->s_magic;\n\tbuf->f_bsize = PAGE_SIZE;\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
    "lines": "24-31",
    "snippet": "int simple_getattr(const struct path *path, struct kstat *stat,\n\t\t   u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tgeneric_fillattr(inode, stat);\n\tstat->blocks = inode->i_mapping->nrpages << (PAGE_SHIFT - 9);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
      "#include <linux/writeback.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mutex.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vfs.h>",
      "#include <linux/mount.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/stat.c",
          "lines": "33-53",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = i_blocksize(inode);\n\tstat->blocks = inode->i_blocks;\n\n\tif (IS_NOATIME(inode))\n\t\tstat->result_mask &= ~STATX_ATIME;\n\tif (IS_AUTOMOUNT(inode))\n\t\tstat->attributes |= STATX_ATTR_AUTOMOUNT;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = i_blocksize(inode);\n\tstat->blocks = inode->i_blocks;\n\n\tif (IS_NOATIME(inode))\n\t\tstat->result_mask &= ~STATX_ATIME;\n\tif (IS_AUTOMOUNT(inode))\n\t\tstat->attributes |= STATX_ATTR_AUTOMOUNT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "path->dentry"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_getattr(const struct path *path, struct kstat *stat,\n\t\t   u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tgeneric_fillattr(inode, stat);\n\tstat->blocks = inode->i_mapping->nrpages << (PAGE_SHIFT - 9);\n\treturn 0;\n}"
  }
]