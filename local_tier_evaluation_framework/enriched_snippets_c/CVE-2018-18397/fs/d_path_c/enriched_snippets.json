[
  {
    "function_name": "get_fs_root_and_pwd_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "394-404",
    "snippet": "static void get_fs_root_and_pwd_rcu(struct fs_struct *fs, struct path *root,\n\t\t\t\t    struct path *pwd)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t\t*pwd = fs->pwd;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&fs->seq",
            "seq"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&fs->seq"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void get_fs_root_and_pwd_rcu(struct fs_struct *fs, struct path *root,\n\t\t\t\t    struct path *pwd)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t\t*pwd = fs->pwd;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}"
  },
  {
    "function_name": "dentry_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "375-392",
    "snippet": "char *dentry_path(struct dentry *dentry, char *buf, int buflen)\n{\n\tchar *p = NULL;\n\tchar *retval;\n\n\tif (d_unlinked(dentry)) {\n\t\tp = buf + buflen;\n\t\tif (prepend(&p, &buflen, \"//deleted\", 10) != 0)\n\t\t\tgoto Elong;\n\t\tbuflen++;\n\t}\n\tretval = __dentry_path(dentry, buf, buflen);\n\tif (!IS_ERR(retval) && p)\n\t\t*p = '/';\t/* restore '/' overriden with '\\0' */\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "retval"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dentry_path",
          "args": [
            "dentry",
            "buf",
            "buflen"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "__dentry_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "324-367",
          "snippet": "static char *__dentry_path(struct dentry *d, char *buf, int buflen)\n{\n\tstruct dentry *dentry;\n\tchar *end, *retval;\n\tint len, seq = 0;\n\tint error = 0;\n\n\tif (buflen < 2)\n\t\tgoto Elong;\n\n\trcu_read_lock();\nrestart:\n\tdentry = d;\n\tend = buf + buflen;\n\tlen = buflen;\n\tprepend(&end, &len, \"\\0\", 1);\n\t/* Get '/' right */\n\tretval = end-1;\n\t*retval = '/';\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\n\t\tprefetch(parent);\n\t\terror = prepend_name(&end, &len, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tretval = end;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (error)\n\t\tgoto Elong;\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic char *__dentry_path(struct dentry *d, char *buf, int buflen)\n{\n\tstruct dentry *dentry;\n\tchar *end, *retval;\n\tint len, seq = 0;\n\tint error = 0;\n\n\tif (buflen < 2)\n\t\tgoto Elong;\n\n\trcu_read_lock();\nrestart:\n\tdentry = d;\n\tend = buf + buflen;\n\tlen = buflen;\n\tprepend(&end, &len, \"\\0\", 1);\n\t/* Get '/' right */\n\tretval = end-1;\n\t*retval = '/';\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\n\t\tprefetch(parent);\n\t\terror = prepend_name(&end, &len, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tretval = end;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (error)\n\t\tgoto Elong;\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepend",
          "args": [
            "&p",
            "&buflen",
            "\"//deleted\"",
            "10"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "75-156",
          "snippet": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unlinked",
          "args": [
            "dentry"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *dentry_path(struct dentry *dentry, char *buf, int buflen)\n{\n\tchar *p = NULL;\n\tchar *retval;\n\n\tif (d_unlinked(dentry)) {\n\t\tp = buf + buflen;\n\t\tif (prepend(&p, &buflen, \"//deleted\", 10) != 0)\n\t\t\tgoto Elong;\n\t\tbuflen++;\n\t}\n\tretval = __dentry_path(dentry, buf, buflen);\n\tif (!IS_ERR(retval) && p)\n\t\t*p = '/';\t/* restore '/' overriden with '\\0' */\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
  },
  {
    "function_name": "dentry_path_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "369-372",
    "snippet": "char *dentry_path_raw(struct dentry *dentry, char *buf, int buflen)\n{\n\treturn __dentry_path(dentry, buf, buflen);\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dentry_path",
          "args": [
            "dentry",
            "buf",
            "buflen"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "__dentry_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "324-367",
          "snippet": "static char *__dentry_path(struct dentry *d, char *buf, int buflen)\n{\n\tstruct dentry *dentry;\n\tchar *end, *retval;\n\tint len, seq = 0;\n\tint error = 0;\n\n\tif (buflen < 2)\n\t\tgoto Elong;\n\n\trcu_read_lock();\nrestart:\n\tdentry = d;\n\tend = buf + buflen;\n\tlen = buflen;\n\tprepend(&end, &len, \"\\0\", 1);\n\t/* Get '/' right */\n\tretval = end-1;\n\t*retval = '/';\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\n\t\tprefetch(parent);\n\t\terror = prepend_name(&end, &len, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tretval = end;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (error)\n\t\tgoto Elong;\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic char *__dentry_path(struct dentry *d, char *buf, int buflen)\n{\n\tstruct dentry *dentry;\n\tchar *end, *retval;\n\tint len, seq = 0;\n\tint error = 0;\n\n\tif (buflen < 2)\n\t\tgoto Elong;\n\n\trcu_read_lock();\nrestart:\n\tdentry = d;\n\tend = buf + buflen;\n\tlen = buflen;\n\tprepend(&end, &len, \"\\0\", 1);\n\t/* Get '/' right */\n\tretval = end-1;\n\t*retval = '/';\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\n\t\tprefetch(parent);\n\t\terror = prepend_name(&end, &len, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tretval = end;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (error)\n\t\tgoto Elong;\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *dentry_path_raw(struct dentry *dentry, char *buf, int buflen)\n{\n\treturn __dentry_path(dentry, buf, buflen);\n}"
  },
  {
    "function_name": "__dentry_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "324-367",
    "snippet": "static char *__dentry_path(struct dentry *d, char *buf, int buflen)\n{\n\tstruct dentry *dentry;\n\tchar *end, *retval;\n\tint len, seq = 0;\n\tint error = 0;\n\n\tif (buflen < 2)\n\t\tgoto Elong;\n\n\trcu_read_lock();\nrestart:\n\tdentry = d;\n\tend = buf + buflen;\n\tlen = buflen;\n\tprepend(&end, &len, \"\\0\", 1);\n\t/* Get '/' right */\n\tretval = end-1;\n\t*retval = '/';\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\n\t\tprefetch(parent);\n\t\terror = prepend_name(&end, &len, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tretval = end;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (error)\n\t\tgoto Elong;\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "done_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepend_name",
          "args": [
            "&end",
            "&len",
            "&dentry->d_name"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "38-56",
          "snippet": "static int prepend_name(char **buffer, int *buflen, const struct qstr *name)\n{\n\tconst char *dname = smp_load_acquire(&name->name); /* ^^^ */\n\tu32 dlen = READ_ONCE(name->len);\n\tchar *p;\n\n\t*buflen -= dlen + 1;\n\tif (*buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\tp = *buffer -= dlen + 1;\n\t*p++ = '/';\n\twhile (dlen--) {\n\t\tchar c = *dname++;\n\t\tif (!c)\n\t\t\tbreak;\n\t\t*p++ = c;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_name(char **buffer, int *buflen, const struct qstr *name)\n{\n\tconst char *dname = smp_load_acquire(&name->name); /* ^^^ */\n\tu32 dlen = READ_ONCE(name->len);\n\tchar *p;\n\n\t*buflen -= dlen + 1;\n\tif (*buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\tp = *buffer -= dlen + 1;\n\t*p++ = '/';\n\twhile (dlen--) {\n\t\tchar c = *dname++;\n\t\tif (!c)\n\t\t\tbreak;\n\t\t*p++ = c;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetch",
          "args": [
            "parent"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin_or_lock",
          "args": [
            "&rename_lock",
            "&seq"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepend",
          "args": [
            "&end",
            "&len",
            "\"\\0\"",
            "1"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "75-156",
          "snippet": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic char *__dentry_path(struct dentry *d, char *buf, int buflen)\n{\n\tstruct dentry *dentry;\n\tchar *end, *retval;\n\tint len, seq = 0;\n\tint error = 0;\n\n\tif (buflen < 2)\n\t\tgoto Elong;\n\n\trcu_read_lock();\nrestart:\n\tdentry = d;\n\tend = buf + buflen;\n\tlen = buflen;\n\tprepend(&end, &len, \"\\0\", 1);\n\t/* Get '/' right */\n\tretval = end-1;\n\t*retval = '/';\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\n\t\tprefetch(parent);\n\t\terror = prepend_name(&end, &len, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tretval = end;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (error)\n\t\tgoto Elong;\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
  },
  {
    "function_name": "simple_dname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "309-318",
    "snippet": "char *simple_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\tchar *end = buffer + buflen;\n\t/* these dentries are never renamed, so d_lock is not needed */\n\tif (prepend(&end, &buflen, \" (deleted)\", 11) ||\n\t    prepend(&end, &buflen, dentry->d_name.name, dentry->d_name.len) ||\n\t    prepend(&end, &buflen, \"/\", 1))  \n\t\tend = ERR_PTR(-ENAMETOOLONG);\n\treturn end;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepend",
          "args": [
            "&end",
            "&buflen",
            "\"/\"",
            "1"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "75-156",
          "snippet": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *simple_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\tchar *end = buffer + buflen;\n\t/* these dentries are never renamed, so d_lock is not needed */\n\tif (prepend(&end, &buflen, \" (deleted)\", 11) ||\n\t    prepend(&end, &buflen, dentry->d_name.name, dentry->d_name.len) ||\n\t    prepend(&end, &buflen, \"/\", 1))  \n\t\tend = ERR_PTR(-ENAMETOOLONG);\n\treturn end;\n}"
  },
  {
    "function_name": "dynamic_dname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "291-307",
    "snippet": "char *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "temp",
            "sz"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "temp",
            "sizeof(temp)",
            "fmt",
            "args"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}"
  },
  {
    "function_name": "d_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "256-285",
    "snippet": "char *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_with_deleted",
          "args": [
            "path",
            "&root",
            "&res",
            "&buflen"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "path_with_deleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "211-223",
          "snippet": "static int path_with_deleted(const struct path *path,\n\t\t\t     const struct path *root,\n\t\t\t     char **buf, int *buflen)\n{\n\tprepend(buf, buflen, \"\\0\", 1);\n\tif (d_unlinked(path->dentry)) {\n\t\tint error = prepend(buf, buflen, \" (deleted)\", 10);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn prepend_path(path, root, buf, buflen);\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int path_with_deleted(const struct path *path,\n\t\t\t     const struct path *root,\n\t\t\t     char **buf, int *buflen)\n{\n\tprepend(buf, buflen, \"\\0\", 1);\n\tif (d_unlinked(path->dentry)) {\n\t\tint error = prepend(buf, buflen, \" (deleted)\", 10);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn prepend_path(path, root, buf, buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fs_root_rcu",
          "args": [
            "current->fs",
            "&root"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "get_fs_root_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "230-238",
          "snippet": "static void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path->dentry->d_op->d_dname",
          "args": [
            "path->dentry",
            "buf",
            "buflen"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "path->dentry"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}"
  },
  {
    "function_name": "get_fs_root_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "230-238",
    "snippet": "static void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&fs->seq",
            "seq"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&fs->seq"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}"
  },
  {
    "function_name": "prepend_unreachable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "225-228",
    "snippet": "static int prepend_unreachable(char **buffer, int *buflen)\n{\n\treturn prepend(buffer, buflen, \"(unreachable)\", 13);\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prepend",
          "args": [
            "buffer",
            "buflen",
            "\"(unreachable)\"",
            "13"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "75-156",
          "snippet": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_unreachable(char **buffer, int *buflen)\n{\n\treturn prepend(buffer, buflen, \"(unreachable)\", 13);\n}"
  },
  {
    "function_name": "path_with_deleted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "211-223",
    "snippet": "static int path_with_deleted(const struct path *path,\n\t\t\t     const struct path *root,\n\t\t\t     char **buf, int *buflen)\n{\n\tprepend(buf, buflen, \"\\0\", 1);\n\tif (d_unlinked(path->dentry)) {\n\t\tint error = prepend(buf, buflen, \" (deleted)\", 10);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn prepend_path(path, root, buf, buflen);\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prepend_path",
          "args": [
            "path",
            "root",
            "buf",
            "buflen"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "75-156",
          "snippet": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unlinked",
          "args": [
            "path->dentry"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int path_with_deleted(const struct path *path,\n\t\t\t     const struct path *root,\n\t\t\t     char **buf, int *buflen)\n{\n\tprepend(buf, buflen, \"\\0\", 1);\n\tif (d_unlinked(path->dentry)) {\n\t\tint error = prepend(buf, buflen, \" (deleted)\", 10);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn prepend_path(path, root, buf, buflen);\n}"
  },
  {
    "function_name": "d_absolute_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "191-206",
    "snippet": "char *d_absolute_path(const struct path *path,\n\t       char *buf, int buflen)\n{\n\tstruct path root = {};\n\tchar *res = buf + buflen;\n\tint error;\n\n\tprepend(&res, &buflen, \"\\0\", 1);\n\terror = prepend_path(path, &root, &res, &buflen);\n\n\tif (error > 1)\n\t\terror = -EINVAL;\n\tif (error < 0)\n\t\treturn ERR_PTR(error);\n\treturn res;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepend_path",
          "args": [
            "path",
            "&root",
            "&res",
            "&buflen"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "75-156",
          "snippet": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *d_absolute_path(const struct path *path,\n\t       char *buf, int buflen)\n{\n\tstruct path root = {};\n\tchar *res = buf + buflen;\n\tint error;\n\n\tprepend(&res, &buflen, \"\\0\", 1);\n\terror = prepend_path(path, &root, &res, &buflen);\n\n\tif (error > 1)\n\t\terror = -EINVAL;\n\tif (error < 0)\n\t\treturn ERR_PTR(error);\n\treturn res;\n}"
  },
  {
    "function_name": "__d_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "174-189",
    "snippet": "char *__d_path(const struct path *path,\n\t       const struct path *root,\n\t       char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tint error;\n\n\tprepend(&res, &buflen, \"\\0\", 1);\n\terror = prepend_path(path, root, &res, &buflen);\n\n\tif (error < 0)\n\t\treturn ERR_PTR(error);\n\tif (error > 0)\n\t\treturn NULL;\n\treturn res;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepend_path",
          "args": [
            "path",
            "root",
            "&res",
            "&buflen"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "75-156",
          "snippet": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *__d_path(const struct path *path,\n\t       const struct path *root,\n\t       char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tint error;\n\n\tprepend(&res, &buflen, \"\\0\", 1);\n\terror = prepend_path(path, root, &res, &buflen);\n\n\tif (error < 0)\n\t\treturn ERR_PTR(error);\n\tif (error > 0)\n\t\treturn NULL;\n\treturn res;\n}"
  },
  {
    "function_name": "prepend_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "75-156",
    "snippet": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "done_seqretry",
          "args": [
            "&mount_lock",
            "m_seq"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_seqretry",
          "args": [
            "&mount_lock",
            "m_seq"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "done_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepend_name",
          "args": [
            "&bptr",
            "&blen",
            "&dentry->d_name"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "prepend_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "38-56",
          "snippet": "static int prepend_name(char **buffer, int *buflen, const struct qstr *name)\n{\n\tconst char *dname = smp_load_acquire(&name->name); /* ^^^ */\n\tu32 dlen = READ_ONCE(name->len);\n\tchar *p;\n\n\t*buflen -= dlen + 1;\n\tif (*buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\tp = *buffer -= dlen + 1;\n\t*p++ = '/';\n\twhile (dlen--) {\n\t\tchar c = *dname++;\n\t\tif (!c)\n\t\t\tbreak;\n\t\t*p++ = c;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_name(char **buffer, int *buflen, const struct qstr *name)\n{\n\tconst char *dname = smp_load_acquire(&name->name); /* ^^^ */\n\tu32 dlen = READ_ONCE(name->len);\n\tchar *p;\n\n\t*buflen -= dlen + 1;\n\tif (*buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\tp = *buffer -= dlen + 1;\n\t*p++ = '/';\n\twhile (dlen--) {\n\t\tchar c = *dname++;\n\t\tif (!c)\n\t\t\tbreak;\n\t\t*p++ = c;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetch",
          "args": [
            "parent"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mounted",
          "args": [
            "vfsmnt"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "is_mounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mount.h",
          "lines": "87-91",
          "snippet": "static inline int is_mounted(struct vfsmount *mnt)\n{\n\t/* neither detached nor internal? */\n\treturn !IS_ERR_OR_NULL(real_mount(mnt)->mnt_ns);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __legitimize_mnt(struct vfsmount *, unsigned);",
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern int __legitimize_mnt(struct vfsmount *, unsigned);\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline int is_mounted(struct vfsmount *mnt)\n{\n\t/* neither detached nor internal? */\n\treturn !IS_ERR_OR_NULL(real_mount(mnt)->mnt_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "mnt->mnt_mountpoint"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "mnt->mnt_parent"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin_or_lock",
          "args": [
            "&rename_lock",
            "&seq"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "vfsmnt"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mount.h",
          "lines": "77-80",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __legitimize_mnt(struct vfsmount *, unsigned);",
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern int __legitimize_mnt(struct vfsmount *, unsigned);\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin_or_lock",
          "args": [
            "&mount_lock",
            "&m_seq"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = READ_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = READ_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}"
  },
  {
    "function_name": "prepend_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "38-56",
    "snippet": "static int prepend_name(char **buffer, int *buflen, const struct qstr *name)\n{\n\tconst char *dname = smp_load_acquire(&name->name); /* ^^^ */\n\tu32 dlen = READ_ONCE(name->len);\n\tchar *p;\n\n\t*buflen -= dlen + 1;\n\tif (*buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\tp = *buffer -= dlen + 1;\n\t*p++ = '/';\n\twhile (dlen--) {\n\t\tchar c = *dname++;\n\t\tif (!c)\n\t\t\tbreak;\n\t\t*p++ = c;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "name->len"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&name->name"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend_name(char **buffer, int *buflen, const struct qstr *name)\n{\n\tconst char *dname = smp_load_acquire(&name->name); /* ^^^ */\n\tu32 dlen = READ_ONCE(name->len);\n\tchar *p;\n\n\t*buflen -= dlen + 1;\n\tif (*buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\tp = *buffer -= dlen + 1;\n\t*p++ = '/';\n\twhile (dlen--) {\n\t\tchar c = *dname++;\n\t\tif (!c)\n\t\t\tbreak;\n\t\t*p++ = c;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "prepend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "11-19",
    "snippet": "static int prepend(char **buffer, int *buflen, const char *str, int namelen)\n{\n\t*buflen -= namelen;\n\tif (*buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*buffer",
            "str",
            "namelen"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int prepend(char **buffer, int *buflen, const char *str, int namelen)\n{\n\t*buflen -= namelen;\n\tif (*buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}"
  },
  {
    "function_name": "getcwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
    "lines": "424-470",
    "snippet": "SYSCALL_DEFINE2(getcwd, char __user *, buf, unsigned long, size)\n{\n\tint error;\n\tstruct path pwd, root;\n\tchar *page = __getname();\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tget_fs_root_and_pwd_rcu(current->fs, &root, &pwd);\n\n\terror = -ENOENT;\n\tif (!d_unlinked(pwd.dentry)) {\n\t\tunsigned long len;\n\t\tchar *cwd = page + PATH_MAX;\n\t\tint buflen = PATH_MAX;\n\n\t\tprepend(&cwd, &buflen, \"\\0\", 1);\n\t\terror = prepend_path(&pwd, &root, &cwd, &buflen);\n\t\trcu_read_unlock();\n\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\t/* Unreachable from current root */\n\t\tif (error > 0) {\n\t\t\terror = prepend_unreachable(&cwd, &buflen);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\terror = -ERANGE;\n\t\tlen = PATH_MAX + page - cwd;\n\t\tif (len <= size) {\n\t\t\terror = len;\n\t\t\tif (copy_to_user(buf, cwd, len))\n\t\t\t\terror = -EFAULT;\n\t\t}\n\t} else {\n\t\trcu_read_unlock();\n\t}\n\nout:\n\t__putname(page);\n\treturn error;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include <linux/prefetch.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE2(getcwd, char __user *, buf, unsigned long, size)\n{\n\tint error;\n\tstruct path pwd, root;\n\tchar *page = __getname();\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tget_fs_root_and_pwd_rcu(current->fs, &root, &pwd);\n\n\terror = -ENOENT;\n\tif (!d_unlinked(pwd.dentry)) {\n\t\tunsigned long len;\n\t\tchar *cwd = page + PATH_MAX;\n\t\tint buflen = PATH_MAX;\n\n\t\tprepend(&cwd, &buflen, \"\\0\", 1);\n\t\terror = prepend_path(&pwd, &root, &cwd, &buflen);\n\t\trcu_read_unlock();\n\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\t/* Unreachable from current root */\n\t\tif (error > 0) {\n\t\t\terror = prepend_unreachable(&cwd, &buflen);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\terror = -ERANGE;\n\t\tlen = PATH_MAX + page - cwd;\n\t\tif (len <= size) {\n\t\t\terror = len;\n\t\t\tif (copy_to_user(buf, cwd, len))\n\t\t\t\terror = -EFAULT;\n\t\t}\n\t} else {\n\t\trcu_read_unlock();\n\t}\n\nout:\n\t__putname(page);\n\treturn error;\n}"
  }
]