[
  {
    "function_name": "set_dumpable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1947-1958",
    "snippet": "void set_dumpable(struct mm_struct *mm, int value)\n{\n\tunsigned long old, new;\n\n\tif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\n\t\treturn;\n\n\tdo {\n\t\told = READ_ONCE(mm->flags);\n\t\tnew = (old & ~MMF_DUMPABLE_MASK) | value;\n\t} while (cmpxchg(&mm->flags, old, new) != old);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&mm->flags",
            "old",
            "new"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "mm->flags"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(unsigned)value > SUID_DUMP_ROOT"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_dumpable(struct mm_struct *mm, int value)\n{\n\tunsigned long old, new;\n\n\tif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\n\t\treturn;\n\n\tdo {\n\t\told = READ_ONCE(mm->flags);\n\t\tnew = (old & ~MMF_DUMPABLE_MASK) | value;\n\t} while (cmpxchg(&mm->flags, old, new) != old);\n}"
  },
  {
    "function_name": "set_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1931-1941",
    "snippet": "void set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__module_get",
          "args": [
            "new->module"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "mm->binfmt->module"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}"
  },
  {
    "function_name": "compat_do_execveat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1914-1928",
    "snippet": "static int compat_do_execveat(int fd, struct filename *filename,\n\t\t\t      const compat_uptr_t __user *__argv,\n\t\t\t      const compat_uptr_t __user *__envp,\n\t\t\t      int flags)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_execveat_common",
          "args": [
            "fd",
            "filename",
            "argv",
            "envp",
            "flags"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "do_execveat_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1862-1868",
          "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int compat_do_execveat(int fd, struct filename *filename,\n\t\t\t      const compat_uptr_t __user *__argv,\n\t\t\t      const compat_uptr_t __user *__envp,\n\t\t\t      int flags)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}"
  },
  {
    "function_name": "compat_do_execve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1899-1912",
    "snippet": "static int compat_do_execve(struct filename *filename,\n\tconst compat_uptr_t __user *__argv,\n\tconst compat_uptr_t __user *__envp)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_execveat_common",
          "args": [
            "AT_FDCWD",
            "filename",
            "argv",
            "envp",
            "0"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "do_execveat_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1862-1868",
          "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int compat_do_execve(struct filename *filename,\n\tconst compat_uptr_t __user *__argv,\n\tconst compat_uptr_t __user *__envp)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}"
  },
  {
    "function_name": "do_execveat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1887-1896",
    "snippet": "int do_execveat(int fd, struct filename *filename,\n\t\tconst char __user *const __user *__argv,\n\t\tconst char __user *const __user *__envp,\n\t\tint flags)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_execveat_common",
          "args": [
            "fd",
            "filename",
            "argv",
            "envp",
            "flags"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "do_execveat_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1862-1868",
          "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint do_execveat(int fd, struct filename *filename,\n\t\tconst char __user *const __user *__argv,\n\t\tconst char __user *const __user *__envp,\n\t\tint flags)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}"
  },
  {
    "function_name": "do_execve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1878-1885",
    "snippet": "int do_execve(struct filename *filename,\n\tconst char __user *const __user *__argv,\n\tconst char __user *const __user *__envp)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_execveat_common",
          "args": [
            "AT_FDCWD",
            "filename",
            "argv",
            "envp",
            "0"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "do_execveat_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1862-1868",
          "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint do_execve(struct filename *filename,\n\tconst char __user *const __user *__argv,\n\tconst char __user *const __user *__envp)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}"
  },
  {
    "function_name": "do_execve_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1870-1876",
    "snippet": "int do_execve_file(struct file *file, void *__argv, void *__envp)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\n\treturn __do_execve_file(AT_FDCWD, NULL, argv, envp, 0, file);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_execve_file",
          "args": [
            "AT_FDCWD",
            "NULL",
            "argv",
            "envp",
            "0",
            "file"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "__do_execve_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1710-1860",
          "snippet": "static int __do_execve_file(int fd, struct filename *filename,\n\t\t\t    struct user_arg_ptr argv,\n\t\t\t    struct user_arg_ptr envp,\n\t\t\t    int flags, struct file *file)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tif (!file)\n\t\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (!filename) {\n\t\tbprm->filename = \"none\";\n\t} else if (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\twould_dump(bprm, bprm->file);\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tmembarrier_execve(current);\n\trseq_execve(current);\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tif (filename)\n\t\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tif (filename)\n\t\tputname(filename);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int __do_execve_file(int fd, struct filename *filename,\n\t\t\t    struct user_arg_ptr argv,\n\t\t\t    struct user_arg_ptr envp,\n\t\t\t    int flags, struct file *file)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tif (!file)\n\t\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (!filename) {\n\t\tbprm->filename = \"none\";\n\t} else if (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\twould_dump(bprm, bprm->file);\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tmembarrier_execve(current);\n\trseq_execve(current);\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tif (filename)\n\t\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tif (filename)\n\t\tputname(filename);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint do_execve_file(struct file *file, void *__argv, void *__envp)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\n\treturn __do_execve_file(AT_FDCWD, NULL, argv, envp, 0, file);\n}"
  },
  {
    "function_name": "do_execveat_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1862-1868",
    "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_execve_file",
          "args": [
            "fd",
            "filename",
            "argv",
            "envp",
            "flags",
            "NULL"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "__do_execve_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1710-1860",
          "snippet": "static int __do_execve_file(int fd, struct filename *filename,\n\t\t\t    struct user_arg_ptr argv,\n\t\t\t    struct user_arg_ptr envp,\n\t\t\t    int flags, struct file *file)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tif (!file)\n\t\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (!filename) {\n\t\tbprm->filename = \"none\";\n\t} else if (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\twould_dump(bprm, bprm->file);\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tmembarrier_execve(current);\n\trseq_execve(current);\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tif (filename)\n\t\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tif (filename)\n\t\tputname(filename);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int __do_execve_file(int fd, struct filename *filename,\n\t\t\t    struct user_arg_ptr argv,\n\t\t\t    struct user_arg_ptr envp,\n\t\t\t    int flags, struct file *file)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tif (!file)\n\t\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (!filename) {\n\t\tbprm->filename = \"none\";\n\t} else if (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\twould_dump(bprm, bprm->file);\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tmembarrier_execve(current);\n\trseq_execve(current);\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tif (filename)\n\t\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tif (filename)\n\t\tputname(filename);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n}"
  },
  {
    "function_name": "__do_execve_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1710-1860",
    "snippet": "static int __do_execve_file(int fd, struct filename *filename,\n\t\t\t    struct user_arg_ptr argv,\n\t\t\t    struct user_arg_ptr envp,\n\t\t\t    int flags, struct file *file)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tif (!file)\n\t\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (!filename) {\n\t\tbprm->filename = \"none\";\n\t} else if (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\twould_dump(bprm, bprm->file);\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tmembarrier_execve(current);\n\trseq_execve(current);\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tif (filename)\n\t\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tif (filename)\n\t\tputname(filename);\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "filename"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "putname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "250-262",
          "snippet": "void putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_files_struct",
          "args": [
            "displaced"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "reset_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "425-435",
          "snippet": "void reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pathbuf"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_bprm",
          "args": [
            "bprm"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "free_bprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1416-1431",
          "snippet": "static void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\t/* If a binfmt changed the interp, free it. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\t/* If a binfmt changed the interp, free it. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "bprm->mm"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_arg_size",
          "args": [
            "bprm",
            "0"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "acct_arg_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "340-342",
          "snippet": "static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "displaced"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "413-423",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_numa_free",
          "args": [
            "current"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_update_integrals",
          "args": [
            "current"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_execve",
          "args": [
            "current"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membarrier_execve",
          "args": [
            "current"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exec_binprm",
          "args": [
            "bprm"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "exec_binprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1685-1705",
          "snippet": "static int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "would_dump",
          "args": [
            "bprm",
            "bprm->file"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "would_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1309-1327",
          "snippet": "void would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_strings",
          "args": [
            "bprm->argc",
            "argv",
            "bprm"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "copy_strings_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "592-606",
          "snippet": "int copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_binprm",
          "args": [
            "bprm"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_binprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1568-1583",
          "snippet": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\tloff_t pos = 0;\n\n\tbprm_fill_uid(bprm);\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->called_set_creds = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\tloff_t pos = 0;\n\n\tbprm_fill_uid(bprm);\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->called_set_creds = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count",
          "args": [
            "envp",
            "MAX_ARG_STRINGS"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "470-494",
          "snippet": "static int count(struct user_arg_ptr argv, int max)\n{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i >= max)\n\t\t\t\treturn -E2BIG;\n\t\t\t++i;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int count(struct user_arg_ptr argv, int max)\n{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i >= max)\n\t\t\t\treturn -E2BIG;\n\t\t\t++i;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bprm_mm_init",
          "args": [
            "bprm"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "bprm_mm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "404-432",
          "snippet": "static int bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\t/* Save current stack limit for all calculations made during exec. */\n\ttask_lock(current->group_leader);\n\tbprm->rlim_stack = current->signal->rlim[RLIMIT_STACK];\n\ttask_unlock(current->group_leader);\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\t/* Save current stack limit for all calculations made during exec. */\n\ttask_lock(current->group_leader);\n\tbprm->rlim_stack = current->signal->rlim[RLIMIT_STACK];\n\ttask_unlock(current->group_leader);\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_on_exec",
          "args": [
            "fd",
            "rcu_dereference_raw(current->files->fdt)"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "783-794",
          "snippet": "void set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "current->files->fdt"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"/dev/fd/%d/%s\"",
            "fd",
            "filename->name"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"/dev/fd/%d\"",
            "fd"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_exec",
          "args": [],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_open_execat",
          "args": [
            "fd",
            "filename",
            "flags"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "do_open_execat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "836-878",
          "snippet": "static struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (path_noexec(&file->f_path))\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (path_noexec(&file->f_path))\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_unsafe_exec",
          "args": [
            "bprm"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "check_unsafe_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1478-1508",
          "snippet": "static void check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\n\tif (p->ptrace)\n\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\n\t/*\n\t * This isn't strictly necessary, but it makes it harder for LSMs to\n\t * mess up.\n\t */\n\tif (task_no_new_privs(current))\n\t\tbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\n\n\tt = p;\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\twhile_each_thread(p, t) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs)\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\telse\n\t\tp->fs->in_exec = 1;\n\tspin_unlock(&p->fs->lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\n\tif (p->ptrace)\n\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\n\t/*\n\t * This isn't strictly necessary, but it makes it harder for LSMs to\n\t * mess up.\n\t */\n\tif (task_no_new_privs(current))\n\t\tbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\n\n\tt = p;\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\twhile_each_thread(p, t) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs)\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\telse\n\t\tp->fs->in_exec = 1;\n\tspin_unlock(&p->fs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_bprm_creds",
          "args": [
            "bprm"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_bprm_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1403-1414",
          "snippet": "int prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bprm)",
            "GFP_KERNEL"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare_files",
          "args": [
            "&displaced"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NPROC"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current_user()->processes"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user",
          "args": [],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filename"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filename"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int __do_execve_file(int fd, struct filename *filename,\n\t\t\t    struct user_arg_ptr argv,\n\t\t\t    struct user_arg_ptr envp,\n\t\t\t    int flags, struct file *file)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tif (!file)\n\t\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (!filename) {\n\t\tbprm->filename = \"none\";\n\t} else if (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_KERNEL, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\twould_dump(bprm, bprm->file);\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tmembarrier_execve(current);\n\trseq_execve(current);\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tif (filename)\n\t\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tif (filename)\n\t\tputname(filename);\n\treturn retval;\n}"
  },
  {
    "function_name": "exec_binprm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1685-1705",
    "snippet": "static int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_exec_connector",
          "args": [
            "current"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_event",
          "args": [
            "PTRACE_EVENT_EXEC",
            "old_vpid"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_process_exec",
          "args": [
            "current",
            "old_pid",
            "bprm"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_bprm",
          "args": [
            "bprm"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_binary_handler",
          "args": [
            "bprm"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "search_binary_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1632-1682",
          "snippet": "int search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(formats);",
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nint search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "current",
            "task_active_pid_ns(current->parent)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current->parent"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "search_binary_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1632-1682",
    "snippet": "int search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(formats);",
      "static DEFINE_RWLOCK(binfmt_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "request_module",
          "args": [
            "\"binfmt-%04x\"",
            "*(ushort *)(bprm->buf + 2)"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable",
          "args": [
            "bprm->buf[3]"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable",
          "args": [
            "bprm->buf[2]"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable",
          "args": [
            "bprm->buf[1]"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable",
          "args": [
            "bprm->buf[0]"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/locking.c",
          "lines": "204-222",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\t/* atomic_dec_and_test implies a barrier */\n\tif (atomic_dec_and_test(&eb->blocking_readers))\n\t\tcond_wake_up_nomb(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\t/* atomic_dec_and_test implies a barrier */\n\tif (atomic_dec_and_test(&eb->blocking_readers))\n\t\tcond_wake_up_nomb(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_sigsegv",
          "args": [
            "SIGSEGV",
            "current"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_binfmt",
          "args": [
            "fmt"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "put_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "103-106",
          "snippet": "static inline void put_binfmt(struct linux_binfmt * fmt)\n{\n\tmodule_put(fmt->module);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void put_binfmt(struct linux_binfmt * fmt)\n{\n\tmodule_put(fmt->module);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/inode.c",
          "lines": "549-1195",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmt->load_binary",
          "args": [
            "bprm"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "fmt->module"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fmt",
            "&formats",
            "lh"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bprm_check",
          "args": [
            "bprm"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MODULES"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nint search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}"
  },
  {
    "function_name": "remove_arg_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1592-1625",
    "snippet": "int remove_arg_zero(struct linux_binprm *bprm)\n{\n\tint ret = 0;\n\tunsigned long offset;\n\tchar *kaddr;\n\tstruct page *page;\n\n\tif (!bprm->argc)\n\t\treturn 0;\n\n\tdo {\n\t\toffset = bprm->p & ~PAGE_MASK;\n\t\tpage = get_arg_page(bprm, bprm->p, 0);\n\t\tif (!page) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\n\t\tfor (; offset < PAGE_SIZE && kaddr[offset];\n\t\t\t\toffset++, bprm->p++)\n\t\t\t;\n\n\t\tkunmap_atomic(kaddr);\n\t\tput_arg_page(page);\n\t} while (offset == PAGE_SIZE);\n\n\tbprm->p++;\n\tbprm->argc--;\n\tret = 0;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_arg_page",
          "args": [
            "page"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "put_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "360-362",
          "snippet": "static void put_arg_page(struct page *page)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void put_arg_page(struct page *page)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_arg_page",
          "args": [
            "bprm",
            "bprm->p",
            "0"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "get_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "344-358",
          "snippet": "static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint remove_arg_zero(struct linux_binprm *bprm)\n{\n\tint ret = 0;\n\tunsigned long offset;\n\tchar *kaddr;\n\tstruct page *page;\n\n\tif (!bprm->argc)\n\t\treturn 0;\n\n\tdo {\n\t\toffset = bprm->p & ~PAGE_MASK;\n\t\tpage = get_arg_page(bprm, bprm->p, 0);\n\t\tif (!page) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\n\t\tfor (; offset < PAGE_SIZE && kaddr[offset];\n\t\t\t\toffset++, bprm->p++)\n\t\t\t;\n\n\t\tkunmap_atomic(kaddr);\n\t\tput_arg_page(page);\n\t} while (offset == PAGE_SIZE);\n\n\tbprm->p++;\n\tbprm->argc--;\n\tret = 0;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "prepare_binprm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1568-1583",
    "snippet": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\tloff_t pos = 0;\n\n\tbprm_fill_uid(bprm);\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->called_set_creds = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "bprm->file",
            "bprm->buf",
            "BINPRM_BUF_SIZE",
            "&pos"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bprm->buf",
            "0",
            "BINPRM_BUF_SIZE"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bprm_set_creds",
          "args": [
            "bprm"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bprm_fill_uid",
          "args": [
            "bprm"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "bprm_fill_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1510-1560",
          "snippet": "static void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\t/*\n\t * Since this can be called multiple times (via prepare_binprm),\n\t * we must clear any previous work done when setting set[ug]id\n\t * bits from any earlier bprm->file uses (for example when run\n\t * first for a setuid script then again for its interpreter).\n\t */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!mnt_may_suid(bprm->file->f_path.mnt))\n\t\treturn;\n\n\tif (task_no_new_privs(current))\n\t\treturn;\n\n\tinode = bprm->file->f_path.dentry->d_inode;\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\n\t/* Be careful if suid/sgid is set */\n\tinode_lock(inode);\n\n\t/* reload atomically mode/uid/gid now that lock held */\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tinode_unlock(inode);\n\n\t/* We ignore suid/sgid if there are no mappings for them in the ns */\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\t/*\n\t * Since this can be called multiple times (via prepare_binprm),\n\t * we must clear any previous work done when setting set[ug]id\n\t * bits from any earlier bprm->file uses (for example when run\n\t * first for a setuid script then again for its interpreter).\n\t */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!mnt_may_suid(bprm->file->f_path.mnt))\n\t\treturn;\n\n\tif (task_no_new_privs(current))\n\t\treturn;\n\n\tinode = bprm->file->f_path.dentry->d_inode;\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\n\t/* Be careful if suid/sgid is set */\n\tinode_lock(inode);\n\n\t/* reload atomically mode/uid/gid now that lock held */\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tinode_unlock(inode);\n\n\t/* We ignore suid/sgid if there are no mappings for them in the ns */\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\tloff_t pos = 0;\n\n\tbprm_fill_uid(bprm);\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->called_set_creds = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n}"
  },
  {
    "function_name": "bprm_fill_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1510-1560",
    "snippet": "static void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\t/*\n\t * Since this can be called multiple times (via prepare_binprm),\n\t * we must clear any previous work done when setting set[ug]id\n\t * bits from any earlier bprm->file uses (for example when run\n\t * first for a setuid script then again for its interpreter).\n\t */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!mnt_may_suid(bprm->file->f_path.mnt))\n\t\treturn;\n\n\tif (task_no_new_privs(current))\n\t\treturn;\n\n\tinode = bprm->file->f_path.dentry->d_inode;\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\n\t/* Be careful if suid/sgid is set */\n\tinode_lock(inode);\n\n\t/* reload atomically mode/uid/gid now that lock held */\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tinode_unlock(inode);\n\n\t/* We ignore suid/sgid if there are no mappings for them in the ns */\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgid_has_mapping",
          "args": [
            "bprm->cred->user_ns",
            "gid"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "bprm->cred->user_ns",
            "uid"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "inode->i_mode"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "current"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_may_suid",
          "args": [
            "bprm->file->f_path.mnt"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_may_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "3395-3406",
          "snippet": "bool mnt_may_suid(struct vfsmount *mnt)\n{\n\t/*\n\t * Foreign mounts (accessed via fchdir or through /proc\n\t * symlinks) are always treated as if they are nosuid.  This\n\t * prevents namespaces from trusting potentially unsafe\n\t * suid/sgid bits, file caps, or security labels that originate\n\t * in other namespaces.\n\t */\n\treturn !(mnt->mnt_flags & MNT_NOSUID) && check_mnt(real_mount(mnt)) &&\n\t       current_in_userns(mnt->mnt_sb->s_user_ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nbool mnt_may_suid(struct vfsmount *mnt)\n{\n\t/*\n\t * Foreign mounts (accessed via fchdir or through /proc\n\t * symlinks) are always treated as if they are nosuid.  This\n\t * prevents namespaces from trusting potentially unsafe\n\t * suid/sgid bits, file caps, or security labels that originate\n\t * in other namespaces.\n\t */\n\treturn !(mnt->mnt_flags & MNT_NOSUID) && check_mnt(real_mount(mnt)) &&\n\t       current_in_userns(mnt->mnt_sb->s_user_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_egid",
          "args": [],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\t/*\n\t * Since this can be called multiple times (via prepare_binprm),\n\t * we must clear any previous work done when setting set[ug]id\n\t * bits from any earlier bprm->file uses (for example when run\n\t * first for a setuid script then again for its interpreter).\n\t */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!mnt_may_suid(bprm->file->f_path.mnt))\n\t\treturn;\n\n\tif (task_no_new_privs(current))\n\t\treturn;\n\n\tinode = bprm->file->f_path.dentry->d_inode;\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\n\t/* Be careful if suid/sgid is set */\n\tinode_lock(inode);\n\n\t/* reload atomically mode/uid/gid now that lock held */\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tinode_unlock(inode);\n\n\t/* We ignore suid/sgid if there are no mappings for them in the ns */\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}"
  },
  {
    "function_name": "check_unsafe_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1478-1508",
    "snippet": "static void check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\n\tif (p->ptrace)\n\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\n\t/*\n\t * This isn't strictly necessary, but it makes it harder for LSMs to\n\t * mess up.\n\t */\n\tif (task_no_new_privs(current))\n\t\tbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\n\n\tt = p;\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\twhile_each_thread(p, t) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs)\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\telse\n\t\tp->fs->in_exec = 1;\n\tspin_unlock(&p->fs->lock);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&p->fs->lock"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&p->fs->lock"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "current"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\n\tif (p->ptrace)\n\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\n\t/*\n\t * This isn't strictly necessary, but it makes it harder for LSMs to\n\t * mess up.\n\t */\n\tif (task_no_new_privs(current))\n\t\tbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\n\n\tt = p;\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\twhile_each_thread(p, t) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs)\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\telse\n\t\tp->fs->in_exec = 1;\n\tspin_unlock(&p->fs->lock);\n}"
  },
  {
    "function_name": "install_exec_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1448-1470",
    "snippet": "void install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bprm_committed_creds",
          "args": [
            "bprm"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_exit_task",
          "args": [
            "current"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dumpable",
          "args": [
            "current->mm"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "bprm->cred"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bprm_committing_creds",
          "args": [
            "bprm"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}"
  },
  {
    "function_name": "bprm_change_interp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1433-1442",
    "snippet": "int bprm_change_interp(const char *interp, struct linux_binprm *bprm)\n{\n\t/* If a binfmt changed the interp, free it first. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "interp",
            "GFP_KERNEL"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bprm->interp"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint bprm_change_interp(const char *interp, struct linux_binprm *bprm)\n{\n\t/* If a binfmt changed the interp, free it first. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "free_bprm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1416-1431",
    "snippet": "static void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\t/* If a binfmt changed the interp, free it. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bprm"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "bprm->file"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "bprm->file"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "bprm->cred"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_arg_pages",
          "args": [
            "bprm"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "free_arg_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "372-378",
          "snippet": "static void free_arg_pages(struct linux_binprm *bprm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ARG_PAGES; i++)\n\t\tfree_arg_page(bprm, i);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_pages(struct linux_binprm *bprm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ARG_PAGES; i++)\n\t\tfree_arg_page(bprm, i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\t/* If a binfmt changed the interp, free it. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}"
  },
  {
    "function_name": "prepare_bprm_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1403-1414",
    "snippet": "int prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bprm->cred"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_exec_creds",
          "args": [],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "finalize_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1388-1394",
    "snippet": "void finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current->group_leader"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current->group_leader"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}"
  },
  {
    "function_name": "setup_new_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1330-1384",
    "snippet": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int suid_dumpable = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_signal_handlers",
          "args": [
            "current",
            "0"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_task_comm",
          "args": [
            "current",
            "kbasename(bprm->filename)",
            "true"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_comm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1239-1246",
          "snippet": "void __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbasename",
          "args": [
            "bprm->filename"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_exec",
          "args": [],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_setup_new_exec",
          "args": [],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dumpable",
          "args": [
            "current->mm",
            "SUID_DUMP_USER"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "set_dumpable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1947-1958",
          "snippet": "void set_dumpable(struct mm_struct *mm, int value)\n{\n\tunsigned long old, new;\n\n\tif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\n\t\treturn;\n\n\tdo {\n\t\told = READ_ONCE(mm->flags);\n\t\tnew = (old & ~MMF_DUMPABLE_MASK) | value;\n\t} while (cmpxchg(&mm->flags, old, new) != old);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_dumpable(struct mm_struct *mm, int value)\n{\n\tunsigned long old, new;\n\n\tif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\n\t\treturn;\n\n\tdo {\n\t\told = READ_ONCE(mm->flags);\n\t\tnew = (old & ~MMF_DUMPABLE_MASK) | value;\n\t} while (cmpxchg(&mm->flags, old, new) != old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "current_egid()",
            "current_gid()"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_egid",
          "args": [],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_euid()",
            "current_uid()"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_pick_mmap_layout",
          "args": [
            "current->mm",
            "&bprm->rlim_stack"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint suid_dumpable = 0;\n\nvoid setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}"
  },
  {
    "function_name": "would_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1309-1327",
    "snippet": "void would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "old"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "user_ns"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "privileged_wrt_inode_uidgid",
          "args": [
            "user_ns",
            "inode"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_READ"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "427-460",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "flush_old_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1254-1306",
    "snippet": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_close_on_exec",
          "args": [
            "current->files"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "do_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "643-677",
          "snippet": "void do_close_on_exec(struct files_struct *files)\n{\n\tunsigned i;\n\tstruct fdtable *fdt;\n\n\t/* exec unshares first */\n\tspin_lock(&files->file_lock);\n\tfor (i = 0; ; i++) {\n\t\tunsigned long set;\n\t\tunsigned fd = i * BITS_PER_LONG;\n\t\tfdt = files_fdtable(files);\n\t\tif (fd >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[i];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[i] = 0;\n\t\tfor ( ; set ; fd++, set >>= 1) {\n\t\t\tstruct file *file;\n\t\t\tif (!(set & 1))\n\t\t\t\tcontinue;\n\t\t\tfile = fdt->fd[fd];\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t\t__put_unused_fd(files, fd);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\n\t}\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid do_close_on_exec(struct files_struct *files)\n{\n\tunsigned i;\n\tstruct fdtable *fdt;\n\n\t/* exec unshares first */\n\tspin_lock(&files->file_lock);\n\tfor (i = 0; ; i++) {\n\t\tunsigned long set;\n\t\tunsigned fd = i * BITS_PER_LONG;\n\t\tfdt = files_fdtable(files);\n\t\tif (fd >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[i];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[i] = 0;\n\t\tfor ( ; set ; fd++, set >>= 1) {\n\t\t\tstruct file *file;\n\t\t\tif (!(set & 1))\n\t\t\t\tcontinue;\n\t\t\tfile = fdt->fd[fd];\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t\t__put_unused_fd(files, fd);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\n\t}\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_thread",
          "args": [],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "USER_DS"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exec_mmap",
          "args": [
            "bprm->mm"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "exec_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1007-1049",
          "snippet": "static int exec_mmap(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *old_mm, *active_mm;\n\n\t/* Notify parent that we're no longer interested in the old VM */\n\ttsk = current;\n\told_mm = current->mm;\n\tmm_release(tsk, old_mm);\n\n\tif (old_mm) {\n\t\tsync_mm_rss(old_mm);\n\t\t/*\n\t\t * Make sure that if there is a core dump in progress\n\t\t * for the old mm, we get out and die instead of going\n\t\t * through with the exec.  We must hold mmap_sem around\n\t\t * checking core_state and changing tsk->mm.\n\t\t */\n\t\tdown_read(&old_mm->mmap_sem);\n\t\tif (unlikely(old_mm->core_state)) {\n\t\t\tup_read(&old_mm->mmap_sem);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\ttask_lock(tsk);\n\tactive_mm = tsk->active_mm;\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tactivate_mm(active_mm, mm);\n\ttsk->mm->vmacache_seqnum = 0;\n\tvmacache_flush(tsk);\n\ttask_unlock(tsk);\n\tif (old_mm) {\n\t\tup_read(&old_mm->mmap_sem);\n\t\tBUG_ON(active_mm != old_mm);\n\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\n\t\tmm_update_next_owner(old_mm);\n\t\tmmput(old_mm);\n\t\treturn 0;\n\t}\n\tmmdrop(active_mm);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int exec_mmap(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *old_mm, *active_mm;\n\n\t/* Notify parent that we're no longer interested in the old VM */\n\ttsk = current;\n\told_mm = current->mm;\n\tmm_release(tsk, old_mm);\n\n\tif (old_mm) {\n\t\tsync_mm_rss(old_mm);\n\t\t/*\n\t\t * Make sure that if there is a core dump in progress\n\t\t * for the old mm, we get out and die instead of going\n\t\t * through with the exec.  We must hold mmap_sem around\n\t\t * checking core_state and changing tsk->mm.\n\t\t */\n\t\tdown_read(&old_mm->mmap_sem);\n\t\tif (unlikely(old_mm->core_state)) {\n\t\t\tup_read(&old_mm->mmap_sem);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\ttask_lock(tsk);\n\tactive_mm = tsk->active_mm;\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tactivate_mm(active_mm, mm);\n\ttsk->mm->vmacache_seqnum = 0;\n\tvmacache_flush(tsk);\n\ttask_unlock(tsk);\n\tif (old_mm) {\n\t\tup_read(&old_mm->mmap_sem);\n\t\tBUG_ON(active_mm != old_mm);\n\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\n\t\tmm_update_next_owner(old_mm);\n\t\tmmput(old_mm);\n\t\treturn 0;\n\t}\n\tmmdrop(active_mm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acct_arg_size",
          "args": [
            "bprm",
            "0"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "acct_arg_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "340-342",
          "snippet": "static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_mm_exe_file",
          "args": [
            "bprm->mm",
            "bprm->file"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_thread",
          "args": [
            "current"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "de_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1057-1223",
          "snippet": "static int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tfreezable_schedule();\n\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tfor (;;) {\n\t\t\tcgroup_threadgroup_change_begin(tsk);\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\t/*\n\t\t\t * Do this under tasklist_lock to ensure that\n\t\t\t * exit_notify() can't miss ->group_exit_task\n\t\t\t */\n\t\t\tsig->notify_count = -1;\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tcgroup_threadgroup_change_end(tsk);\n\t\t\tfreezable_schedule();\n\t\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\t\ttsk->real_start_time = leader->real_start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\ttsk->pid = leader->pid;\n\t\tchange_pid(tsk, PIDTYPE_PID, task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_TGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tcgroup_threadgroup_change_end(tsk);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n#ifdef CONFIG_POSIX_TIMERS\n\texit_itimers(sig);\n\tflush_itimer_signals();\n#endif\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t/* protects against exit_notify() and __exit_signal() */\n\tread_lock(&tasklist_lock);\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tfreezable_schedule();\n\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tfor (;;) {\n\t\t\tcgroup_threadgroup_change_begin(tsk);\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\t/*\n\t\t\t * Do this under tasklist_lock to ensure that\n\t\t\t * exit_notify() can't miss ->group_exit_task\n\t\t\t */\n\t\t\tsig->notify_count = -1;\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tcgroup_threadgroup_change_end(tsk);\n\t\t\tfreezable_schedule();\n\t\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\t\ttsk->real_start_time = leader->real_start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\ttsk->pid = leader->pid;\n\t\tchange_pid(tsk, PIDTYPE_PID, task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_TGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tcgroup_threadgroup_change_end(tsk);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n#ifdef CONFIG_POSIX_TIMERS\n\texit_itimers(sig);\n\tflush_itimer_signals();\n#endif\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t/* protects against exit_notify() and __exit_signal() */\n\tread_lock(&tasklist_lock);\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "__set_task_comm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1239-1246",
    "snippet": "void __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_comm",
          "args": [
            "tsk",
            "exec"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "tsk->comm",
            "buf",
            "sizeof(tsk->comm)"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_task_rename",
          "args": [
            "tsk",
            "buf"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}"
  },
  {
    "function_name": "__get_task_comm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1225-1231",
    "snippet": "char *__get_task_comm(char *buf, size_t buf_size, struct task_struct *tsk)\n{\n\ttask_lock(tsk);\n\tstrncpy(buf, tsk->comm, buf_size);\n\ttask_unlock(tsk);\n\treturn buf;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf",
            "tsk->comm",
            "buf_size"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nchar *__get_task_comm(char *buf, size_t buf_size, struct task_struct *tsk)\n{\n\ttask_lock(tsk);\n\tstrncpy(buf, tsk->comm, buf_size);\n\ttask_unlock(tsk);\n\treturn buf;\n}"
  },
  {
    "function_name": "de_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1057-1223",
    "snippet": "static int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tfreezable_schedule();\n\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tfor (;;) {\n\t\t\tcgroup_threadgroup_change_begin(tsk);\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\t/*\n\t\t\t * Do this under tasklist_lock to ensure that\n\t\t\t * exit_notify() can't miss ->group_exit_task\n\t\t\t */\n\t\t\tsig->notify_count = -1;\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tcgroup_threadgroup_change_end(tsk);\n\t\t\tfreezable_schedule();\n\t\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\t\ttsk->real_start_time = leader->real_start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\ttsk->pid = leader->pid;\n\t\tchange_pid(tsk, PIDTYPE_PID, task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_TGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tcgroup_threadgroup_change_end(tsk);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n#ifdef CONFIG_POSIX_TIMERS\n\texit_itimers(sig);\n\tflush_itimer_signals();\n#endif\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t/* protects against exit_notify() and __exit_signal() */\n\tread_lock(&tasklist_lock);\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/locking.c",
          "lines": "204-222",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\t/* atomic_dec_and_test implies a barrier */\n\tif (atomic_dec_and_test(&eb->blocking_readers))\n\t\tcond_wake_up_nomb(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\t/* atomic_dec_and_test implies a barrier */\n\tif (atomic_dec_and_test(&eb->blocking_readers))\n\t\tcond_wake_up_nomb(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/inode.c",
          "lines": "549-1195",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!thread_group_leader(tsk)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cleanup_sighand",
          "args": [
            "oldsighand"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oldsighand->siglock"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tsk->sighand",
            "newsighand"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oldsighand->siglock"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newsighand->action",
            "oldsighand->action",
            "sizeof(newsighand->action)"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&newsighand->count",
            "1"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "sighand_cachep",
            "GFP_KERNEL"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&oldsighand->count"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_itimer_signals",
          "args": [],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_itimers",
          "args": [
            "sig"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_task",
          "args": [
            "leader"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "release_task_mempolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc/task_mmu.c",
          "lines": "121-123",
          "snippet": "static void release_task_mempolicy(struct proc_maps_private *priv)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <asm/elf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <asm/elf.h>\n#include <linux/pkeys.h>\n#include <linux/uaccess.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/sched/mm.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void release_task_mempolicy(struct proc_maps_private *priv)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_end",
          "args": [
            "tsk"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_up_parent",
          "args": [
            "leader",
            "leader->parent"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "leader->ptrace"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "leader->exit_state != EXIT_ZOMBIE"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&leader->sibling",
            "&tsk->sibling"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_rcu",
          "args": [
            "&leader->tasks",
            "&tsk->tasks"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transfer_pid",
          "args": [
            "leader",
            "tsk",
            "PIDTYPE_SID"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transfer_pid",
          "args": [
            "leader",
            "tsk",
            "PIDTYPE_PGID"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transfer_pid",
          "args": [
            "leader",
            "tsk",
            "PIDTYPE_TGID"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_pid",
          "args": [
            "tsk",
            "PIDTYPE_PID",
            "task_pid(leader)"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "leader"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "has_group_leader_pid(tsk)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_group_leader_pid",
          "args": [
            "tsk"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!same_thread_group(leader, tsk)"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "leader",
            "tsk"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__fatal_signal_pending(tsk)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "tsk"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_end",
          "args": [
            "tsk"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_KILLABLE"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "leader->exit_state"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_begin",
          "args": [
            "tsk"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "lock"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "lock"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__fatal_signal_pending(tsk)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "tsk"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "lock"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_KILLABLE"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_other_threads",
          "args": [
            "tsk"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "lock"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_group_exit",
          "args": [
            "sig"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "lock"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tfreezable_schedule();\n\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tfor (;;) {\n\t\t\tcgroup_threadgroup_change_begin(tsk);\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\t/*\n\t\t\t * Do this under tasklist_lock to ensure that\n\t\t\t * exit_notify() can't miss ->group_exit_task\n\t\t\t */\n\t\t\tsig->notify_count = -1;\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tcgroup_threadgroup_change_end(tsk);\n\t\t\tfreezable_schedule();\n\t\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\t\ttsk->real_start_time = leader->real_start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\ttsk->pid = leader->pid;\n\t\tchange_pid(tsk, PIDTYPE_PID, task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_TGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tcgroup_threadgroup_change_end(tsk);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n#ifdef CONFIG_POSIX_TIMERS\n\texit_itimers(sig);\n\tflush_itimer_signals();\n#endif\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t/* protects against exit_notify() and __exit_signal() */\n\tread_lock(&tasklist_lock);\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "exec_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1007-1049",
    "snippet": "static int exec_mmap(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *old_mm, *active_mm;\n\n\t/* Notify parent that we're no longer interested in the old VM */\n\ttsk = current;\n\told_mm = current->mm;\n\tmm_release(tsk, old_mm);\n\n\tif (old_mm) {\n\t\tsync_mm_rss(old_mm);\n\t\t/*\n\t\t * Make sure that if there is a core dump in progress\n\t\t * for the old mm, we get out and die instead of going\n\t\t * through with the exec.  We must hold mmap_sem around\n\t\t * checking core_state and changing tsk->mm.\n\t\t */\n\t\tdown_read(&old_mm->mmap_sem);\n\t\tif (unlikely(old_mm->core_state)) {\n\t\t\tup_read(&old_mm->mmap_sem);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\ttask_lock(tsk);\n\tactive_mm = tsk->active_mm;\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tactivate_mm(active_mm, mm);\n\ttsk->mm->vmacache_seqnum = 0;\n\tvmacache_flush(tsk);\n\ttask_unlock(tsk);\n\tif (old_mm) {\n\t\tup_read(&old_mm->mmap_sem);\n\t\tBUG_ON(active_mm != old_mm);\n\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\n\t\tmm_update_next_owner(old_mm);\n\t\tmmput(old_mm);\n\t\treturn 0;\n\t}\n\tmmdrop(active_mm);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "active_mm"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "old_mm"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_update_next_owner",
          "args": [
            "old_mm"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setmax_mm_hiwater_rss",
          "args": [
            "&tsk->signal->maxrss",
            "old_mm"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "active_mm != old_mm"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&old_mm->mmap_sem"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmacache_flush",
          "args": [
            "tsk"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "activate_mm",
          "args": [
            "active_mm",
            "mm"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&old_mm->mmap_sem"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "old_mm->core_state"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&old_mm->mmap_sem"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "old_mm"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_release",
          "args": [
            "tsk",
            "old_mm"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int exec_mmap(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *old_mm, *active_mm;\n\n\t/* Notify parent that we're no longer interested in the old VM */\n\ttsk = current;\n\told_mm = current->mm;\n\tmm_release(tsk, old_mm);\n\n\tif (old_mm) {\n\t\tsync_mm_rss(old_mm);\n\t\t/*\n\t\t * Make sure that if there is a core dump in progress\n\t\t * for the old mm, we get out and die instead of going\n\t\t * through with the exec.  We must hold mmap_sem around\n\t\t * checking core_state and changing tsk->mm.\n\t\t */\n\t\tdown_read(&old_mm->mmap_sem);\n\t\tif (unlikely(old_mm->core_state)) {\n\t\t\tup_read(&old_mm->mmap_sem);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\ttask_lock(tsk);\n\tactive_mm = tsk->active_mm;\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tactivate_mm(active_mm, mm);\n\ttsk->mm->vmacache_seqnum = 0;\n\tvmacache_flush(tsk);\n\ttask_unlock(tsk);\n\tif (old_mm) {\n\t\tup_read(&old_mm->mmap_sem);\n\t\tBUG_ON(active_mm != old_mm);\n\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\n\t\tmm_update_next_owner(old_mm);\n\t\tmmput(old_mm);\n\t\treturn 0;\n\t}\n\tmmdrop(active_mm);\n\treturn 0;\n}"
  },
  {
    "function_name": "read_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "998-1004",
    "snippet": "ssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "addr",
            "addr + len"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_read",
          "args": [
            "file",
            "(void __user *)addr",
            "len",
            "&pos"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "437-461",
          "snippet": "ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}"
  },
  {
    "function_name": "kernel_read_file_from_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "982-995",
    "snippet": "int kernel_read_file_from_fd(int fd, void **buf, loff_t *size, loff_t max_size,\n\t\t\t     enum kernel_read_file_id id)\n{\n\tstruct fd f = fdget(fd);\n\tint ret = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\tret = kernel_read_file(f.file, buf, size, max_size, id);\nout:\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read_file",
          "args": [
            "f.file",
            "buf",
            "size",
            "max_size",
            "id"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_read_file_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "982-995",
          "snippet": "int kernel_read_file_from_fd(int fd, void **buf, loff_t *size, loff_t max_size,\n\t\t\t     enum kernel_read_file_id id)\n{\n\tstruct fd f = fdget(fd);\n\tint ret = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\tret = kernel_read_file(f.file, buf, size, max_size, id);\nout:\n\tfdput(f);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint kernel_read_file_from_fd(int fd, void **buf, loff_t *size, loff_t max_size,\n\t\t\t     enum kernel_read_file_id id)\n{\n\tstruct fd f = fdget(fd);\n\tint ret = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\tret = kernel_read_file(f.file, buf, size, max_size, id);\nout:\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernel_read_file_from_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "963-979",
    "snippet": "int kernel_read_file_from_path(const char *path, void **buf, loff_t *size,\n\t\t\t       loff_t max_size, enum kernel_read_file_id id)\n{\n\tstruct file *file;\n\tint ret;\n\n\tif (!path || !*path)\n\t\treturn -EINVAL;\n\n\tfile = filp_open(path, O_RDONLY, 0);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tret = kernel_read_file(file, buf, size, max_size, id);\n\tfput(file);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_read_file",
          "args": [
            "file",
            "buf",
            "size",
            "max_size",
            "id"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_read_file_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "982-995",
          "snippet": "int kernel_read_file_from_fd(int fd, void **buf, loff_t *size, loff_t max_size,\n\t\t\t     enum kernel_read_file_id id)\n{\n\tstruct fd f = fdget(fd);\n\tint ret = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\tret = kernel_read_file(f.file, buf, size, max_size, id);\nout:\n\tfdput(f);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint kernel_read_file_from_fd(int fd, void **buf, loff_t *size, loff_t max_size,\n\t\t\t     enum kernel_read_file_id id)\n{\n\tstruct fd f = fdget(fd);\n\tint ret = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\tret = kernel_read_file(f.file, buf, size, max_size, id);\nout:\n\tfdput(f);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_open",
          "args": [
            "path",
            "O_RDONLY",
            "0"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1024-1034",
          "snippet": "struct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint kernel_read_file_from_path(const char *path, void **buf, loff_t *size,\n\t\t\t       loff_t max_size, enum kernel_read_file_id id)\n{\n\tstruct file *file;\n\tint ret;\n\n\tif (!path || !*path)\n\t\treturn -EINVAL;\n\n\tfile = filp_open(path, O_RDONLY, 0);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tret = kernel_read_file(file, buf, size, max_size, id);\n\tfput(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernel_read_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "893-960",
    "snippet": "int kernel_read_file(struct file *file, void **buf, loff_t *size,\n\t\t     loff_t max_size, enum kernel_read_file_id id)\n{\n\tloff_t i_size, pos;\n\tssize_t bytes = 0;\n\tint ret;\n\n\tif (!S_ISREG(file_inode(file)->i_mode) || max_size < 0)\n\t\treturn -EINVAL;\n\n\tret = deny_write_access(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = security_kernel_read_file(file, id);\n\tif (ret)\n\t\tgoto out;\n\n\ti_size = i_size_read(file_inode(file));\n\tif (i_size <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (i_size > SIZE_MAX || (max_size > 0 && i_size > max_size)) {\n\t\tret = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tif (id != READING_FIRMWARE_PREALLOC_BUFFER)\n\t\t*buf = vmalloc(i_size);\n\tif (!*buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpos = 0;\n\twhile (pos < i_size) {\n\t\tbytes = kernel_read(file, *buf + pos, i_size - pos, &pos);\n\t\tif (bytes < 0) {\n\t\t\tret = bytes;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (bytes == 0)\n\t\t\tbreak;\n\t}\n\n\tif (pos != i_size) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\tret = security_kernel_post_read_file(file, *buf, i_size, id);\n\tif (!ret)\n\t\t*size = pos;\n\nout_free:\n\tif (ret < 0) {\n\t\tif (id != READING_FIRMWARE_PREALLOC_BUFFER) {\n\t\t\tvfree(*buf);\n\t\t\t*buf = NULL;\n\t\t}\n\t}\n\nout:\n\tallow_write_access(file);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "file"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "*buf"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_kernel_post_read_file",
          "args": [
            "file",
            "*buf",
            "i_size",
            "id"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "*buf + pos",
            "i_size - pos",
            "&pos"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "i_size"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_blocks_use_vmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/jffs2/nodelist.h",
          "lines": "296-299",
          "snippet": "static inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"os-linux.h\"",
            "#include \"os-ecos.h\"",
            "#include \"summary.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"jffs2_fs_i.h\"",
            "#include \"jffs2_fs_sb.h\"",
            "#include <linux/jffs2.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"os-linux.h\"\n#include \"os-ecos.h\"\n#include \"summary.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"jffs2_fs_i.h\"\n#include \"jffs2_fs_sb.h\"\n#include <linux/jffs2.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file_inode(file)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_kernel_read_file",
          "args": [
            "file",
            "id"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deny_write_access",
          "args": [
            "file"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "file_inode(file)->i_mode"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint kernel_read_file(struct file *file, void **buf, loff_t *size,\n\t\t     loff_t max_size, enum kernel_read_file_id id)\n{\n\tloff_t i_size, pos;\n\tssize_t bytes = 0;\n\tint ret;\n\n\tif (!S_ISREG(file_inode(file)->i_mode) || max_size < 0)\n\t\treturn -EINVAL;\n\n\tret = deny_write_access(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = security_kernel_read_file(file, id);\n\tif (ret)\n\t\tgoto out;\n\n\ti_size = i_size_read(file_inode(file));\n\tif (i_size <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (i_size > SIZE_MAX || (max_size > 0 && i_size > max_size)) {\n\t\tret = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tif (id != READING_FIRMWARE_PREALLOC_BUFFER)\n\t\t*buf = vmalloc(i_size);\n\tif (!*buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpos = 0;\n\twhile (pos < i_size) {\n\t\tbytes = kernel_read(file, *buf + pos, i_size - pos, &pos);\n\t\tif (bytes < 0) {\n\t\t\tret = bytes;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (bytes == 0)\n\t\t\tbreak;\n\t}\n\n\tif (pos != i_size) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\tret = security_kernel_post_read_file(file, *buf, i_size, id);\n\tif (!ret)\n\t\t*size = pos;\n\nout_free:\n\tif (ret < 0) {\n\t\tif (id != READING_FIRMWARE_PREALLOC_BUFFER) {\n\t\t\tvfree(*buf);\n\t\t\t*buf = NULL;\n\t\t}\n\t}\n\nout:\n\tallow_write_access(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "open_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "880-890",
    "snippet": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "filename"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "putname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "250-262",
          "snippet": "void putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_open_execat",
          "args": [
            "AT_FDCWD",
            "filename",
            "0"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "do_open_execat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "836-878",
          "snippet": "static struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (path_noexec(&file->f_path))\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (path_noexec(&file->f_path))\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filename"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "filename"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getname_kernel",
          "args": [
            "name"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "getname_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "214-248",
          "snippet": "struct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}"
  },
  {
    "function_name": "do_open_execat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "836-878",
    "snippet": "static struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (path_noexec(&file->f_path))\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_open",
          "args": [
            "file"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deny_write_access",
          "args": [
            "file"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_noexec",
          "args": [
            "&file->f_path"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "path_noexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "108-112",
          "snippet": "bool path_noexec(const struct path *path)\n{\n\treturn (path->mnt->mnt_flags & MNT_NOEXEC) ||\n\t       (path->mnt->mnt_sb->s_iflags & SB_I_NOEXEC);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nbool path_noexec(const struct path *path)\n{\n\treturn (path->mnt->mnt_flags & MNT_NOEXEC) ||\n\t       (path->mnt->mnt_sb->s_iflags & SB_I_NOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "file_inode(file)->i_mode"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_filp_open",
          "args": [
            "fd",
            "name",
            "&open_exec_flags"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "do_filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "3556-3571",
          "snippet": "struct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (path_noexec(&file->f_path))\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "transfer_args_to_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "807-831",
    "snippet": "int transfer_args_to_stack(struct linux_binprm *bprm,\n\t\t\t   unsigned long *sp_location)\n{\n\tunsigned long index, stop, sp;\n\tint ret = 0;\n\n\tstop = bprm->p >> PAGE_SHIFT;\n\tsp = *sp_location;\n\n\tfor (index = MAX_ARG_PAGES - 1; index >= stop; index--) {\n\t\tunsigned int offset = index == stop ? bprm->p & ~PAGE_MASK : 0;\n\t\tchar *src = kmap(bprm->page[index]) + offset;\n\t\tsp -= PAGE_SIZE - offset;\n\t\tif (copy_to_user((void *) sp, src, PAGE_SIZE - offset) != 0)\n\t\t\tret = -EFAULT;\n\t\tkunmap(bprm->page[index]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t*sp_location = sp;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "bprm->page[index]"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void *) sp",
            "src",
            "PAGE_SIZE - offset"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "bprm->page[index]"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint transfer_args_to_stack(struct linux_binprm *bprm,\n\t\t\t   unsigned long *sp_location)\n{\n\tunsigned long index, stop, sp;\n\tint ret = 0;\n\n\tstop = bprm->p >> PAGE_SHIFT;\n\tsp = *sp_location;\n\n\tfor (index = MAX_ARG_PAGES - 1; index >= stop; index--) {\n\t\tunsigned int offset = index == stop ? bprm->p & ~PAGE_MASK : 0;\n\t\tchar *src = kmap(bprm->page[index]) + offset;\n\t\tsp -= PAGE_SIZE - offset;\n\t\tif (copy_to_user((void *) sp, src, PAGE_SIZE - offset) != 0)\n\t\t\tret = -EFAULT;\n\t\tkunmap(bprm->page[index]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t*sp_location = sp;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_arg_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "688-798",
    "snippet": "int setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_stack",
          "args": [
            "vma",
            "stack_base"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shift_arg_pages",
          "args": [
            "vma",
            "stack_shift"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "shift_arg_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "623-682",
          "snippet": "static int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t/*\n\t * ensure there are no vmas between where we want to go\n\t * and where we are\n\t */\n\tif (vma != find_vma(mm, new_start))\n\t\treturn -EFAULT;\n\n\t/*\n\t * cover the whole range: [new_start, old_end)\n\t */\n\tif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * move the page tables downwards, on failure we rely on\n\t * process cleanup to remove whatever mess we made.\n\t */\n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length, false))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, old_start, old_end);\n\tif (new_end > old_start) {\n\t\t/*\n\t\t * when the old and new regions overlap clear from new_end.\n\t\t */\n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t} else {\n\t\t/*\n\t\t * otherwise, clean from old_start; this is done to not touch\n\t\t * the address space in [new_end, old_start) some architectures\n\t\t * have constraints on va-space that make this illegal (IA64) -\n\t\t * for the others its just a little faster.\n\t\t */\n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t}\n\ttlb_finish_mmu(&tlb, old_start, old_end);\n\n\t/*\n\t * Shrink the vma to just the new range.  Always succeeds.\n\t */\n\tvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t/*\n\t * ensure there are no vmas between where we want to go\n\t * and where we are\n\t */\n\tif (vma != find_vma(mm, new_start))\n\t\treturn -EFAULT;\n\n\t/*\n\t * cover the whole range: [new_start, old_end)\n\t */\n\tif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * move the page tables downwards, on failure we rely on\n\t * process cleanup to remove whatever mess we made.\n\t */\n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length, false))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, old_start, old_end);\n\tif (new_end > old_start) {\n\t\t/*\n\t\t * when the old and new regions overlap clear from new_end.\n\t\t */\n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t} else {\n\t\t/*\n\t\t * otherwise, clean from old_start; this is done to not touch\n\t\t * the address space in [new_end, old_start) some architectures\n\t\t * have constraints on va-space that make this illegal (IA64) -\n\t\t * for the others its just a little faster.\n\t\t */\n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t}\n\ttlb_finish_mmu(&tlb, old_start, old_end);\n\n\t/*\n\t * Shrink the vma to just the new range.  Always succeeds.\n\t */\n\tvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "prev != vma"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mprotect_fixup",
          "args": [
            "vma",
            "&prev",
            "vma->vm_start",
            "vma->vm_end",
            "vm_flags"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "executable_stack == EXSTACK_ENABLE_X"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "stack_top < mmap_min_addr"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "stack_top"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_align_stack",
          "args": [
            "stack_top"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "stack_top - stack_base"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "shift_arg_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "623-682",
    "snippet": "static int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t/*\n\t * ensure there are no vmas between where we want to go\n\t * and where we are\n\t */\n\tif (vma != find_vma(mm, new_start))\n\t\treturn -EFAULT;\n\n\t/*\n\t * cover the whole range: [new_start, old_end)\n\t */\n\tif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * move the page tables downwards, on failure we rely on\n\t * process cleanup to remove whatever mess we made.\n\t */\n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length, false))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, old_start, old_end);\n\tif (new_end > old_start) {\n\t\t/*\n\t\t * when the old and new regions overlap clear from new_end.\n\t\t */\n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t} else {\n\t\t/*\n\t\t * otherwise, clean from old_start; this is done to not touch\n\t\t * the address space in [new_end, old_start) some architectures\n\t\t * have constraints on va-space that make this illegal (IA64) -\n\t\t * for the others its just a little faster.\n\t\t */\n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t}\n\ttlb_finish_mmu(&tlb, old_start, old_end);\n\n\t/*\n\t * Shrink the vma to just the new range.  Always succeeds.\n\t */\n\tvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_adjust",
          "args": [
            "vma",
            "new_start",
            "new_end",
            "vma->vm_pgoff",
            "NULL"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_finish_mmu",
          "args": [
            "&tlb",
            "old_start",
            "old_end"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pgd_range",
          "args": [
            "&tlb",
            "old_start",
            "old_end",
            "new_end",
            "vma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pgd_range",
          "args": [
            "&tlb",
            "new_end",
            "old_end",
            "new_end",
            "vma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_gather_mmu",
          "args": [
            "&tlb",
            "mm",
            "old_start",
            "old_end"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_page_tables",
          "args": [
            "vma",
            "old_start",
            "vma",
            "new_start",
            "length",
            "false"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_adjust",
          "args": [
            "vma",
            "new_start",
            "old_end",
            "vma->vm_pgoff",
            "NULL"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "new_start"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_start > new_end"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t/*\n\t * ensure there are no vmas between where we want to go\n\t * and where we are\n\t */\n\tif (vma != find_vma(mm, new_start))\n\t\treturn -EFAULT;\n\n\t/*\n\t * cover the whole range: [new_start, old_end)\n\t */\n\tif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * move the page tables downwards, on failure we rely on\n\t * process cleanup to remove whatever mess we made.\n\t */\n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length, false))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, old_start, old_end);\n\tif (new_end > old_start) {\n\t\t/*\n\t\t * when the old and new regions overlap clear from new_end.\n\t\t */\n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t} else {\n\t\t/*\n\t\t * otherwise, clean from old_start; this is done to not touch\n\t\t * the address space in [new_end, old_start) some architectures\n\t\t * have constraints on va-space that make this illegal (IA64) -\n\t\t * for the others its just a little faster.\n\t\t */\n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t}\n\ttlb_finish_mmu(&tlb, old_start, old_end);\n\n\t/*\n\t * Shrink the vma to just the new range.  Always succeeds.\n\t */\n\tvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_strings_kernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "592-606",
    "snippet": "int copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "oldfs"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_strings",
          "args": [
            "argc",
            "argv",
            "bprm"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "copy_strings_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "592-606",
          "snippet": "int copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}"
  },
  {
    "function_name": "copy_strings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "501-587",
    "snippet": "static int copy_strings(int argc, struct user_arg_ptr argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tstruct page *kmapped_page = NULL;\n\tchar *kaddr = NULL;\n\tunsigned long kpos = 0;\n\tint ret;\n\n\twhile (argc-- > 0) {\n\t\tconst char __user *str;\n\t\tint len;\n\t\tunsigned long pos;\n\n\t\tret = -EFAULT;\n\t\tstr = get_user_arg_ptr(argv, argc);\n\t\tif (IS_ERR(str))\n\t\t\tgoto out;\n\n\t\tlen = strnlen_user(str, MAX_ARG_STRLEN);\n\t\tif (!len)\n\t\t\tgoto out;\n\n\t\tret = -E2BIG;\n\t\tif (!valid_arg_len(bprm, len))\n\t\t\tgoto out;\n\n\t\t/* We're going to work our way backwords. */\n\t\tpos = bprm->p;\n\t\tstr += len;\n\t\tbprm->p -= len;\n\n\t\twhile (len > 0) {\n\t\t\tint offset, bytes_to_copy;\n\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tret = -ERESTARTNOHAND;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\toffset = pos % PAGE_SIZE;\n\t\t\tif (offset == 0)\n\t\t\t\toffset = PAGE_SIZE;\n\n\t\t\tbytes_to_copy = offset;\n\t\t\tif (bytes_to_copy > len)\n\t\t\t\tbytes_to_copy = len;\n\n\t\t\toffset -= bytes_to_copy;\n\t\t\tpos -= bytes_to_copy;\n\t\t\tstr -= bytes_to_copy;\n\t\t\tlen -= bytes_to_copy;\n\n\t\t\tif (!kmapped_page || kpos != (pos & PAGE_MASK)) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = get_arg_page(bprm, pos, 1);\n\t\t\t\tif (!page) {\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (kmapped_page) {\n\t\t\t\t\tflush_kernel_dcache_page(kmapped_page);\n\t\t\t\t\tkunmap(kmapped_page);\n\t\t\t\t\tput_arg_page(kmapped_page);\n\t\t\t\t}\n\t\t\t\tkmapped_page = page;\n\t\t\t\tkaddr = kmap(kmapped_page);\n\t\t\t\tkpos = pos & PAGE_MASK;\n\t\t\t\tflush_arg_page(bprm, kpos, kmapped_page);\n\t\t\t}\n\t\t\tif (copy_from_user(kaddr+offset, str, bytes_to_copy)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nout:\n\tif (kmapped_page) {\n\t\tflush_kernel_dcache_page(kmapped_page);\n\t\tkunmap(kmapped_page);\n\t\tput_arg_page(kmapped_page);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_arg_page",
          "args": [
            "kmapped_page"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "put_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "360-362",
          "snippet": "static void put_arg_page(struct page *page)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void put_arg_page(struct page *page)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "kmapped_page"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_kernel_dcache_page",
          "args": [
            "kmapped_page"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kaddr+offset",
            "str",
            "bytes_to_copy"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_arg_page",
          "args": [
            "bprm",
            "kpos",
            "kmapped_page"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "flush_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "380-383",
          "snippet": "static void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "kmapped_page"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "kmapped_page"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_kernel_dcache_page",
          "args": [
            "kmapped_page"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_arg_page",
          "args": [
            "bprm",
            "pos",
            "1"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "get_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "344-358",
          "snippet": "static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_arg_len",
          "args": [
            "bprm",
            "len"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "valid_arg_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "391-394",
          "snippet": "static bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "str",
            "MAX_ARG_STRLEN"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_arg_ptr",
          "args": [
            "argv",
            "argc"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int copy_strings(int argc, struct user_arg_ptr argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tstruct page *kmapped_page = NULL;\n\tchar *kaddr = NULL;\n\tunsigned long kpos = 0;\n\tint ret;\n\n\twhile (argc-- > 0) {\n\t\tconst char __user *str;\n\t\tint len;\n\t\tunsigned long pos;\n\n\t\tret = -EFAULT;\n\t\tstr = get_user_arg_ptr(argv, argc);\n\t\tif (IS_ERR(str))\n\t\t\tgoto out;\n\n\t\tlen = strnlen_user(str, MAX_ARG_STRLEN);\n\t\tif (!len)\n\t\t\tgoto out;\n\n\t\tret = -E2BIG;\n\t\tif (!valid_arg_len(bprm, len))\n\t\t\tgoto out;\n\n\t\t/* We're going to work our way backwords. */\n\t\tpos = bprm->p;\n\t\tstr += len;\n\t\tbprm->p -= len;\n\n\t\twhile (len > 0) {\n\t\t\tint offset, bytes_to_copy;\n\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tret = -ERESTARTNOHAND;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\toffset = pos % PAGE_SIZE;\n\t\t\tif (offset == 0)\n\t\t\t\toffset = PAGE_SIZE;\n\n\t\t\tbytes_to_copy = offset;\n\t\t\tif (bytes_to_copy > len)\n\t\t\t\tbytes_to_copy = len;\n\n\t\t\toffset -= bytes_to_copy;\n\t\t\tpos -= bytes_to_copy;\n\t\t\tstr -= bytes_to_copy;\n\t\t\tlen -= bytes_to_copy;\n\n\t\t\tif (!kmapped_page || kpos != (pos & PAGE_MASK)) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = get_arg_page(bprm, pos, 1);\n\t\t\t\tif (!page) {\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (kmapped_page) {\n\t\t\t\t\tflush_kernel_dcache_page(kmapped_page);\n\t\t\t\t\tkunmap(kmapped_page);\n\t\t\t\t\tput_arg_page(kmapped_page);\n\t\t\t\t}\n\t\t\t\tkmapped_page = page;\n\t\t\t\tkaddr = kmap(kmapped_page);\n\t\t\t\tkpos = pos & PAGE_MASK;\n\t\t\t\tflush_arg_page(bprm, kpos, kmapped_page);\n\t\t\t}\n\t\t\tif (copy_from_user(kaddr+offset, str, bytes_to_copy)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nout:\n\tif (kmapped_page) {\n\t\tflush_kernel_dcache_page(kmapped_page);\n\t\tkunmap(kmapped_page);\n\t\tput_arg_page(kmapped_page);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "470-494",
    "snippet": "static int count(struct user_arg_ptr argv, int max)\n{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i >= max)\n\t\t\t\treturn -E2BIG;\n\t\t\t++i;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_arg_ptr",
          "args": [
            "argv",
            "i"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int count(struct user_arg_ptr argv, int max)\n{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i >= max)\n\t\t\t\treturn -E2BIG;\n\t\t\t++i;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}"
  },
  {
    "function_name": "get_user_arg_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "446-465",
    "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "native",
            "argv.ptr.native + nr"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "compat"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "argv.is_compat"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
  },
  {
    "function_name": "bprm_mm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "404-432",
    "snippet": "static int bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\t/* Save current stack limit for all calculations made during exec. */\n\ttask_lock(current->group_leader);\n\tbprm->rlim_stack = current->signal->rlim[RLIMIT_STACK];\n\ttask_unlock(current->group_leader);\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bprm_mm_init",
          "args": [
            "bprm"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__bprm_mm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "385-389",
          "snippet": "static int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current->group_leader"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current->group_leader"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_alloc",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\t/* Save current stack limit for all calculations made during exec. */\n\ttask_lock(current->group_leader);\n\tbprm->rlim_stack = current->signal->rlim[RLIMIT_STACK];\n\ttask_unlock(current->group_leader);\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "valid_arg_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "391-394",
    "snippet": "static bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}"
  },
  {
    "function_name": "__bprm_mm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "385-389",
    "snippet": "static int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\n\treturn 0;\n}"
  },
  {
    "function_name": "flush_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "380-383",
    "snippet": "static void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n}"
  },
  {
    "function_name": "free_arg_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "372-378",
    "snippet": "static void free_arg_pages(struct linux_binprm *bprm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ARG_PAGES; i++)\n\t\tfree_arg_page(bprm, i);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_arg_page",
          "args": [
            "bprm",
            "i"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "free_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "364-370",
          "snippet": "static void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_pages(struct linux_binprm *bprm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ARG_PAGES; i++)\n\t\tfree_arg_page(bprm, i);\n}"
  },
  {
    "function_name": "free_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "364-370",
    "snippet": "static void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "bprm->page[i]"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "put_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "360-362",
    "snippet": "static void put_arg_page(struct page *page)\n{\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void put_arg_page(struct page *page)\n{\n}"
  },
  {
    "function_name": "get_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "344-358",
    "snippet": "static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER|__GFP_ZERO"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "87-106",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/sched/signal.h>\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "acct_arg_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "340-342",
    "snippet": "static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}"
  },
  {
    "function_name": "valid_arg_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "333-336",
    "snippet": "static bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= MAX_ARG_STRLEN;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= MAX_ARG_STRLEN;\n}"
  },
  {
    "function_name": "__bprm_mm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "288-331",
    "snippet": "static int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mm_struct *mm = bprm->mm;\n\n\tbprm->vma = vma = vm_area_alloc(mm);\n\tif (!vma)\n\t\treturn -ENOMEM;\n\tvma_set_anonymous(vma);\n\n\tif (down_write_killable(&mm->mmap_sem)) {\n\t\terr = -EINTR;\n\t\tgoto err_free;\n\t}\n\n\t/*\n\t * Place the stack at the largest stack address the architecture\n\t * supports. Later, we'll move this to an appropriate place. We don't\n\t * use STACK_TOP because that can depend on attributes which aren't\n\t * configured yet.\n\t */\n\tBUILD_BUG_ON(VM_STACK_FLAGS & VM_STACK_INCOMPLETE_SETUP);\n\tvma->vm_end = STACK_TOP_MAX;\n\tvma->vm_start = vma->vm_end - PAGE_SIZE;\n\tvma->vm_flags = VM_SOFTDIRTY | VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\terr = insert_vm_struct(mm, vma);\n\tif (err)\n\t\tgoto err;\n\n\tmm->stack_vm = mm->total_vm = 1;\n\tarch_bprm_mm_init(mm, vma);\n\tup_write(&mm->mmap_sem);\n\tbprm->p = vma->vm_end - sizeof(void *);\n\treturn 0;\nerr:\n\tup_write(&mm->mmap_sem);\nerr_free:\n\tbprm->vma = NULL;\n\tvm_area_free(vma);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_area_free",
          "args": [
            "vma"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_bprm_mm_init",
          "args": [
            "mm",
            "vma"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_vm_struct",
          "args": [
            "mm",
            "vma"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_get_page_prot",
          "args": [
            "vma->vm_flags"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "VM_STACK_FLAGS & VM_STACK_INCOMPLETE_SETUP"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_set_anonymous",
          "args": [
            "vma"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_area_alloc",
          "args": [
            "mm"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mm_struct *mm = bprm->mm;\n\n\tbprm->vma = vma = vm_area_alloc(mm);\n\tif (!vma)\n\t\treturn -ENOMEM;\n\tvma_set_anonymous(vma);\n\n\tif (down_write_killable(&mm->mmap_sem)) {\n\t\terr = -EINTR;\n\t\tgoto err_free;\n\t}\n\n\t/*\n\t * Place the stack at the largest stack address the architecture\n\t * supports. Later, we'll move this to an appropriate place. We don't\n\t * use STACK_TOP because that can depend on attributes which aren't\n\t * configured yet.\n\t */\n\tBUILD_BUG_ON(VM_STACK_FLAGS & VM_STACK_INCOMPLETE_SETUP);\n\tvma->vm_end = STACK_TOP_MAX;\n\tvma->vm_start = vma->vm_end - PAGE_SIZE;\n\tvma->vm_flags = VM_SOFTDIRTY | VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\terr = insert_vm_struct(mm, vma);\n\tif (err)\n\t\tgoto err;\n\n\tmm->stack_vm = mm->total_vm = 1;\n\tarch_bprm_mm_init(mm, vma);\n\tup_write(&mm->mmap_sem);\n\tbprm->p = vma->vm_end - sizeof(void *);\n\treturn 0;\nerr:\n\tup_write(&mm->mmap_sem);\nerr_free:\n\tbprm->vma = NULL;\n\tvm_area_free(vma);\n\treturn err;\n}"
  },
  {
    "function_name": "flush_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "282-286",
    "snippet": "static void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n\tflush_cache_page(bprm->vma, pos, page_to_pfn(page));\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "bprm->vma",
            "pos",
            "page_to_pfn(page)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n\tflush_cache_page(bprm->vma, pos, page_to_pfn(page));\n}"
  },
  {
    "function_name": "free_arg_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "278-280",
    "snippet": "static void free_arg_pages(struct linux_binprm *bprm)\n{\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_pages(struct linux_binprm *bprm)\n{\n}"
  },
  {
    "function_name": "put_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "273-276",
    "snippet": "static void put_arg_page(struct page *page)\n{\n\tput_page(page);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void put_arg_page(struct page *page)\n{\n\tput_page(page);\n}"
  },
  {
    "function_name": "get_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "195-271",
    "snippet": "static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\tint ret;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n#ifdef CONFIG_STACK_GROWSUP\n\tif (write) {\n\t\tret = expand_downwards(bprm->vma, pos);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n#endif\n\n\tif (write)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We are doing an exec().  'current' is the process\n\t * doing the exec and bprm->mm is the new process's mm.\n\t */\n\tret = get_user_pages_remote(current, bprm->mm, pos, 1, gup_flags,\n\t\t\t&page, NULL, NULL);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tif (write) {\n\t\tunsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;\n\t\tunsigned long ptr_size, limit;\n\n\t\t/*\n\t\t * Since the stack will hold pointers to the strings, we\n\t\t * must account for them as well.\n\t\t *\n\t\t * The size calculation is the entire vma while each arg page is\n\t\t * built, so each time we get here it's calculating how far it\n\t\t * is currently (rather than each call being just the newly\n\t\t * added size from the arg page).  As a result, we need to\n\t\t * always add the entire size of the pointers, so that on the\n\t\t * last call to get_arg_page() we'll actually have the entire\n\t\t * correct size.\n\t\t */\n\t\tptr_size = (bprm->argc + bprm->envc) * sizeof(void *);\n\t\tif (ptr_size > ULONG_MAX - size)\n\t\t\tgoto fail;\n\t\tsize += ptr_size;\n\n\t\tacct_arg_size(bprm, size / PAGE_SIZE);\n\n\t\t/*\n\t\t * We've historically supported up to 32 pages (ARG_MAX)\n\t\t * of argument strings even with small stacks\n\t\t */\n\t\tif (size <= ARG_MAX)\n\t\t\treturn page;\n\n\t\t/*\n\t\t * Limit to 1/4 of the max stack size or 3/4 of _STK_LIM\n\t\t * (whichever is smaller) for the argv+env strings.\n\t\t * This ensures that:\n\t\t *  - the remaining binfmt code will not run out of stack space,\n\t\t *  - the program will have a reasonable amount of stack left\n\t\t *    to work from.\n\t\t */\n\t\tlimit = _STK_LIM / 4 * 3;\n\t\tlimit = min(limit, bprm->rlim_stack.rlim_cur / 4);\n\t\tif (size > limit)\n\t\t\tgoto fail;\n\t}\n\n\treturn page;\n\nfail:\n\tput_page(page);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "limit",
            "bprm->rlim_stack.rlim_cur / 4"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acct_arg_size",
          "args": [
            "bprm",
            "size / PAGE_SIZE"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "acct_arg_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "340-342",
          "snippet": "static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "current",
            "bprm->mm",
            "pos",
            "1",
            "gup_flags",
            "&page",
            "NULL",
            "NULL"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_downwards",
          "args": [
            "bprm->vma",
            "pos"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\tint ret;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n#ifdef CONFIG_STACK_GROWSUP\n\tif (write) {\n\t\tret = expand_downwards(bprm->vma, pos);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n#endif\n\n\tif (write)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We are doing an exec().  'current' is the process\n\t * doing the exec and bprm->mm is the new process's mm.\n\t */\n\tret = get_user_pages_remote(current, bprm->mm, pos, 1, gup_flags,\n\t\t\t&page, NULL, NULL);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tif (write) {\n\t\tunsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;\n\t\tunsigned long ptr_size, limit;\n\n\t\t/*\n\t\t * Since the stack will hold pointers to the strings, we\n\t\t * must account for them as well.\n\t\t *\n\t\t * The size calculation is the entire vma while each arg page is\n\t\t * built, so each time we get here it's calculating how far it\n\t\t * is currently (rather than each call being just the newly\n\t\t * added size from the arg page).  As a result, we need to\n\t\t * always add the entire size of the pointers, so that on the\n\t\t * last call to get_arg_page() we'll actually have the entire\n\t\t * correct size.\n\t\t */\n\t\tptr_size = (bprm->argc + bprm->envc) * sizeof(void *);\n\t\tif (ptr_size > ULONG_MAX - size)\n\t\t\tgoto fail;\n\t\tsize += ptr_size;\n\n\t\tacct_arg_size(bprm, size / PAGE_SIZE);\n\n\t\t/*\n\t\t * We've historically supported up to 32 pages (ARG_MAX)\n\t\t * of argument strings even with small stacks\n\t\t */\n\t\tif (size <= ARG_MAX)\n\t\t\treturn page;\n\n\t\t/*\n\t\t * Limit to 1/4 of the max stack size or 3/4 of _STK_LIM\n\t\t * (whichever is smaller) for the argv+env strings.\n\t\t * This ensures that:\n\t\t *  - the remaining binfmt code will not run out of stack space,\n\t\t *  - the program will have a reasonable amount of stack left\n\t\t *    to work from.\n\t\t */\n\t\tlimit = _STK_LIM / 4 * 3;\n\t\tlimit = min(limit, bprm->rlim_stack.rlim_cur / 4);\n\t\tif (size > limit)\n\t\t\tgoto fail;\n\t}\n\n\treturn page;\n\nfail:\n\tput_page(page);\n\treturn NULL;\n}"
  },
  {
    "function_name": "acct_arg_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "183-193",
    "snippet": "static void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n\tstruct mm_struct *mm = current->mm;\n\tlong diff = (long)(pages - bprm->vma_pages);\n\n\tif (!mm || !diff)\n\t\treturn;\n\n\tbprm->vma_pages = pages;\n\tadd_mm_counter(mm, MM_ANONPAGES, diff);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES",
            "diff"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n\tstruct mm_struct *mm = current->mm;\n\tlong diff = (long)(pages - bprm->vma_pages);\n\n\tif (!mm || !diff)\n\t\treturn;\n\n\tbprm->vma_pages = pages;\n\tadd_mm_counter(mm, MM_ANONPAGES, diff);\n}"
  },
  {
    "function_name": "path_noexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "108-112",
    "snippet": "bool path_noexec(const struct path *path)\n{\n\treturn (path->mnt->mnt_flags & MNT_NOEXEC) ||\n\t       (path->mnt->mnt_sb->s_iflags & SB_I_NOEXEC);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nbool path_noexec(const struct path *path)\n{\n\treturn (path->mnt->mnt_flags & MNT_NOEXEC) ||\n\t       (path->mnt->mnt_sb->s_iflags & SB_I_NOEXEC);\n}"
  },
  {
    "function_name": "put_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "103-106",
    "snippet": "static inline void put_binfmt(struct linux_binfmt * fmt)\n{\n\tmodule_put(fmt->module);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "fmt->module"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void put_binfmt(struct linux_binfmt * fmt)\n{\n\tmodule_put(fmt->module);\n}"
  },
  {
    "function_name": "unregister_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "94-99",
    "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(binfmt_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/lock.c",
          "lines": "52-68",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&fmt->lh"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/lock.c",
          "lines": "22-33",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
  },
  {
    "function_name": "__register_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "81-90",
    "snippet": "void __register_binfmt(struct linux_binfmt * fmt, int insert)\n{\n\tBUG_ON(!fmt);\n\tif (WARN_ON(!fmt->load_binary))\n\t\treturn;\n\twrite_lock(&binfmt_lock);\n\tinsert ? list_add(&fmt->lh, &formats) :\n\t\t list_add_tail(&fmt->lh, &formats);\n\twrite_unlock(&binfmt_lock);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(formats);",
      "static DEFINE_RWLOCK(binfmt_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/lock.c",
          "lines": "52-68",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fmt->lh",
            "&formats"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&fmt->lh",
            "&formats"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/lock.c",
          "lines": "22-33",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!fmt->load_binary"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!fmt"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid __register_binfmt(struct linux_binfmt * fmt, int insert)\n{\n\tBUG_ON(!fmt);\n\tif (WARN_ON(!fmt->load_binary))\n\t\treturn;\n\twrite_lock(&binfmt_lock);\n\tinsert ? list_add(&fmt->lh, &formats) :\n\t\t list_add_tail(&fmt->lh, &formats);\n\twrite_unlock(&binfmt_lock);\n}"
  },
  {
    "function_name": "uselib",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "121-173",
    "snippet": "SYSCALL_DEFINE1(uselib, const char __user *, library)\n{\n\tstruct linux_binfmt *fmt;\n\tstruct file *file;\n\tstruct filename *tmp = getname(library);\n\tint error = PTR_ERR(tmp);\n\tstatic const struct open_flags uselib_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_READ | MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif (IS_ERR(tmp))\n\t\tgoto out;\n\n\tfile = do_filp_open(AT_FDCWD, tmp, &uselib_flags);\n\tputname(tmp);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\terror = -EACCES;\n\tif (path_noexec(&file->f_path))\n\t\tgoto exit;\n\n\tfsnotify_open(file);\n\n\terror = -ENOEXEC;\n\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!fmt->load_shlib)\n\t\t\tcontinue;\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\terror = fmt->load_shlib(file);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tif (error != -ENOEXEC)\n\t\t\tbreak;\n\t}\n\tread_unlock(&binfmt_lock);\nexit:\n\tfput(file);\nout:\n  \treturn error;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(formats);",
      "static DEFINE_RWLOCK(binfmt_lock);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nSYSCALL_DEFINE1(uselib, const char __user *, library)\n{\n\tstruct linux_binfmt *fmt;\n\tstruct file *file;\n\tstruct filename *tmp = getname(library);\n\tint error = PTR_ERR(tmp);\n\tstatic const struct open_flags uselib_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_READ | MAY_EXEC,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif (IS_ERR(tmp))\n\t\tgoto out;\n\n\tfile = do_filp_open(AT_FDCWD, tmp, &uselib_flags);\n\tputname(tmp);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\terror = -EACCES;\n\tif (path_noexec(&file->f_path))\n\t\tgoto exit;\n\n\tfsnotify_open(file);\n\n\terror = -ENOEXEC;\n\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!fmt->load_shlib)\n\t\t\tcontinue;\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\terror = fmt->load_shlib(file);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tif (error != -ENOEXEC)\n\t\t\tbreak;\n\t}\n\tread_unlock(&binfmt_lock);\nexit:\n\tfput(file);\nout:\n  \treturn error;\n}"
  },
  {
    "function_name": "execve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1960-1966",
    "snippet": "SYSCALL_DEFINE3(execve,\n\t\tconst char __user *, filename,\n\t\tconst char __user *const __user *, argv,\n\t\tconst char __user *const __user *, envp)\n{\n\treturn do_execve(getname(filename), argv, envp);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(execve,\n\t\tconst char __user *, filename,\n\t\tconst char __user *const __user *, argv,\n\t\tconst char __user *const __user *, envp)\n{\n\treturn do_execve(getname(filename), argv, envp);\n}"
  },
  {
    "function_name": "execveat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1968-1979",
    "snippet": "SYSCALL_DEFINE5(execveat,\n\t\tint, fd, const char __user *, filename,\n\t\tconst char __user *const __user *, argv,\n\t\tconst char __user *const __user *, envp,\n\t\tint, flags)\n{\n\tint lookup_flags = (flags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;\n\n\treturn do_execveat(fd,\n\t\t\t   getname_flags(filename, lookup_flags, NULL),\n\t\t\t   argv, envp, flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE5(execveat,\n\t\tint, fd, const char __user *, filename,\n\t\tconst char __user *const __user *, argv,\n\t\tconst char __user *const __user *, envp,\n\t\tint, flags)\n{\n\tint lookup_flags = (flags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;\n\n\treturn do_execveat(fd,\n\t\t\t   getname_flags(filename, lookup_flags, NULL),\n\t\t\t   argv, envp, flags);\n}"
  },
  {
    "function_name": "execve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1982-1987",
    "snippet": "SYSCALL_DEFINE3(execve, const char __user *, filename,\n\tconst compat_uptr_t __user *, argv,\n\tconst compat_uptr_t __user *, envp)\n{\n\treturn compat_do_execve(getname(filename), argv, envp);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(execve, const char __user *, filename,\n\tconst compat_uptr_t __user *, argv,\n\tconst compat_uptr_t __user *, envp)\n{\n\treturn compat_do_execve(getname(filename), argv, envp);\n}"
  },
  {
    "function_name": "execveat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
    "lines": "1989-2000",
    "snippet": "SYSCALL_DEFINE5(execveat, int, fd,\n\t\t       const char __user *, filename,\n\t\t       const compat_uptr_t __user *, argv,\n\t\t       const compat_uptr_t __user *, envp,\n\t\t       int,  flags)\n{\n\tint lookup_flags = (flags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;\n\n\treturn compat_do_execveat(fd,\n\t\t\t\t  getname_flags(filename, lookup_flags, NULL),\n\t\t\t\t  argv, envp, flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/numa_balancing.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE5(execveat, int, fd,\n\t\t       const char __user *, filename,\n\t\t       const compat_uptr_t __user *, argv,\n\t\t       const compat_uptr_t __user *, envp,\n\t\t       int,  flags)\n{\n\tint lookup_flags = (flags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;\n\n\treturn compat_do_execveat(fd,\n\t\t\t\t  getname_flags(filename, lookup_flags, NULL),\n\t\t\t\t  argv, envp, flags);\n}"
  }
]