[
  {
    "function_name": "compat_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "420-464",
    "snippet": "static int compat_filldir(struct dir_context *ctx, const char *name, int namlen,\n\t\tloff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct compat_linux_dirent __user * dirent;\n\tstruct compat_getdents_callback *buf =\n\t\tcontainer_of(ctx, struct compat_getdents_callback, ctx);\n\tcompat_ulong_t d_ino;\n\tint reclen = ALIGN(offsetof(struct compat_linux_dirent, d_name) +\n\t\tnamlen + 2, sizeof(compat_long_t));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(d_ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tif (__put_user(d_type, (char  __user *) dirent + reclen - 1))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_type",
            "(char  __user *) dirent + reclen - 1"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "dirent->d_name + namlen"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "dirent->d_name",
            "name",
            "namlen"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "reclen",
            "&dirent->d_reclen"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_ino",
            "&dirent->d_ino"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "offset",
            "&dirent->d_off"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offsetof(struct compat_linux_dirent, d_name) +\n\t\tnamlen + 2",
            "sizeof(compat_long_t)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structcompat_getdents_callback",
            "ctx"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic int compat_filldir(struct dir_context *ctx, const char *name, int namlen,\n\t\tloff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct compat_linux_dirent __user * dirent;\n\tstruct compat_getdents_callback *buf =\n\t\tcontainer_of(ctx, struct compat_getdents_callback, ctx);\n\tcompat_ulong_t d_ino;\n\tint reclen = ALIGN(offsetof(struct compat_linux_dirent, d_name) +\n\t\tnamlen + 2, sizeof(compat_long_t));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(d_ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tif (__put_user(d_type, (char  __user *) dirent + reclen - 1))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "compat_fillonedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "350-382",
    "snippet": "static int compat_fillonedir(struct dir_context *ctx, const char *name,\n\t\t\t     int namlen, loff_t offset, u64 ino,\n\t\t\t     unsigned int d_type)\n{\n\tstruct compat_readdir_callback *buf =\n\t\tcontainer_of(ctx, struct compat_readdir_callback, ctx);\n\tstruct compat_old_linux_dirent __user *dirent;\n\tcompat_ulong_t d_ino;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->result = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tbuf->result++;\n\tdirent = buf->dirent;\n\tif (!access_ok(VERIFY_WRITE, dirent,\n\t\t\t(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent))\n\t\tgoto efault;\n\tif (\t__put_user(d_ino, &dirent->d_ino) ||\n\t\t__put_user(offset, &dirent->d_offset) ||\n\t\t__put_user(namlen, &dirent->d_namlen) ||\n\t\t__copy_to_user(dirent->d_name, name, namlen) ||\n\t\t__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "dirent->d_name + namlen"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "dirent->d_name",
            "name",
            "namlen"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "namlen",
            "&dirent->d_namlen"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "offset",
            "&dirent->d_offset"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_ino",
            "&dirent->d_ino"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "dirent",
            "(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structcompat_readdir_callback",
            "ctx"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic int compat_fillonedir(struct dir_context *ctx, const char *name,\n\t\t\t     int namlen, loff_t offset, u64 ino,\n\t\t\t     unsigned int d_type)\n{\n\tstruct compat_readdir_callback *buf =\n\t\tcontainer_of(ctx, struct compat_readdir_callback, ctx);\n\tstruct compat_old_linux_dirent __user *dirent;\n\tcompat_ulong_t d_ino;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->result = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tbuf->result++;\n\tdirent = buf->dirent;\n\tif (!access_ok(VERIFY_WRITE, dirent,\n\t\t\t(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent))\n\t\tgoto efault;\n\tif (\t__put_user(d_ino, &dirent->d_ino) ||\n\t\t__put_user(offset, &dirent->d_offset) ||\n\t\t__put_user(namlen, &dirent->d_namlen) ||\n\t\t__copy_to_user(dirent->d_name, name, namlen) ||\n\t\t__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "ksys_getdents64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "295-327",
    "snippet": "int ksys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent,\n\t\t    unsigned int count)\n{\n\tstruct fd f;\n\tstruct linux_dirent64 __user * lastdirent;\n\tstruct getdents_callback64 buf = {\n\t\t.ctx.actor = filldir64,\n\t\t.count = count,\n\t\t.current_dir = dirent\n\t};\n\tint error;\n\n\tif (!access_ok(VERIFY_WRITE, dirent, count))\n\t\treturn -EFAULT;\n\n\tf = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tlastdirent = buf.previous;\n\tif (lastdirent) {\n\t\ttypeof(lastdirent->d_off) d_off = buf.ctx.pos;\n\t\tif (__put_user(d_off, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput_pos(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput_pos",
          "args": [
            "f"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_off",
            "&lastdirent->d_off"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "lastdirent->d_off"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_dir",
          "args": [
            "f.file",
            "&buf.ctx"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
          "lines": "26-64",
          "snippet": "int iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tbool shared = false;\n\tint res = -ENOTDIR;\n\tif (file->f_op->iterate_shared)\n\t\tshared = true;\n\telse if (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tif (shared)\n\t\tres = down_read_killable(&inode->i_rwsem);\n\telse\n\t\tres = down_write_killable(&inode->i_rwsem);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tif (shared)\n\t\t\tres = file->f_op->iterate_shared(file, ctx);\n\t\telse\n\t\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tif (shared)\n\t\tinode_unlock_shared(inode);\n\telse\n\t\tinode_unlock(inode);\nout:\n\treturn res;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/dirent.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tbool shared = false;\n\tint res = -ENOTDIR;\n\tif (file->f_op->iterate_shared)\n\t\tshared = true;\n\telse if (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tif (shared)\n\t\tres = down_read_killable(&inode->i_rwsem);\n\telse\n\t\tres = down_write_killable(&inode->i_rwsem);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tif (shared)\n\t\t\tres = file->f_op->iterate_shared(file, ctx);\n\t\telse\n\t\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tif (shared)\n\t\tinode_unlock_shared(inode);\n\telse\n\t\tinode_unlock(inode);\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget_pos",
          "args": [
            "fd"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "dirent",
            "count"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint ksys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent,\n\t\t    unsigned int count)\n{\n\tstruct fd f;\n\tstruct linux_dirent64 __user * lastdirent;\n\tstruct getdents_callback64 buf = {\n\t\t.ctx.actor = filldir64,\n\t\t.count = count,\n\t\t.current_dir = dirent\n\t};\n\tint error;\n\n\tif (!access_ok(VERIFY_WRITE, dirent, count))\n\t\treturn -EFAULT;\n\n\tf = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tlastdirent = buf.previous;\n\tif (lastdirent) {\n\t\ttypeof(lastdirent->d_off) d_off = buf.ctx.pos;\n\t\tif (__put_user(d_off, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput_pos(f);\n\treturn error;\n}"
  },
  {
    "function_name": "filldir64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "253-293",
    "snippet": "static int filldir64(struct dir_context *ctx, const char *name, int namlen,\n\t\t     loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent64 __user *dirent;\n\tstruct getdents_callback64 *buf =\n\t\tcontainer_of(ctx, struct getdents_callback64, ctx);\n\tint reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + namlen + 1,\n\t\tsizeof(u64));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(0, &dirent->d_off))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (__put_user(d_type, &dirent->d_type))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "dirent->d_name + namlen"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "dirent->d_name",
            "name",
            "namlen"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_type",
            "&dirent->d_type"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "reclen",
            "&dirent->d_reclen"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&dirent->d_off"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ino",
            "&dirent->d_ino"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "offset",
            "&dirent->d_off"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offsetof(struct linux_dirent64, d_name) + namlen + 1",
            "sizeof(u64)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structgetdents_callback64",
            "ctx"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic int filldir64(struct dir_context *ctx, const char *name, int namlen,\n\t\t     loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent64 __user *dirent;\n\tstruct getdents_callback64 *buf =\n\t\tcontainer_of(ctx, struct getdents_callback64, ctx);\n\tint reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + namlen + 1,\n\t\tsizeof(u64));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(0, &dirent->d_off))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (__put_user(d_type, &dirent->d_type))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "166-210",
    "snippet": "static int filldir(struct dir_context *ctx, const char *name, int namlen,\n\t\t   loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent __user * dirent;\n\tstruct getdents_callback *buf =\n\t\tcontainer_of(ctx, struct getdents_callback, ctx);\n\tunsigned long d_ino;\n\tint reclen = ALIGN(offsetof(struct linux_dirent, d_name) + namlen + 2,\n\t\tsizeof(long));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(d_ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tif (__put_user(d_type, (char __user *) dirent + reclen - 1))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_type",
            "(char __user *) dirent + reclen - 1"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "dirent->d_name + namlen"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "dirent->d_name",
            "name",
            "namlen"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "reclen",
            "&dirent->d_reclen"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_ino",
            "&dirent->d_ino"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "offset",
            "&dirent->d_off"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offsetof(struct linux_dirent, d_name) + namlen + 2",
            "sizeof(long)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structgetdents_callback",
            "ctx"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic int filldir(struct dir_context *ctx, const char *name, int namlen,\n\t\t   loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct linux_dirent __user * dirent;\n\tstruct getdents_callback *buf =\n\t\tcontainer_of(ctx, struct getdents_callback, ctx);\n\tunsigned long d_ino;\n\tint reclen = ALIGN(offsetof(struct linux_dirent, d_name) + namlen + 2,\n\t\tsizeof(long));\n\n\tbuf->error = -EINVAL;\t/* only used if we fail.. */\n\tif (reclen > buf->count)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->error = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tdirent = buf->previous;\n\tif (dirent) {\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tif (__put_user(offset, &dirent->d_off))\n\t\t\tgoto efault;\n\t}\n\tdirent = buf->current_dir;\n\tif (__put_user(d_ino, &dirent->d_ino))\n\t\tgoto efault;\n\tif (__put_user(reclen, &dirent->d_reclen))\n\t\tgoto efault;\n\tif (copy_to_user(dirent->d_name, name, namlen))\n\t\tgoto efault;\n\tif (__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\tif (__put_user(d_type, (char __user *) dirent + reclen - 1))\n\t\tgoto efault;\n\tbuf->previous = dirent;\n\tdirent = (void __user *)dirent + reclen;\n\tbuf->current_dir = dirent;\n\tbuf->count -= reclen;\n\treturn 0;\nefault:\n\tbuf->error = -EFAULT;\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "fillonedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "91-122",
    "snippet": "static int fillonedir(struct dir_context *ctx, const char *name, int namlen,\n\t\t      loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_callback *buf =\n\t\tcontainer_of(ctx, struct readdir_callback, ctx);\n\tstruct old_linux_dirent __user * dirent;\n\tunsigned long d_ino;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->result = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tbuf->result++;\n\tdirent = buf->dirent;\n\tif (!access_ok(VERIFY_WRITE, dirent,\n\t\t\t(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent))\n\t\tgoto efault;\n\tif (\t__put_user(d_ino, &dirent->d_ino) ||\n\t\t__put_user(offset, &dirent->d_offset) ||\n\t\t__put_user(namlen, &dirent->d_namlen) ||\n\t\t__copy_to_user(dirent->d_name, name, namlen) ||\n\t\t__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "dirent->d_name + namlen"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "dirent->d_name",
            "name",
            "namlen"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "namlen",
            "&dirent->d_namlen"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "offset",
            "&dirent->d_offset"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "d_ino",
            "&dirent->d_ino"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "dirent",
            "(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structreaddir_callback",
            "ctx"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic int fillonedir(struct dir_context *ctx, const char *name, int namlen,\n\t\t      loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_callback *buf =\n\t\tcontainer_of(ctx, struct readdir_callback, ctx);\n\tstruct old_linux_dirent __user * dirent;\n\tunsigned long d_ino;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\td_ino = ino;\n\tif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\n\t\tbuf->result = -EOVERFLOW;\n\t\treturn -EOVERFLOW;\n\t}\n\tbuf->result++;\n\tdirent = buf->dirent;\n\tif (!access_ok(VERIFY_WRITE, dirent,\n\t\t\t(unsigned long)(dirent->d_name + namlen + 1) -\n\t\t\t\t(unsigned long)dirent))\n\t\tgoto efault;\n\tif (\t__put_user(d_ino, &dirent->d_ino) ||\n\t\t__put_user(offset, &dirent->d_offset) ||\n\t\t__put_user(namlen, &dirent->d_namlen) ||\n\t\t__copy_to_user(dirent->d_name, name, namlen) ||\n\t\t__put_user(0, dirent->d_name + namlen))\n\t\tgoto efault;\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "iterate_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "26-64",
    "snippet": "int iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tbool shared = false;\n\tint res = -ENOTDIR;\n\tif (file->f_op->iterate_shared)\n\t\tshared = true;\n\telse if (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tif (shared)\n\t\tres = down_read_killable(&inode->i_rwsem);\n\telse\n\t\tres = down_write_killable(&inode->i_rwsem);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tif (shared)\n\t\t\tres = file->f_op->iterate_shared(file, ctx);\n\t\telse\n\t\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tif (shared)\n\t\tinode_unlock_shared(inode);\n\telse\n\t\tinode_unlock(inode);\nout:\n\treturn res;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock_shared",
          "args": [
            "inode"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_file_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/file.c",
          "lines": "155-175",
          "snippet": "static void ovl_file_accessed(struct file *file)\n{\n\tstruct inode *inode, *upperinode;\n\n\tif (file->f_flags & O_NOATIME)\n\t\treturn;\n\n\tinode = file_inode(file);\n\tupperinode = ovl_inode_upper(inode);\n\n\tif (!upperinode)\n\t\treturn;\n\n\tif ((!timespec64_equal(&inode->i_mtime, &upperinode->i_mtime) ||\n\t     !timespec64_equal(&inode->i_ctime, &upperinode->i_ctime))) {\n\t\tinode->i_mtime = upperinode->i_mtime;\n\t\tinode->i_ctime = upperinode->i_ctime;\n\t}\n\n\ttouch_atime(&file->f_path);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/uio.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/uio.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic void ovl_file_accessed(struct file *file)\n{\n\tstruct inode *inode, *upperinode;\n\n\tif (file->f_flags & O_NOATIME)\n\t\treturn;\n\n\tinode = file_inode(file);\n\tupperinode = ovl_inode_upper(inode);\n\n\tif (!upperinode)\n\t\treturn;\n\n\tif ((!timespec64_equal(&inode->i_mtime, &upperinode->i_mtime) ||\n\t     !timespec64_equal(&inode->i_ctime, &upperinode->i_ctime))) {\n\t\tinode->i_mtime = upperinode->i_mtime;\n\t\tinode->i_ctime = upperinode->i_ctime;\n\t}\n\n\ttouch_atime(&file->f_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "file"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->iterate",
          "args": [
            "file",
            "ctx"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->iterate_shared",
          "args": [
            "file",
            "ctx"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DEADDIR",
          "args": [
            "inode"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&inode->i_rwsem"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_killable",
          "args": [
            "&inode->i_rwsem"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_file_permission",
          "args": [
            "file",
            "MAY_READ"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tbool shared = false;\n\tint res = -ENOTDIR;\n\tif (file->f_op->iterate_shared)\n\t\tshared = true;\n\telse if (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tif (shared)\n\t\tres = down_read_killable(&inode->i_rwsem);\n\telse\n\t\tres = down_write_killable(&inode->i_rwsem);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tif (shared)\n\t\t\tres = file->f_op->iterate_shared(file, ctx);\n\t\telse\n\t\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tif (shared)\n\t\tinode_unlock_shared(inode);\n\telse\n\t\tinode_unlock(inode);\nout:\n\treturn res;\n}"
  },
  {
    "function_name": "old_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "124-143",
    "snippet": "SYSCALL_DEFINE3(old_readdir, unsigned int, fd,\n\t\tstruct old_linux_dirent __user *, dirent, unsigned int, count)\n{\n\tint error;\n\tstruct fd f = fdget_pos(fd);\n\tstruct readdir_callback buf = {\n\t\t.ctx.actor = fillonedir,\n\t\t.dirent = dirent\n\t};\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (buf.result)\n\t\terror = buf.result;\n\n\tfdput_pos(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nSYSCALL_DEFINE3(old_readdir, unsigned int, fd,\n\t\tstruct old_linux_dirent __user *, dirent, unsigned int, count)\n{\n\tint error;\n\tstruct fd f = fdget_pos(fd);\n\tstruct readdir_callback buf = {\n\t\t.ctx.actor = fillonedir,\n\t\t.dirent = dirent\n\t};\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (buf.result)\n\t\terror = buf.result;\n\n\tfdput_pos(f);\n\treturn error;\n}"
  },
  {
    "function_name": "getdents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "212-243",
    "snippet": "SYSCALL_DEFINE3(getdents, unsigned int, fd,\n\t\tstruct linux_dirent __user *, dirent, unsigned int, count)\n{\n\tstruct fd f;\n\tstruct linux_dirent __user * lastdirent;\n\tstruct getdents_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.count = count,\n\t\t.current_dir = dirent\n\t};\n\tint error;\n\n\tif (!access_ok(VERIFY_WRITE, dirent, count))\n\t\treturn -EFAULT;\n\n\tf = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tlastdirent = buf.previous;\n\tif (lastdirent) {\n\t\tif (put_user(buf.ctx.pos, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput_pos(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nSYSCALL_DEFINE3(getdents, unsigned int, fd,\n\t\tstruct linux_dirent __user *, dirent, unsigned int, count)\n{\n\tstruct fd f;\n\tstruct linux_dirent __user * lastdirent;\n\tstruct getdents_callback buf = {\n\t\t.ctx.actor = filldir,\n\t\t.count = count,\n\t\t.current_dir = dirent\n\t};\n\tint error;\n\n\tif (!access_ok(VERIFY_WRITE, dirent, count))\n\t\treturn -EFAULT;\n\n\tf = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tlastdirent = buf.previous;\n\tif (lastdirent) {\n\t\tif (put_user(buf.ctx.pos, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput_pos(f);\n\treturn error;\n}"
  },
  {
    "function_name": "getdents64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "330-334",
    "snippet": "SYSCALL_DEFINE3(getdents64, unsigned int, fd,\n\t\tstruct linux_dirent64 __user *, dirent, unsigned int, count)\n{\n\treturn ksys_getdents64(fd, dirent, count);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nSYSCALL_DEFINE3(getdents64, unsigned int, fd,\n\t\tstruct linux_dirent64 __user *, dirent, unsigned int, count)\n{\n\treturn ksys_getdents64(fd, dirent, count);\n}"
  },
  {
    "function_name": "old_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "384-403",
    "snippet": "SYSCALL_DEFINE3(old_readdir, unsigned int, fd,\n\t\tstruct compat_old_linux_dirent __user *, dirent, unsigned int, count)\n{\n\tint error;\n\tstruct fd f = fdget_pos(fd);\n\tstruct compat_readdir_callback buf = {\n\t\t.ctx.actor = compat_fillonedir,\n\t\t.dirent = dirent\n\t};\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (buf.result)\n\t\terror = buf.result;\n\n\tfdput_pos(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nSYSCALL_DEFINE3(old_readdir, unsigned int, fd,\n\t\tstruct compat_old_linux_dirent __user *, dirent, unsigned int, count)\n{\n\tint error;\n\tstruct fd f = fdget_pos(fd);\n\tstruct compat_readdir_callback buf = {\n\t\t.ctx.actor = compat_fillonedir,\n\t\t.dirent = dirent\n\t};\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (buf.result)\n\t\terror = buf.result;\n\n\tfdput_pos(f);\n\treturn error;\n}"
  },
  {
    "function_name": "getdents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/readdir.c",
    "lines": "466-497",
    "snippet": "SYSCALL_DEFINE3(getdents, unsigned int, fd,\n\t\tstruct compat_linux_dirent __user *, dirent, unsigned int, count)\n{\n\tstruct fd f;\n\tstruct compat_linux_dirent __user * lastdirent;\n\tstruct compat_getdents_callback buf = {\n\t\t.ctx.actor = compat_filldir,\n\t\t.current_dir = dirent,\n\t\t.count = count\n\t};\n\tint error;\n\n\tif (!access_ok(VERIFY_WRITE, dirent, count))\n\t\treturn -EFAULT;\n\n\tf = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tlastdirent = buf.previous;\n\tif (lastdirent) {\n\t\tif (put_user(buf.ctx.pos, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput_pos(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/dirent.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nSYSCALL_DEFINE3(getdents, unsigned int, fd,\n\t\tstruct compat_linux_dirent __user *, dirent, unsigned int, count)\n{\n\tstruct fd f;\n\tstruct compat_linux_dirent __user * lastdirent;\n\tstruct compat_getdents_callback buf = {\n\t\t.ctx.actor = compat_filldir,\n\t\t.current_dir = dirent,\n\t\t.count = count\n\t};\n\tint error;\n\n\tif (!access_ok(VERIFY_WRITE, dirent, count))\n\t\treturn -EFAULT;\n\n\tf = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = iterate_dir(f.file, &buf.ctx);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tlastdirent = buf.previous;\n\tif (lastdirent) {\n\t\tif (put_user(buf.ctx.pos, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput_pos(f);\n\treturn error;\n}"
  }
]