[
  {
    "function_name": "nonseekable_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1205-1209",
    "snippet": "int nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}"
  },
  {
    "function_name": "generic_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1190-1195",
    "snippet": "int generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}"
  },
  {
    "function_name": "filp_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1130-1148",
    "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_remove_posix",
          "args": [
            "filp",
            "id"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "locks_remove_posix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2463-2494",
          "snippet": "void locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tint error;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tctx =  smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\terror = vfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n\ttrace_locks_remove_posix(inode, &lock, error);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tint error;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tctx =  smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\terror = vfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n\ttrace_locks_remove_posix(inode, &lock, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnotify_flush",
          "args": [
            "filp",
            "id"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "dnotify_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/notify/dnotify/dnotify.c",
          "lines": "149-195",
          "snippet": "void dnotify_flush(struct file *filp, fl_owner_t id)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct dnotify_mark *dn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tbool free = false;\n\n\tinode = file_inode(filp);\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, dnotify_group);\n\tif (!fsn_mark)\n\t\treturn;\n\tdn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\n\n\tmutex_lock(&dnotify_group->mark_mutex);\n\n\tspin_lock(&fsn_mark->lock);\n\tprev = &dn_mark->dn;\n\twhile ((dn = *prev) != NULL) {\n\t\tif ((dn->dn_owner == id) && (dn->dn_filp == filp)) {\n\t\t\t*prev = dn->dn_next;\n\t\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\t\t\tdnotify_recalc_inode_mask(fsn_mark);\n\t\t\tbreak;\n\t\t}\n\t\tprev = &dn->dn_next;\n\t}\n\n\tspin_unlock(&fsn_mark->lock);\n\n\t/* nothing else could have found us thanks to the dnotify_groups\n\t   mark_mutex */\n\tif (dn_mark->dn == NULL) {\n\t\tfsnotify_detach_mark(fsn_mark);\n\t\tfree = true;\n\t}\n\n\tmutex_unlock(&dnotify_group->mark_mutex);\n\n\tif (free)\n\t\tfsnotify_free_mark(fsn_mark);\n\tfsnotify_put_mark(fsn_mark);\n}",
          "includes": [
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dnotify_struct_cache",
            "static struct fsnotify_group *dnotify_group"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/dnotify.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *dnotify_struct_cache;\nstatic struct fsnotify_group *dnotify_group;\n\nvoid dnotify_flush(struct file *filp, fl_owner_t id)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct dnotify_mark *dn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tbool free = false;\n\n\tinode = file_inode(filp);\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, dnotify_group);\n\tif (!fsn_mark)\n\t\treturn;\n\tdn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\n\n\tmutex_lock(&dnotify_group->mark_mutex);\n\n\tspin_lock(&fsn_mark->lock);\n\tprev = &dn_mark->dn;\n\twhile ((dn = *prev) != NULL) {\n\t\tif ((dn->dn_owner == id) && (dn->dn_filp == filp)) {\n\t\t\t*prev = dn->dn_next;\n\t\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\t\t\tdnotify_recalc_inode_mask(fsn_mark);\n\t\t\tbreak;\n\t\t}\n\t\tprev = &dn->dn_next;\n\t}\n\n\tspin_unlock(&fsn_mark->lock);\n\n\t/* nothing else could have found us thanks to the dnotify_groups\n\t   mark_mutex */\n\tif (dn_mark->dn == NULL) {\n\t\tfsnotify_detach_mark(fsn_mark);\n\t\tfree = true;\n\t}\n\n\tmutex_unlock(&dnotify_group->mark_mutex);\n\n\tif (free)\n\t\tfsnotify_free_mark(fsn_mark);\n\tfsnotify_put_mark(fsn_mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(filp->f_mode & FMODE_PATH)"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp->f_op->flush",
          "args": [
            "filp",
            "id"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"VFS: Close: file count is 0\\n\""
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_count",
          "args": [
            "filp"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
  },
  {
    "function_name": "do_sys_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1048-1074",
    "snippet": "long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint fd = build_open_flags(flags, mode, &op);\n\tstruct filename *tmp;\n\n\tif (fd)\n\t\treturn fd;\n\n\ttmp = getname(filename);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tfd = get_unused_fd_flags(flags);\n\tif (fd >= 0) {\n\t\tstruct file *f = do_filp_open(dfd, tmp, &op);\n\t\tif (IS_ERR(f)) {\n\t\t\tput_unused_fd(fd);\n\t\t\tfd = PTR_ERR(f);\n\t\t} else {\n\t\t\tfsnotify_open(f);\n\t\t\tfd_install(fd, f);\n\t\t}\n\t}\n\tputname(tmp);\n\treturn fd;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "tmp"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "putname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "250-262",
          "snippet": "void putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "f"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_open",
          "args": [
            "f"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "f"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "556-562",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_filp_open",
          "args": [
            "dfd",
            "tmp",
            "&op"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "do_filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "3556-3571",
          "snippet": "struct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "flags"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "542-545",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tmp"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getname",
          "args": [
            "filename"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "getname_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "214-248",
          "snippet": "struct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_open_flags",
          "args": [
            "flags",
            "mode",
            "&op"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "build_open_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "924-993",
          "snippet": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\t/*\n\t * Clear out all open flags we don't know about so that we don't report\n\t * them in fcntl(F_GETFD) or similar interfaces.\n\t */\n\tflags &= VALID_OPEN_FLAGS;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\t/*\n\t * Clear out all open flags we don't know about so that we don't report\n\t * them in fcntl(F_GETFD) or similar interfaces.\n\t */\n\tflags &= VALID_OPEN_FLAGS;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint fd = build_open_flags(flags, mode, &op);\n\tstruct filename *tmp;\n\n\tif (fd)\n\t\treturn fd;\n\n\ttmp = getname(filename);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tfd = get_unused_fd_flags(flags);\n\tif (fd >= 0) {\n\t\tstruct file *f = do_filp_open(dfd, tmp, &op);\n\t\tif (IS_ERR(f)) {\n\t\t\tput_unused_fd(fd);\n\t\t\tfd = PTR_ERR(f);\n\t\t} else {\n\t\t\tfsnotify_open(f);\n\t\t\tfd_install(fd, f);\n\t\t}\n\t}\n\tputname(tmp);\n\treturn fd;\n}"
  },
  {
    "function_name": "file_open_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1037-1045",
    "snippet": "struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_file_open_root",
          "args": [
            "dentry",
            "mnt",
            "filename",
            "&op"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "do_file_open_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "3573-3600",
          "snippet": "struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename *filename;\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfilename = getname_kernel(name);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\n\tset_nameidata(&nd, -1, filename);\n\tfile = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(&nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\tputname(filename);\n\treturn file;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename *filename;\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfilename = getname_kernel(name);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\n\tset_nameidata(&nd, -1, filename);\n\tfile = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(&nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\tputname(filename);\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_open_flags",
          "args": [
            "flags",
            "mode",
            "&op"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "build_open_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "924-993",
          "snippet": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\t/*\n\t * Clear out all open flags we don't know about so that we don't report\n\t * them in fcntl(F_GETFD) or similar interfaces.\n\t */\n\tflags &= VALID_OPEN_FLAGS;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\t/*\n\t * Clear out all open flags we don't know about so that we don't report\n\t * them in fcntl(F_GETFD) or similar interfaces.\n\t */\n\tflags &= VALID_OPEN_FLAGS;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}"
  },
  {
    "function_name": "filp_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1024-1034",
    "snippet": "struct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "name"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "putname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "250-262",
          "snippet": "void putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_open_name",
          "args": [
            "name",
            "flags",
            "mode"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "file_open_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1006-1011",
          "snippet": "struct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "name"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "name"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getname_kernel",
          "args": [
            "filename"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "getname_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "214-248",
          "snippet": "struct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}"
  },
  {
    "function_name": "file_open_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1006-1011",
    "snippet": "struct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_filp_open",
          "args": [
            "AT_FDCWD",
            "name",
            "&op"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "do_filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "3556-3571",
          "snippet": "struct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_open_flags",
          "args": [
            "flags",
            "mode",
            "&op"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "build_open_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "924-993",
          "snippet": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\t/*\n\t * Clear out all open flags we don't know about so that we don't report\n\t * them in fcntl(F_GETFD) or similar interfaces.\n\t */\n\tflags &= VALID_OPEN_FLAGS;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\t/*\n\t * Clear out all open flags we don't know about so that we don't report\n\t * them in fcntl(F_GETFD) or similar interfaces.\n\t */\n\tflags &= VALID_OPEN_FLAGS;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}"
  },
  {
    "function_name": "build_open_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "924-993",
    "snippet": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\t/*\n\t * Clear out all open flags we don't know about so that we don't report\n\t * them in fcntl(F_GETFD) or similar interfaces.\n\t */\n\tflags &= VALID_OPEN_FLAGS;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACC_MODE",
          "args": [
            "flags"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode = ACC_MODE(flags);\n\n\t/*\n\t * Clear out all open flags we don't know about so that we don't report\n\t * them in fcntl(F_GETFD) or similar interfaces.\n\t */\n\tflags &= VALID_OPEN_FLAGS;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "open_with_fake_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "906-921",
    "snippet": "struct file *open_with_fake_path(const struct path *path, int flags,\n\t\t\t\tstruct inode *inode, const struct cred *cred)\n{\n\tstruct file *f = alloc_empty_file_noaccount(flags, cred);\n\tif (!IS_ERR(f)) {\n\t\tint error;\n\n\t\tf->f_path = *path;\n\t\terror = do_dentry_open(f, inode, NULL);\n\t\tif (error) {\n\t\t\tfput(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_dentry_open",
          "args": [
            "f",
            "inode",
            "NULL"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "do_dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "716-811",
          "snippet": "static int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\t/* Ensure that we skip any errors that predate opening of the file */\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(locks_inode(f), f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\t/* normally all 3 are set; ->open() can clear them if needed */\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tf->f_mode |= FMODE_OPENED;\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_write_hint = WRITE_LIFE_NOT_SET;\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\ncleanup_all:\n\tif (WARN_ON_ONCE(error > 0))\n\t\terror = -EINVAL;\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\t/* Ensure that we skip any errors that predate opening of the file */\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(locks_inode(f), f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\t/* normally all 3 are set; ->open() can clear them if needed */\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tf->f_mode |= FMODE_OPENED;\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_write_hint = WRITE_LIFE_NOT_SET;\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\ncleanup_all:\n\tif (WARN_ON_ONCE(error > 0))\n\t\terror = -EINVAL;\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_empty_file_noaccount",
          "args": [
            "flags",
            "cred"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_empty_file_noaccount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "170-178",
          "snippet": "struct file *alloc_empty_file_noaccount(int flags, const struct cred *cred)\n{\n\tstruct file *f = __alloc_file(flags, cred);\n\n\tif (!IS_ERR(f))\n\t\tf->f_mode |= FMODE_NOACCOUNT;\n\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_empty_file_noaccount(int flags, const struct cred *cred)\n{\n\tstruct file *f = __alloc_file(flags, cred);\n\n\tif (!IS_ERR(f))\n\t\tf->f_mode |= FMODE_NOACCOUNT;\n\n\treturn f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *open_with_fake_path(const struct path *path, int flags,\n\t\t\t\tstruct inode *inode, const struct cred *cred)\n{\n\tstruct file *f = alloc_empty_file_noaccount(flags, cred);\n\tif (!IS_ERR(f)) {\n\t\tint error;\n\n\t\tf->f_path = *path;\n\t\terror = do_dentry_open(f, inode, NULL);\n\t\tif (error) {\n\t\t\tfput(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
  },
  {
    "function_name": "dentry_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "883-903",
    "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = alloc_empty_file(flags, cred);\n\tif (!IS_ERR(f)) {\n\t\terror = vfs_open(path, f);\n\t\tif (error) {\n\t\t\tfput(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_open",
          "args": [
            "path",
            "f"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "877-881",
          "snippet": "int vfs_open(const struct path *path, struct file *file)\n{\n\tfile->f_path = *path;\n\treturn do_dentry_open(file, d_backing_inode(path->dentry), NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint vfs_open(const struct path *path, struct file *file)\n{\n\tfile->f_path = *path;\n\treturn do_dentry_open(file, d_backing_inode(path->dentry), NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_empty_file",
          "args": [
            "flags",
            "cred"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_empty_file_noaccount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "170-178",
          "snippet": "struct file *alloc_empty_file_noaccount(int flags, const struct cred *cred)\n{\n\tstruct file *f = __alloc_file(flags, cred);\n\n\tif (!IS_ERR(f))\n\t\tf->f_mode |= FMODE_NOACCOUNT;\n\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_empty_file_noaccount(int flags, const struct cred *cred)\n{\n\tstruct file *f = __alloc_file(flags, cred);\n\n\tif (!IS_ERR(f))\n\t\tf->f_mode |= FMODE_NOACCOUNT;\n\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!path->mnt"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "cred"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = alloc_empty_file(flags, cred);\n\tif (!IS_ERR(f)) {\n\t\terror = vfs_open(path, f);\n\t\tif (error) {\n\t\t\tfput(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
  },
  {
    "function_name": "vfs_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "877-881",
    "snippet": "int vfs_open(const struct path *path, struct file *file)\n{\n\tfile->f_path = *path;\n\treturn do_dentry_open(file, d_backing_inode(path->dentry), NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_dentry_open",
          "args": [
            "file",
            "d_backing_inode(path->dentry)",
            "NULL"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "do_dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "716-811",
          "snippet": "static int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\t/* Ensure that we skip any errors that predate opening of the file */\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(locks_inode(f), f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\t/* normally all 3 are set; ->open() can clear them if needed */\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tf->f_mode |= FMODE_OPENED;\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_write_hint = WRITE_LIFE_NOT_SET;\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\ncleanup_all:\n\tif (WARN_ON_ONCE(error > 0))\n\t\terror = -EINVAL;\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\t/* Ensure that we skip any errors that predate opening of the file */\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(locks_inode(f), f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\t/* normally all 3 are set; ->open() can clear them if needed */\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tf->f_mode |= FMODE_OPENED;\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_write_hint = WRITE_LIFE_NOT_SET;\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\ncleanup_all:\n\tif (WARN_ON_ONCE(error > 0))\n\t\terror = -EINVAL;\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path->dentry"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint vfs_open(const struct path *path, struct file *file)\n{\n\tfile->f_path = *path;\n\treturn do_dentry_open(file, d_backing_inode(path->dentry), NULL);\n}"
  },
  {
    "function_name": "file_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "865-868",
    "snippet": "char *file_path(struct file *filp, char *buf, int buflen)\n{\n\treturn d_path(&filp->f_path, buf, buflen);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "&filp->f_path",
            "buf",
            "buflen"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "256-285",
          "snippet": "char *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nchar *file_path(struct file *filp, char *buf, int buflen)\n{\n\treturn d_path(&filp->f_path, buf, buflen);\n}"
  },
  {
    "function_name": "finish_no_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "858-862",
    "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 0;\n}"
  },
  {
    "function_name": "finish_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "834-841",
    "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *))\n{\n\tBUG_ON(file->f_mode & FMODE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\treturn do_dentry_open(file, d_backing_inode(dentry), open);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_dentry_open",
          "args": [
            "file",
            "d_backing_inode(dentry)",
            "open"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "do_dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "716-811",
          "snippet": "static int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\t/* Ensure that we skip any errors that predate opening of the file */\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(locks_inode(f), f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\t/* normally all 3 are set; ->open() can clear them if needed */\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tf->f_mode |= FMODE_OPENED;\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_write_hint = WRITE_LIFE_NOT_SET;\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\ncleanup_all:\n\tif (WARN_ON_ONCE(error > 0))\n\t\terror = -EINVAL;\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\t/* Ensure that we skip any errors that predate opening of the file */\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(locks_inode(f), f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\t/* normally all 3 are set; ->open() can clear them if needed */\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tf->f_mode |= FMODE_OPENED;\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_write_hint = WRITE_LIFE_NOT_SET;\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\ncleanup_all:\n\tif (WARN_ON_ONCE(error > 0))\n\t\terror = -EINVAL;\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "file->f_mode & FMODE_OPENED"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *))\n{\n\tBUG_ON(file->f_mode & FMODE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\treturn do_dentry_open(file, d_backing_inode(dentry), open);\n}"
  },
  {
    "function_name": "do_dentry_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "716-811",
    "snippet": "static int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\t/* Ensure that we skip any errors that predate opening of the file */\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(locks_inode(f), f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\t/* normally all 3 are set; ->open() can clear them if needed */\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tf->f_mode |= FMODE_OPENED;\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_write_hint = WRITE_LIFE_NOT_SET;\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\ncleanup_all:\n\tif (WARN_ON_ONCE(error > 0))\n\t\terror = -EINVAL;\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&f->f_path"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_drop_write",
          "args": [
            "f->f_path.mnt"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "456-459",
          "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fops_put",
          "args": [
            "f->f_op"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "error > 0"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_ra_state_init",
          "args": [
            "&f->f_ra",
            "f->f_mapping->host->i_mapping"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "f->f_op->write || f->f_op->write_iter"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "f->f_op->read || f->f_op->read_iter"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_readcount_inc",
          "args": [
            "inode"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "inode",
            "f"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "nonseekable_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1205-1209",
          "snippet": "int nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "break_lease",
          "args": [
            "locks_inode(f)",
            "f->f_flags"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open_break_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfsd/vfs.c",
          "lines": "687-695",
          "snippet": "static int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "f"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_file_open",
          "args": [
            "f"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "WARN_ON(!f->f_op)"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!f->f_op"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fops_get",
          "args": [
            "inode->i_fop"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mnt_want_write",
          "args": [
            "f->f_path.mnt"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "399-405",
          "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nint __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_write_access",
          "args": [
            "inode"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "special_file",
          "args": [
            "inode->i_mode"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f->f_flags & O_PATH"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_sample_wb_err",
          "args": [
            "f->f_mapping"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&f->f_path"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "469-473",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\tstatic const struct file_operations empty_fops = {};\n\tint error;\n\n\tpath_get(&f->f_path);\n\tf->f_inode = inode;\n\tf->f_mapping = inode->i_mapping;\n\n\t/* Ensure that we skip any errors that predate opening of the file */\n\tf->f_wb_err = filemap_sample_wb_err(f->f_mapping);\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH | FMODE_OPENED;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(locks_inode(f), f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\t/* normally all 3 are set; ->open() can clear them if needed */\n\tf->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tf->f_mode |= FMODE_OPENED;\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_write_hint = WRITE_LIFE_NOT_SET;\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\ncleanup_all:\n\tif (WARN_ON_ONCE(error > 0))\n\t\terror = -EINVAL;\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "ksys_fchown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "691-709",
    "snippet": "int ksys_fchown(unsigned int fd, uid_t user, gid_t group)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\terror = mnt_want_write_file(f.file);\n\tif (error)\n\t\tgoto out_fput;\n\taudit_file(f.file);\n\terror = chown_common(&f.file->f_path, user, group);\n\tmnt_drop_write_file(f.file);\nout_fput:\n\tfdput(f);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "f.file"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "461-465",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chown_common",
          "args": [
            "&f.file->f_path",
            "user",
            "group"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "chown_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "600-640",
          "snippet": "static int chown_common(const struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\nretry_deleg:\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\n\tinode_lock(inode);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int chown_common(const struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\nretry_deleg:\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\n\tinode_lock(inode);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_file",
          "args": [
            "f.file"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "f.file"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "414-423",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint ksys_fchown(unsigned int fd, uid_t user, gid_t group)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\tgoto out;\n\n\terror = mnt_want_write_file(f.file);\n\tif (error)\n\t\tgoto out_fput;\n\taudit_file(f.file);\n\terror = chown_common(&f.file->f_path, user, group);\n\tmnt_drop_write_file(f.file);\nout_fput:\n\tfdput(f);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "do_fchownat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "642-672",
    "snippet": "int do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,\n\t\tint flag)\n{\n\tstruct path path;\n\tint error = -EINVAL;\n\tint lookup_flags;\n\n\tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\tgoto out;\n\n\tlookup_flags = (flag & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto out_release;\n\terror = chown_common(&path, user, group);\n\tmnt_drop_write(path.mnt);\nout_release:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path.mnt"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "461-465",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chown_common",
          "args": [
            "&path",
            "user",
            "group"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "chown_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "600-640",
          "snippet": "static int chown_common(const struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\nretry_deleg:\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\n\tinode_lock(inode);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int chown_common(const struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\nretry_deleg:\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\n\tinode_lock(inode);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path.mnt"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "414-423",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "dfd",
            "filename",
            "lookup_flags",
            "&path"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group,\n\t\tint flag)\n{\n\tstruct path path;\n\tint error = -EINVAL;\n\tint lookup_flags;\n\n\tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\tgoto out;\n\n\tlookup_flags = (flag & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto out_release;\n\terror = chown_common(&path, user, group);\n\tmnt_drop_write(path.mnt);\nout_release:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "chown_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "600-640",
    "snippet": "static int chown_common(const struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\nretry_deleg:\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\n\tinode_lock(inode);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "break_deleg_wait",
          "args": [
            "&delegated_inode"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "path->dentry",
            "&newattrs",
            "&delegated_inode"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "226-345",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_chown",
          "args": [
            "path",
            "uid",
            "gid"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "group"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "user"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int chown_common(const struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\nretry_deleg:\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\n\tinode_lock(inode);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "do_fchmodat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "571-587",
    "snippet": "int do_fchmodat(int dfd, const char __user *filename, umode_t mode)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (!error) {\n\t\terror = chmod_common(&path, mode);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chmod_common",
          "args": [
            "&path",
            "mode"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "chmod_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "524-551",
          "snippet": "static int chmod_common(const struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tinode_lock(inode);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int chmod_common(const struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tinode_lock(inode);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "dfd",
            "filename",
            "lookup_flags",
            "&path"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_fchmodat(int dfd, const char __user *filename, umode_t mode)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (!error) {\n\t\terror = chmod_common(&path, mode);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ksys_fchmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "553-564",
    "snippet": "int ksys_fchmod(unsigned int fd, umode_t mode)\n{\n\tstruct fd f = fdget(fd);\n\tint err = -EBADF;\n\n\tif (f.file) {\n\t\taudit_file(f.file);\n\t\terr = chmod_common(&f.file->f_path, mode);\n\t\tfdput(f);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod_common",
          "args": [
            "&f.file->f_path",
            "mode"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "chmod_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "524-551",
          "snippet": "static int chmod_common(const struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tinode_lock(inode);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int chmod_common(const struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tinode_lock(inode);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_file",
          "args": [
            "f.file"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint ksys_fchmod(unsigned int fd, umode_t mode)\n{\n\tstruct fd f = fdget(fd);\n\tint err = -EBADF;\n\n\tif (f.file) {\n\t\taudit_file(f.file);\n\t\terr = chmod_common(&f.file->f_path, mode);\n\t\tfdput(f);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "chmod_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "524-551",
    "snippet": "static int chmod_common(const struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tinode_lock(inode);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path->mnt"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "461-465",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "break_deleg_wait",
          "args": [
            "&delegated_inode"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "path->dentry",
            "&newattrs",
            "&delegated_inode"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "226-345",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_chmod",
          "args": [
            "path",
            "mode"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path->mnt"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "414-423",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int chmod_common(const struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tinode_lock(inode);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tinode_unlock(inode);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}"
  },
  {
    "function_name": "ksys_chroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "486-517",
    "snippet": "int ksys_chroot(const char __user *filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\terror = -EPERM;\n\tif (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))\n\t\tgoto dput_and_out;\n\terror = security_path_chroot(&path);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_root(current->fs, &path);\n\terror = 0;\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs_root",
          "args": [
            "current->fs",
            "&path"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "set_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs_struct.c",
          "lines": "14-27",
          "snippet": "void set_fs_root(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_root;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_root = fs->root;\n\tfs->root = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\tif (old_root.dentry)\n\t\tpath_put(&old_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n\nvoid set_fs_root(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_root;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_root = fs->root;\n\tfs->root = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\tif (old_root.dentry)\n\t\tpath_put(&old_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_chroot",
          "args": [
            "&path"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "current_user_ns()",
            "CAP_SYS_CHROOT"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "path.dentry->d_inode",
            "MAY_EXEC | MAY_CHDIR"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "427-460",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "filename",
            "lookup_flags",
            "&path"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint ksys_chroot(const char __user *filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\terror = -EPERM;\n\tif (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))\n\t\tgoto dput_and_out;\n\terror = security_path_chroot(&path);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_root(current->fs, &path);\n\terror = 0;\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "ksys_chdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "433-457",
    "snippet": "int ksys_chdir(const char __user *filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_pwd(current->fs, &path);\n\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs_pwd",
          "args": [
            "current->fs",
            "&path"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "set_fs_pwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs_struct.c",
          "lines": "33-47",
          "snippet": "void set_fs_pwd(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_pwd;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_pwd = fs->pwd;\n\tfs->pwd = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\n\tif (old_pwd.dentry)\n\t\tpath_put(&old_pwd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n\nvoid set_fs_pwd(struct fs_struct *fs, const struct path *path)\n{\n\tstruct path old_pwd;\n\n\tpath_get(path);\n\tspin_lock(&fs->lock);\n\twrite_seqcount_begin(&fs->seq);\n\told_pwd = fs->pwd;\n\tfs->pwd = *path;\n\twrite_seqcount_end(&fs->seq);\n\tspin_unlock(&fs->lock);\n\n\tif (old_pwd.dentry)\n\t\tpath_put(&old_pwd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "path.dentry->d_inode",
            "MAY_EXEC | MAY_CHDIR"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "427-460",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "filename",
            "lookup_flags",
            "&path"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint ksys_chdir(const char __user *filename)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nretry:\n\terror = user_path_at(AT_FDCWD, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);\n\tif (error)\n\t\tgoto dput_and_out;\n\n\tset_fs_pwd(current->fs, &path);\n\ndput_and_out:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "do_faccessat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "347-421",
    "snippet": "long do_faccessat(int dfd, const char __user *filename, int mode)\n{\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tstruct path path;\n\tstruct inode *inode;\n\tint res;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\n\tif (mode & ~S_IRWXO)\t/* where's F_OK, X_OK, W_OK, R_OK? */\n\t\treturn -EINVAL;\n\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\treturn -ENOMEM;\n\n\toverride_cred->fsuid = override_cred->uid;\n\toverride_cred->fsgid = override_cred->gid;\n\n\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\n\t\t/* Clear the capabilities if we switch to a non-root user */\n\t\tkuid_t root_uid = make_kuid(override_cred->user_ns, 0);\n\t\tif (!uid_eq(override_cred->uid, root_uid))\n\t\t\tcap_clear(override_cred->cap_effective);\n\t\telse\n\t\t\toverride_cred->cap_effective =\n\t\t\t\toverride_cred->cap_permitted;\n\t}\n\n\told_cred = override_creds(override_cred);\nretry:\n\tres = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (res)\n\t\tgoto out;\n\n\tinode = d_backing_inode(path.dentry);\n\n\tif ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {\n\t\t/*\n\t\t * MAY_EXEC on regular files is denied if the fs is mounted\n\t\t * with the \"noexec\" flag.\n\t\t */\n\t\tres = -EACCES;\n\t\tif (path_noexec(&path))\n\t\t\tgoto out_path_release;\n\t}\n\n\tres = inode_permission(inode, mode | MAY_ACCESS);\n\t/* SuS v2 requires we report a read only fs too */\n\tif (res || !(mode & S_IWOTH) || special_file(inode->i_mode))\n\t\tgoto out_path_release;\n\t/*\n\t * This is a rare case where using __mnt_is_readonly()\n\t * is OK without a mnt_want/drop_write() pair.  Since\n\t * no actual write to the fs is performed here, we do\n\t * not need to telegraph to that to anyone.\n\t *\n\t * By doing this, we accept that this access is\n\t * inherently racy and know that the fs may change\n\t * state before we even see this result.\n\t */\n\tif (__mnt_is_readonly(path.mnt))\n\t\tres = -EROFS;\n\nout_path_release:\n\tpath_put(&path);\n\tif (retry_estale(res, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override_cred"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "old_cred"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "res",
            "lookup_flags"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_is_readonly",
          "args": [
            "path.mnt"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_is_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "248-255",
          "snippet": "int __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (sb_rdonly(mnt->mnt_sb))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nint __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (sb_rdonly(mnt->mnt_sb))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "special_file",
          "args": [
            "inode->i_mode"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "mode | MAY_ACCESS"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "427-460",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_noexec",
          "args": [
            "&path"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "path_noexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "108-112",
          "snippet": "bool path_noexec(const struct path *path)\n{\n\treturn (path->mnt->mnt_flags & MNT_NOEXEC) ||\n\t       (path->mnt->mnt_sb->s_iflags & SB_I_NOEXEC);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nbool path_noexec(const struct path *path)\n{\n\treturn (path->mnt->mnt_flags & MNT_NOEXEC) ||\n\t       (path->mnt->mnt_sb->s_iflags & SB_I_NOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path.dentry"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "dfd",
            "filename",
            "lookup_flags",
            "&path"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "override_cred"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_override_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/util.c",
          "lines": "39-44",
          "snippet": "const struct cred *ovl_override_creds(struct super_block *sb)\n{\n\tstruct ovl_fs *ofs = sb->s_fs_info;\n\n\treturn override_creds(ofs->creator_cred);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/namei.h>",
            "#include <linux/uuid.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/ratelimit.h>\n#include <linux/namei.h>\n#include <linux/uuid.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nconst struct cred *ovl_override_creds(struct super_block *sb)\n{\n\tstruct ovl_fs *ofs = sb->s_fs_info;\n\n\treturn override_creds(ofs->creator_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_clear",
          "args": [
            "override_cred->cap_effective"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "override_cred->uid",
            "root_uid"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "override_cred->user_ns",
            "0"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure",
          "args": [
            "SECURE_NO_SETUID_FIXUP"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong do_faccessat(int dfd, const char __user *filename, int mode)\n{\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tstruct path path;\n\tstruct inode *inode;\n\tint res;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\n\tif (mode & ~S_IRWXO)\t/* where's F_OK, X_OK, W_OK, R_OK? */\n\t\treturn -EINVAL;\n\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\treturn -ENOMEM;\n\n\toverride_cred->fsuid = override_cred->uid;\n\toverride_cred->fsgid = override_cred->gid;\n\n\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\n\t\t/* Clear the capabilities if we switch to a non-root user */\n\t\tkuid_t root_uid = make_kuid(override_cred->user_ns, 0);\n\t\tif (!uid_eq(override_cred->uid, root_uid))\n\t\t\tcap_clear(override_cred->cap_effective);\n\t\telse\n\t\t\toverride_cred->cap_effective =\n\t\t\t\toverride_cred->cap_permitted;\n\t}\n\n\told_cred = override_creds(override_cred);\nretry:\n\tres = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (res)\n\t\tgoto out;\n\n\tinode = d_backing_inode(path.dentry);\n\n\tif ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {\n\t\t/*\n\t\t * MAY_EXEC on regular files is denied if the fs is mounted\n\t\t * with the \"noexec\" flag.\n\t\t */\n\t\tres = -EACCES;\n\t\tif (path_noexec(&path))\n\t\t\tgoto out_path_release;\n\t}\n\n\tres = inode_permission(inode, mode | MAY_ACCESS);\n\t/* SuS v2 requires we report a read only fs too */\n\tif (res || !(mode & S_IWOTH) || special_file(inode->i_mode))\n\t\tgoto out_path_release;\n\t/*\n\t * This is a rare case where using __mnt_is_readonly()\n\t * is OK without a mnt_want/drop_write() pair.  Since\n\t * no actual write to the fs is performed here, we do\n\t * not need to telegraph to that to anyone.\n\t *\n\t * By doing this, we accept that this access is\n\t * inherently racy and know that the fs may change\n\t * state before we even see this result.\n\t */\n\tif (__mnt_is_readonly(path.mnt))\n\t\tres = -EROFS;\n\nout_path_release:\n\tpath_put(&path);\n\tif (retry_estale(res, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\treturn res;\n}"
  },
  {
    "function_name": "ksys_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "325-335",
    "snippet": "int ksys_fallocate(int fd, int mode, loff_t offset, loff_t len)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (f.file) {\n\t\terror = vfs_fallocate(f.file, mode, offset, len);\n\t\tfdput(f);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_fallocate",
          "args": [
            "f.file",
            "mode",
            "offset",
            "len"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "228-322",
          "snippet": "int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Unshare range should only be used with allocate mode. */\n\tif ((mode & FALLOC_FL_UNSHARE_RANGE) &&\n\t    (mode & ~(FALLOC_FL_UNSHARE_RANGE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(file);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tfile_end_write(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Unshare range should only be used with allocate mode. */\n\tif ((mode & FALLOC_FL_UNSHARE_RANGE) &&\n\t    (mode & ~(FALLOC_FL_UNSHARE_RANGE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(file);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tfile_end_write(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint ksys_fallocate(int fd, int mode, loff_t offset, loff_t len)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (f.file) {\n\t\terror = vfs_fallocate(f.file, mode, offset, len);\n\t\tfdput(f);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "228-322",
    "snippet": "int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Unshare range should only be used with allocate mode. */\n\tif ((mode & FALLOC_FL_UNSHARE_RANGE) &&\n\t    (mode & ~(FALLOC_FL_UNSHARE_RANGE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(file);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tfile_end_write(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->fallocate",
          "args": [
            "file",
            "mode",
            "offset",
            "len"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "inode->i_mode"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_file_permission",
          "args": [
            "file",
            "MAY_WRITE"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "inode"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Unshare range should only be used with allocate mode. */\n\tif ((mode & FALLOC_FL_UNSHARE_RANGE) &&\n\t    (mode & ~(FALLOC_FL_UNSHARE_RANGE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(file);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tfile_end_write(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_sys_ftruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "154-200",
    "snippet": "long do_sys_ftruncate(unsigned int fd, loff_t length, int small)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct fd f;\n\tint error;\n\n\terror = -EINVAL;\n\tif (length < 0)\n\t\tgoto out;\n\terror = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* explicitly opened as large or we are on 64-bit box */\n\tif (f.file->f_flags & O_LARGEFILE)\n\t\tsmall = 0;\n\n\tdentry = f.file->f_path.dentry;\n\tinode = dentry->d_inode;\n\terror = -EINVAL;\n\tif (!S_ISREG(inode->i_mode) || !(f.file->f_mode & FMODE_WRITE))\n\t\tgoto out_putf;\n\n\terror = -EINVAL;\n\t/* Cannot ftruncate over 2^31 bytes without large file support */\n\tif (small && length > MAX_NON_LFS)\n\t\tgoto out_putf;\n\n\terror = -EPERM;\n\t/* Check IS_APPEND on real upper inode */\n\tif (IS_APPEND(file_inode(f.file)))\n\t\tgoto out_putf;\n\n\tsb_start_write(inode->i_sb);\n\terror = locks_verify_truncate(inode, f.file, length);\n\tif (!error)\n\t\terror = security_path_truncate(&f.file->f_path);\n\tif (!error)\n\t\terror = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, f.file);\n\tsb_end_write(inode->i_sb);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "inode->i_sb"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_truncate",
          "args": [
            "dentry",
            "length",
            "ATTR_MTIME|ATTR_CTIME",
            "f.file"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "do_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "37-66",
          "snippet": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_truncate",
          "args": [
            "&f.file->f_path"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_verify_truncate",
          "args": [
            "inode",
            "f.file",
            "length"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_start_write",
          "args": [
            "inode->i_sb"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "file_inode(f.file)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "f.file"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong do_sys_ftruncate(unsigned int fd, loff_t length, int small)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct fd f;\n\tint error;\n\n\terror = -EINVAL;\n\tif (length < 0)\n\t\tgoto out;\n\terror = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* explicitly opened as large or we are on 64-bit box */\n\tif (f.file->f_flags & O_LARGEFILE)\n\t\tsmall = 0;\n\n\tdentry = f.file->f_path.dentry;\n\tinode = dentry->d_inode;\n\terror = -EINVAL;\n\tif (!S_ISREG(inode->i_mode) || !(f.file->f_mode & FMODE_WRITE))\n\t\tgoto out_putf;\n\n\terror = -EINVAL;\n\t/* Cannot ftruncate over 2^31 bytes without large file support */\n\tif (small && length > MAX_NON_LFS)\n\t\tgoto out_putf;\n\n\terror = -EPERM;\n\t/* Check IS_APPEND on real upper inode */\n\tif (IS_APPEND(file_inode(f.file)))\n\t\tgoto out_putf;\n\n\tsb_start_write(inode->i_sb);\n\terror = locks_verify_truncate(inode, f.file, length);\n\tif (!error)\n\t\terror = security_path_truncate(&f.file->f_path);\n\tif (!error)\n\t\terror = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, f.file);\n\tsb_end_write(inode->i_sb);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "do_sys_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "120-140",
    "snippet": "long do_sys_truncate(const char __user *pathname, loff_t length)\n{\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\tif (length < 0)\t/* sorry, but loff_t says... */\n\t\treturn -EINVAL;\n\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_truncate(&path, length);\n\t\tpath_put(&path);\n\t}\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_truncate",
          "args": [
            "&path",
            "length"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "68-117",
          "snippet": "long vfs_truncate(const struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong vfs_truncate(const struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong do_sys_truncate(const char __user *pathname, loff_t length)\n{\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\tif (length < 0)\t/* sorry, but loff_t says... */\n\t\treturn -EINVAL;\n\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_truncate(&path, length);\n\t\tpath_put(&path);\n\t}\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "68-117",
    "snippet": "long vfs_truncate(const struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path->mnt"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "461-465",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_truncate",
          "args": [
            "path->dentry",
            "length",
            "0",
            "NULL"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "do_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "37-66",
          "snippet": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_truncate",
          "args": [
            "path"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_verify_truncate",
          "args": [
            "inode",
            "NULL",
            "length"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "break_lease",
          "args": [
            "inode",
            "O_WRONLY"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open_break_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfsd/vfs.c",
          "lines": "687-695",
          "snippet": "static int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_write_access",
          "args": [
            "inode"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_WRITE"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "427-460",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path->mnt"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "414-423",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong vfs_truncate(const struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "do_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "37-66",
    "snippet": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dentry->d_inode"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "dentry",
            "&newattrs",
            "NULL"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "226-345",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "dentry->d_inode"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_needs_remove_privs",
          "args": [
            "dentry"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_needs_remove_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1782-1798",
          "snippet": "int dentry_needs_remove_privs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint mask = 0;\n\tint ret;\n\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tmask = should_remove_suid(dentry);\n\tret = security_inode_need_killpriv(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tmask |= ATTR_KILL_PRIV;\n\treturn mask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint dentry_needs_remove_privs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint mask = 0;\n\tint ret;\n\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tmask = should_remove_suid(dentry);\n\tret = security_inode_need_killpriv(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tmask |= ATTR_KILL_PRIV;\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "142-145",
    "snippet": "SYSCALL_DEFINE2(truncate, const char __user *, path, long, length)\n{\n\treturn do_sys_truncate(path, length);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(truncate, const char __user *, path, long, length)\n{\n\treturn do_sys_truncate(path, length);\n}"
  },
  {
    "function_name": "truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "148-151",
    "snippet": "SYSCALL_DEFINE2(truncate, const char __user *, path, compat_off_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(truncate, const char __user *, path, compat_off_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}"
  },
  {
    "function_name": "ftruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "202-205",
    "snippet": "SYSCALL_DEFINE2(ftruncate, unsigned int, fd, unsigned long, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(ftruncate, unsigned int, fd, unsigned long, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}"
  },
  {
    "function_name": "ftruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "208-211",
    "snippet": "SYSCALL_DEFINE2(ftruncate, unsigned int, fd, compat_ulong_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(ftruncate, unsigned int, fd, compat_ulong_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}"
  },
  {
    "function_name": "truncate64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "216-219",
    "snippet": "SYSCALL_DEFINE2(truncate64, const char __user *, path, loff_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(truncate64, const char __user *, path, loff_t, length)\n{\n\treturn do_sys_truncate(path, length);\n}"
  },
  {
    "function_name": "ftruncate64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "221-224",
    "snippet": "SYSCALL_DEFINE2(ftruncate64, unsigned int, fd, loff_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(ftruncate64, unsigned int, fd, loff_t, length)\n{\n\treturn do_sys_ftruncate(fd, length, 0);\n}"
  },
  {
    "function_name": "fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "337-340",
    "snippet": "SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n{\n\treturn ksys_fallocate(fd, mode, offset, len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n{\n\treturn ksys_fallocate(fd, mode, offset, len);\n}"
  },
  {
    "function_name": "faccessat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "423-426",
    "snippet": "SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)\n{\n\treturn do_faccessat(dfd, filename, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)\n{\n\treturn do_faccessat(dfd, filename, mode);\n}"
  },
  {
    "function_name": "access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "428-431",
    "snippet": "SYSCALL_DEFINE2(access, const char __user *, filename, int, mode)\n{\n\treturn do_faccessat(AT_FDCWD, filename, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(access, const char __user *, filename, int, mode)\n{\n\treturn do_faccessat(AT_FDCWD, filename, mode);\n}"
  },
  {
    "function_name": "chdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "459-462",
    "snippet": "SYSCALL_DEFINE1(chdir, const char __user *, filename)\n{\n\treturn ksys_chdir(filename);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE1(chdir, const char __user *, filename)\n{\n\treturn ksys_chdir(filename);\n}"
  },
  {
    "function_name": "fchdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "464-484",
    "snippet": "SYSCALL_DEFINE1(fchdir, unsigned int, fd)\n{\n\tstruct fd f = fdget_raw(fd);\n\tint error;\n\n\terror = -EBADF;\n\tif (!f.file)\n\t\tgoto out;\n\n\terror = -ENOTDIR;\n\tif (!d_can_lookup(f.file->f_path.dentry))\n\t\tgoto out_putf;\n\n\terror = inode_permission(file_inode(f.file), MAY_EXEC | MAY_CHDIR);\n\tif (!error)\n\t\tset_fs_pwd(current->fs, &f.file->f_path);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE1(fchdir, unsigned int, fd)\n{\n\tstruct fd f = fdget_raw(fd);\n\tint error;\n\n\terror = -EBADF;\n\tif (!f.file)\n\t\tgoto out;\n\n\terror = -ENOTDIR;\n\tif (!d_can_lookup(f.file->f_path.dentry))\n\t\tgoto out_putf;\n\n\terror = inode_permission(file_inode(f.file), MAY_EXEC | MAY_CHDIR);\n\tif (!error)\n\t\tset_fs_pwd(current->fs, &f.file->f_path);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "chroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "519-522",
    "snippet": "SYSCALL_DEFINE1(chroot, const char __user *, filename)\n{\n\treturn ksys_chroot(filename);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE1(chroot, const char __user *, filename)\n{\n\treturn ksys_chroot(filename);\n}"
  },
  {
    "function_name": "fchmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "566-569",
    "snippet": "SYSCALL_DEFINE2(fchmod, unsigned int, fd, umode_t, mode)\n{\n\treturn ksys_fchmod(fd, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(fchmod, unsigned int, fd, umode_t, mode)\n{\n\treturn ksys_fchmod(fd, mode);\n}"
  },
  {
    "function_name": "fchmodat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "589-593",
    "snippet": "SYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename,\n\t\tumode_t, mode)\n{\n\treturn do_fchmodat(dfd, filename, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE3(fchmodat, int, dfd, const char __user *, filename,\n\t\tumode_t, mode)\n{\n\treturn do_fchmodat(dfd, filename, mode);\n}"
  },
  {
    "function_name": "chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "595-598",
    "snippet": "SYSCALL_DEFINE2(chmod, const char __user *, filename, umode_t, mode)\n{\n\treturn do_fchmodat(AT_FDCWD, filename, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(chmod, const char __user *, filename, umode_t, mode)\n{\n\treturn do_fchmodat(AT_FDCWD, filename, mode);\n}"
  },
  {
    "function_name": "fchownat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "674-678",
    "snippet": "SYSCALL_DEFINE5(fchownat, int, dfd, const char __user *, filename, uid_t, user,\n\t\tgid_t, group, int, flag)\n{\n\treturn do_fchownat(dfd, filename, user, group, flag);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE5(fchownat, int, dfd, const char __user *, filename, uid_t, user,\n\t\tgid_t, group, int, flag)\n{\n\treturn do_fchownat(dfd, filename, user, group, flag);\n}"
  },
  {
    "function_name": "chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "680-683",
    "snippet": "SYSCALL_DEFINE3(chown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn do_fchownat(AT_FDCWD, filename, user, group, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE3(chown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn do_fchownat(AT_FDCWD, filename, user, group, 0);\n}"
  },
  {
    "function_name": "lchown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "685-689",
    "snippet": "SYSCALL_DEFINE3(lchown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn do_fchownat(AT_FDCWD, filename, user, group,\n\t\t\t   AT_SYMLINK_NOFOLLOW);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE3(lchown, const char __user *, filename, uid_t, user, gid_t, group)\n{\n\treturn do_fchownat(AT_FDCWD, filename, user, group,\n\t\t\t   AT_SYMLINK_NOFOLLOW);\n}"
  },
  {
    "function_name": "fchown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "711-714",
    "snippet": "SYSCALL_DEFINE3(fchown, unsigned int, fd, uid_t, user, gid_t, group)\n{\n\treturn ksys_fchown(fd, user, group);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE3(fchown, unsigned int, fd, uid_t, user, gid_t, group)\n{\n\treturn ksys_fchown(fd, user, group);\n}"
  },
  {
    "function_name": "open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1076-1082",
    "snippet": "SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n}"
  },
  {
    "function_name": "openat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1084-1091",
    "snippet": "SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags,\n\t\tumode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\treturn do_sys_open(dfd, filename, flags, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags,\n\t\tumode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\treturn do_sys_open(dfd, filename, flags, mode);\n}"
  },
  {
    "function_name": "open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1098-1101",
    "snippet": "SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n{\n\treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n{\n\treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n}"
  },
  {
    "function_name": "openat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1107-1110",
    "snippet": "SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode)\n{\n\treturn do_sys_open(dfd, filename, flags, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode)\n{\n\treturn do_sys_open(dfd, filename, flags, mode);\n}"
  },
  {
    "function_name": "creat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1119-1122",
    "snippet": "SYSCALL_DEFINE2(creat, const char __user *, pathname, umode_t, mode)\n{\n\treturn ksys_open(pathname, O_CREAT | O_WRONLY | O_TRUNC, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE2(creat, const char __user *, pathname, umode_t, mode)\n{\n\treturn ksys_open(pathname, O_CREAT | O_WRONLY | O_TRUNC, mode);\n}"
  },
  {
    "function_name": "close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1157-1169",
    "snippet": "SYSCALL_DEFINE1(close, unsigned int, fd)\n{\n\tint retval = __close_fd(current->files, fd);\n\n\t/* can't restart close syscall because file table entry was cleared */\n\tif (unlikely(retval == -ERESTARTSYS ||\n\t\t     retval == -ERESTARTNOINTR ||\n\t\t     retval == -ERESTARTNOHAND ||\n\t\t     retval == -ERESTART_RESTARTBLOCK))\n\t\tretval = -EINTR;\n\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE1(close, unsigned int, fd)\n{\n\tint retval = __close_fd(current->files, fd);\n\n\t/* can't restart close syscall because file table entry was cleared */\n\tif (unlikely(retval == -ERESTARTSYS ||\n\t\t     retval == -ERESTARTNOINTR ||\n\t\t     retval == -ERESTARTNOHAND ||\n\t\t     retval == -ERESTART_RESTARTBLOCK))\n\t\tretval = -EINTR;\n\n\treturn retval;\n}"
  },
  {
    "function_name": "vhangup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
    "lines": "1175-1182",
    "snippet": "SYSCALL_DEFINE0(vhangup)\n{\n\tif (capable(CAP_SYS_TTY_CONFIG)) {\n\t\ttty_vhangup_self();\n\t\treturn 0;\n\t}\n\treturn -EPERM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nSYSCALL_DEFINE0(vhangup)\n{\n\tif (capable(CAP_SYS_TTY_CONFIG)) {\n\t\ttty_vhangup_self();\n\t\treturn 0;\n\t}\n\treturn -EPERM;\n}"
  }
]