[
  {
    "function_name": "iomap_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "2123-2137",
    "snippet": "sector_t\niomap_bmap(struct address_space *mapping, sector_t bno,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t pos = bno << inode->i_blkbits;\n\tunsigned blocksize = i_blocksize(inode);\n\n\tif (filemap_write_and_wait(mapping))\n\t\treturn 0;\n\n\tbno = 0;\n\tiomap_apply(inode, pos, blocksize, 0, ops, &bno, iomap_bmap_actor);\n\treturn bno;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "pos",
            "blocksize",
            "0",
            "ops",
            "&bno",
            "iomap_bmap_actor"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "mapping"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nsector_t\niomap_bmap(struct address_space *mapping, sector_t bno,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t pos = bno << inode->i_blkbits;\n\tunsigned blocksize = i_blocksize(inode);\n\n\tif (filemap_write_and_wait(mapping))\n\t\treturn 0;\n\n\tbno = 0;\n\tiomap_apply(inode, pos, blocksize, 0, ops, &bno, iomap_bmap_actor);\n\treturn bno;\n}"
  },
  {
    "function_name": "iomap_bmap_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "2106-2120",
    "snippet": "static loff_t\niomap_bmap_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tsector_t *bno = data, addr;\n\n\tif (iomap->type == IOMAP_MAPPED) {\n\t\taddr = (pos - iomap->offset + iomap->addr) >> inode->i_blkbits;\n\t\tif (addr > INT_MAX)\n\t\t\tWARN(1, \"would truncate bmap result\\n\");\n\t\telse\n\t\t\t*bno = addr;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"would truncate bmap result\\n\""
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_bmap_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tsector_t *bno = data, addr;\n\n\tif (iomap->type == IOMAP_MAPPED) {\n\t\taddr = (pos - iomap->offset + iomap->addr) >> inode->i_blkbits;\n\t\tif (addr > INT_MAX)\n\t\t\tWARN(1, \"would truncate bmap result\\n\");\n\t\telse\n\t\t\t*bno = addr;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "iomap_swapfile_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "2059-2102",
    "snippet": "int iomap_swapfile_activate(struct swap_info_struct *sis,\n\t\tstruct file *swap_file, sector_t *pagespan,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct iomap_swapfile_info isi = {\n\t\t.sis = sis,\n\t\t.lowest_ppage = (sector_t)-1ULL,\n\t};\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tloff_t pos = 0;\n\tloff_t len = ALIGN_DOWN(i_size_read(inode), PAGE_SIZE);\n\tloff_t ret;\n\n\t/*\n\t * Persist all file mapping metadata so that we won't have any\n\t * IOMAP_F_DIRTY iomaps.\n\t */\n\tret = vfs_fsync(swap_file, 1);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_REPORT,\n\t\t\t\tops, &isi, iomap_swapfile_activate_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\tif (isi.iomap.length) {\n\t\tret = iomap_swapfile_add_extent(&isi);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*pagespan = 1 + isi.highest_ppage - isi.lowest_ppage;\n\tsis->max = isi.nr_pages;\n\tsis->pages = isi.nr_pages - 1;\n\tsis->highest_bit = isi.nr_pages - 1;\n\treturn isi.nr_extents;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_swapfile_add_extent",
          "args": [
            "&isi"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_swapfile_add_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1954-1996",
          "snippet": "static int iomap_swapfile_add_extent(struct iomap_swapfile_info *isi)\n{\n\tstruct iomap *iomap = &isi->iomap;\n\tunsigned long nr_pages;\n\tuint64_t first_ppage;\n\tuint64_t first_ppage_reported;\n\tuint64_t next_ppage;\n\tint error;\n\n\t/*\n\t * Round the start up and the end down so that the physical\n\t * extent aligns to a page boundary.\n\t */\n\tfirst_ppage = ALIGN(iomap->addr, PAGE_SIZE) >> PAGE_SHIFT;\n\tnext_ppage = ALIGN_DOWN(iomap->addr + iomap->length, PAGE_SIZE) >>\n\t\t\tPAGE_SHIFT;\n\n\t/* Skip too-short physical extents. */\n\tif (first_ppage >= next_ppage)\n\t\treturn 0;\n\tnr_pages = next_ppage - first_ppage;\n\n\t/*\n\t * Calculate how much swap space we're adding; the first page contains\n\t * the swap header and doesn't count.  The mm still wants that first\n\t * page fed to add_swap_extent, however.\n\t */\n\tfirst_ppage_reported = first_ppage;\n\tif (iomap->offset == 0)\n\t\tfirst_ppage_reported++;\n\tif (isi->lowest_ppage > first_ppage_reported)\n\t\tisi->lowest_ppage = first_ppage_reported;\n\tif (isi->highest_ppage < (next_ppage - 1))\n\t\tisi->highest_ppage = next_ppage - 1;\n\n\t/* Add extent, set up for the next call. */\n\terror = add_swap_extent(isi->sis, isi->nr_pages, nr_pages, first_ppage);\n\tif (error < 0)\n\t\treturn error;\n\tisi->nr_extents += error;\n\tisi->nr_pages += nr_pages;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int iomap_swapfile_add_extent(struct iomap_swapfile_info *isi)\n{\n\tstruct iomap *iomap = &isi->iomap;\n\tunsigned long nr_pages;\n\tuint64_t first_ppage;\n\tuint64_t first_ppage_reported;\n\tuint64_t next_ppage;\n\tint error;\n\n\t/*\n\t * Round the start up and the end down so that the physical\n\t * extent aligns to a page boundary.\n\t */\n\tfirst_ppage = ALIGN(iomap->addr, PAGE_SIZE) >> PAGE_SHIFT;\n\tnext_ppage = ALIGN_DOWN(iomap->addr + iomap->length, PAGE_SIZE) >>\n\t\t\tPAGE_SHIFT;\n\n\t/* Skip too-short physical extents. */\n\tif (first_ppage >= next_ppage)\n\t\treturn 0;\n\tnr_pages = next_ppage - first_ppage;\n\n\t/*\n\t * Calculate how much swap space we're adding; the first page contains\n\t * the swap header and doesn't count.  The mm still wants that first\n\t * page fed to add_swap_extent, however.\n\t */\n\tfirst_ppage_reported = first_ppage;\n\tif (iomap->offset == 0)\n\t\tfirst_ppage_reported++;\n\tif (isi->lowest_ppage > first_ppage_reported)\n\t\tisi->lowest_ppage = first_ppage_reported;\n\tif (isi->highest_ppage < (next_ppage - 1))\n\t\tisi->highest_ppage = next_ppage - 1;\n\n\t/* Add extent, set up for the next call. */\n\terror = add_swap_extent(isi->sis, isi->nr_pages, nr_pages, first_ppage);\n\tif (error < 0)\n\t\treturn error;\n\tisi->nr_extents += error;\n\tisi->nr_pages += nr_pages;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "pos",
            "len",
            "IOMAP_REPORT",
            "ops",
            "&isi",
            "iomap_swapfile_activate_actor"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "swap_file",
            "1"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
          "lines": "209-212",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "i_size_read(inode)",
            "PAGE_SIZE"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint iomap_swapfile_activate(struct swap_info_struct *sis,\n\t\tstruct file *swap_file, sector_t *pagespan,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct iomap_swapfile_info isi = {\n\t\t.sis = sis,\n\t\t.lowest_ppage = (sector_t)-1ULL,\n\t};\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tloff_t pos = 0;\n\tloff_t len = ALIGN_DOWN(i_size_read(inode), PAGE_SIZE);\n\tloff_t ret;\n\n\t/*\n\t * Persist all file mapping metadata so that we won't have any\n\t * IOMAP_F_DIRTY iomaps.\n\t */\n\tret = vfs_fsync(swap_file, 1);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_REPORT,\n\t\t\t\tops, &isi, iomap_swapfile_activate_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\tif (isi.iomap.length) {\n\t\tret = iomap_swapfile_add_extent(&isi);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*pagespan = 1 + isi.highest_ppage - isi.lowest_ppage;\n\tsis->max = isi.nr_pages;\n\tsis->pages = isi.nr_pages - 1;\n\tsis->highest_bit = isi.nr_pages - 1;\n\treturn isi.nr_extents;\n}"
  },
  {
    "function_name": "iomap_swapfile_activate_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "2003-2053",
    "snippet": "static loff_t iomap_swapfile_activate_actor(struct inode *inode, loff_t pos,\n\t\tloff_t count, void *data, struct iomap *iomap)\n{\n\tstruct iomap_swapfile_info *isi = data;\n\tint error;\n\n\tswitch (iomap->type) {\n\tcase IOMAP_MAPPED:\n\tcase IOMAP_UNWRITTEN:\n\t\t/* Only real or unwritten extents. */\n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\t/* No inline data. */\n\t\tpr_err(\"swapon: file is inline\\n\");\n\t\treturn -EINVAL;\n\tdefault:\n\t\tpr_err(\"swapon: file has unallocated extents\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* No uncommitted metadata or shared blocks. */\n\tif (iomap->flags & IOMAP_F_DIRTY) {\n\t\tpr_err(\"swapon: file is not committed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (iomap->flags & IOMAP_F_SHARED) {\n\t\tpr_err(\"swapon: file has shared extents\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Only one bdev per swap file. */\n\tif (iomap->bdev != isi->sis->bdev) {\n\t\tpr_err(\"swapon: file is on multiple devices\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (isi->iomap.length == 0) {\n\t\t/* No accumulated extent, so just store it. */\n\t\tmemcpy(&isi->iomap, iomap, sizeof(isi->iomap));\n\t} else if (isi->iomap.addr + isi->iomap.length == iomap->addr) {\n\t\t/* Append this to the accumulated extent. */\n\t\tisi->iomap.length += iomap->length;\n\t} else {\n\t\t/* Otherwise, add the retained iomap and store this one. */\n\t\terror = iomap_swapfile_add_extent(isi);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmemcpy(&isi->iomap, iomap, sizeof(isi->iomap));\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&isi->iomap",
            "iomap",
            "sizeof(isi->iomap)"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_swapfile_add_extent",
          "args": [
            "isi"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_swapfile_add_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1954-1996",
          "snippet": "static int iomap_swapfile_add_extent(struct iomap_swapfile_info *isi)\n{\n\tstruct iomap *iomap = &isi->iomap;\n\tunsigned long nr_pages;\n\tuint64_t first_ppage;\n\tuint64_t first_ppage_reported;\n\tuint64_t next_ppage;\n\tint error;\n\n\t/*\n\t * Round the start up and the end down so that the physical\n\t * extent aligns to a page boundary.\n\t */\n\tfirst_ppage = ALIGN(iomap->addr, PAGE_SIZE) >> PAGE_SHIFT;\n\tnext_ppage = ALIGN_DOWN(iomap->addr + iomap->length, PAGE_SIZE) >>\n\t\t\tPAGE_SHIFT;\n\n\t/* Skip too-short physical extents. */\n\tif (first_ppage >= next_ppage)\n\t\treturn 0;\n\tnr_pages = next_ppage - first_ppage;\n\n\t/*\n\t * Calculate how much swap space we're adding; the first page contains\n\t * the swap header and doesn't count.  The mm still wants that first\n\t * page fed to add_swap_extent, however.\n\t */\n\tfirst_ppage_reported = first_ppage;\n\tif (iomap->offset == 0)\n\t\tfirst_ppage_reported++;\n\tif (isi->lowest_ppage > first_ppage_reported)\n\t\tisi->lowest_ppage = first_ppage_reported;\n\tif (isi->highest_ppage < (next_ppage - 1))\n\t\tisi->highest_ppage = next_ppage - 1;\n\n\t/* Add extent, set up for the next call. */\n\terror = add_swap_extent(isi->sis, isi->nr_pages, nr_pages, first_ppage);\n\tif (error < 0)\n\t\treturn error;\n\tisi->nr_extents += error;\n\tisi->nr_pages += nr_pages;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int iomap_swapfile_add_extent(struct iomap_swapfile_info *isi)\n{\n\tstruct iomap *iomap = &isi->iomap;\n\tunsigned long nr_pages;\n\tuint64_t first_ppage;\n\tuint64_t first_ppage_reported;\n\tuint64_t next_ppage;\n\tint error;\n\n\t/*\n\t * Round the start up and the end down so that the physical\n\t * extent aligns to a page boundary.\n\t */\n\tfirst_ppage = ALIGN(iomap->addr, PAGE_SIZE) >> PAGE_SHIFT;\n\tnext_ppage = ALIGN_DOWN(iomap->addr + iomap->length, PAGE_SIZE) >>\n\t\t\tPAGE_SHIFT;\n\n\t/* Skip too-short physical extents. */\n\tif (first_ppage >= next_ppage)\n\t\treturn 0;\n\tnr_pages = next_ppage - first_ppage;\n\n\t/*\n\t * Calculate how much swap space we're adding; the first page contains\n\t * the swap header and doesn't count.  The mm still wants that first\n\t * page fed to add_swap_extent, however.\n\t */\n\tfirst_ppage_reported = first_ppage;\n\tif (iomap->offset == 0)\n\t\tfirst_ppage_reported++;\n\tif (isi->lowest_ppage > first_ppage_reported)\n\t\tisi->lowest_ppage = first_ppage_reported;\n\tif (isi->highest_ppage < (next_ppage - 1))\n\t\tisi->highest_ppage = next_ppage - 1;\n\n\t/* Add extent, set up for the next call. */\n\terror = add_swap_extent(isi->sis, isi->nr_pages, nr_pages, first_ppage);\n\tif (error < 0)\n\t\treturn error;\n\tisi->nr_extents += error;\n\tisi->nr_pages += nr_pages;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&isi->iomap",
            "iomap",
            "sizeof(isi->iomap)"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swapon: file is on multiple devices\\n\""
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swapon: file has shared extents\\n\""
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swapon: file is not committed\\n\""
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swapon: file has unallocated extents\\n\""
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swapon: file is inline\\n\""
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t iomap_swapfile_activate_actor(struct inode *inode, loff_t pos,\n\t\tloff_t count, void *data, struct iomap *iomap)\n{\n\tstruct iomap_swapfile_info *isi = data;\n\tint error;\n\n\tswitch (iomap->type) {\n\tcase IOMAP_MAPPED:\n\tcase IOMAP_UNWRITTEN:\n\t\t/* Only real or unwritten extents. */\n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\t/* No inline data. */\n\t\tpr_err(\"swapon: file is inline\\n\");\n\t\treturn -EINVAL;\n\tdefault:\n\t\tpr_err(\"swapon: file has unallocated extents\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* No uncommitted metadata or shared blocks. */\n\tif (iomap->flags & IOMAP_F_DIRTY) {\n\t\tpr_err(\"swapon: file is not committed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (iomap->flags & IOMAP_F_SHARED) {\n\t\tpr_err(\"swapon: file has shared extents\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Only one bdev per swap file. */\n\tif (iomap->bdev != isi->sis->bdev) {\n\t\tpr_err(\"swapon: file is on multiple devices\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (isi->iomap.length == 0) {\n\t\t/* No accumulated extent, so just store it. */\n\t\tmemcpy(&isi->iomap, iomap, sizeof(isi->iomap));\n\t} else if (isi->iomap.addr + isi->iomap.length == iomap->addr) {\n\t\t/* Append this to the accumulated extent. */\n\t\tisi->iomap.length += iomap->length;\n\t} else {\n\t\t/* Otherwise, add the retained iomap and store this one. */\n\t\terror = iomap_swapfile_add_extent(isi);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmemcpy(&isi->iomap, iomap, sizeof(isi->iomap));\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "iomap_swapfile_add_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1954-1996",
    "snippet": "static int iomap_swapfile_add_extent(struct iomap_swapfile_info *isi)\n{\n\tstruct iomap *iomap = &isi->iomap;\n\tunsigned long nr_pages;\n\tuint64_t first_ppage;\n\tuint64_t first_ppage_reported;\n\tuint64_t next_ppage;\n\tint error;\n\n\t/*\n\t * Round the start up and the end down so that the physical\n\t * extent aligns to a page boundary.\n\t */\n\tfirst_ppage = ALIGN(iomap->addr, PAGE_SIZE) >> PAGE_SHIFT;\n\tnext_ppage = ALIGN_DOWN(iomap->addr + iomap->length, PAGE_SIZE) >>\n\t\t\tPAGE_SHIFT;\n\n\t/* Skip too-short physical extents. */\n\tif (first_ppage >= next_ppage)\n\t\treturn 0;\n\tnr_pages = next_ppage - first_ppage;\n\n\t/*\n\t * Calculate how much swap space we're adding; the first page contains\n\t * the swap header and doesn't count.  The mm still wants that first\n\t * page fed to add_swap_extent, however.\n\t */\n\tfirst_ppage_reported = first_ppage;\n\tif (iomap->offset == 0)\n\t\tfirst_ppage_reported++;\n\tif (isi->lowest_ppage > first_ppage_reported)\n\t\tisi->lowest_ppage = first_ppage_reported;\n\tif (isi->highest_ppage < (next_ppage - 1))\n\t\tisi->highest_ppage = next_ppage - 1;\n\n\t/* Add extent, set up for the next call. */\n\terror = add_swap_extent(isi->sis, isi->nr_pages, nr_pages, first_ppage);\n\tif (error < 0)\n\t\treturn error;\n\tisi->nr_extents += error;\n\tisi->nr_pages += nr_pages;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_swap_extent",
          "args": [
            "isi->sis",
            "isi->nr_pages",
            "nr_pages",
            "first_ppage"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "iomap->addr + iomap->length",
            "PAGE_SIZE"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "iomap->addr",
            "PAGE_SIZE"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int iomap_swapfile_add_extent(struct iomap_swapfile_info *isi)\n{\n\tstruct iomap *iomap = &isi->iomap;\n\tunsigned long nr_pages;\n\tuint64_t first_ppage;\n\tuint64_t first_ppage_reported;\n\tuint64_t next_ppage;\n\tint error;\n\n\t/*\n\t * Round the start up and the end down so that the physical\n\t * extent aligns to a page boundary.\n\t */\n\tfirst_ppage = ALIGN(iomap->addr, PAGE_SIZE) >> PAGE_SHIFT;\n\tnext_ppage = ALIGN_DOWN(iomap->addr + iomap->length, PAGE_SIZE) >>\n\t\t\tPAGE_SHIFT;\n\n\t/* Skip too-short physical extents. */\n\tif (first_ppage >= next_ppage)\n\t\treturn 0;\n\tnr_pages = next_ppage - first_ppage;\n\n\t/*\n\t * Calculate how much swap space we're adding; the first page contains\n\t * the swap header and doesn't count.  The mm still wants that first\n\t * page fed to add_swap_extent, however.\n\t */\n\tfirst_ppage_reported = first_ppage;\n\tif (iomap->offset == 0)\n\t\tfirst_ppage_reported++;\n\tif (isi->lowest_ppage > first_ppage_reported)\n\t\tisi->lowest_ppage = first_ppage_reported;\n\tif (isi->highest_ppage < (next_ppage - 1))\n\t\tisi->highest_ppage = next_ppage - 1;\n\n\t/* Add extent, set up for the next call. */\n\terror = add_swap_extent(isi->sis, isi->nr_pages, nr_pages, first_ppage);\n\tif (error < 0)\n\t\treturn error;\n\tisi->nr_extents += error;\n\tisi->nr_pages += nr_pages;\n\treturn 0;\n}"
  },
  {
    "function_name": "iomap_dio_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1777-1933",
    "snippet": "ssize_t\niomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,\n\t\tconst struct iomap_ops *ops, iomap_dio_end_io_t end_io)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tsize_t count = iov_iter_count(iter);\n\tloff_t pos = iocb->ki_pos, start = pos;\n\tloff_t end = iocb->ki_pos + count - 1, ret = 0;\n\tunsigned int flags = IOMAP_DIRECT;\n\tstruct blk_plug plug;\n\tstruct iomap_dio *dio;\n\n\tlockdep_assert_held(&inode->i_rwsem);\n\n\tif (!count)\n\t\treturn 0;\n\n\tdio = kmalloc(sizeof(*dio), GFP_KERNEL);\n\tif (!dio)\n\t\treturn -ENOMEM;\n\n\tdio->iocb = iocb;\n\tatomic_set(&dio->ref, 1);\n\tdio->size = 0;\n\tdio->i_size = i_size_read(inode);\n\tdio->end_io = end_io;\n\tdio->error = 0;\n\tdio->flags = 0;\n\tdio->wait_for_completion = is_sync_kiocb(iocb);\n\n\tdio->submit.iter = iter;\n\tdio->submit.waiter = current;\n\tdio->submit.cookie = BLK_QC_T_NONE;\n\tdio->submit.last_queue = NULL;\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tif (pos >= dio->i_size)\n\t\t\tgoto out_free_dio;\n\n\t\tif (iter_is_iovec(iter) && iov_iter_rw(iter) == READ)\n\t\t\tdio->flags |= IOMAP_DIO_DIRTY;\n\t} else {\n\t\tflags |= IOMAP_WRITE;\n\t\tdio->flags |= IOMAP_DIO_WRITE;\n\n\t\t/* for data sync or sync, we need sync completion processing */\n\t\tif (iocb->ki_flags & IOCB_DSYNC)\n\t\t\tdio->flags |= IOMAP_DIO_NEED_SYNC;\n\n\t\t/*\n\t\t * For datasync only writes, we optimistically try using FUA for\n\t\t * this IO.  Any non-FUA write that occurs will clear this flag,\n\t\t * hence we know before completion whether a cache flush is\n\t\t * necessary.\n\t\t */\n\t\tif ((iocb->ki_flags & (IOCB_DSYNC | IOCB_SYNC)) == IOCB_DSYNC)\n\t\t\tdio->flags |= IOMAP_DIO_WRITE_FUA;\n\t}\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (filemap_range_has_page(mapping, start, end)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_free_dio;\n\t\t}\n\t\tflags |= IOMAP_NOWAIT;\n\t}\n\n\tret = filemap_write_and_wait_range(mapping, start, end);\n\tif (ret)\n\t\tgoto out_free_dio;\n\n\t/*\n\t * Try to invalidate cache pages for the range we're direct\n\t * writing.  If this invalidation fails, tough, the write will\n\t * still work, but racing two incompatible write paths is a\n\t * pretty crazy thing to do, so we don't support it 100%.\n\t */\n\tret = invalidate_inode_pages2_range(mapping,\n\t\t\tstart >> PAGE_SHIFT, end >> PAGE_SHIFT);\n\tif (ret)\n\t\tdio_warn_stale_pagecache(iocb->ki_filp);\n\tret = 0;\n\n\tif (iov_iter_rw(iter) == WRITE && !dio->wait_for_completion &&\n\t    !inode->i_sb->s_dio_done_wq) {\n\t\tret = sb_init_dio_done_wq(inode->i_sb);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_dio;\n\t}\n\n\tinode_dio_begin(inode);\n\n\tblk_start_plug(&plug);\n\tdo {\n\t\tret = iomap_apply(inode, pos, count, flags, ops, dio,\n\t\t\t\tiomap_dio_actor);\n\t\tif (ret <= 0) {\n\t\t\t/* magic error code to fall back to buffered I/O */\n\t\t\tif (ret == -ENOTBLK) {\n\t\t\t\tdio->wait_for_completion = true;\n\t\t\t\tret = 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Splicing to pipes can fail on a full pipe. We have to\n\t\t\t * swallow this to make it look like a short IO\n\t\t\t * otherwise the higher splice layers will completely\n\t\t\t * mishandle the error and stop moving data.\n\t\t\t */\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tpos += ret;\n\n\t\tif (iov_iter_rw(iter) == READ && pos >= dio->i_size)\n\t\t\tbreak;\n\t} while ((count = iov_iter_count(iter)) > 0);\n\tblk_finish_plug(&plug);\n\n\tif (ret < 0)\n\t\tiomap_dio_set_error(dio, ret);\n\n\t/*\n\t * If all the writes we issued were FUA, we don't need to flush the\n\t * cache on IO completion. Clear the sync flag for this case.\n\t */\n\tif (dio->flags & IOMAP_DIO_WRITE_FUA)\n\t\tdio->flags &= ~IOMAP_DIO_NEED_SYNC;\n\n\tif (!atomic_dec_and_test(&dio->ref)) {\n\t\tif (!dio->wait_for_completion)\n\t\t\treturn -EIOCBQUEUED;\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!READ_ONCE(dio->submit.waiter))\n\t\t\t\tbreak;\n\n\t\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t\t    !dio->submit.last_queue ||\n\t\t\t    !blk_poll(dio->submit.last_queue,\n\t\t\t\t\t dio->submit.cookie))\n\t\t\t\tio_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\n\tret = iomap_dio_complete(dio);\n\n\treturn ret;\n\nout_free_dio:\n\tkfree(dio);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define IOMAP_DIO_DIRTY\t\t(1 << 31)",
      "#define IOMAP_DIO_WRITE\t\t(1 << 30)",
      "#define IOMAP_DIO_NEED_SYNC\t(1 << 29)",
      "#define IOMAP_DIO_WRITE_FUA\t(1 << 28)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dio"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_dio_complete",
          "args": [
            "dio"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1503-1509",
          "snippet": "static void iomap_dio_complete_work(struct work_struct *work)\n{\n\tstruct iomap_dio *dio = container_of(work, struct iomap_dio, aio.work);\n\tstruct kiocb *iocb = dio->iocb;\n\n\tiocb->ki_complete(iocb, iomap_dio_complete(dio), 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void iomap_dio_complete_work(struct work_struct *work)\n{\n\tstruct iomap_dio *dio = container_of(work, struct iomap_dio, aio.work);\n\tstruct kiocb *iocb = dio->iocb;\n\n\tiocb->ki_complete(iocb, iomap_dio_complete(dio), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_poll",
          "args": [
            "dio->submit.last_queue",
            "dio->submit.cookie"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dio->submit.waiter"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&dio->ref"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_dio_set_error",
          "args": [
            "dio",
            "ret"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dio_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1516-1519",
          "snippet": "static inline void iomap_dio_set_error(struct iomap_dio *dio, int ret)\n{\n\tcmpxchg(&dio->error, 0, ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic inline void iomap_dio_set_error(struct iomap_dio *dio, int ret)\n{\n\tcmpxchg(&dio->error, 0, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "pos",
            "count",
            "flags",
            "ops",
            "dio",
            "iomap_dio_actor"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dio_begin",
          "args": [
            "inode"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_init_dio_done_wq",
          "args": [
            "inode->i_sb"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "sb_init_dio_done_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/direct-io.c",
          "lines": "620-636",
          "snippet": "int sb_init_dio_done_wq(struct super_block *sb)\n{\n\tstruct workqueue_struct *old;\n\tstruct workqueue_struct *wq = alloc_workqueue(\"dio/%s\",\n\t\t\t\t\t\t      WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t\t      sb->s_id);\n\tif (!wq)\n\t\treturn -ENOMEM;\n\t/*\n\t * This has to be atomic as more DIOs can race to create the workqueue\n\t */\n\told = cmpxchg(&sb->s_dio_done_wq, NULL, wq);\n\t/* Someone created workqueue before us? Free ours... */\n\tif (old)\n\t\tdestroy_workqueue(wq);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint sb_init_dio_done_wq(struct super_block *sb)\n{\n\tstruct workqueue_struct *old;\n\tstruct workqueue_struct *wq = alloc_workqueue(\"dio/%s\",\n\t\t\t\t\t\t      WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t\t      sb->s_id);\n\tif (!wq)\n\t\treturn -ENOMEM;\n\t/*\n\t * This has to be atomic as more DIOs can race to create the workqueue\n\t */\n\told = cmpxchg(&sb->s_dio_done_wq, NULL, wq);\n\t/* Someone created workqueue before us? Free ours... */\n\tif (old)\n\t\tdestroy_workqueue(wq);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dio_warn_stale_pagecache",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "dio_warn_stale_pagecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/direct-io.c",
          "lines": "225-241",
          "snippet": "void dio_warn_stale_pagecache(struct file *filp)\n{\n\tstatic DEFINE_RATELIMIT_STATE(_rs, 86400 * HZ, DEFAULT_RATELIMIT_BURST);\n\tchar pathname[128];\n\tstruct inode *inode = file_inode(filp);\n\tchar *path;\n\n\terrseq_set(&inode->i_mapping->wb_err, -EIO);\n\tif (__ratelimit(&_rs)) {\n\t\tpath = file_path(filp, pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tpr_crit(\"Page cache invalidation failure on direct I/O.  Possible data corruption due to collision with buffered I/O!\\n\");\n\t\tpr_crit(\"File: %s PID: %d Comm: %.20s\\n\", path, current->pid,\n\t\t\tcurrent->comm);\n\t}\n}",
          "includes": [
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid dio_warn_stale_pagecache(struct file *filp)\n{\n\tstatic DEFINE_RATELIMIT_STATE(_rs, 86400 * HZ, DEFAULT_RATELIMIT_BURST);\n\tchar pathname[128];\n\tstruct inode *inode = file_inode(filp);\n\tchar *path;\n\n\terrseq_set(&inode->i_mapping->wb_err, -EIO);\n\tif (__ratelimit(&_rs)) {\n\t\tpath = file_path(filp, pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tpr_crit(\"Page cache invalidation failure on direct I/O.  Possible data corruption due to collision with buffered I/O!\\n\");\n\t\tpr_crit(\"File: %s PID: %d Comm: %.20s\\n\", path, current->pid,\n\t\t\tcurrent->comm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "mapping",
            "start >> PAGE_SHIFT",
            "end >> PAGE_SHIFT"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "mapping",
            "start",
            "end"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_filemap_write_and_wait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/write.c",
          "lines": "1962-1971",
          "snippet": "int nfs_filemap_write_and_wait_range(struct address_space *mapping,\n\t\tloff_t lstart, loff_t lend)\n{\n\tint ret;\n\n\tret = filemap_write_and_wait_range(mapping, lstart, lend);\n\tif (ret == 0)\n\t\tret = pnfs_sync_inode(mapping->host, true);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/iversion.h>",
            "#include <linux/wait.h>",
            "#include <linux/freezer.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint nfs_filemap_write_and_wait_range(struct address_space *mapping,\n\t\tloff_t lstart, loff_t lend)\n{\n\tint ret;\n\n\tret = filemap_write_and_wait_range(mapping, lstart, lend);\n\tif (ret == 0)\n\t\tret = pnfs_sync_inode(mapping->host, true);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_range_has_page",
          "args": [
            "mapping",
            "start",
            "end"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter_is_iovec",
          "args": [
            "iter"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dio->ref",
            "1"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*dio)",
            "GFP_KERNEL"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&inode->i_rwsem"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\n#define IOMAP_DIO_DIRTY\t\t(1 << 31)\n#define IOMAP_DIO_WRITE\t\t(1 << 30)\n#define IOMAP_DIO_NEED_SYNC\t(1 << 29)\n#define IOMAP_DIO_WRITE_FUA\t(1 << 28)\n\nssize_t\niomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,\n\t\tconst struct iomap_ops *ops, iomap_dio_end_io_t end_io)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tsize_t count = iov_iter_count(iter);\n\tloff_t pos = iocb->ki_pos, start = pos;\n\tloff_t end = iocb->ki_pos + count - 1, ret = 0;\n\tunsigned int flags = IOMAP_DIRECT;\n\tstruct blk_plug plug;\n\tstruct iomap_dio *dio;\n\n\tlockdep_assert_held(&inode->i_rwsem);\n\n\tif (!count)\n\t\treturn 0;\n\n\tdio = kmalloc(sizeof(*dio), GFP_KERNEL);\n\tif (!dio)\n\t\treturn -ENOMEM;\n\n\tdio->iocb = iocb;\n\tatomic_set(&dio->ref, 1);\n\tdio->size = 0;\n\tdio->i_size = i_size_read(inode);\n\tdio->end_io = end_io;\n\tdio->error = 0;\n\tdio->flags = 0;\n\tdio->wait_for_completion = is_sync_kiocb(iocb);\n\n\tdio->submit.iter = iter;\n\tdio->submit.waiter = current;\n\tdio->submit.cookie = BLK_QC_T_NONE;\n\tdio->submit.last_queue = NULL;\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tif (pos >= dio->i_size)\n\t\t\tgoto out_free_dio;\n\n\t\tif (iter_is_iovec(iter) && iov_iter_rw(iter) == READ)\n\t\t\tdio->flags |= IOMAP_DIO_DIRTY;\n\t} else {\n\t\tflags |= IOMAP_WRITE;\n\t\tdio->flags |= IOMAP_DIO_WRITE;\n\n\t\t/* for data sync or sync, we need sync completion processing */\n\t\tif (iocb->ki_flags & IOCB_DSYNC)\n\t\t\tdio->flags |= IOMAP_DIO_NEED_SYNC;\n\n\t\t/*\n\t\t * For datasync only writes, we optimistically try using FUA for\n\t\t * this IO.  Any non-FUA write that occurs will clear this flag,\n\t\t * hence we know before completion whether a cache flush is\n\t\t * necessary.\n\t\t */\n\t\tif ((iocb->ki_flags & (IOCB_DSYNC | IOCB_SYNC)) == IOCB_DSYNC)\n\t\t\tdio->flags |= IOMAP_DIO_WRITE_FUA;\n\t}\n\n\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\tif (filemap_range_has_page(mapping, start, end)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_free_dio;\n\t\t}\n\t\tflags |= IOMAP_NOWAIT;\n\t}\n\n\tret = filemap_write_and_wait_range(mapping, start, end);\n\tif (ret)\n\t\tgoto out_free_dio;\n\n\t/*\n\t * Try to invalidate cache pages for the range we're direct\n\t * writing.  If this invalidation fails, tough, the write will\n\t * still work, but racing two incompatible write paths is a\n\t * pretty crazy thing to do, so we don't support it 100%.\n\t */\n\tret = invalidate_inode_pages2_range(mapping,\n\t\t\tstart >> PAGE_SHIFT, end >> PAGE_SHIFT);\n\tif (ret)\n\t\tdio_warn_stale_pagecache(iocb->ki_filp);\n\tret = 0;\n\n\tif (iov_iter_rw(iter) == WRITE && !dio->wait_for_completion &&\n\t    !inode->i_sb->s_dio_done_wq) {\n\t\tret = sb_init_dio_done_wq(inode->i_sb);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_dio;\n\t}\n\n\tinode_dio_begin(inode);\n\n\tblk_start_plug(&plug);\n\tdo {\n\t\tret = iomap_apply(inode, pos, count, flags, ops, dio,\n\t\t\t\tiomap_dio_actor);\n\t\tif (ret <= 0) {\n\t\t\t/* magic error code to fall back to buffered I/O */\n\t\t\tif (ret == -ENOTBLK) {\n\t\t\t\tdio->wait_for_completion = true;\n\t\t\t\tret = 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Splicing to pipes can fail on a full pipe. We have to\n\t\t\t * swallow this to make it look like a short IO\n\t\t\t * otherwise the higher splice layers will completely\n\t\t\t * mishandle the error and stop moving data.\n\t\t\t */\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tpos += ret;\n\n\t\tif (iov_iter_rw(iter) == READ && pos >= dio->i_size)\n\t\t\tbreak;\n\t} while ((count = iov_iter_count(iter)) > 0);\n\tblk_finish_plug(&plug);\n\n\tif (ret < 0)\n\t\tiomap_dio_set_error(dio, ret);\n\n\t/*\n\t * If all the writes we issued were FUA, we don't need to flush the\n\t * cache on IO completion. Clear the sync flag for this case.\n\t */\n\tif (dio->flags & IOMAP_DIO_WRITE_FUA)\n\t\tdio->flags &= ~IOMAP_DIO_NEED_SYNC;\n\n\tif (!atomic_dec_and_test(&dio->ref)) {\n\t\tif (!dio->wait_for_completion)\n\t\t\treturn -EIOCBQUEUED;\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!READ_ONCE(dio->submit.waiter))\n\t\t\t\tbreak;\n\n\t\t\tif (!(iocb->ki_flags & IOCB_HIPRI) ||\n\t\t\t    !dio->submit.last_queue ||\n\t\t\t    !blk_poll(dio->submit.last_queue,\n\t\t\t\t\t dio->submit.cookie))\n\t\t\t\tio_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n\n\tret = iomap_dio_complete(dio);\n\n\treturn ret;\n\nout_free_dio:\n\tkfree(dio);\n\treturn ret;\n}"
  },
  {
    "function_name": "iomap_dio_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1743-1766",
    "snippet": "static loff_t\niomap_dio_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tstruct iomap_dio *dio = data;\n\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\tif (WARN_ON_ONCE(dio->flags & IOMAP_DIO_WRITE))\n\t\t\treturn -EIO;\n\t\treturn iomap_dio_hole_actor(length, dio);\n\tcase IOMAP_UNWRITTEN:\n\t\tif (!(dio->flags & IOMAP_DIO_WRITE))\n\t\t\treturn iomap_dio_hole_actor(length, dio);\n\t\treturn iomap_dio_bio_actor(inode, pos, length, dio, iomap);\n\tcase IOMAP_MAPPED:\n\t\treturn iomap_dio_bio_actor(inode, pos, length, dio, iomap);\n\tcase IOMAP_INLINE:\n\t\treturn iomap_dio_inline_actor(inode, pos, length, dio, iomap);\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define IOMAP_DIO_WRITE\t\t(1 << 30)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_dio_inline_actor",
          "args": [
            "inode",
            "pos",
            "length",
            "dio",
            "iomap"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dio_inline_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1716-1741",
          "snippet": "static loff_t\niomap_dio_inline_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tstruct iomap_dio *dio, struct iomap *iomap)\n{\n\tstruct iov_iter *iter = dio->submit.iter;\n\tsize_t copied;\n\n\tBUG_ON(pos + length > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\tif (dio->flags & IOMAP_DIO_WRITE) {\n\t\tloff_t size = inode->i_size;\n\n\t\tif (pos > size)\n\t\t\tmemset(iomap->inline_data + size, 0, pos - size);\n\t\tcopied = copy_from_iter(iomap->inline_data + pos, length, iter);\n\t\tif (copied) {\n\t\t\tif (pos + copied > size)\n\t\t\t\ti_size_write(inode, pos + copied);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else {\n\t\tcopied = copy_to_iter(iomap->inline_data + pos, length, iter);\n\t}\n\tdio->size += copied;\n\treturn copied;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IOMAP_DIO_WRITE\t\t(1 << 30)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\n#define IOMAP_DIO_WRITE\t\t(1 << 30)\n\nstatic loff_t\niomap_dio_inline_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tstruct iomap_dio *dio, struct iomap *iomap)\n{\n\tstruct iov_iter *iter = dio->submit.iter;\n\tsize_t copied;\n\n\tBUG_ON(pos + length > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\tif (dio->flags & IOMAP_DIO_WRITE) {\n\t\tloff_t size = inode->i_size;\n\n\t\tif (pos > size)\n\t\t\tmemset(iomap->inline_data + size, 0, pos - size);\n\t\tcopied = copy_from_iter(iomap->inline_data + pos, length, iter);\n\t\tif (copied) {\n\t\t\tif (pos + copied > size)\n\t\t\t\ti_size_write(inode, pos + copied);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else {\n\t\tcopied = copy_to_iter(iomap->inline_data + pos, length, iter);\n\t}\n\tdio->size += copied;\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_dio_bio_actor",
          "args": [
            "inode",
            "pos",
            "length",
            "dio",
            "iomap"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dio_bio_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1577-1706",
          "snippet": "static loff_t\niomap_dio_bio_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tstruct iomap_dio *dio, struct iomap *iomap)\n{\n\tunsigned int blkbits = blksize_bits(bdev_logical_block_size(iomap->bdev));\n\tunsigned int fs_block_size = i_blocksize(inode), pad;\n\tunsigned int align = iov_iter_alignment(dio->submit.iter);\n\tstruct iov_iter iter;\n\tstruct bio *bio;\n\tbool need_zeroout = false;\n\tbool use_fua = false;\n\tint nr_pages, ret = 0;\n\tsize_t copied = 0;\n\n\tif ((pos | length | align) & ((1 << blkbits) - 1))\n\t\treturn -EINVAL;\n\n\tif (iomap->type == IOMAP_UNWRITTEN) {\n\t\tdio->flags |= IOMAP_DIO_UNWRITTEN;\n\t\tneed_zeroout = true;\n\t}\n\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tdio->flags |= IOMAP_DIO_COW;\n\n\tif (iomap->flags & IOMAP_F_NEW) {\n\t\tneed_zeroout = true;\n\t} else if (iomap->type == IOMAP_MAPPED) {\n\t\t/*\n\t\t * Use a FUA write if we need datasync semantics, this is a pure\n\t\t * data IO that doesn't require any metadata updates (including\n\t\t * after IO completion such as unwritten extent conversion) and\n\t\t * the underlying device supports FUA. This allows us to avoid\n\t\t * cache flushes on IO completion.\n\t\t */\n\t\tif (!(iomap->flags & (IOMAP_F_SHARED|IOMAP_F_DIRTY)) &&\n\t\t    (dio->flags & IOMAP_DIO_WRITE_FUA) &&\n\t\t    blk_queue_fua(bdev_get_queue(iomap->bdev)))\n\t\t\tuse_fua = true;\n\t}\n\n\t/*\n\t * Operate on a partial iter trimmed to the extent we were called for.\n\t * We'll update the iter in the dio once we're done with this extent.\n\t */\n\titer = *dio->submit.iter;\n\tiov_iter_truncate(&iter, length);\n\n\tnr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);\n\tif (nr_pages <= 0)\n\t\treturn nr_pages;\n\n\tif (need_zeroout) {\n\t\t/* zero out from the start of the block to the write offset */\n\t\tpad = pos & (fs_block_size - 1);\n\t\tif (pad)\n\t\t\tiomap_dio_zero(dio, iomap, pos - pad, pad);\n\t}\n\n\tdo {\n\t\tsize_t n;\n\t\tif (dio->error) {\n\t\t\tiov_iter_revert(dio->submit.iter, copied);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbio = bio_alloc(GFP_KERNEL, nr_pages);\n\t\tbio_set_dev(bio, iomap->bdev);\n\t\tbio->bi_iter.bi_sector = iomap_sector(iomap, pos);\n\t\tbio->bi_write_hint = dio->iocb->ki_hint;\n\t\tbio->bi_ioprio = dio->iocb->ki_ioprio;\n\t\tbio->bi_private = dio;\n\t\tbio->bi_end_io = iomap_dio_bio_end_io;\n\n\t\tret = bio_iov_iter_get_pages(bio, &iter);\n\t\tif (unlikely(ret)) {\n\t\t\t/*\n\t\t\t * We have to stop part way through an IO. We must fall\n\t\t\t * through to the sub-block tail zeroing here, otherwise\n\t\t\t * this short IO may expose stale data in the tail of\n\t\t\t * the block we haven't written data to.\n\t\t\t */\n\t\t\tbio_put(bio);\n\t\t\tgoto zero_tail;\n\t\t}\n\n\t\tn = bio->bi_iter.bi_size;\n\t\tif (dio->flags & IOMAP_DIO_WRITE) {\n\t\t\tbio->bi_opf = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\t\t\tif (use_fua)\n\t\t\t\tbio->bi_opf |= REQ_FUA;\n\t\t\telse\n\t\t\t\tdio->flags &= ~IOMAP_DIO_WRITE_FUA;\n\t\t\ttask_io_account_write(n);\n\t\t} else {\n\t\t\tbio->bi_opf = REQ_OP_READ;\n\t\t\tif (dio->flags & IOMAP_DIO_DIRTY)\n\t\t\t\tbio_set_pages_dirty(bio);\n\t\t}\n\n\t\tiov_iter_advance(dio->submit.iter, n);\n\n\t\tdio->size += n;\n\t\tpos += n;\n\t\tcopied += n;\n\n\t\tnr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);\n\n\t\tatomic_inc(&dio->ref);\n\n\t\tdio->submit.last_queue = bdev_get_queue(iomap->bdev);\n\t\tdio->submit.cookie = submit_bio(bio);\n\t} while (nr_pages);\n\n\t/*\n\t * We need to zeroout the tail of a sub-block write if the extent type\n\t * requires zeroing or the write extends beyond EOF. If we don't zero\n\t * the block tail in the latter case, we can expose stale data via mmap\n\t * reads of the EOF block.\n\t */\nzero_tail:\n\tif (need_zeroout ||\n\t    ((dio->flags & IOMAP_DIO_WRITE) && pos >= i_size_read(inode))) {\n\t\t/* zero out from the end of the write to the end of the block */\n\t\tpad = pos & (fs_block_size - 1);\n\t\tif (pad)\n\t\t\tiomap_dio_zero(dio, iomap, pos, fs_block_size - pad);\n\t}\n\treturn copied ? copied : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IOMAP_DIO_DIRTY\t\t(1 << 31)",
            "#define IOMAP_DIO_WRITE\t\t(1 << 30)",
            "#define IOMAP_DIO_WRITE_FUA\t(1 << 28)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\n#define IOMAP_DIO_DIRTY\t\t(1 << 31)\n#define IOMAP_DIO_WRITE\t\t(1 << 30)\n#define IOMAP_DIO_WRITE_FUA\t(1 << 28)\n\nstatic loff_t\niomap_dio_bio_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tstruct iomap_dio *dio, struct iomap *iomap)\n{\n\tunsigned int blkbits = blksize_bits(bdev_logical_block_size(iomap->bdev));\n\tunsigned int fs_block_size = i_blocksize(inode), pad;\n\tunsigned int align = iov_iter_alignment(dio->submit.iter);\n\tstruct iov_iter iter;\n\tstruct bio *bio;\n\tbool need_zeroout = false;\n\tbool use_fua = false;\n\tint nr_pages, ret = 0;\n\tsize_t copied = 0;\n\n\tif ((pos | length | align) & ((1 << blkbits) - 1))\n\t\treturn -EINVAL;\n\n\tif (iomap->type == IOMAP_UNWRITTEN) {\n\t\tdio->flags |= IOMAP_DIO_UNWRITTEN;\n\t\tneed_zeroout = true;\n\t}\n\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tdio->flags |= IOMAP_DIO_COW;\n\n\tif (iomap->flags & IOMAP_F_NEW) {\n\t\tneed_zeroout = true;\n\t} else if (iomap->type == IOMAP_MAPPED) {\n\t\t/*\n\t\t * Use a FUA write if we need datasync semantics, this is a pure\n\t\t * data IO that doesn't require any metadata updates (including\n\t\t * after IO completion such as unwritten extent conversion) and\n\t\t * the underlying device supports FUA. This allows us to avoid\n\t\t * cache flushes on IO completion.\n\t\t */\n\t\tif (!(iomap->flags & (IOMAP_F_SHARED|IOMAP_F_DIRTY)) &&\n\t\t    (dio->flags & IOMAP_DIO_WRITE_FUA) &&\n\t\t    blk_queue_fua(bdev_get_queue(iomap->bdev)))\n\t\t\tuse_fua = true;\n\t}\n\n\t/*\n\t * Operate on a partial iter trimmed to the extent we were called for.\n\t * We'll update the iter in the dio once we're done with this extent.\n\t */\n\titer = *dio->submit.iter;\n\tiov_iter_truncate(&iter, length);\n\n\tnr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);\n\tif (nr_pages <= 0)\n\t\treturn nr_pages;\n\n\tif (need_zeroout) {\n\t\t/* zero out from the start of the block to the write offset */\n\t\tpad = pos & (fs_block_size - 1);\n\t\tif (pad)\n\t\t\tiomap_dio_zero(dio, iomap, pos - pad, pad);\n\t}\n\n\tdo {\n\t\tsize_t n;\n\t\tif (dio->error) {\n\t\t\tiov_iter_revert(dio->submit.iter, copied);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbio = bio_alloc(GFP_KERNEL, nr_pages);\n\t\tbio_set_dev(bio, iomap->bdev);\n\t\tbio->bi_iter.bi_sector = iomap_sector(iomap, pos);\n\t\tbio->bi_write_hint = dio->iocb->ki_hint;\n\t\tbio->bi_ioprio = dio->iocb->ki_ioprio;\n\t\tbio->bi_private = dio;\n\t\tbio->bi_end_io = iomap_dio_bio_end_io;\n\n\t\tret = bio_iov_iter_get_pages(bio, &iter);\n\t\tif (unlikely(ret)) {\n\t\t\t/*\n\t\t\t * We have to stop part way through an IO. We must fall\n\t\t\t * through to the sub-block tail zeroing here, otherwise\n\t\t\t * this short IO may expose stale data in the tail of\n\t\t\t * the block we haven't written data to.\n\t\t\t */\n\t\t\tbio_put(bio);\n\t\t\tgoto zero_tail;\n\t\t}\n\n\t\tn = bio->bi_iter.bi_size;\n\t\tif (dio->flags & IOMAP_DIO_WRITE) {\n\t\t\tbio->bi_opf = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\t\t\tif (use_fua)\n\t\t\t\tbio->bi_opf |= REQ_FUA;\n\t\t\telse\n\t\t\t\tdio->flags &= ~IOMAP_DIO_WRITE_FUA;\n\t\t\ttask_io_account_write(n);\n\t\t} else {\n\t\t\tbio->bi_opf = REQ_OP_READ;\n\t\t\tif (dio->flags & IOMAP_DIO_DIRTY)\n\t\t\t\tbio_set_pages_dirty(bio);\n\t\t}\n\n\t\tiov_iter_advance(dio->submit.iter, n);\n\n\t\tdio->size += n;\n\t\tpos += n;\n\t\tcopied += n;\n\n\t\tnr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);\n\n\t\tatomic_inc(&dio->ref);\n\n\t\tdio->submit.last_queue = bdev_get_queue(iomap->bdev);\n\t\tdio->submit.cookie = submit_bio(bio);\n\t} while (nr_pages);\n\n\t/*\n\t * We need to zeroout the tail of a sub-block write if the extent type\n\t * requires zeroing or the write extends beyond EOF. If we don't zero\n\t * the block tail in the latter case, we can expose stale data via mmap\n\t * reads of the EOF block.\n\t */\nzero_tail:\n\tif (need_zeroout ||\n\t    ((dio->flags & IOMAP_DIO_WRITE) && pos >= i_size_read(inode))) {\n\t\t/* zero out from the end of the write to the end of the block */\n\t\tpad = pos & (fs_block_size - 1);\n\t\tif (pad)\n\t\t\tiomap_dio_zero(dio, iomap, pos, fs_block_size - pad);\n\t}\n\treturn copied ? copied : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_dio_hole_actor",
          "args": [
            "length",
            "dio"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dio_hole_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1708-1714",
          "snippet": "static loff_t\niomap_dio_hole_actor(loff_t length, struct iomap_dio *dio)\n{\n\tlength = iov_iter_zero(length, dio->submit.iter);\n\tdio->size += length;\n\treturn length;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_dio_hole_actor(loff_t length, struct iomap_dio *dio)\n{\n\tlength = iov_iter_zero(length, dio->submit.iter);\n\tdio->size += length;\n\treturn length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dio->flags & IOMAP_DIO_WRITE"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\n#define IOMAP_DIO_WRITE\t\t(1 << 30)\n\nstatic loff_t\niomap_dio_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tstruct iomap_dio *dio = data;\n\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\tif (WARN_ON_ONCE(dio->flags & IOMAP_DIO_WRITE))\n\t\t\treturn -EIO;\n\t\treturn iomap_dio_hole_actor(length, dio);\n\tcase IOMAP_UNWRITTEN:\n\t\tif (!(dio->flags & IOMAP_DIO_WRITE))\n\t\t\treturn iomap_dio_hole_actor(length, dio);\n\t\treturn iomap_dio_bio_actor(inode, pos, length, dio, iomap);\n\tcase IOMAP_MAPPED:\n\t\treturn iomap_dio_bio_actor(inode, pos, length, dio, iomap);\n\tcase IOMAP_INLINE:\n\t\treturn iomap_dio_inline_actor(inode, pos, length, dio, iomap);\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n}"
  },
  {
    "function_name": "iomap_dio_inline_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1716-1741",
    "snippet": "static loff_t\niomap_dio_inline_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tstruct iomap_dio *dio, struct iomap *iomap)\n{\n\tstruct iov_iter *iter = dio->submit.iter;\n\tsize_t copied;\n\n\tBUG_ON(pos + length > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\tif (dio->flags & IOMAP_DIO_WRITE) {\n\t\tloff_t size = inode->i_size;\n\n\t\tif (pos > size)\n\t\t\tmemset(iomap->inline_data + size, 0, pos - size);\n\t\tcopied = copy_from_iter(iomap->inline_data + pos, length, iter);\n\t\tif (copied) {\n\t\t\tif (pos + copied > size)\n\t\t\t\ti_size_write(inode, pos + copied);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else {\n\t\tcopied = copy_to_iter(iomap->inline_data + pos, length, iter);\n\t}\n\tdio->size += copied;\n\treturn copied;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define IOMAP_DIO_WRITE\t\t(1 << 30)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_iter",
          "args": [
            "iomap->inline_data + pos",
            "length",
            "iter"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2059-2079",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos + copied"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2436-2448",
          "snippet": "static inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_iter",
          "args": [
            "iomap->inline_data + pos",
            "length",
            "iter"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iomap->inline_data + size",
            "0",
            "pos - size"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pos + length > PAGE_SIZE - offset_in_page(iomap->inline_data)"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "iomap->inline_data"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\n#define IOMAP_DIO_WRITE\t\t(1 << 30)\n\nstatic loff_t\niomap_dio_inline_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tstruct iomap_dio *dio, struct iomap *iomap)\n{\n\tstruct iov_iter *iter = dio->submit.iter;\n\tsize_t copied;\n\n\tBUG_ON(pos + length > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\tif (dio->flags & IOMAP_DIO_WRITE) {\n\t\tloff_t size = inode->i_size;\n\n\t\tif (pos > size)\n\t\t\tmemset(iomap->inline_data + size, 0, pos - size);\n\t\tcopied = copy_from_iter(iomap->inline_data + pos, length, iter);\n\t\tif (copied) {\n\t\t\tif (pos + copied > size)\n\t\t\t\ti_size_write(inode, pos + copied);\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t} else {\n\t\tcopied = copy_to_iter(iomap->inline_data + pos, length, iter);\n\t}\n\tdio->size += copied;\n\treturn copied;\n}"
  },
  {
    "function_name": "iomap_dio_hole_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1708-1714",
    "snippet": "static loff_t\niomap_dio_hole_actor(loff_t length, struct iomap_dio *dio)\n{\n\tlength = iov_iter_zero(length, dio->submit.iter);\n\tdio->size += length;\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_zero",
          "args": [
            "length",
            "dio->submit.iter"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_dio_hole_actor(loff_t length, struct iomap_dio *dio)\n{\n\tlength = iov_iter_zero(length, dio->submit.iter);\n\tdio->size += length;\n\treturn length;\n}"
  },
  {
    "function_name": "iomap_dio_bio_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1577-1706",
    "snippet": "static loff_t\niomap_dio_bio_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tstruct iomap_dio *dio, struct iomap *iomap)\n{\n\tunsigned int blkbits = blksize_bits(bdev_logical_block_size(iomap->bdev));\n\tunsigned int fs_block_size = i_blocksize(inode), pad;\n\tunsigned int align = iov_iter_alignment(dio->submit.iter);\n\tstruct iov_iter iter;\n\tstruct bio *bio;\n\tbool need_zeroout = false;\n\tbool use_fua = false;\n\tint nr_pages, ret = 0;\n\tsize_t copied = 0;\n\n\tif ((pos | length | align) & ((1 << blkbits) - 1))\n\t\treturn -EINVAL;\n\n\tif (iomap->type == IOMAP_UNWRITTEN) {\n\t\tdio->flags |= IOMAP_DIO_UNWRITTEN;\n\t\tneed_zeroout = true;\n\t}\n\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tdio->flags |= IOMAP_DIO_COW;\n\n\tif (iomap->flags & IOMAP_F_NEW) {\n\t\tneed_zeroout = true;\n\t} else if (iomap->type == IOMAP_MAPPED) {\n\t\t/*\n\t\t * Use a FUA write if we need datasync semantics, this is a pure\n\t\t * data IO that doesn't require any metadata updates (including\n\t\t * after IO completion such as unwritten extent conversion) and\n\t\t * the underlying device supports FUA. This allows us to avoid\n\t\t * cache flushes on IO completion.\n\t\t */\n\t\tif (!(iomap->flags & (IOMAP_F_SHARED|IOMAP_F_DIRTY)) &&\n\t\t    (dio->flags & IOMAP_DIO_WRITE_FUA) &&\n\t\t    blk_queue_fua(bdev_get_queue(iomap->bdev)))\n\t\t\tuse_fua = true;\n\t}\n\n\t/*\n\t * Operate on a partial iter trimmed to the extent we were called for.\n\t * We'll update the iter in the dio once we're done with this extent.\n\t */\n\titer = *dio->submit.iter;\n\tiov_iter_truncate(&iter, length);\n\n\tnr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);\n\tif (nr_pages <= 0)\n\t\treturn nr_pages;\n\n\tif (need_zeroout) {\n\t\t/* zero out from the start of the block to the write offset */\n\t\tpad = pos & (fs_block_size - 1);\n\t\tif (pad)\n\t\t\tiomap_dio_zero(dio, iomap, pos - pad, pad);\n\t}\n\n\tdo {\n\t\tsize_t n;\n\t\tif (dio->error) {\n\t\t\tiov_iter_revert(dio->submit.iter, copied);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbio = bio_alloc(GFP_KERNEL, nr_pages);\n\t\tbio_set_dev(bio, iomap->bdev);\n\t\tbio->bi_iter.bi_sector = iomap_sector(iomap, pos);\n\t\tbio->bi_write_hint = dio->iocb->ki_hint;\n\t\tbio->bi_ioprio = dio->iocb->ki_ioprio;\n\t\tbio->bi_private = dio;\n\t\tbio->bi_end_io = iomap_dio_bio_end_io;\n\n\t\tret = bio_iov_iter_get_pages(bio, &iter);\n\t\tif (unlikely(ret)) {\n\t\t\t/*\n\t\t\t * We have to stop part way through an IO. We must fall\n\t\t\t * through to the sub-block tail zeroing here, otherwise\n\t\t\t * this short IO may expose stale data in the tail of\n\t\t\t * the block we haven't written data to.\n\t\t\t */\n\t\t\tbio_put(bio);\n\t\t\tgoto zero_tail;\n\t\t}\n\n\t\tn = bio->bi_iter.bi_size;\n\t\tif (dio->flags & IOMAP_DIO_WRITE) {\n\t\t\tbio->bi_opf = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\t\t\tif (use_fua)\n\t\t\t\tbio->bi_opf |= REQ_FUA;\n\t\t\telse\n\t\t\t\tdio->flags &= ~IOMAP_DIO_WRITE_FUA;\n\t\t\ttask_io_account_write(n);\n\t\t} else {\n\t\t\tbio->bi_opf = REQ_OP_READ;\n\t\t\tif (dio->flags & IOMAP_DIO_DIRTY)\n\t\t\t\tbio_set_pages_dirty(bio);\n\t\t}\n\n\t\tiov_iter_advance(dio->submit.iter, n);\n\n\t\tdio->size += n;\n\t\tpos += n;\n\t\tcopied += n;\n\n\t\tnr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);\n\n\t\tatomic_inc(&dio->ref);\n\n\t\tdio->submit.last_queue = bdev_get_queue(iomap->bdev);\n\t\tdio->submit.cookie = submit_bio(bio);\n\t} while (nr_pages);\n\n\t/*\n\t * We need to zeroout the tail of a sub-block write if the extent type\n\t * requires zeroing or the write extends beyond EOF. If we don't zero\n\t * the block tail in the latter case, we can expose stale data via mmap\n\t * reads of the EOF block.\n\t */\nzero_tail:\n\tif (need_zeroout ||\n\t    ((dio->flags & IOMAP_DIO_WRITE) && pos >= i_size_read(inode))) {\n\t\t/* zero out from the end of the write to the end of the block */\n\t\tpad = pos & (fs_block_size - 1);\n\t\tif (pad)\n\t\t\tiomap_dio_zero(dio, iomap, pos, fs_block_size - pad);\n\t}\n\treturn copied ? copied : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define IOMAP_DIO_DIRTY\t\t(1 << 31)",
      "#define IOMAP_DIO_WRITE\t\t(1 << 30)",
      "#define IOMAP_DIO_WRITE_FUA\t(1 << 28)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_dio_zero",
          "args": [
            "dio",
            "iomap",
            "pos",
            "fs_block_size - pad"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dio_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1556-1575",
          "snippet": "static blk_qc_t\niomap_dio_zero(struct iomap_dio *dio, struct iomap *iomap, loff_t pos,\n\t\tunsigned len)\n{\n\tstruct page *page = ZERO_PAGE(0);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(GFP_KERNEL, 1);\n\tbio_set_dev(bio, iomap->bdev);\n\tbio->bi_iter.bi_sector = iomap_sector(iomap, pos);\n\tbio->bi_private = dio;\n\tbio->bi_end_io = iomap_dio_bio_end_io;\n\n\tget_page(page);\n\t__bio_add_page(bio, page, len, 0);\n\tbio_set_op_attrs(bio, REQ_OP_WRITE, REQ_SYNC | REQ_IDLE);\n\n\tatomic_inc(&dio->ref);\n\treturn submit_bio(bio);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic blk_qc_t\niomap_dio_zero(struct iomap_dio *dio, struct iomap *iomap, loff_t pos,\n\t\tunsigned len)\n{\n\tstruct page *page = ZERO_PAGE(0);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(GFP_KERNEL, 1);\n\tbio_set_dev(bio, iomap->bdev);\n\tbio->bi_iter.bi_sector = iomap_sector(iomap, pos);\n\tbio->bi_private = dio;\n\tbio->bi_end_io = iomap_dio_bio_end_io;\n\n\tget_page(page);\n\t__bio_add_page(bio, page, len, 0);\n\tbio_set_op_attrs(bio, REQ_OP_WRITE, REQ_SYNC | REQ_IDLE);\n\n\tatomic_inc(&dio->ref);\n\treturn submit_bio(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "bio"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-116",
          "snippet": "static struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "iomap->bdev"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dio->ref"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_npages",
          "args": [
            "&iter",
            "BIO_MAX_PAGES"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "dio->submit.iter",
            "n"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_pages_dirty",
          "args": [
            "bio"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_account_write",
          "args": [
            "n"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_iov_iter_get_pages",
          "args": [
            "bio",
            "&iter"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_sector",
          "args": [
            "iomap",
            "pos"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "101-105",
          "snippet": "static sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "bio",
            "iomap->bdev"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_KERNEL",
            "nr_pages"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.c",
          "lines": "2667-2676",
          "snippet": "struct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set btrfs_bioset;\n\nstruct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_revert",
          "args": [
            "dio->submit.iter",
            "copied"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_npages",
          "args": [
            "&iter",
            "BIO_MAX_PAGES"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "&iter",
            "length"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_fua",
          "args": [
            "bdev_get_queue(iomap->bdev)"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "iomap->bdev"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_alignment",
          "args": [
            "dio->submit.iter"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "bdev_logical_block_size(iomap->bdev)"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "iomap->bdev"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\n#define IOMAP_DIO_DIRTY\t\t(1 << 31)\n#define IOMAP_DIO_WRITE\t\t(1 << 30)\n#define IOMAP_DIO_WRITE_FUA\t(1 << 28)\n\nstatic loff_t\niomap_dio_bio_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tstruct iomap_dio *dio, struct iomap *iomap)\n{\n\tunsigned int blkbits = blksize_bits(bdev_logical_block_size(iomap->bdev));\n\tunsigned int fs_block_size = i_blocksize(inode), pad;\n\tunsigned int align = iov_iter_alignment(dio->submit.iter);\n\tstruct iov_iter iter;\n\tstruct bio *bio;\n\tbool need_zeroout = false;\n\tbool use_fua = false;\n\tint nr_pages, ret = 0;\n\tsize_t copied = 0;\n\n\tif ((pos | length | align) & ((1 << blkbits) - 1))\n\t\treturn -EINVAL;\n\n\tif (iomap->type == IOMAP_UNWRITTEN) {\n\t\tdio->flags |= IOMAP_DIO_UNWRITTEN;\n\t\tneed_zeroout = true;\n\t}\n\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tdio->flags |= IOMAP_DIO_COW;\n\n\tif (iomap->flags & IOMAP_F_NEW) {\n\t\tneed_zeroout = true;\n\t} else if (iomap->type == IOMAP_MAPPED) {\n\t\t/*\n\t\t * Use a FUA write if we need datasync semantics, this is a pure\n\t\t * data IO that doesn't require any metadata updates (including\n\t\t * after IO completion such as unwritten extent conversion) and\n\t\t * the underlying device supports FUA. This allows us to avoid\n\t\t * cache flushes on IO completion.\n\t\t */\n\t\tif (!(iomap->flags & (IOMAP_F_SHARED|IOMAP_F_DIRTY)) &&\n\t\t    (dio->flags & IOMAP_DIO_WRITE_FUA) &&\n\t\t    blk_queue_fua(bdev_get_queue(iomap->bdev)))\n\t\t\tuse_fua = true;\n\t}\n\n\t/*\n\t * Operate on a partial iter trimmed to the extent we were called for.\n\t * We'll update the iter in the dio once we're done with this extent.\n\t */\n\titer = *dio->submit.iter;\n\tiov_iter_truncate(&iter, length);\n\n\tnr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);\n\tif (nr_pages <= 0)\n\t\treturn nr_pages;\n\n\tif (need_zeroout) {\n\t\t/* zero out from the start of the block to the write offset */\n\t\tpad = pos & (fs_block_size - 1);\n\t\tif (pad)\n\t\t\tiomap_dio_zero(dio, iomap, pos - pad, pad);\n\t}\n\n\tdo {\n\t\tsize_t n;\n\t\tif (dio->error) {\n\t\t\tiov_iter_revert(dio->submit.iter, copied);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbio = bio_alloc(GFP_KERNEL, nr_pages);\n\t\tbio_set_dev(bio, iomap->bdev);\n\t\tbio->bi_iter.bi_sector = iomap_sector(iomap, pos);\n\t\tbio->bi_write_hint = dio->iocb->ki_hint;\n\t\tbio->bi_ioprio = dio->iocb->ki_ioprio;\n\t\tbio->bi_private = dio;\n\t\tbio->bi_end_io = iomap_dio_bio_end_io;\n\n\t\tret = bio_iov_iter_get_pages(bio, &iter);\n\t\tif (unlikely(ret)) {\n\t\t\t/*\n\t\t\t * We have to stop part way through an IO. We must fall\n\t\t\t * through to the sub-block tail zeroing here, otherwise\n\t\t\t * this short IO may expose stale data in the tail of\n\t\t\t * the block we haven't written data to.\n\t\t\t */\n\t\t\tbio_put(bio);\n\t\t\tgoto zero_tail;\n\t\t}\n\n\t\tn = bio->bi_iter.bi_size;\n\t\tif (dio->flags & IOMAP_DIO_WRITE) {\n\t\t\tbio->bi_opf = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\t\t\tif (use_fua)\n\t\t\t\tbio->bi_opf |= REQ_FUA;\n\t\t\telse\n\t\t\t\tdio->flags &= ~IOMAP_DIO_WRITE_FUA;\n\t\t\ttask_io_account_write(n);\n\t\t} else {\n\t\t\tbio->bi_opf = REQ_OP_READ;\n\t\t\tif (dio->flags & IOMAP_DIO_DIRTY)\n\t\t\t\tbio_set_pages_dirty(bio);\n\t\t}\n\n\t\tiov_iter_advance(dio->submit.iter, n);\n\n\t\tdio->size += n;\n\t\tpos += n;\n\t\tcopied += n;\n\n\t\tnr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);\n\n\t\tatomic_inc(&dio->ref);\n\n\t\tdio->submit.last_queue = bdev_get_queue(iomap->bdev);\n\t\tdio->submit.cookie = submit_bio(bio);\n\t} while (nr_pages);\n\n\t/*\n\t * We need to zeroout the tail of a sub-block write if the extent type\n\t * requires zeroing or the write extends beyond EOF. If we don't zero\n\t * the block tail in the latter case, we can expose stale data via mmap\n\t * reads of the EOF block.\n\t */\nzero_tail:\n\tif (need_zeroout ||\n\t    ((dio->flags & IOMAP_DIO_WRITE) && pos >= i_size_read(inode))) {\n\t\t/* zero out from the end of the write to the end of the block */\n\t\tpad = pos & (fs_block_size - 1);\n\t\tif (pad)\n\t\t\tiomap_dio_zero(dio, iomap, pos, fs_block_size - pad);\n\t}\n\treturn copied ? copied : ret;\n}"
  },
  {
    "function_name": "iomap_dio_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1556-1575",
    "snippet": "static blk_qc_t\niomap_dio_zero(struct iomap_dio *dio, struct iomap *iomap, loff_t pos,\n\t\tunsigned len)\n{\n\tstruct page *page = ZERO_PAGE(0);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(GFP_KERNEL, 1);\n\tbio_set_dev(bio, iomap->bdev);\n\tbio->bi_iter.bi_sector = iomap_sector(iomap, pos);\n\tbio->bi_private = dio;\n\tbio->bi_end_io = iomap_dio_bio_end_io;\n\n\tget_page(page);\n\t__bio_add_page(bio, page, len, 0);\n\tbio_set_op_attrs(bio, REQ_OP_WRITE, REQ_SYNC | REQ_IDLE);\n\n\tatomic_inc(&dio->ref);\n\treturn submit_bio(bio);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "bio"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-116",
          "snippet": "static struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dio->ref"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_op_attrs",
          "args": [
            "bio",
            "REQ_OP_WRITE",
            "REQ_SYNC | REQ_IDLE"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bio_add_page",
          "args": [
            "bio",
            "page",
            "len",
            "0"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_sector",
          "args": [
            "iomap",
            "pos"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "101-105",
          "snippet": "static sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "bio",
            "iomap->bdev"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_KERNEL",
            "1"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.c",
          "lines": "2667-2676",
          "snippet": "struct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set btrfs_bioset;\n\nstruct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic blk_qc_t\niomap_dio_zero(struct iomap_dio *dio, struct iomap *iomap, loff_t pos,\n\t\tunsigned len)\n{\n\tstruct page *page = ZERO_PAGE(0);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(GFP_KERNEL, 1);\n\tbio_set_dev(bio, iomap->bdev);\n\tbio->bi_iter.bi_sector = iomap_sector(iomap, pos);\n\tbio->bi_private = dio;\n\tbio->bi_end_io = iomap_dio_bio_end_io;\n\n\tget_page(page);\n\t__bio_add_page(bio, page, len, 0);\n\tbio_set_op_attrs(bio, REQ_OP_WRITE, REQ_SYNC | REQ_IDLE);\n\n\tatomic_inc(&dio->ref);\n\treturn submit_bio(bio);\n}"
  },
  {
    "function_name": "iomap_dio_bio_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1521-1554",
    "snippet": "static void iomap_dio_bio_end_io(struct bio *bio)\n{\n\tstruct iomap_dio *dio = bio->bi_private;\n\tbool should_dirty = (dio->flags & IOMAP_DIO_DIRTY);\n\n\tif (bio->bi_status)\n\t\tiomap_dio_set_error(dio, blk_status_to_errno(bio->bi_status));\n\n\tif (atomic_dec_and_test(&dio->ref)) {\n\t\tif (dio->wait_for_completion) {\n\t\t\tstruct task_struct *waiter = dio->submit.waiter;\n\t\t\tWRITE_ONCE(dio->submit.waiter, NULL);\n\t\t\twake_up_process(waiter);\n\t\t} else if (dio->flags & IOMAP_DIO_WRITE) {\n\t\t\tstruct inode *inode = file_inode(dio->iocb->ki_filp);\n\n\t\t\tINIT_WORK(&dio->aio.work, iomap_dio_complete_work);\n\t\t\tqueue_work(inode->i_sb->s_dio_done_wq, &dio->aio.work);\n\t\t} else {\n\t\t\tiomap_dio_complete_work(&dio->aio.work);\n\t\t}\n\t}\n\n\tif (should_dirty) {\n\t\tbio_check_pages_dirty(bio);\n\t} else {\n\t\tstruct bio_vec *bvec;\n\t\tint i;\n\n\t\tbio_for_each_segment_all(bvec, bio, i)\n\t\t\tput_page(bvec->bv_page);\n\t\tbio_put(bio);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define IOMAP_DIO_DIRTY\t\t(1 << 31)",
      "#define IOMAP_DIO_WRITE\t\t(1 << 30)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "bvec->bv_page"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_check_pages_dirty",
          "args": [
            "bio"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_dio_complete_work",
          "args": [
            "&dio->aio.work"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1503-1509",
          "snippet": "static void iomap_dio_complete_work(struct work_struct *work)\n{\n\tstruct iomap_dio *dio = container_of(work, struct iomap_dio, aio.work);\n\tstruct kiocb *iocb = dio->iocb;\n\n\tiocb->ki_complete(iocb, iomap_dio_complete(dio), 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void iomap_dio_complete_work(struct work_struct *work)\n{\n\tstruct iomap_dio *dio = container_of(work, struct iomap_dio, aio.work);\n\tstruct kiocb *iocb = dio->iocb;\n\n\tiocb->ki_complete(iocb, iomap_dio_complete(dio), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "inode->i_sb->s_dio_done_wq",
            "&dio->aio.work"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "wb_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "187-204",
          "snippet": "static void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&dio->aio.work",
            "iomap_dio_complete_work"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "dio->iocb->ki_filp"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "waiter"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "dio->submit.waiter",
            "NULL"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&dio->ref"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_dio_set_error",
          "args": [
            "dio",
            "blk_status_to_errno(bio->bi_status)"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dio_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1516-1519",
          "snippet": "static inline void iomap_dio_set_error(struct iomap_dio *dio, int ret)\n{\n\tcmpxchg(&dio->error, 0, ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic inline void iomap_dio_set_error(struct iomap_dio *dio, int ret)\n{\n\tcmpxchg(&dio->error, 0, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "bio->bi_status"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\n#define IOMAP_DIO_DIRTY\t\t(1 << 31)\n#define IOMAP_DIO_WRITE\t\t(1 << 30)\n\nstatic void iomap_dio_bio_end_io(struct bio *bio)\n{\n\tstruct iomap_dio *dio = bio->bi_private;\n\tbool should_dirty = (dio->flags & IOMAP_DIO_DIRTY);\n\n\tif (bio->bi_status)\n\t\tiomap_dio_set_error(dio, blk_status_to_errno(bio->bi_status));\n\n\tif (atomic_dec_and_test(&dio->ref)) {\n\t\tif (dio->wait_for_completion) {\n\t\t\tstruct task_struct *waiter = dio->submit.waiter;\n\t\t\tWRITE_ONCE(dio->submit.waiter, NULL);\n\t\t\twake_up_process(waiter);\n\t\t} else if (dio->flags & IOMAP_DIO_WRITE) {\n\t\t\tstruct inode *inode = file_inode(dio->iocb->ki_filp);\n\n\t\t\tINIT_WORK(&dio->aio.work, iomap_dio_complete_work);\n\t\t\tqueue_work(inode->i_sb->s_dio_done_wq, &dio->aio.work);\n\t\t} else {\n\t\t\tiomap_dio_complete_work(&dio->aio.work);\n\t\t}\n\t}\n\n\tif (should_dirty) {\n\t\tbio_check_pages_dirty(bio);\n\t} else {\n\t\tstruct bio_vec *bvec;\n\t\tint i;\n\n\t\tbio_for_each_segment_all(bvec, bio, i)\n\t\t\tput_page(bvec->bv_page);\n\t\tbio_put(bio);\n\t}\n}"
  },
  {
    "function_name": "iomap_dio_set_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1516-1519",
    "snippet": "static inline void iomap_dio_set_error(struct iomap_dio *dio, int ret)\n{\n\tcmpxchg(&dio->error, 0, ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&dio->error",
            "0",
            "ret"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic inline void iomap_dio_set_error(struct iomap_dio *dio, int ret)\n{\n\tcmpxchg(&dio->error, 0, ret);\n}"
  },
  {
    "function_name": "iomap_dio_complete_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1503-1509",
    "snippet": "static void iomap_dio_complete_work(struct work_struct *work)\n{\n\tstruct iomap_dio *dio = container_of(work, struct iomap_dio, aio.work);\n\tstruct kiocb *iocb = dio->iocb;\n\n\tiocb->ki_complete(iocb, iomap_dio_complete(dio), 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iocb->ki_complete",
          "args": [
            "iocb",
            "iomap_dio_complete(dio)",
            "0"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_dio_complete",
          "args": [
            "dio"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1503-1509",
          "snippet": "static void iomap_dio_complete_work(struct work_struct *work)\n{\n\tstruct iomap_dio *dio = container_of(work, struct iomap_dio, aio.work);\n\tstruct kiocb *iocb = dio->iocb;\n\n\tiocb->ki_complete(iocb, iomap_dio_complete(dio), 0);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structiomap_dio",
            "aio.work"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void iomap_dio_complete_work(struct work_struct *work)\n{\n\tstruct iomap_dio *dio = container_of(work, struct iomap_dio, aio.work);\n\tstruct kiocb *iocb = dio->iocb;\n\n\tiocb->ki_complete(iocb, iomap_dio_complete(dio), 0);\n}"
  },
  {
    "function_name": "iomap_dio_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1444-1501",
    "snippet": "static ssize_t iomap_dio_complete(struct iomap_dio *dio)\n{\n\tstruct kiocb *iocb = dio->iocb;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tloff_t offset = iocb->ki_pos;\n\tssize_t ret;\n\n\tif (dio->end_io) {\n\t\tret = dio->end_io(iocb,\n\t\t\t\tdio->error ? dio->error : dio->size,\n\t\t\t\tdio->flags);\n\t} else {\n\t\tret = dio->error;\n\t}\n\n\tif (likely(!ret)) {\n\t\tret = dio->size;\n\t\t/* check for short read */\n\t\tif (offset + ret > dio->i_size &&\n\t\t    !(dio->flags & IOMAP_DIO_WRITE))\n\t\t\tret = dio->i_size - offset;\n\t\tiocb->ki_pos += ret;\n\t}\n\n\t/*\n\t * Try again to invalidate clean pages which might have been cached by\n\t * non-direct readahead, or faulted in by get_user_pages() if the source\n\t * of the write was an mmap'ed region of the file we're writing.  Either\n\t * one is a pretty crazy thing to do, so we don't support it 100%.  If\n\t * this invalidation fails, tough, the write still worked...\n\t *\n\t * And this page cache invalidation has to be after dio->end_io(), as\n\t * some filesystems convert unwritten extents to real allocations in\n\t * end_io() when necessary, otherwise a racing buffer read would cache\n\t * zeros from unwritten extents.\n\t */\n\tif (!dio->error &&\n\t    (dio->flags & IOMAP_DIO_WRITE) && inode->i_mapping->nrpages) {\n\t\tint err;\n\t\terr = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\toffset >> PAGE_SHIFT,\n\t\t\t\t(offset + dio->size - 1) >> PAGE_SHIFT);\n\t\tif (err)\n\t\t\tdio_warn_stale_pagecache(iocb->ki_filp);\n\t}\n\n\t/*\n\t * If this is a DSYNC write, make sure we push it to stable storage now\n\t * that we've written data.\n\t */\n\tif (ret > 0 && (dio->flags & IOMAP_DIO_NEED_SYNC))\n\t\tret = generic_write_sync(iocb, ret);\n\n\tinode_dio_end(file_inode(iocb->ki_filp));\n\tkfree(dio);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define IOMAP_DIO_WRITE\t\t(1 << 30)",
      "#define IOMAP_DIO_NEED_SYNC\t(1 << 29)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dio"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_end",
          "args": [
            "file_inode(iocb->ki_filp)"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "iocb",
            "ret"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dio_warn_stale_pagecache",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "dio_warn_stale_pagecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/direct-io.c",
          "lines": "225-241",
          "snippet": "void dio_warn_stale_pagecache(struct file *filp)\n{\n\tstatic DEFINE_RATELIMIT_STATE(_rs, 86400 * HZ, DEFAULT_RATELIMIT_BURST);\n\tchar pathname[128];\n\tstruct inode *inode = file_inode(filp);\n\tchar *path;\n\n\terrseq_set(&inode->i_mapping->wb_err, -EIO);\n\tif (__ratelimit(&_rs)) {\n\t\tpath = file_path(filp, pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tpr_crit(\"Page cache invalidation failure on direct I/O.  Possible data corruption due to collision with buffered I/O!\\n\");\n\t\tpr_crit(\"File: %s PID: %d Comm: %.20s\\n\", path, current->pid,\n\t\t\tcurrent->comm);\n\t}\n}",
          "includes": [
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid dio_warn_stale_pagecache(struct file *filp)\n{\n\tstatic DEFINE_RATELIMIT_STATE(_rs, 86400 * HZ, DEFAULT_RATELIMIT_BURST);\n\tchar pathname[128];\n\tstruct inode *inode = file_inode(filp);\n\tchar *path;\n\n\terrseq_set(&inode->i_mapping->wb_err, -EIO);\n\tif (__ratelimit(&_rs)) {\n\t\tpath = file_path(filp, pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tpr_crit(\"Page cache invalidation failure on direct I/O.  Possible data corruption due to collision with buffered I/O!\\n\");\n\t\tpr_crit(\"File: %s PID: %d Comm: %.20s\\n\", path, current->pid,\n\t\t\tcurrent->comm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "inode->i_mapping",
            "offset >> PAGE_SHIFT",
            "(offset + dio->size - 1) >> PAGE_SHIFT"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dio->end_io",
          "args": [
            "iocb",
            "dio->error ? dio->error : dio->size",
            "dio->flags"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\n#define IOMAP_DIO_WRITE\t\t(1 << 30)\n#define IOMAP_DIO_NEED_SYNC\t(1 << 29)\n\nstatic ssize_t iomap_dio_complete(struct iomap_dio *dio)\n{\n\tstruct kiocb *iocb = dio->iocb;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tloff_t offset = iocb->ki_pos;\n\tssize_t ret;\n\n\tif (dio->end_io) {\n\t\tret = dio->end_io(iocb,\n\t\t\t\tdio->error ? dio->error : dio->size,\n\t\t\t\tdio->flags);\n\t} else {\n\t\tret = dio->error;\n\t}\n\n\tif (likely(!ret)) {\n\t\tret = dio->size;\n\t\t/* check for short read */\n\t\tif (offset + ret > dio->i_size &&\n\t\t    !(dio->flags & IOMAP_DIO_WRITE))\n\t\t\tret = dio->i_size - offset;\n\t\tiocb->ki_pos += ret;\n\t}\n\n\t/*\n\t * Try again to invalidate clean pages which might have been cached by\n\t * non-direct readahead, or faulted in by get_user_pages() if the source\n\t * of the write was an mmap'ed region of the file we're writing.  Either\n\t * one is a pretty crazy thing to do, so we don't support it 100%.  If\n\t * this invalidation fails, tough, the write still worked...\n\t *\n\t * And this page cache invalidation has to be after dio->end_io(), as\n\t * some filesystems convert unwritten extents to real allocations in\n\t * end_io() when necessary, otherwise a racing buffer read would cache\n\t * zeros from unwritten extents.\n\t */\n\tif (!dio->error &&\n\t    (dio->flags & IOMAP_DIO_WRITE) && inode->i_mapping->nrpages) {\n\t\tint err;\n\t\terr = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\toffset >> PAGE_SHIFT,\n\t\t\t\t(offset + dio->size - 1) >> PAGE_SHIFT);\n\t\tif (err)\n\t\t\tdio_warn_stale_pagecache(iocb->ki_filp);\n\t}\n\n\t/*\n\t * If this is a DSYNC write, make sure we push it to stable storage now\n\t * that we've written data.\n\t */\n\tif (ret > 0 && (dio->flags & IOMAP_DIO_NEED_SYNC))\n\t\tret = generic_write_sync(iocb, ret);\n\n\tinode_dio_end(file_inode(iocb->ki_filp));\n\tkfree(dio);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iomap_seek_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1380-1406",
    "snippet": "loff_t\niomap_seek_data(struct inode *inode, loff_t offset, const struct iomap_ops *ops)\n{\n\tloff_t size = i_size_read(inode);\n\tloff_t length = size - offset;\n\tloff_t ret;\n\n\t/* Nothing to be found before or beyond the end of the file. */\n\tif (offset < 0 || offset >= size)\n\t\treturn -ENXIO;\n\n\twhile (length > 0) {\n\t\tret = iomap_apply(inode, offset, length, IOMAP_REPORT, ops,\n\t\t\t\t  &offset, iomap_seek_data_actor);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\toffset += ret;\n\t\tlength -= ret;\n\t}\n\n\tif (length <= 0)\n\t\treturn -ENXIO;\n\treturn offset;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "offset",
            "length",
            "IOMAP_REPORT",
            "ops",
            "&offset",
            "iomap_seek_data_actor"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_seek_data(struct inode *inode, loff_t offset, const struct iomap_ops *ops)\n{\n\tloff_t size = i_size_read(inode);\n\tloff_t length = size - offset;\n\tloff_t ret;\n\n\t/* Nothing to be found before or beyond the end of the file. */\n\tif (offset < 0 || offset >= size)\n\t\treturn -ENXIO;\n\n\twhile (length > 0) {\n\t\tret = iomap_apply(inode, offset, length, IOMAP_REPORT, ops,\n\t\t\t\t  &offset, iomap_seek_data_actor);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\toffset += ret;\n\t\tlength -= ret;\n\t}\n\n\tif (length <= 0)\n\t\treturn -ENXIO;\n\treturn offset;\n}"
  },
  {
    "function_name": "iomap_seek_data_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1361-1378",
    "snippet": "static loff_t\niomap_seek_data_actor(struct inode *inode, loff_t offset, loff_t length,\n\t\t      void *data, struct iomap *iomap)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\treturn length;\n\tcase IOMAP_UNWRITTEN:\n\t\toffset = page_cache_seek_hole_data(inode, offset, length,\n\t\t\t\t\t\t   SEEK_DATA);\n\t\tif (offset < 0)\n\t\t\treturn length;\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\t*(loff_t *)data = offset;\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_seek_hole_data",
          "args": [
            "inode",
            "offset",
            "length",
            "SEEK_DATA"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_seek_hole_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1268-1312",
          "snippet": "static loff_t\npage_cache_seek_hole_data(struct inode *inode, loff_t offset, loff_t length,\n\t\tint whence)\n{\n\tpgoff_t index = offset >> PAGE_SHIFT;\n\tpgoff_t end = DIV_ROUND_UP(offset + length, PAGE_SIZE);\n\tloff_t lastoff = offset;\n\tstruct pagevec pvec;\n\n\tif (length <= 0)\n\t\treturn -ENOENT;\n\n\tpagevec_init(&pvec);\n\n\tdo {\n\t\tunsigned nr_pages, i;\n\n\t\tnr_pages = pagevec_lookup_range(&pvec, inode->i_mapping, &index,\n\t\t\t\t\t\tend - 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page_seek_hole_data(inode, page, &lastoff, whence))\n\t\t\t\tgoto check_range;\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t} while (index < end);\n\n\t/* When no page at lastoff and we are not done, we found a hole. */\n\tif (whence != SEEK_HOLE)\n\t\tgoto not_found;\n\ncheck_range:\n\tif (lastoff < offset + length)\n\t\tgoto out;\nnot_found:\n\tlastoff = -ENOENT;\nout:\n\tpagevec_release(&pvec);\n\treturn lastoff;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\npage_cache_seek_hole_data(struct inode *inode, loff_t offset, loff_t length,\n\t\tint whence)\n{\n\tpgoff_t index = offset >> PAGE_SHIFT;\n\tpgoff_t end = DIV_ROUND_UP(offset + length, PAGE_SIZE);\n\tloff_t lastoff = offset;\n\tstruct pagevec pvec;\n\n\tif (length <= 0)\n\t\treturn -ENOENT;\n\n\tpagevec_init(&pvec);\n\n\tdo {\n\t\tunsigned nr_pages, i;\n\n\t\tnr_pages = pagevec_lookup_range(&pvec, inode->i_mapping, &index,\n\t\t\t\t\t\tend - 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page_seek_hole_data(inode, page, &lastoff, whence))\n\t\t\t\tgoto check_range;\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t} while (index < end);\n\n\t/* When no page at lastoff and we are not done, we found a hole. */\n\tif (whence != SEEK_HOLE)\n\t\tgoto not_found;\n\ncheck_range:\n\tif (lastoff < offset + length)\n\t\tgoto out;\nnot_found:\n\tlastoff = -ENOENT;\nout:\n\tpagevec_release(&pvec);\n\treturn lastoff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_seek_data_actor(struct inode *inode, loff_t offset, loff_t length,\n\t\t      void *data, struct iomap *iomap)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\treturn length;\n\tcase IOMAP_UNWRITTEN:\n\t\toffset = page_cache_seek_hole_data(inode, offset, length,\n\t\t\t\t\t\t   SEEK_DATA);\n\t\tif (offset < 0)\n\t\t\treturn length;\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\t*(loff_t *)data = offset;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "iomap_seek_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1334-1358",
    "snippet": "loff_t\niomap_seek_hole(struct inode *inode, loff_t offset, const struct iomap_ops *ops)\n{\n\tloff_t size = i_size_read(inode);\n\tloff_t length = size - offset;\n\tloff_t ret;\n\n\t/* Nothing to be found before or beyond the end of the file. */\n\tif (offset < 0 || offset >= size)\n\t\treturn -ENXIO;\n\n\twhile (length > 0) {\n\t\tret = iomap_apply(inode, offset, length, IOMAP_REPORT, ops,\n\t\t\t\t  &offset, iomap_seek_hole_actor);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\toffset += ret;\n\t\tlength -= ret;\n\t}\n\n\treturn offset;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "offset",
            "length",
            "IOMAP_REPORT",
            "ops",
            "&offset",
            "iomap_seek_hole_actor"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_seek_hole(struct inode *inode, loff_t offset, const struct iomap_ops *ops)\n{\n\tloff_t size = i_size_read(inode);\n\tloff_t length = size - offset;\n\tloff_t ret;\n\n\t/* Nothing to be found before or beyond the end of the file. */\n\tif (offset < 0 || offset >= size)\n\t\treturn -ENXIO;\n\n\twhile (length > 0) {\n\t\tret = iomap_apply(inode, offset, length, IOMAP_REPORT, ops,\n\t\t\t\t  &offset, iomap_seek_hole_actor);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\toffset += ret;\n\t\tlength -= ret;\n\t}\n\n\treturn offset;\n}"
  },
  {
    "function_name": "iomap_seek_hole_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1315-1332",
    "snippet": "static loff_t\niomap_seek_hole_actor(struct inode *inode, loff_t offset, loff_t length,\n\t\t      void *data, struct iomap *iomap)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_UNWRITTEN:\n\t\toffset = page_cache_seek_hole_data(inode, offset, length,\n\t\t\t\t\t\t   SEEK_HOLE);\n\t\tif (offset < 0)\n\t\t\treturn length;\n\t\t/* fall through */\n\tcase IOMAP_HOLE:\n\t\t*(loff_t *)data = offset;\n\t\treturn 0;\n\tdefault:\n\t\treturn length;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_seek_hole_data",
          "args": [
            "inode",
            "offset",
            "length",
            "SEEK_HOLE"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_seek_hole_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1268-1312",
          "snippet": "static loff_t\npage_cache_seek_hole_data(struct inode *inode, loff_t offset, loff_t length,\n\t\tint whence)\n{\n\tpgoff_t index = offset >> PAGE_SHIFT;\n\tpgoff_t end = DIV_ROUND_UP(offset + length, PAGE_SIZE);\n\tloff_t lastoff = offset;\n\tstruct pagevec pvec;\n\n\tif (length <= 0)\n\t\treturn -ENOENT;\n\n\tpagevec_init(&pvec);\n\n\tdo {\n\t\tunsigned nr_pages, i;\n\n\t\tnr_pages = pagevec_lookup_range(&pvec, inode->i_mapping, &index,\n\t\t\t\t\t\tend - 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page_seek_hole_data(inode, page, &lastoff, whence))\n\t\t\t\tgoto check_range;\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t} while (index < end);\n\n\t/* When no page at lastoff and we are not done, we found a hole. */\n\tif (whence != SEEK_HOLE)\n\t\tgoto not_found;\n\ncheck_range:\n\tif (lastoff < offset + length)\n\t\tgoto out;\nnot_found:\n\tlastoff = -ENOENT;\nout:\n\tpagevec_release(&pvec);\n\treturn lastoff;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\npage_cache_seek_hole_data(struct inode *inode, loff_t offset, loff_t length,\n\t\tint whence)\n{\n\tpgoff_t index = offset >> PAGE_SHIFT;\n\tpgoff_t end = DIV_ROUND_UP(offset + length, PAGE_SIZE);\n\tloff_t lastoff = offset;\n\tstruct pagevec pvec;\n\n\tif (length <= 0)\n\t\treturn -ENOENT;\n\n\tpagevec_init(&pvec);\n\n\tdo {\n\t\tunsigned nr_pages, i;\n\n\t\tnr_pages = pagevec_lookup_range(&pvec, inode->i_mapping, &index,\n\t\t\t\t\t\tend - 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page_seek_hole_data(inode, page, &lastoff, whence))\n\t\t\t\tgoto check_range;\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t} while (index < end);\n\n\t/* When no page at lastoff and we are not done, we found a hole. */\n\tif (whence != SEEK_HOLE)\n\t\tgoto not_found;\n\ncheck_range:\n\tif (lastoff < offset + length)\n\t\tgoto out;\nnot_found:\n\tlastoff = -ENOENT;\nout:\n\tpagevec_release(&pvec);\n\treturn lastoff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_seek_hole_actor(struct inode *inode, loff_t offset, loff_t length,\n\t\t      void *data, struct iomap *iomap)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_UNWRITTEN:\n\t\toffset = page_cache_seek_hole_data(inode, offset, length,\n\t\t\t\t\t\t   SEEK_HOLE);\n\t\tif (offset < 0)\n\t\t\treturn length;\n\t\t/* fall through */\n\tcase IOMAP_HOLE:\n\t\t*(loff_t *)data = offset;\n\t\treturn 0;\n\tdefault:\n\t\treturn length;\n\t}\n}"
  },
  {
    "function_name": "page_cache_seek_hole_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1268-1312",
    "snippet": "static loff_t\npage_cache_seek_hole_data(struct inode *inode, loff_t offset, loff_t length,\n\t\tint whence)\n{\n\tpgoff_t index = offset >> PAGE_SHIFT;\n\tpgoff_t end = DIV_ROUND_UP(offset + length, PAGE_SIZE);\n\tloff_t lastoff = offset;\n\tstruct pagevec pvec;\n\n\tif (length <= 0)\n\t\treturn -ENOENT;\n\n\tpagevec_init(&pvec);\n\n\tdo {\n\t\tunsigned nr_pages, i;\n\n\t\tnr_pages = pagevec_lookup_range(&pvec, inode->i_mapping, &index,\n\t\t\t\t\t\tend - 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page_seek_hole_data(inode, page, &lastoff, whence))\n\t\t\t\tgoto check_range;\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t} while (index < end);\n\n\t/* When no page at lastoff and we are not done, we found a hole. */\n\tif (whence != SEEK_HOLE)\n\t\tgoto not_found;\n\ncheck_range:\n\tif (lastoff < offset + length)\n\t\tgoto out;\nnot_found:\n\tlastoff = -ENOENT;\nout:\n\tpagevec_release(&pvec);\n\treturn lastoff;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/hugetlbfs/inode.c",
          "lines": "101-109",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/falloc.h>",
            "#include <linux/sched/signal.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/falloc.h>\n#include <linux/sched/signal.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_seek_hole_data",
          "args": [
            "inode",
            "page",
            "&lastoff",
            "whence"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "page_seek_hole_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1212-1257",
          "snippet": "static bool\npage_seek_hole_data(struct inode *inode, struct page *page, loff_t *lastoff,\n\t\tint whence)\n{\n\tconst struct address_space_operations *ops = inode->i_mapping->a_ops;\n\tunsigned int bsize = i_blocksize(inode), off;\n\tbool seek_data = whence == SEEK_DATA;\n\tloff_t poff = page_offset(page);\n\n\tif (WARN_ON_ONCE(*lastoff >= poff + PAGE_SIZE))\n\t\treturn false;\n\n\tif (*lastoff < poff) {\n\t\t/*\n\t\t * Last offset smaller than the start of the page means we found\n\t\t * a hole:\n\t\t */\n\t\tif (whence == SEEK_HOLE)\n\t\t\treturn true;\n\t\t*lastoff = poff;\n\t}\n\n\t/*\n\t * Just check the page unless we can and should check block ranges:\n\t */\n\tif (bsize == PAGE_SIZE || !ops->is_partially_uptodate)\n\t\treturn PageUptodate(page) == seek_data;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping))\n\t\tgoto out_unlock_not_found;\n\n\tfor (off = 0; off < PAGE_SIZE; off += bsize) {\n\t\tif (offset_in_page(*lastoff) >= off + bsize)\n\t\t\tcontinue;\n\t\tif (ops->is_partially_uptodate(page, off, bsize) == seek_data) {\n\t\t\tunlock_page(page);\n\t\t\treturn true;\n\t\t}\n\t\t*lastoff = poff + off + bsize;\n\t}\n\nout_unlock_not_found:\n\tunlock_page(page);\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic bool\npage_seek_hole_data(struct inode *inode, struct page *page, loff_t *lastoff,\n\t\tint whence)\n{\n\tconst struct address_space_operations *ops = inode->i_mapping->a_ops;\n\tunsigned int bsize = i_blocksize(inode), off;\n\tbool seek_data = whence == SEEK_DATA;\n\tloff_t poff = page_offset(page);\n\n\tif (WARN_ON_ONCE(*lastoff >= poff + PAGE_SIZE))\n\t\treturn false;\n\n\tif (*lastoff < poff) {\n\t\t/*\n\t\t * Last offset smaller than the start of the page means we found\n\t\t * a hole:\n\t\t */\n\t\tif (whence == SEEK_HOLE)\n\t\t\treturn true;\n\t\t*lastoff = poff;\n\t}\n\n\t/*\n\t * Just check the page unless we can and should check block ranges:\n\t */\n\tif (bsize == PAGE_SIZE || !ops->is_partially_uptodate)\n\t\treturn PageUptodate(page) == seek_data;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping))\n\t\tgoto out_unlock_not_found;\n\n\tfor (off = 0; off < PAGE_SIZE; off += bsize) {\n\t\tif (offset_in_page(*lastoff) >= off + bsize)\n\t\t\tcontinue;\n\t\tif (ops->is_partially_uptodate(page, off, bsize) == seek_data) {\n\t\t\tunlock_page(page);\n\t\t\treturn true;\n\t\t}\n\t\t*lastoff = poff + off + bsize;\n\t}\n\nout_unlock_not_found:\n\tunlock_page(page);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_range",
          "args": [
            "&pvec",
            "inode->i_mapping",
            "&index",
            "end - 1"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "offset + length",
            "PAGE_SIZE"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\npage_cache_seek_hole_data(struct inode *inode, loff_t offset, loff_t length,\n\t\tint whence)\n{\n\tpgoff_t index = offset >> PAGE_SHIFT;\n\tpgoff_t end = DIV_ROUND_UP(offset + length, PAGE_SIZE);\n\tloff_t lastoff = offset;\n\tstruct pagevec pvec;\n\n\tif (length <= 0)\n\t\treturn -ENOENT;\n\n\tpagevec_init(&pvec);\n\n\tdo {\n\t\tunsigned nr_pages, i;\n\n\t\tnr_pages = pagevec_lookup_range(&pvec, inode->i_mapping, &index,\n\t\t\t\t\t\tend - 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page_seek_hole_data(inode, page, &lastoff, whence))\n\t\t\t\tgoto check_range;\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t} while (index < end);\n\n\t/* When no page at lastoff and we are not done, we found a hole. */\n\tif (whence != SEEK_HOLE)\n\t\tgoto not_found;\n\ncheck_range:\n\tif (lastoff < offset + length)\n\t\tgoto out;\nnot_found:\n\tlastoff = -ENOENT;\nout:\n\tpagevec_release(&pvec);\n\treturn lastoff;\n}"
  },
  {
    "function_name": "page_seek_hole_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1212-1257",
    "snippet": "static bool\npage_seek_hole_data(struct inode *inode, struct page *page, loff_t *lastoff,\n\t\tint whence)\n{\n\tconst struct address_space_operations *ops = inode->i_mapping->a_ops;\n\tunsigned int bsize = i_blocksize(inode), off;\n\tbool seek_data = whence == SEEK_DATA;\n\tloff_t poff = page_offset(page);\n\n\tif (WARN_ON_ONCE(*lastoff >= poff + PAGE_SIZE))\n\t\treturn false;\n\n\tif (*lastoff < poff) {\n\t\t/*\n\t\t * Last offset smaller than the start of the page means we found\n\t\t * a hole:\n\t\t */\n\t\tif (whence == SEEK_HOLE)\n\t\t\treturn true;\n\t\t*lastoff = poff;\n\t}\n\n\t/*\n\t * Just check the page unless we can and should check block ranges:\n\t */\n\tif (bsize == PAGE_SIZE || !ops->is_partially_uptodate)\n\t\treturn PageUptodate(page) == seek_data;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping))\n\t\tgoto out_unlock_not_found;\n\n\tfor (off = 0; off < PAGE_SIZE; off += bsize) {\n\t\tif (offset_in_page(*lastoff) >= off + bsize)\n\t\t\tcontinue;\n\t\tif (ops->is_partially_uptodate(page, off, bsize) == seek_data) {\n\t\t\tunlock_page(page);\n\t\t\treturn true;\n\t\t}\n\t\t*lastoff = poff + off + bsize;\n\t}\n\nout_unlock_not_found:\n\tunlock_page(page);\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->is_partially_uptodate",
          "args": [
            "page",
            "off",
            "bsize"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "*lastoff"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != inode->i_mapping"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "*lastoff >= poff + PAGE_SIZE"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic bool\npage_seek_hole_data(struct inode *inode, struct page *page, loff_t *lastoff,\n\t\tint whence)\n{\n\tconst struct address_space_operations *ops = inode->i_mapping->a_ops;\n\tunsigned int bsize = i_blocksize(inode), off;\n\tbool seek_data = whence == SEEK_DATA;\n\tloff_t poff = page_offset(page);\n\n\tif (WARN_ON_ONCE(*lastoff >= poff + PAGE_SIZE))\n\t\treturn false;\n\n\tif (*lastoff < poff) {\n\t\t/*\n\t\t * Last offset smaller than the start of the page means we found\n\t\t * a hole:\n\t\t */\n\t\tif (whence == SEEK_HOLE)\n\t\t\treturn true;\n\t\t*lastoff = poff;\n\t}\n\n\t/*\n\t * Just check the page unless we can and should check block ranges:\n\t */\n\tif (bsize == PAGE_SIZE || !ops->is_partially_uptodate)\n\t\treturn PageUptodate(page) == seek_data;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping))\n\t\tgoto out_unlock_not_found;\n\n\tfor (off = 0; off < PAGE_SIZE; off += bsize) {\n\t\tif (offset_in_page(*lastoff) >= off + bsize)\n\t\t\tcontinue;\n\t\tif (ops->is_partially_uptodate(page, off, bsize) == seek_data) {\n\t\t\tunlock_page(page);\n\t\t\treturn true;\n\t\t}\n\t\t*lastoff = poff + off + bsize;\n\t}\n\nout_unlock_not_found:\n\tunlock_page(page);\n\treturn false;\n}"
  },
  {
    "function_name": "iomap_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1163-1205",
    "snippet": "int iomap_fiemap(struct inode *inode, struct fiemap_extent_info *fi,\n\t\tloff_t start, loff_t len, const struct iomap_ops *ops)\n{\n\tstruct fiemap_ctx ctx;\n\tloff_t ret;\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.fi = fi;\n\tctx.prev.type = IOMAP_HOLE;\n\n\tret = fiemap_check_flags(fi, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fi->fi_flags & FIEMAP_FLAG_SYNC) {\n\t\tret = filemap_write_and_wait(inode->i_mapping);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, start, len, IOMAP_REPORT, ops, &ctx,\n\t\t\t\tiomap_fiemap_actor);\n\t\t/* inode with no (attribute) mapping will give ENOENT */\n\t\tif (ret == -ENOENT)\n\t\t\tbreak;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\tstart += ret;\n\t\tlen -= ret;\n\t}\n\n\tif (ctx.prev.type != IOMAP_HOLE) {\n\t\tret = iomap_to_fiemap(fi, &ctx.prev, FIEMAP_EXTENT_LAST);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_to_fiemap",
          "args": [
            "fi",
            "&ctx.prev",
            "FIEMAP_EXTENT_LAST"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_to_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1111-1139",
          "snippet": "static int iomap_to_fiemap(struct fiemap_extent_info *fi,\n\t\tstruct iomap *iomap, u32 flags)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/* skip holes */\n\t\treturn 0;\n\tcase IOMAP_DELALLOC:\n\t\tflags |= FIEMAP_EXTENT_DELALLOC | FIEMAP_EXTENT_UNKNOWN;\n\t\tbreak;\n\tcase IOMAP_MAPPED:\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\tflags |= FIEMAP_EXTENT_DATA_INLINE;\n\t\tbreak;\n\t}\n\n\tif (iomap->flags & IOMAP_F_MERGED)\n\t\tflags |= FIEMAP_EXTENT_MERGED;\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tflags |= FIEMAP_EXTENT_SHARED;\n\n\treturn fiemap_fill_next_extent(fi, iomap->offset,\n\t\t\tiomap->addr != IOMAP_NULL_ADDR ? iomap->addr : 0,\n\t\t\tiomap->length, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int iomap_to_fiemap(struct fiemap_extent_info *fi,\n\t\tstruct iomap *iomap, u32 flags)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/* skip holes */\n\t\treturn 0;\n\tcase IOMAP_DELALLOC:\n\t\tflags |= FIEMAP_EXTENT_DELALLOC | FIEMAP_EXTENT_UNKNOWN;\n\t\tbreak;\n\tcase IOMAP_MAPPED:\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\tflags |= FIEMAP_EXTENT_DATA_INLINE;\n\t\tbreak;\n\t}\n\n\tif (iomap->flags & IOMAP_F_MERGED)\n\t\tflags |= FIEMAP_EXTENT_MERGED;\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tflags |= FIEMAP_EXTENT_SHARED;\n\n\treturn fiemap_fill_next_extent(fi, iomap->offset,\n\t\t\tiomap->addr != IOMAP_NULL_ADDR ? iomap->addr : 0,\n\t\t\tiomap->length, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "start",
            "len",
            "IOMAP_REPORT",
            "ops",
            "&ctx",
            "iomap_fiemap_actor"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fiemap_check_flags",
          "args": [
            "fi",
            "FIEMAP_FLAG_SYNC"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "142-152",
          "snippet": "int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint iomap_fiemap(struct inode *inode, struct fiemap_extent_info *fi,\n\t\tloff_t start, loff_t len, const struct iomap_ops *ops)\n{\n\tstruct fiemap_ctx ctx;\n\tloff_t ret;\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.fi = fi;\n\tctx.prev.type = IOMAP_HOLE;\n\n\tret = fiemap_check_flags(fi, FIEMAP_FLAG_SYNC);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fi->fi_flags & FIEMAP_FLAG_SYNC) {\n\t\tret = filemap_write_and_wait(inode->i_mapping);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, start, len, IOMAP_REPORT, ops, &ctx,\n\t\t\t\tiomap_fiemap_actor);\n\t\t/* inode with no (attribute) mapping will give ENOENT */\n\t\tif (ret == -ENOENT)\n\t\t\tbreak;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\tstart += ret;\n\t\tlen -= ret;\n\t}\n\n\tif (ctx.prev.type != IOMAP_HOLE) {\n\t\tret = iomap_to_fiemap(fi, &ctx.prev, FIEMAP_EXTENT_LAST);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iomap_fiemap_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1141-1161",
    "snippet": "static loff_t\niomap_fiemap_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct fiemap_ctx *ctx = data;\n\tloff_t ret = length;\n\n\tif (iomap->type == IOMAP_HOLE)\n\t\treturn length;\n\n\tret = iomap_to_fiemap(ctx->fi, &ctx->prev, 0);\n\tctx->prev = *iomap;\n\tswitch (ret) {\n\tcase 0:\t\t/* success */\n\t\treturn length;\n\tcase 1:\t\t/* extent array full */\n\t\treturn 0;\n\tdefault:\n\t\treturn ret;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_to_fiemap",
          "args": [
            "ctx->fi",
            "&ctx->prev",
            "0"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_to_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1111-1139",
          "snippet": "static int iomap_to_fiemap(struct fiemap_extent_info *fi,\n\t\tstruct iomap *iomap, u32 flags)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/* skip holes */\n\t\treturn 0;\n\tcase IOMAP_DELALLOC:\n\t\tflags |= FIEMAP_EXTENT_DELALLOC | FIEMAP_EXTENT_UNKNOWN;\n\t\tbreak;\n\tcase IOMAP_MAPPED:\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\tflags |= FIEMAP_EXTENT_DATA_INLINE;\n\t\tbreak;\n\t}\n\n\tif (iomap->flags & IOMAP_F_MERGED)\n\t\tflags |= FIEMAP_EXTENT_MERGED;\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tflags |= FIEMAP_EXTENT_SHARED;\n\n\treturn fiemap_fill_next_extent(fi, iomap->offset,\n\t\t\tiomap->addr != IOMAP_NULL_ADDR ? iomap->addr : 0,\n\t\t\tiomap->length, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int iomap_to_fiemap(struct fiemap_extent_info *fi,\n\t\tstruct iomap *iomap, u32 flags)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/* skip holes */\n\t\treturn 0;\n\tcase IOMAP_DELALLOC:\n\t\tflags |= FIEMAP_EXTENT_DELALLOC | FIEMAP_EXTENT_UNKNOWN;\n\t\tbreak;\n\tcase IOMAP_MAPPED:\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\tflags |= FIEMAP_EXTENT_DATA_INLINE;\n\t\tbreak;\n\t}\n\n\tif (iomap->flags & IOMAP_F_MERGED)\n\t\tflags |= FIEMAP_EXTENT_MERGED;\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tflags |= FIEMAP_EXTENT_SHARED;\n\n\treturn fiemap_fill_next_extent(fi, iomap->offset,\n\t\t\tiomap->addr != IOMAP_NULL_ADDR ? iomap->addr : 0,\n\t\t\tiomap->length, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_fiemap_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct fiemap_ctx *ctx = data;\n\tloff_t ret = length;\n\n\tif (iomap->type == IOMAP_HOLE)\n\t\treturn length;\n\n\tret = iomap_to_fiemap(ctx->fi, &ctx->prev, 0);\n\tctx->prev = *iomap;\n\tswitch (ret) {\n\tcase 0:\t\t/* success */\n\t\treturn length;\n\tcase 1:\t\t/* extent array full */\n\t\treturn 0;\n\tdefault:\n\t\treturn ret;\n\t}\n}"
  },
  {
    "function_name": "iomap_to_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1111-1139",
    "snippet": "static int iomap_to_fiemap(struct fiemap_extent_info *fi,\n\t\tstruct iomap *iomap, u32 flags)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/* skip holes */\n\t\treturn 0;\n\tcase IOMAP_DELALLOC:\n\t\tflags |= FIEMAP_EXTENT_DELALLOC | FIEMAP_EXTENT_UNKNOWN;\n\t\tbreak;\n\tcase IOMAP_MAPPED:\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\tflags |= FIEMAP_EXTENT_DATA_INLINE;\n\t\tbreak;\n\t}\n\n\tif (iomap->flags & IOMAP_F_MERGED)\n\t\tflags |= FIEMAP_EXTENT_MERGED;\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tflags |= FIEMAP_EXTENT_SHARED;\n\n\treturn fiemap_fill_next_extent(fi, iomap->offset,\n\t\t\tiomap->addr != IOMAP_NULL_ADDR ? iomap->addr : 0,\n\t\t\tiomap->length, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fiemap_fill_next_extent",
          "args": [
            "fi",
            "iomap->offset",
            "iomap->addr != IOMAP_NULL_ADDR ? iomap->addr : 0",
            "iomap->length",
            "flags"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_fill_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ioctl.c",
          "lines": "89-125",
          "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
            "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
            "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int iomap_to_fiemap(struct fiemap_extent_info *fi,\n\t\tstruct iomap *iomap, u32 flags)\n{\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/* skip holes */\n\t\treturn 0;\n\tcase IOMAP_DELALLOC:\n\t\tflags |= FIEMAP_EXTENT_DELALLOC | FIEMAP_EXTENT_UNKNOWN;\n\t\tbreak;\n\tcase IOMAP_MAPPED:\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tflags |= FIEMAP_EXTENT_UNWRITTEN;\n\t\tbreak;\n\tcase IOMAP_INLINE:\n\t\tflags |= FIEMAP_EXTENT_DATA_INLINE;\n\t\tbreak;\n\t}\n\n\tif (iomap->flags & IOMAP_F_MERGED)\n\t\tflags |= FIEMAP_EXTENT_MERGED;\n\tif (iomap->flags & IOMAP_F_SHARED)\n\t\tflags |= FIEMAP_EXTENT_SHARED;\n\n\treturn fiemap_fill_next_extent(fi, iomap->offset,\n\t\t\tiomap->addr != IOMAP_NULL_ADDR ? iomap->addr : 0,\n\t\t\tiomap->length, flags);\n}"
  },
  {
    "function_name": "iomap_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1064-1103",
    "snippet": "vm_fault_t iomap_page_mkwrite(struct vm_fault *vmf, const struct iomap_ops *ops)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tunsigned long length;\n\tloff_t offset, size;\n\tssize_t ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_SHIFT) > size)\n\t\tlength = offset_in_page(size);\n\telse\n\t\tlength = PAGE_SIZE;\n\n\toffset = page_offset(page);\n\twhile (length > 0) {\n\t\tret = iomap_apply(inode, offset, length,\n\t\t\t\tIOMAP_WRITE | IOMAP_FAULT, ops, page,\n\t\t\t\tiomap_page_mkwrite_actor);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_unlock;\n\t\toffset += ret;\n\t\tlength -= ret;\n\t}\n\n\twait_for_stable_page(page);\n\treturn VM_FAULT_LOCKED;\nout_unlock:\n\tunlock_page(page);\n\treturn block_page_mkwrite_return(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_page_mkwrite_return",
          "args": [
            "ret"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret <= 0"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "offset",
            "length",
            "IOMAP_WRITE | IOMAP_FAULT",
            "ops",
            "page",
            "iomap_page_mkwrite_actor"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "size"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vmf->vma->vm_file"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nvm_fault_t iomap_page_mkwrite(struct vm_fault *vmf, const struct iomap_ops *ops)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vmf->vma->vm_file);\n\tunsigned long length;\n\tloff_t offset, size;\n\tssize_t ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_SHIFT) > size)\n\t\tlength = offset_in_page(size);\n\telse\n\t\tlength = PAGE_SIZE;\n\n\toffset = page_offset(page);\n\twhile (length > 0) {\n\t\tret = iomap_apply(inode, offset, length,\n\t\t\t\tIOMAP_WRITE | IOMAP_FAULT, ops, page,\n\t\t\t\tiomap_page_mkwrite_actor);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_unlock;\n\t\toffset += ret;\n\t\tlength -= ret;\n\t}\n\n\twait_for_stable_page(page);\n\treturn VM_FAULT_LOCKED;\nout_unlock:\n\tunlock_page(page);\n\treturn block_page_mkwrite_return(ret);\n}"
  },
  {
    "function_name": "iomap_page_mkwrite_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1043-1062",
    "snippet": "static loff_t\niomap_page_mkwrite_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tstruct page *page = data;\n\tint ret;\n\n\tif (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = __block_write_begin_int(page, pos, length, NULL, iomap);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tblock_commit_write(page, 0, length);\n\t} else {\n\t\tWARN_ON_ONCE(!PageUptodate(page));\n\t\tiomap_page_create(inode, page);\n\t\tset_page_dirty(page);\n\t}\n\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "676-698",
          "snippet": "int\niomap_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint newly_dirty;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 0);\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\treturn newly_dirty;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint newly_dirty;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 0);\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_page_create",
          "args": [
            "inode",
            "page"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_page_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "107-122",
          "snippet": "static struct iomap_page *\niomap_page_create(struct inode *inode, struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (iop || i_blocksize(inode) == PAGE_SIZE)\n\t\treturn iop;\n\n\tiop = kmalloc(sizeof(*iop), GFP_NOFS | __GFP_NOFAIL);\n\tatomic_set(&iop->read_count, 0);\n\tatomic_set(&iop->write_count, 0);\n\tbitmap_zero(iop->uptodate, PAGE_SIZE / SECTOR_SIZE);\n\tset_page_private(page, (unsigned long)iop);\n\tSetPagePrivate(page);\n\treturn iop;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic struct iomap_page *\niomap_page_create(struct inode *inode, struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (iop || i_blocksize(inode) == PAGE_SIZE)\n\t\treturn iop;\n\n\tiop = kmalloc(sizeof(*iop), GFP_NOFS | __GFP_NOFAIL);\n\tatomic_set(&iop->read_count, 0);\n\tatomic_set(&iop->write_count, 0);\n\tbitmap_zero(iop->uptodate, PAGE_SIZE / SECTOR_SIZE);\n\tset_page_private(page, (unsigned long)iop);\n\tSetPagePrivate(page);\n\treturn iop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_commit_write",
          "args": [
            "page",
            "0",
            "length"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2432-2437",
          "snippet": "int block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin_int",
          "args": [
            "page",
            "pos",
            "length",
            "NULL",
            "iomap"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1928-2011",
          "snippet": "int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block, struct iomap *iomap)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\tif (get_block) {\n\t\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tiomap_to_bh(inode, block, bh, iomap);\n\t\t\t}\n\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __block_write_begin_int(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block, struct iomap *iomap)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\tif (get_block) {\n\t\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tiomap_to_bh(inode, block, bh, iomap);\n\t\t\t}\n\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_page_mkwrite_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tstruct page *page = data;\n\tint ret;\n\n\tif (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = __block_write_begin_int(page, pos, length, NULL, iomap);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tblock_commit_write(page, 0, length);\n\t} else {\n\t\tWARN_ON_ONCE(!PageUptodate(page));\n\t\tiomap_page_create(inode, page);\n\t\tset_page_dirty(page);\n\t}\n\n\treturn length;\n}"
  },
  {
    "function_name": "iomap_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1029-1040",
    "snippet": "int\niomap_truncate_page(struct inode *inode, loff_t pos, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tunsigned int blocksize = i_blocksize(inode);\n\tunsigned int off = pos & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!off)\n\t\treturn 0;\n\treturn iomap_zero_range(inode, pos, blocksize - off, did_zero, ops);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_zero_range",
          "args": [
            "inode",
            "pos",
            "blocksize - off",
            "did_zero",
            "ops"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_zero_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1009-1026",
          "snippet": "int\niomap_zero_range(struct inode *inode, loff_t pos, loff_t len, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tloff_t ret;\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_ZERO,\n\t\t\t\tops, did_zero, iomap_zero_range_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_zero_range(struct inode *inode, loff_t pos, loff_t len, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tloff_t ret;\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_ZERO,\n\t\t\t\tops, did_zero, iomap_zero_range_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_truncate_page(struct inode *inode, loff_t pos, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tunsigned int blocksize = i_blocksize(inode);\n\tunsigned int off = pos & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!off)\n\t\treturn 0;\n\treturn iomap_zero_range(inode, pos, blocksize - off, did_zero, ops);\n}"
  },
  {
    "function_name": "iomap_zero_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "1009-1026",
    "snippet": "int\niomap_zero_range(struct inode *inode, loff_t pos, loff_t len, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tloff_t ret;\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_ZERO,\n\t\t\t\tops, did_zero, iomap_zero_range_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "pos",
            "len",
            "IOMAP_ZERO",
            "ops",
            "did_zero",
            "iomap_zero_range_actor"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_zero_range(struct inode *inode, loff_t pos, loff_t len, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tloff_t ret;\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_ZERO,\n\t\t\t\tops, did_zero, iomap_zero_range_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iomap_zero_range_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "974-1007",
    "snippet": "static loff_t\niomap_zero_range_actor(struct inode *inode, loff_t pos, loff_t count,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tbool *did_zero = data;\n\tloff_t written = 0;\n\tint status;\n\n\t/* already zeroed?  we're done. */\n\tif (iomap->type == IOMAP_HOLE || iomap->type == IOMAP_UNWRITTEN)\n\t    \treturn count;\n\n\tdo {\n\t\tunsigned offset, bytes;\n\n\t\toffset = offset_in_page(pos);\n\t\tbytes = min_t(loff_t, PAGE_SIZE - offset, count);\n\n\t\tif (IS_DAX(inode))\n\t\t\tstatus = iomap_dax_zero(pos, offset, bytes, iomap);\n\t\telse\n\t\t\tstatus = iomap_zero(inode, pos, offset, bytes, iomap);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\twritten += bytes;\n\t\tif (did_zero)\n\t\t\t*did_zero = true;\n\t} while (count > 0);\n\n\treturn written;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_zero",
          "args": [
            "inode",
            "pos",
            "offset",
            "bytes",
            "iomap"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_zero_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "1009-1026",
          "snippet": "int\niomap_zero_range(struct inode *inode, loff_t pos, loff_t len, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tloff_t ret;\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_ZERO,\n\t\t\t\tops, did_zero, iomap_zero_range_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_zero_range(struct inode *inode, loff_t pos, loff_t len, bool *did_zero,\n\t\tconst struct iomap_ops *ops)\n{\n\tloff_t ret;\n\n\twhile (len > 0) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_ZERO,\n\t\t\t\tops, did_zero, iomap_zero_range_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_dax_zero",
          "args": [
            "pos",
            "offset",
            "bytes",
            "iomap"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_dax_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "967-972",
          "snippet": "static int iomap_dax_zero(loff_t pos, unsigned offset, unsigned bytes,\n\t\tstruct iomap *iomap)\n{\n\treturn __dax_zero_page_range(iomap->bdev, iomap->dax_dev,\n\t\t\tiomap_sector(iomap, pos & PAGE_MASK), offset, bytes);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int iomap_dax_zero(loff_t pos, unsigned offset, unsigned bytes,\n\t\tstruct iomap *iomap)\n{\n\treturn __dax_zero_page_range(iomap->bdev, iomap->dax_dev,\n\t\t\tiomap_sector(iomap, pos & PAGE_MASK), offset, bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "PAGE_SIZE - offset",
            "count"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "pos"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_zero_range_actor(struct inode *inode, loff_t pos, loff_t count,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tbool *did_zero = data;\n\tloff_t written = 0;\n\tint status;\n\n\t/* already zeroed?  we're done. */\n\tif (iomap->type == IOMAP_HOLE || iomap->type == IOMAP_UNWRITTEN)\n\t    \treturn count;\n\n\tdo {\n\t\tunsigned offset, bytes;\n\n\t\toffset = offset_in_page(pos);\n\t\tbytes = min_t(loff_t, PAGE_SIZE - offset, count);\n\n\t\tif (IS_DAX(inode))\n\t\t\tstatus = iomap_dax_zero(pos, offset, bytes, iomap);\n\t\telse\n\t\t\tstatus = iomap_zero(inode, pos, offset, bytes, iomap);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\twritten += bytes;\n\t\tif (did_zero)\n\t\t\t*did_zero = true;\n\t} while (count > 0);\n\n\treturn written;\n}"
  },
  {
    "function_name": "iomap_dax_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "967-972",
    "snippet": "static int iomap_dax_zero(loff_t pos, unsigned offset, unsigned bytes,\n\t\tstruct iomap *iomap)\n{\n\treturn __dax_zero_page_range(iomap->bdev, iomap->dax_dev,\n\t\t\tiomap_sector(iomap, pos & PAGE_MASK), offset, bytes);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dax_zero_page_range",
          "args": [
            "iomap->bdev",
            "iomap->dax_dev",
            "iomap_sector(iomap, pos & PAGE_MASK)",
            "offset",
            "bytes"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "__dax_zero_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1034-1063",
          "snippet": "int __dax_zero_page_range(struct block_device *bdev,\n\t\tstruct dax_device *dax_dev, sector_t sector,\n\t\tunsigned int offset, unsigned int size)\n{\n\tif (dax_range_is_aligned(bdev, offset, size)) {\n\t\tsector_t start_sector = sector + (offset >> 9);\n\n\t\treturn blkdev_issue_zeroout(bdev, start_sector,\n\t\t\t\tsize >> 9, GFP_NOFS, 0);\n\t} else {\n\t\tpgoff_t pgoff;\n\t\tlong rc, id;\n\t\tvoid *kaddr;\n\n\t\trc = bdev_dax_pgoff(bdev, sector, PAGE_SIZE, &pgoff);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tid = dax_read_lock();\n\t\trc = dax_direct_access(dax_dev, pgoff, 1, &kaddr, NULL);\n\t\tif (rc < 0) {\n\t\t\tdax_read_unlock(id);\n\t\t\treturn rc;\n\t\t}\n\t\tmemset(kaddr + offset, 0, size);\n\t\tdax_flush(dax_dev, kaddr + offset, size);\n\t\tdax_read_unlock(id);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint __dax_zero_page_range(struct block_device *bdev,\n\t\tstruct dax_device *dax_dev, sector_t sector,\n\t\tunsigned int offset, unsigned int size)\n{\n\tif (dax_range_is_aligned(bdev, offset, size)) {\n\t\tsector_t start_sector = sector + (offset >> 9);\n\n\t\treturn blkdev_issue_zeroout(bdev, start_sector,\n\t\t\t\tsize >> 9, GFP_NOFS, 0);\n\t} else {\n\t\tpgoff_t pgoff;\n\t\tlong rc, id;\n\t\tvoid *kaddr;\n\n\t\trc = bdev_dax_pgoff(bdev, sector, PAGE_SIZE, &pgoff);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tid = dax_read_lock();\n\t\trc = dax_direct_access(dax_dev, pgoff, 1, &kaddr, NULL);\n\t\tif (rc < 0) {\n\t\t\tdax_read_unlock(id);\n\t\t\treturn rc;\n\t\t}\n\t\tmemset(kaddr + offset, 0, size);\n\t\tdax_flush(dax_dev, kaddr + offset, size);\n\t\tdax_read_unlock(id);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_sector",
          "args": [
            "iomap",
            "pos & PAGE_MASK"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "101-105",
          "snippet": "static sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int iomap_dax_zero(loff_t pos, unsigned offset, unsigned bytes,\n\t\tstruct iomap *iomap)\n{\n\treturn __dax_zero_page_range(iomap->bdev, iomap->dax_dev,\n\t\t\tiomap_sector(iomap, pos & PAGE_MASK), offset, bytes);\n}"
  },
  {
    "function_name": "iomap_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "950-965",
    "snippet": "static int iomap_zero(struct inode *inode, loff_t pos, unsigned offset,\n\t\tunsigned bytes, struct iomap *iomap)\n{\n\tstruct page *page;\n\tint status;\n\n\tstatus = iomap_write_begin(inode, pos, bytes, AOP_FLAG_NOFS, &page,\n\t\t\t\t   iomap);\n\tif (status)\n\t\treturn status;\n\n\tzero_user(page, offset, bytes);\n\tmark_page_accessed(page);\n\n\treturn iomap_write_end(inode, pos, bytes, bytes, page, iomap);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_write_end",
          "args": [
            "inode",
            "pos",
            "bytes",
            "bytes",
            "page",
            "iomap"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "745-766",
          "snippet": "static int\niomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tint ret;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tret = iomap_write_end_inline(inode, page, iomap, pos, copied);\n\t} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = generic_write_end(NULL, inode->i_mapping, pos, len,\n\t\t\t\tcopied, page, NULL);\n\t} else {\n\t\tret = __iomap_write_end(inode, pos, len, copied, page, iomap);\n\t}\n\n\tif (iomap->page_done)\n\t\tiomap->page_done(inode, pos, copied, page, iomap);\n\n\tif (ret < len)\n\t\tiomap_write_failed(inode, pos, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tint ret;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tret = iomap_write_end_inline(inode, page, iomap, pos, copied);\n\t} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = generic_write_end(NULL, inode->i_mapping, pos, len,\n\t\t\t\tcopied, page, NULL);\n\t} else {\n\t\tret = __iomap_write_end(inode, pos, len, copied, page, iomap);\n\t}\n\n\tif (iomap->page_done)\n\t\tiomap->page_done(inode, pos, copied, page, iomap);\n\n\tif (ret < len)\n\t\tiomap_write_failed(inode, pos, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "page"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "bytes"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_write_begin",
          "args": [
            "inode",
            "pos",
            "bytes",
            "AOP_FLAG_NOFS",
            "&page",
            "iomap"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "641-674",
          "snippet": "static int\niomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, struct iomap *iomap)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status = 0;\n\n\tBUG_ON(pos + len > iomap->offset + iomap->length);\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tpage = grab_cache_page_write_begin(inode->i_mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (iomap->type == IOMAP_INLINE)\n\t\tiomap_read_inline_data(inode, page, iomap);\n\telse if (iomap->flags & IOMAP_F_BUFFER_HEAD)\n\t\tstatus = __block_write_begin_int(page, pos, len, NULL, iomap);\n\telse\n\t\tstatus = __iomap_write_begin(inode, pos, len, page, iomap);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\n\t\tiomap_write_failed(inode, pos, len);\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, struct iomap *iomap)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status = 0;\n\n\tBUG_ON(pos + len > iomap->offset + iomap->length);\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tpage = grab_cache_page_write_begin(inode->i_mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (iomap->type == IOMAP_INLINE)\n\t\tiomap_read_inline_data(inode, page, iomap);\n\telse if (iomap->flags & IOMAP_F_BUFFER_HEAD)\n\t\tstatus = __block_write_begin_int(page, pos, len, NULL, iomap);\n\telse\n\t\tstatus = __iomap_write_begin(inode, pos, len, page, iomap);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\n\t\tiomap_write_failed(inode, pos, len);\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int iomap_zero(struct inode *inode, loff_t pos, unsigned offset,\n\t\tunsigned bytes, struct iomap *iomap)\n{\n\tstruct page *page;\n\tint status;\n\n\tstatus = iomap_write_begin(inode, pos, bytes, AOP_FLAG_NOFS, &page,\n\t\t\t\t   iomap);\n\tif (status)\n\t\treturn status;\n\n\tzero_user(page, offset, bytes);\n\tmark_page_accessed(page);\n\n\treturn iomap_write_end(inode, pos, bytes, bytes, page, iomap);\n}"
  },
  {
    "function_name": "iomap_file_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "931-947",
    "snippet": "int\niomap_file_dirty(struct inode *inode, loff_t pos, loff_t len,\n\t\tconst struct iomap_ops *ops)\n{\n\tloff_t ret;\n\n\twhile (len) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_WRITE, ops, NULL,\n\t\t\t\tiomap_dirty_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "pos",
            "len",
            "IOMAP_WRITE",
            "ops",
            "NULL",
            "iomap_dirty_actor"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_file_dirty(struct inode *inode, loff_t pos, loff_t len,\n\t\tconst struct iomap_ops *ops)\n{\n\tloff_t ret;\n\n\twhile (len) {\n\t\tret = iomap_apply(inode, pos, len, IOMAP_WRITE, ops, NULL,\n\t\t\t\tiomap_dirty_actor);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\tpos += ret;\n\t\tlen -= ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iomap_dirty_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "885-929",
    "snippet": "static loff_t\niomap_dirty_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tlong status = 0;\n\tssize_t written = 0;\n\n\tdo {\n\t\tstruct page *page, *rpage;\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\n\t\toffset = offset_in_page(pos);\n\t\tbytes = min_t(loff_t, PAGE_SIZE - offset, length);\n\n\t\trpage = __iomap_read_page(inode, pos);\n\t\tif (IS_ERR(rpage))\n\t\t\treturn PTR_ERR(rpage);\n\n\t\tstatus = iomap_write_begin(inode, pos, bytes,\n\t\t\t\t\t   AOP_FLAG_NOFS, &page, iomap);\n\t\tput_page(rpage);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\n\t\tWARN_ON_ONCE(!PageUptodate(page));\n\n\t\tstatus = iomap_write_end(inode, pos, bytes, bytes, page, iomap);\n\t\tif (unlikely(status <= 0)) {\n\t\t\tif (WARN_ON_ONCE(status == 0))\n\t\t\t\treturn -EIO;\n\t\t\treturn status;\n\t\t}\n\n\t\tcond_resched();\n\n\t\tpos += status;\n\t\twritten += status;\n\t\tlength -= status;\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t} while (length);\n\n\treturn written;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "inode->i_mapping"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "status == 0"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status <= 0"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_write_end",
          "args": [
            "inode",
            "pos",
            "bytes",
            "bytes",
            "page",
            "iomap"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "745-766",
          "snippet": "static int\niomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tint ret;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tret = iomap_write_end_inline(inode, page, iomap, pos, copied);\n\t} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = generic_write_end(NULL, inode->i_mapping, pos, len,\n\t\t\t\tcopied, page, NULL);\n\t} else {\n\t\tret = __iomap_write_end(inode, pos, len, copied, page, iomap);\n\t}\n\n\tif (iomap->page_done)\n\t\tiomap->page_done(inode, pos, copied, page, iomap);\n\n\tif (ret < len)\n\t\tiomap_write_failed(inode, pos, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tint ret;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tret = iomap_write_end_inline(inode, page, iomap, pos, copied);\n\t} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = generic_write_end(NULL, inode->i_mapping, pos, len,\n\t\t\t\tcopied, page, NULL);\n\t} else {\n\t\tret = __iomap_write_end(inode, pos, len, copied, page, iomap);\n\t}\n\n\tif (iomap->page_done)\n\t\tiomap->page_done(inode, pos, copied, page, iomap);\n\n\tif (ret < len)\n\t\tiomap_write_failed(inode, pos, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "rpage"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_write_begin",
          "args": [
            "inode",
            "pos",
            "bytes",
            "AOP_FLAG_NOFS",
            "&page",
            "iomap"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "641-674",
          "snippet": "static int\niomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, struct iomap *iomap)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status = 0;\n\n\tBUG_ON(pos + len > iomap->offset + iomap->length);\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tpage = grab_cache_page_write_begin(inode->i_mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (iomap->type == IOMAP_INLINE)\n\t\tiomap_read_inline_data(inode, page, iomap);\n\telse if (iomap->flags & IOMAP_F_BUFFER_HEAD)\n\t\tstatus = __block_write_begin_int(page, pos, len, NULL, iomap);\n\telse\n\t\tstatus = __iomap_write_begin(inode, pos, len, page, iomap);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\n\t\tiomap_write_failed(inode, pos, len);\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, struct iomap *iomap)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status = 0;\n\n\tBUG_ON(pos + len > iomap->offset + iomap->length);\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tpage = grab_cache_page_write_begin(inode->i_mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (iomap->type == IOMAP_INLINE)\n\t\tiomap_read_inline_data(inode, page, iomap);\n\telse if (iomap->flags & IOMAP_F_BUFFER_HEAD)\n\t\tstatus = __block_write_begin_int(page, pos, len, NULL, iomap);\n\telse\n\t\tstatus = __iomap_write_begin(inode, pos, len, page, iomap);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\n\t\tiomap_write_failed(inode, pos, len);\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rpage"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rpage"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iomap_read_page",
          "args": [
            "inode",
            "pos"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "__iomap_read_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "869-883",
          "snippet": "static struct page *\n__iomap_read_page(struct inode *inode, loff_t offset)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, NULL);\n\tif (IS_ERR(page))\n\t\treturn page;\n\tif (!PageUptodate(page)) {\n\t\tput_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic struct page *\n__iomap_read_page(struct inode *inode, loff_t offset)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, NULL);\n\tif (IS_ERR(page))\n\t\treturn page;\n\tif (!PageUptodate(page)) {\n\t\tput_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "PAGE_SIZE - offset",
            "length"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "pos"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_dirty_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tlong status = 0;\n\tssize_t written = 0;\n\n\tdo {\n\t\tstruct page *page, *rpage;\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\n\t\toffset = offset_in_page(pos);\n\t\tbytes = min_t(loff_t, PAGE_SIZE - offset, length);\n\n\t\trpage = __iomap_read_page(inode, pos);\n\t\tif (IS_ERR(rpage))\n\t\t\treturn PTR_ERR(rpage);\n\n\t\tstatus = iomap_write_begin(inode, pos, bytes,\n\t\t\t\t\t   AOP_FLAG_NOFS, &page, iomap);\n\t\tput_page(rpage);\n\t\tif (unlikely(status))\n\t\t\treturn status;\n\n\t\tWARN_ON_ONCE(!PageUptodate(page));\n\n\t\tstatus = iomap_write_end(inode, pos, bytes, bytes, page, iomap);\n\t\tif (unlikely(status <= 0)) {\n\t\t\tif (WARN_ON_ONCE(status == 0))\n\t\t\t\treturn -EIO;\n\t\t\treturn status;\n\t\t}\n\n\t\tcond_resched();\n\n\t\tpos += status;\n\t\twritten += status;\n\t\tlength -= status;\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t} while (length);\n\n\treturn written;\n}"
  },
  {
    "function_name": "__iomap_read_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "869-883",
    "snippet": "static struct page *\n__iomap_read_page(struct inode *inode, loff_t offset)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, NULL);\n\tif (IS_ERR(page))\n\t\treturn page;\n\tif (!PageUptodate(page)) {\n\t\tput_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "offset >> PAGE_SHIFT",
            "NULL"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic struct page *\n__iomap_read_page(struct inode *inode, loff_t offset)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, NULL);\n\tif (IS_ERR(page))\n\t\treturn page;\n\tif (!PageUptodate(page)) {\n\t\tput_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
  },
  {
    "function_name": "iomap_file_buffered_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "849-866",
    "snippet": "ssize_t\niomap_file_buffered_write(struct kiocb *iocb, struct iov_iter *iter,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\tloff_t pos = iocb->ki_pos, ret = 0, written = 0;\n\n\twhile (iov_iter_count(iter)) {\n\t\tret = iomap_apply(inode, pos, iov_iter_count(iter),\n\t\t\t\tIOMAP_WRITE, ops, iter, iomap_write_actor);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tpos += ret;\n\t\twritten += ret;\n\t}\n\n\treturn written ? written : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "pos",
            "iov_iter_count(iter)",
            "IOMAP_WRITE",
            "ops",
            "iter",
            "iomap_write_actor"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nssize_t\niomap_file_buffered_write(struct kiocb *iocb, struct iov_iter *iter,\n\t\tconst struct iomap_ops *ops)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\tloff_t pos = iocb->ki_pos, ret = 0, written = 0;\n\n\twhile (iov_iter_count(iter)) {\n\t\tret = iomap_apply(inode, pos, iov_iter_count(iter),\n\t\t\t\tIOMAP_WRITE, ops, iter, iomap_write_actor);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tpos += ret;\n\t\twritten += ret;\n\t}\n\n\treturn written ? written : ret;\n}"
  },
  {
    "function_name": "iomap_write_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "768-847",
    "snippet": "static loff_t\niomap_write_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct iov_iter *i = data;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = AOP_FLAG_NOFS;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\n\t\toffset = offset_in_page(pos);\n\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\nagain:\n\t\tif (bytes > length)\n\t\t\tbytes = length;\n\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = iomap_write_begin(inode, pos, bytes, flags, &page,\n\t\t\t\tiomap);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(inode->i_mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\n\t\tflush_dcache_page(page);\n\n\t\tstatus = iomap_write_end(inode, pos, bytes, copied, page,\n\t\t\t\tiomap);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\n\t\tcond_resched();\n\n\t\tiov_iter_advance(i, copied);\n\t\tif (unlikely(copied == 0)) {\n\t\t\t/*\n\t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tpos += copied;\n\t\twritten += copied;\n\t\tlength -= copied;\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t} while (iov_iter_count(i) && length);\n\n\treturn written ? written : status;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "i"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "inode->i_mapping"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "PAGE_SIZE - offset",
            "iov_iter_single_seg_count(i)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_single_seg_count",
          "args": [
            "i"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied == 0"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "i",
            "copied"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status < 0"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_write_end",
          "args": [
            "inode",
            "pos",
            "bytes",
            "copied",
            "page",
            "iomap"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "745-766",
          "snippet": "static int\niomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tint ret;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tret = iomap_write_end_inline(inode, page, iomap, pos, copied);\n\t} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = generic_write_end(NULL, inode->i_mapping, pos, len,\n\t\t\t\tcopied, page, NULL);\n\t} else {\n\t\tret = __iomap_write_end(inode, pos, len, copied, page, iomap);\n\t}\n\n\tif (iomap->page_done)\n\t\tiomap->page_done(inode, pos, copied, page, iomap);\n\n\tif (ret < len)\n\t\tiomap_write_failed(inode, pos, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tint ret;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tret = iomap_write_end_inline(inode, page, iomap, pos, copied);\n\t} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = generic_write_end(NULL, inode->i_mapping, pos, len,\n\t\t\t\tcopied, page, NULL);\n\t} else {\n\t\tret = __iomap_write_end(inode, pos, len, copied, page, iomap);\n\t}\n\n\tif (iomap->page_done)\n\t\tiomap->page_done(inode, pos, copied, page, iomap);\n\n\tif (ret < len)\n\t\tiomap_write_failed(inode, pos, len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_copy_from_user_atomic",
          "args": [
            "page",
            "i",
            "offset",
            "bytes"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_writably_mapped",
          "args": [
            "inode->i_mapping"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_write_begin",
          "args": [
            "inode",
            "pos",
            "bytes",
            "flags",
            "&page",
            "iomap"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "641-674",
          "snippet": "static int\niomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, struct iomap *iomap)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status = 0;\n\n\tBUG_ON(pos + len > iomap->offset + iomap->length);\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tpage = grab_cache_page_write_begin(inode->i_mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (iomap->type == IOMAP_INLINE)\n\t\tiomap_read_inline_data(inode, page, iomap);\n\telse if (iomap->flags & IOMAP_F_BUFFER_HEAD)\n\t\tstatus = __block_write_begin_int(page, pos, len, NULL, iomap);\n\telse\n\t\tstatus = __iomap_write_begin(inode, pos, len, page, iomap);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\n\t\tiomap_write_failed(inode, pos, len);\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, struct iomap *iomap)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status = 0;\n\n\tBUG_ON(pos + len > iomap->offset + iomap->length);\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tpage = grab_cache_page_write_begin(inode->i_mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (iomap->type == IOMAP_INLINE)\n\t\tiomap_read_inline_data(inode, page, iomap);\n\telse if (iomap->flags & IOMAP_F_BUFFER_HEAD)\n\t\tstatus = __block_write_begin_int(page, pos, len, NULL, iomap);\n\telse\n\t\tstatus = __iomap_write_begin(inode, pos, len, page, iomap);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\n\t\tiomap_write_failed(inode, pos, len);\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "iov_iter_fault_in_readable(i, bytes)"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_fault_in_readable",
          "args": [
            "i",
            "bytes"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "PAGE_SIZE - offset",
            "iov_iter_count(i)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "i"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "pos"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_write_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct iov_iter *i = data;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = AOP_FLAG_NOFS;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\n\t\toffset = offset_in_page(pos);\n\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\nagain:\n\t\tif (bytes > length)\n\t\t\tbytes = length;\n\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = iomap_write_begin(inode, pos, bytes, flags, &page,\n\t\t\t\tiomap);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(inode->i_mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\n\t\tflush_dcache_page(page);\n\n\t\tstatus = iomap_write_end(inode, pos, bytes, copied, page,\n\t\t\t\tiomap);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\n\t\tcond_resched();\n\n\t\tiov_iter_advance(i, copied);\n\t\tif (unlikely(copied == 0)) {\n\t\t\t/*\n\t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tpos += copied;\n\t\twritten += copied;\n\t\tlength -= copied;\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t} while (iov_iter_count(i) && length);\n\n\treturn written ? written : status;\n}"
  },
  {
    "function_name": "iomap_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "745-766",
    "snippet": "static int\niomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tint ret;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tret = iomap_write_end_inline(inode, page, iomap, pos, copied);\n\t} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = generic_write_end(NULL, inode->i_mapping, pos, len,\n\t\t\t\tcopied, page, NULL);\n\t} else {\n\t\tret = __iomap_write_end(inode, pos, len, copied, page, iomap);\n\t}\n\n\tif (iomap->page_done)\n\t\tiomap->page_done(inode, pos, copied, page, iomap);\n\n\tif (ret < len)\n\t\tiomap_write_failed(inode, pos, len);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_write_failed",
          "args": [
            "inode",
            "pos",
            "len"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "573-584",
          "snippet": "static void\niomap_write_failed(struct inode *inode, loff_t pos, unsigned len)\n{\n\tloff_t i_size = i_size_read(inode);\n\n\t/*\n\t * Only truncate newly allocated pages beyoned EOF, even if the\n\t * write started inside the existing inode size.\n\t */\n\tif (pos + len > i_size)\n\t\ttruncate_pagecache_range(inode, max(pos, i_size), pos + len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_write_failed(struct inode *inode, loff_t pos, unsigned len)\n{\n\tloff_t i_size = i_size_read(inode);\n\n\t/*\n\t * Only truncate newly allocated pages beyoned EOF, even if the\n\t * write started inside the existing inode size.\n\t */\n\tif (pos + len > i_size)\n\t\ttruncate_pagecache_range(inode, max(pos, i_size), pos + len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap->page_done",
          "args": [
            "inode",
            "pos",
            "copied",
            "page",
            "iomap"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iomap_write_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied",
            "page",
            "iomap"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "__iomap_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "701-725",
          "snippet": "static int\n__iomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tflush_dcache_page(page);\n\n\t/*\n\t * The blocks that were entirely written will now be uptodate, so we\n\t * don't have to worry about a readpage reading them and overwriting a\n\t * partial write.  However if we have encountered a short write and only\n\t * partially written into a block, it will not be marked uptodate, so a\n\t * readpage might come in and destroy our partial write.\n\t *\n\t * Do the simplest thing, and just treat any short write to a non\n\t * uptodate page as a zero-length write, and force the caller to redo\n\t * the whole thing.\n\t */\n\tif (unlikely(copied < len && !PageUptodate(page))) {\n\t\tcopied = 0;\n\t} else {\n\t\tiomap_set_range_uptodate(page, offset_in_page(pos), len);\n\t\tiomap_set_page_dirty(page);\n\t}\n\treturn __generic_write_end(inode, pos, copied, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\n__iomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tflush_dcache_page(page);\n\n\t/*\n\t * The blocks that were entirely written will now be uptodate, so we\n\t * don't have to worry about a readpage reading them and overwriting a\n\t * partial write.  However if we have encountered a short write and only\n\t * partially written into a block, it will not be marked uptodate, so a\n\t * readpage might come in and destroy our partial write.\n\t *\n\t * Do the simplest thing, and just treat any short write to a non\n\t * uptodate page as a zero-length write, and force the caller to redo\n\t * the whole thing.\n\t */\n\tif (unlikely(copied < len && !PageUptodate(page))) {\n\t\tcopied = 0;\n\t} else {\n\t\tiomap_set_range_uptodate(page, offset_in_page(pos), len);\n\t\tiomap_set_page_dirty(page);\n\t}\n\treturn __generic_write_end(inode, pos, copied, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "NULL",
            "inode->i_mapping",
            "pos",
            "len",
            "copied",
            "page",
            "NULL"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2157-2163",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\treturn __generic_write_end(mapping->host, pos, copied, page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\treturn __generic_write_end(mapping->host, pos, copied, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_write_end_inline",
          "args": [
            "inode",
            "page",
            "iomap",
            "pos",
            "copied"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_write_end_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "727-743",
          "snippet": "static int\niomap_write_end_inline(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap, loff_t pos, unsigned copied)\n{\n\tvoid *addr;\n\n\tWARN_ON_ONCE(!PageUptodate(page));\n\tBUG_ON(pos + copied > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(iomap->inline_data + pos, addr + pos, copied);\n\tkunmap_atomic(addr);\n\n\tmark_inode_dirty(inode);\n\t__generic_write_end(inode, pos, copied, page);\n\treturn copied;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_end_inline(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap, loff_t pos, unsigned copied)\n{\n\tvoid *addr;\n\n\tWARN_ON_ONCE(!PageUptodate(page));\n\tBUG_ON(pos + copied > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(iomap->inline_data + pos, addr + pos, copied);\n\tkunmap_atomic(addr);\n\n\tmark_inode_dirty(inode);\n\t__generic_write_end(inode, pos, copied, page);\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tint ret;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tret = iomap_write_end_inline(inode, page, iomap, pos, copied);\n\t} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {\n\t\tret = generic_write_end(NULL, inode->i_mapping, pos, len,\n\t\t\t\tcopied, page, NULL);\n\t} else {\n\t\tret = __iomap_write_end(inode, pos, len, copied, page, iomap);\n\t}\n\n\tif (iomap->page_done)\n\t\tiomap->page_done(inode, pos, copied, page, iomap);\n\n\tif (ret < len)\n\t\tiomap_write_failed(inode, pos, len);\n\treturn ret;\n}"
  },
  {
    "function_name": "iomap_write_end_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "727-743",
    "snippet": "static int\niomap_write_end_inline(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap, loff_t pos, unsigned copied)\n{\n\tvoid *addr;\n\n\tWARN_ON_ONCE(!PageUptodate(page));\n\tBUG_ON(pos + copied > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(iomap->inline_data + pos, addr + pos, copied);\n\tkunmap_atomic(addr);\n\n\tmark_inode_dirty(inode);\n\t__generic_write_end(inode, pos, copied, page);\n\treturn copied;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__generic_write_end",
          "args": [
            "inode",
            "pos",
            "copied",
            "page"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2087-2119",
          "snippet": "int __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,\n\t\tstruct page *page)\n{\n\tloff_t old_size = inode->i_size;\n\tbool i_size_changed = false;\n\n\t/*\n\t * No need to use i_size_read() here, the i_size cannot change under us\n\t * because we hold i_rwsem.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\ti_size_write(inode, pos + copied);\n\t\ti_size_changed = true;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,\n\t\tstruct page *page)\n{\n\tloff_t old_size = inode->i_size;\n\tbool i_size_changed = false;\n\n\t/*\n\t * No need to use i_size_read() here, the i_size cannot change under us\n\t * because we hold i_rwsem.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\ti_size_write(inode, pos + copied);\n\t\ti_size_changed = true;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2059-2079",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iomap->inline_data + pos",
            "addr + pos",
            "copied"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pos + copied > PAGE_SIZE - offset_in_page(iomap->inline_data)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "iomap->inline_data"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_end_inline(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap, loff_t pos, unsigned copied)\n{\n\tvoid *addr;\n\n\tWARN_ON_ONCE(!PageUptodate(page));\n\tBUG_ON(pos + copied > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(iomap->inline_data + pos, addr + pos, copied);\n\tkunmap_atomic(addr);\n\n\tmark_inode_dirty(inode);\n\t__generic_write_end(inode, pos, copied, page);\n\treturn copied;\n}"
  },
  {
    "function_name": "__iomap_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "701-725",
    "snippet": "static int\n__iomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tflush_dcache_page(page);\n\n\t/*\n\t * The blocks that were entirely written will now be uptodate, so we\n\t * don't have to worry about a readpage reading them and overwriting a\n\t * partial write.  However if we have encountered a short write and only\n\t * partially written into a block, it will not be marked uptodate, so a\n\t * readpage might come in and destroy our partial write.\n\t *\n\t * Do the simplest thing, and just treat any short write to a non\n\t * uptodate page as a zero-length write, and force the caller to redo\n\t * the whole thing.\n\t */\n\tif (unlikely(copied < len && !PageUptodate(page))) {\n\t\tcopied = 0;\n\t} else {\n\t\tiomap_set_range_uptodate(page, offset_in_page(pos), len);\n\t\tiomap_set_page_dirty(page);\n\t}\n\treturn __generic_write_end(inode, pos, copied, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__generic_write_end",
          "args": [
            "inode",
            "pos",
            "copied",
            "page"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "__generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2087-2119",
          "snippet": "int __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,\n\t\tstruct page *page)\n{\n\tloff_t old_size = inode->i_size;\n\tbool i_size_changed = false;\n\n\t/*\n\t * No need to use i_size_read() here, the i_size cannot change under us\n\t * because we hold i_rwsem.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\ti_size_write(inode, pos + copied);\n\t\ti_size_changed = true;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,\n\t\tstruct page *page)\n{\n\tloff_t old_size = inode->i_size;\n\tbool i_size_changed = false;\n\n\t/*\n\t * No need to use i_size_read() here, the i_size cannot change under us\n\t * because we hold i_rwsem.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\ti_size_write(inode, pos + copied);\n\t\ti_size_changed = true;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_set_page_dirty",
          "args": [
            "page"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "676-698",
          "snippet": "int\niomap_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint newly_dirty;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 0);\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\treturn newly_dirty;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint newly_dirty;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 0);\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_set_range_uptodate",
          "args": [
            "page",
            "offset_in_page(pos)",
            "len"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_set_range_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "198-219",
          "snippet": "static void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "pos"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < len && !PageUptodate(page)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\n__iomap_write_end(struct inode *inode, loff_t pos, unsigned len,\n\t\tunsigned copied, struct page *page, struct iomap *iomap)\n{\n\tflush_dcache_page(page);\n\n\t/*\n\t * The blocks that were entirely written will now be uptodate, so we\n\t * don't have to worry about a readpage reading them and overwriting a\n\t * partial write.  However if we have encountered a short write and only\n\t * partially written into a block, it will not be marked uptodate, so a\n\t * readpage might come in and destroy our partial write.\n\t *\n\t * Do the simplest thing, and just treat any short write to a non\n\t * uptodate page as a zero-length write, and force the caller to redo\n\t * the whole thing.\n\t */\n\tif (unlikely(copied < len && !PageUptodate(page))) {\n\t\tcopied = 0;\n\t} else {\n\t\tiomap_set_range_uptodate(page, offset_in_page(pos), len);\n\t\tiomap_set_page_dirty(page);\n\t}\n\treturn __generic_write_end(inode, pos, copied, page);\n}"
  },
  {
    "function_name": "iomap_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "676-698",
    "snippet": "int\niomap_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint newly_dirty;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 0);\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\treturn newly_dirty;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "mapping->host",
            "I_DIRTY_PAGES"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2107-2217",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page_memcg",
          "args": [
            "page"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty",
          "args": [
            "page",
            "mapping",
            "0"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "573-586",
          "snippet": "void __set_page_dirty(struct page *page, struct address_space *mapping,\n\t\t\t     int warn)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t}\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __set_page_dirty(struct page *page, struct address_space *mapping,\n\t\t\t     int warn)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t}\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page_memcg",
          "args": [
            "page"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mapping"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint newly_dirty;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 0);\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\treturn newly_dirty;\n}"
  },
  {
    "function_name": "iomap_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "641-674",
    "snippet": "static int\niomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, struct iomap *iomap)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status = 0;\n\n\tBUG_ON(pos + len > iomap->offset + iomap->length);\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tpage = grab_cache_page_write_begin(inode->i_mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (iomap->type == IOMAP_INLINE)\n\t\tiomap_read_inline_data(inode, page, iomap);\n\telse if (iomap->flags & IOMAP_F_BUFFER_HEAD)\n\t\tstatus = __block_write_begin_int(page, pos, len, NULL, iomap);\n\telse\n\t\tstatus = __iomap_write_begin(inode, pos, len, page, iomap);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\n\t\tiomap_write_failed(inode, pos, len);\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_write_failed",
          "args": [
            "inode",
            "pos",
            "len"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "573-584",
          "snippet": "static void\niomap_write_failed(struct inode *inode, loff_t pos, unsigned len)\n{\n\tloff_t i_size = i_size_read(inode);\n\n\t/*\n\t * Only truncate newly allocated pages beyoned EOF, even if the\n\t * write started inside the existing inode size.\n\t */\n\tif (pos + len > i_size)\n\t\ttruncate_pagecache_range(inode, max(pos, i_size), pos + len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_write_failed(struct inode *inode, loff_t pos, unsigned len)\n{\n\tloff_t i_size = i_size_read(inode);\n\n\t/*\n\t * Only truncate newly allocated pages beyoned EOF, even if the\n\t * write started inside the existing inode size.\n\t */\n\tif (pos + len > i_size)\n\t\ttruncate_pagecache_range(inode, max(pos, i_size), pos + len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iomap_write_begin",
          "args": [
            "inode",
            "pos",
            "len",
            "page",
            "iomap"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "__iomap_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "608-639",
          "snippet": "static int\n__iomap_write_begin(struct inode *inode, loff_t pos, unsigned len,\n\t\tstruct page *page, struct iomap *iomap)\n{\n\tstruct iomap_page *iop = iomap_page_create(inode, page);\n\tloff_t block_size = i_blocksize(inode);\n\tloff_t block_start = pos & ~(block_size - 1);\n\tloff_t block_end = (pos + len + block_size - 1) & ~(block_size - 1);\n\tunsigned from = offset_in_page(pos), to = from + len, poff, plen;\n\tint status = 0;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tdo {\n\t\tiomap_adjust_read_range(inode, iop, &block_start,\n\t\t\t\tblock_end - block_start, &poff, &plen);\n\t\tif (plen == 0)\n\t\t\tbreak;\n\n\t\tif ((from > poff && from < poff + plen) ||\n\t\t    (to > poff && to < poff + plen)) {\n\t\t\tstatus = iomap_read_page_sync(inode, block_start, page,\n\t\t\t\t\tpoff, plen, from, to, iomap);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\n\t} while ((block_start += plen) < block_end);\n\n\treturn status;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\n__iomap_write_begin(struct inode *inode, loff_t pos, unsigned len,\n\t\tstruct page *page, struct iomap *iomap)\n{\n\tstruct iomap_page *iop = iomap_page_create(inode, page);\n\tloff_t block_size = i_blocksize(inode);\n\tloff_t block_start = pos & ~(block_size - 1);\n\tloff_t block_end = (pos + len + block_size - 1) & ~(block_size - 1);\n\tunsigned from = offset_in_page(pos), to = from + len, poff, plen;\n\tint status = 0;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tdo {\n\t\tiomap_adjust_read_range(inode, iop, &block_start,\n\t\t\t\tblock_end - block_start, &poff, &plen);\n\t\tif (plen == 0)\n\t\t\tbreak;\n\n\t\tif ((from > poff && from < poff + plen) ||\n\t\t    (to > poff && to < poff + plen)) {\n\t\t\tstatus = iomap_read_page_sync(inode, block_start, page,\n\t\t\t\t\tpoff, plen, from, to, iomap);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\n\t} while ((block_start += plen) < block_end);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin_int",
          "args": [
            "page",
            "pos",
            "len",
            "NULL",
            "iomap"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1928-2011",
          "snippet": "int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block, struct iomap *iomap)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\tif (get_block) {\n\t\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tiomap_to_bh(inode, block, bh, iomap);\n\t\t\t}\n\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __block_write_begin_int(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block, struct iomap *iomap)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\tif (get_block) {\n\t\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tiomap_to_bh(inode, block, bh, iomap);\n\t\t\t}\n\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_read_inline_data",
          "args": [
            "inode",
            "page",
            "iomap"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "244-262",
          "snippet": "static void\niomap_read_inline_data(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap)\n{\n\tsize_t size = i_size_read(inode);\n\tvoid *addr;\n\n\tif (PageUptodate(page))\n\t\treturn;\n\n\tBUG_ON(page->index);\n\tBUG_ON(size > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(addr, iomap->inline_data, size);\n\tmemset(addr + size, 0, PAGE_SIZE - size);\n\tkunmap_atomic(addr);\n\tSetPageUptodate(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_read_inline_data(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap)\n{\n\tsize_t size = i_size_read(inode);\n\tvoid *addr;\n\n\tif (PageUptodate(page))\n\t\treturn;\n\n\tBUG_ON(page->index);\n\tBUG_ON(size > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(addr, iomap->inline_data, size);\n\tmemset(addr + size, 0, PAGE_SIZE - size);\n\tkunmap_atomic(addr);\n\tSetPageUptodate(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "inode->i_mapping",
            "index",
            "flags"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pos + len > iomap->offset + iomap->length"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_write_begin(struct inode *inode, loff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, struct iomap *iomap)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status = 0;\n\n\tBUG_ON(pos + len > iomap->offset + iomap->length);\n\n\tif (fatal_signal_pending(current))\n\t\treturn -EINTR;\n\n\tpage = grab_cache_page_write_begin(inode->i_mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (iomap->type == IOMAP_INLINE)\n\t\tiomap_read_inline_data(inode, page, iomap);\n\telse if (iomap->flags & IOMAP_F_BUFFER_HEAD)\n\t\tstatus = __block_write_begin_int(page, pos, len, NULL, iomap);\n\telse\n\t\tstatus = __iomap_write_begin(inode, pos, len, page, iomap);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\n\t\tiomap_write_failed(inode, pos, len);\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
  },
  {
    "function_name": "__iomap_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "608-639",
    "snippet": "static int\n__iomap_write_begin(struct inode *inode, loff_t pos, unsigned len,\n\t\tstruct page *page, struct iomap *iomap)\n{\n\tstruct iomap_page *iop = iomap_page_create(inode, page);\n\tloff_t block_size = i_blocksize(inode);\n\tloff_t block_start = pos & ~(block_size - 1);\n\tloff_t block_end = (pos + len + block_size - 1) & ~(block_size - 1);\n\tunsigned from = offset_in_page(pos), to = from + len, poff, plen;\n\tint status = 0;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tdo {\n\t\tiomap_adjust_read_range(inode, iop, &block_start,\n\t\t\t\tblock_end - block_start, &poff, &plen);\n\t\tif (plen == 0)\n\t\t\tbreak;\n\n\t\tif ((from > poff && from < poff + plen) ||\n\t\t    (to > poff && to < poff + plen)) {\n\t\t\tstatus = iomap_read_page_sync(inode, block_start, page,\n\t\t\t\t\tpoff, plen, from, to, iomap);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\n\t} while ((block_start += plen) < block_end);\n\n\treturn status;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_read_page_sync",
          "args": [
            "inode",
            "block_start",
            "page",
            "poff",
            "plen",
            "from",
            "to",
            "iomap"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_read_page_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "586-606",
          "snippet": "static int\niomap_read_page_sync(struct inode *inode, loff_t block_start, struct page *page,\n\t\tunsigned poff, unsigned plen, unsigned from, unsigned to,\n\t\tstruct iomap *iomap)\n{\n\tstruct bio_vec bvec;\n\tstruct bio bio;\n\n\tif (iomap->type != IOMAP_MAPPED || block_start >= i_size_read(inode)) {\n\t\tzero_user_segments(page, poff, from, to, poff + plen);\n\t\tiomap_set_range_uptodate(page, poff, plen);\n\t\treturn 0;\n\t}\n\n\tbio_init(&bio, &bvec, 1);\n\tbio.bi_opf = REQ_OP_READ;\n\tbio.bi_iter.bi_sector = iomap_sector(iomap, block_start);\n\tbio_set_dev(&bio, iomap->bdev);\n\t__bio_add_page(&bio, page, plen, poff);\n\treturn submit_bio_wait(&bio);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_read_page_sync(struct inode *inode, loff_t block_start, struct page *page,\n\t\tunsigned poff, unsigned plen, unsigned from, unsigned to,\n\t\tstruct iomap *iomap)\n{\n\tstruct bio_vec bvec;\n\tstruct bio bio;\n\n\tif (iomap->type != IOMAP_MAPPED || block_start >= i_size_read(inode)) {\n\t\tzero_user_segments(page, poff, from, to, poff + plen);\n\t\tiomap_set_range_uptodate(page, poff, plen);\n\t\treturn 0;\n\t}\n\n\tbio_init(&bio, &bvec, 1);\n\tbio.bi_opf = REQ_OP_READ;\n\tbio.bi_iter.bi_sector = iomap_sector(iomap, block_start);\n\tbio_set_dev(&bio, iomap->bdev);\n\t__bio_add_page(&bio, page, plen, poff);\n\treturn submit_bio_wait(&bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_adjust_read_range",
          "args": [
            "inode",
            "iop",
            "&block_start",
            "block_end - block_start",
            "&poff",
            "&plen"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_adjust_read_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "141-196",
          "snippet": "static void\niomap_adjust_read_range(struct inode *inode, struct iomap_page *iop,\n\t\tloff_t *pos, loff_t length, unsigned *offp, unsigned *lenp)\n{\n\tloff_t orig_pos = *pos;\n\tloff_t isize = i_size_read(inode);\n\tunsigned block_bits = inode->i_blkbits;\n\tunsigned block_size = (1 << block_bits);\n\tunsigned poff = offset_in_page(*pos);\n\tunsigned plen = min_t(loff_t, PAGE_SIZE - poff, length);\n\tunsigned first = poff >> block_bits;\n\tunsigned last = (poff + plen - 1) >> block_bits;\n\n\t/*\n\t * If the block size is smaller than the page size we need to check the\n\t * per-block uptodate status and adjust the offset and length if needed\n\t * to avoid reading in already uptodate ranges.\n\t */\n\tif (iop) {\n\t\tunsigned int i;\n\n\t\t/* move forward for each leading block marked uptodate */\n\t\tfor (i = first; i <= last; i++) {\n\t\t\tif (!test_bit(i, iop->uptodate))\n\t\t\t\tbreak;\n\t\t\t*pos += block_size;\n\t\t\tpoff += block_size;\n\t\t\tplen -= block_size;\n\t\t\tfirst++;\n\t\t}\n\n\t\t/* truncate len if we find any trailing uptodate block(s) */\n\t\tfor ( ; i <= last; i++) {\n\t\t\tif (test_bit(i, iop->uptodate)) {\n\t\t\t\tplen -= (last - i + 1) * block_size;\n\t\t\t\tlast = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the extent spans the block that contains the i_size we need to\n\t * handle both halves separately so that we properly zero data in the\n\t * page cache for blocks that are entirely outside of i_size.\n\t */\n\tif (orig_pos <= isize && orig_pos + length > isize) {\n\t\tunsigned end = offset_in_page(isize - 1) >> block_bits;\n\n\t\tif (first <= end && last > end)\n\t\t\tplen -= (last - end) * block_size;\n\t}\n\n\t*offp = poff;\n\t*lenp = plen;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_adjust_read_range(struct inode *inode, struct iomap_page *iop,\n\t\tloff_t *pos, loff_t length, unsigned *offp, unsigned *lenp)\n{\n\tloff_t orig_pos = *pos;\n\tloff_t isize = i_size_read(inode);\n\tunsigned block_bits = inode->i_blkbits;\n\tunsigned block_size = (1 << block_bits);\n\tunsigned poff = offset_in_page(*pos);\n\tunsigned plen = min_t(loff_t, PAGE_SIZE - poff, length);\n\tunsigned first = poff >> block_bits;\n\tunsigned last = (poff + plen - 1) >> block_bits;\n\n\t/*\n\t * If the block size is smaller than the page size we need to check the\n\t * per-block uptodate status and adjust the offset and length if needed\n\t * to avoid reading in already uptodate ranges.\n\t */\n\tif (iop) {\n\t\tunsigned int i;\n\n\t\t/* move forward for each leading block marked uptodate */\n\t\tfor (i = first; i <= last; i++) {\n\t\t\tif (!test_bit(i, iop->uptodate))\n\t\t\t\tbreak;\n\t\t\t*pos += block_size;\n\t\t\tpoff += block_size;\n\t\t\tplen -= block_size;\n\t\t\tfirst++;\n\t\t}\n\n\t\t/* truncate len if we find any trailing uptodate block(s) */\n\t\tfor ( ; i <= last; i++) {\n\t\t\tif (test_bit(i, iop->uptodate)) {\n\t\t\t\tplen -= (last - i + 1) * block_size;\n\t\t\t\tlast = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the extent spans the block that contains the i_size we need to\n\t * handle both halves separately so that we properly zero data in the\n\t * page cache for blocks that are entirely outside of i_size.\n\t */\n\tif (orig_pos <= isize && orig_pos + length > isize) {\n\t\tunsigned end = offset_in_page(isize - 1) >> block_bits;\n\n\t\tif (first <= end && last > end)\n\t\t\tplen -= (last - end) * block_size;\n\t}\n\n\t*offp = poff;\n\t*lenp = plen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "pos"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_page_create",
          "args": [
            "inode",
            "page"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_page_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "107-122",
          "snippet": "static struct iomap_page *\niomap_page_create(struct inode *inode, struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (iop || i_blocksize(inode) == PAGE_SIZE)\n\t\treturn iop;\n\n\tiop = kmalloc(sizeof(*iop), GFP_NOFS | __GFP_NOFAIL);\n\tatomic_set(&iop->read_count, 0);\n\tatomic_set(&iop->write_count, 0);\n\tbitmap_zero(iop->uptodate, PAGE_SIZE / SECTOR_SIZE);\n\tset_page_private(page, (unsigned long)iop);\n\tSetPagePrivate(page);\n\treturn iop;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic struct iomap_page *\niomap_page_create(struct inode *inode, struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (iop || i_blocksize(inode) == PAGE_SIZE)\n\t\treturn iop;\n\n\tiop = kmalloc(sizeof(*iop), GFP_NOFS | __GFP_NOFAIL);\n\tatomic_set(&iop->read_count, 0);\n\tatomic_set(&iop->write_count, 0);\n\tbitmap_zero(iop->uptodate, PAGE_SIZE / SECTOR_SIZE);\n\tset_page_private(page, (unsigned long)iop);\n\tSetPagePrivate(page);\n\treturn iop;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\n__iomap_write_begin(struct inode *inode, loff_t pos, unsigned len,\n\t\tstruct page *page, struct iomap *iomap)\n{\n\tstruct iomap_page *iop = iomap_page_create(inode, page);\n\tloff_t block_size = i_blocksize(inode);\n\tloff_t block_start = pos & ~(block_size - 1);\n\tloff_t block_end = (pos + len + block_size - 1) & ~(block_size - 1);\n\tunsigned from = offset_in_page(pos), to = from + len, poff, plen;\n\tint status = 0;\n\n\tif (PageUptodate(page))\n\t\treturn 0;\n\n\tdo {\n\t\tiomap_adjust_read_range(inode, iop, &block_start,\n\t\t\t\tblock_end - block_start, &poff, &plen);\n\t\tif (plen == 0)\n\t\t\tbreak;\n\n\t\tif ((from > poff && from < poff + plen) ||\n\t\t    (to > poff && to < poff + plen)) {\n\t\t\tstatus = iomap_read_page_sync(inode, block_start, page,\n\t\t\t\t\tpoff, plen, from, to, iomap);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t}\n\n\t} while ((block_start += plen) < block_end);\n\n\treturn status;\n}"
  },
  {
    "function_name": "iomap_read_page_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "586-606",
    "snippet": "static int\niomap_read_page_sync(struct inode *inode, loff_t block_start, struct page *page,\n\t\tunsigned poff, unsigned plen, unsigned from, unsigned to,\n\t\tstruct iomap *iomap)\n{\n\tstruct bio_vec bvec;\n\tstruct bio bio;\n\n\tif (iomap->type != IOMAP_MAPPED || block_start >= i_size_read(inode)) {\n\t\tzero_user_segments(page, poff, from, to, poff + plen);\n\t\tiomap_set_range_uptodate(page, poff, plen);\n\t\treturn 0;\n\t}\n\n\tbio_init(&bio, &bvec, 1);\n\tbio.bi_opf = REQ_OP_READ;\n\tbio.bi_iter.bi_sector = iomap_sector(iomap, block_start);\n\tbio_set_dev(&bio, iomap->bdev);\n\t__bio_add_page(&bio, page, plen, poff);\n\treturn submit_bio_wait(&bio);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio_wait",
          "args": [
            "&bio"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/check-integrity.c",
          "lines": "2880-2884",
          "snippet": "int btrfsic_submit_bio_wait(struct bio *bio)\n{\n\t__btrfsic_submit_bio(bio);\n\treturn submit_bio_wait(bio);\n}",
          "includes": [
            "#include \"compression.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/crc32c.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"compression.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/crc32c.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(struct bio *bio)\n{\n\t__btrfsic_submit_bio(bio);\n\treturn submit_bio_wait(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bio_add_page",
          "args": [
            "&bio",
            "page",
            "plen",
            "poff"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "&bio",
            "iomap->bdev"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_sector",
          "args": [
            "iomap",
            "block_start"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "101-105",
          "snippet": "static sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_init",
          "args": [
            "&bio",
            "&bvec",
            "1"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_set_range_uptodate",
          "args": [
            "page",
            "poff",
            "plen"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_set_range_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "198-219",
          "snippet": "static void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "poff",
            "from",
            "to",
            "poff + plen"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic int\niomap_read_page_sync(struct inode *inode, loff_t block_start, struct page *page,\n\t\tunsigned poff, unsigned plen, unsigned from, unsigned to,\n\t\tstruct iomap *iomap)\n{\n\tstruct bio_vec bvec;\n\tstruct bio bio;\n\n\tif (iomap->type != IOMAP_MAPPED || block_start >= i_size_read(inode)) {\n\t\tzero_user_segments(page, poff, from, to, poff + plen);\n\t\tiomap_set_range_uptodate(page, poff, plen);\n\t\treturn 0;\n\t}\n\n\tbio_init(&bio, &bvec, 1);\n\tbio.bi_opf = REQ_OP_READ;\n\tbio.bi_iter.bi_sector = iomap_sector(iomap, block_start);\n\tbio_set_dev(&bio, iomap->bdev);\n\t__bio_add_page(&bio, page, plen, poff);\n\treturn submit_bio_wait(&bio);\n}"
  },
  {
    "function_name": "iomap_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "573-584",
    "snippet": "static void\niomap_write_failed(struct inode *inode, loff_t pos, unsigned len)\n{\n\tloff_t i_size = i_size_read(inode);\n\n\t/*\n\t * Only truncate newly allocated pages beyoned EOF, even if the\n\t * write started inside the existing inode size.\n\t */\n\tif (pos + len > i_size)\n\t\ttruncate_pagecache_range(inode, max(pos, i_size), pos + len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "inode",
            "max(pos, i_size)",
            "pos + len"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "pos",
            "i_size"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "392-432",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_write_failed(struct inode *inode, loff_t pos, unsigned len)\n{\n\tloff_t i_size = i_size_read(inode);\n\n\t/*\n\t * Only truncate newly allocated pages beyoned EOF, even if the\n\t * write started inside the existing inode size.\n\t */\n\tif (pos + len > i_size)\n\t\ttruncate_pagecache_range(inode, max(pos, i_size), pos + len);\n}"
  },
  {
    "function_name": "iomap_migrate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "547-569",
    "snippet": "int\niomap_migrate_page(struct address_space *mapping, struct page *newpage,\n\t\tstruct page *page, enum migrate_mode mode)\n{\n\tint ret;\n\n\tret = migrate_page_move_mapping(mapping, newpage, page, NULL, mode, 0);\n\tif (ret != MIGRATEPAGE_SUCCESS)\n\t\treturn ret;\n\n\tif (page_has_private(page)) {\n\t\tClearPagePrivate(page);\n\t\tset_page_private(newpage, page_private(page));\n\t\tset_page_private(page, 0);\n\t\tSetPagePrivate(newpage);\n\t}\n\n\tif (mode != MIGRATE_SYNC_NO_COPY)\n\t\tmigrate_page_copy(newpage, page);\n\telse\n\t\tmigrate_page_states(newpage, page);\n\treturn MIGRATEPAGE_SUCCESS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_page_states",
          "args": [
            "newpage",
            "page"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_copy",
          "args": [
            "newpage",
            "page"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "newpage"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "newpage",
            "page_private(page)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_private_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/write.c",
          "lines": "149-155",
          "snippet": "static struct nfs_page *\nnfs_page_private_request(struct page *page)\n{\n\tif (!PagePrivate(page))\n\t\treturn NULL;\n\treturn (struct nfs_page *)page_private(page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/iversion.h>",
            "#include <linux/wait.h>",
            "#include <linux/freezer.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_page_private_request(struct page *page)\n{\n\tif (!PagePrivate(page))\n\t\treturn NULL;\n\treturn (struct nfs_page *)page_private(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_move_mapping",
          "args": [
            "mapping",
            "newpage",
            "page",
            "NULL",
            "mode",
            "0"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_migrate_page(struct address_space *mapping, struct page *newpage,\n\t\tstruct page *page, enum migrate_mode mode)\n{\n\tint ret;\n\n\tret = migrate_page_move_mapping(mapping, newpage, page, NULL, mode, 0);\n\tif (ret != MIGRATEPAGE_SUCCESS)\n\t\treturn ret;\n\n\tif (page_has_private(page)) {\n\t\tClearPagePrivate(page);\n\t\tset_page_private(newpage, page_private(page));\n\t\tset_page_private(page, 0);\n\t\tSetPagePrivate(newpage);\n\t}\n\n\tif (mode != MIGRATE_SYNC_NO_COPY)\n\t\tmigrate_page_copy(newpage, page);\n\telse\n\t\tmigrate_page_states(newpage, page);\n\treturn MIGRATEPAGE_SUCCESS;\n}"
  },
  {
    "function_name": "iomap_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "531-543",
    "snippet": "void\niomap_invalidatepage(struct page *page, unsigned int offset, unsigned int len)\n{\n\t/*\n\t * If we are invalidating the entire page, clear the dirty state from it\n\t * and release it to avoid unnecessary buildup of the LRU.\n\t */\n\tif (offset == 0 && len == PAGE_SIZE) {\n\t\tWARN_ON_ONCE(PageWriteback(page));\n\t\tcancel_dirty_page(page);\n\t\tiomap_page_release(page);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_page_release",
          "args": [
            "page"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_page_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "124-136",
          "snippet": "static void\niomap_page_release(struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (!iop)\n\t\treturn;\n\tWARN_ON_ONCE(atomic_read(&iop->read_count));\n\tWARN_ON_ONCE(atomic_read(&iop->write_count));\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tkfree(iop);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_page_release(struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (!iop)\n\t\treturn;\n\tWARN_ON_ONCE(atomic_read(&iop->read_count));\n\tWARN_ON_ONCE(atomic_read(&iop->write_count));\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tkfree(iop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_dirty_page",
          "args": [
            "page"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nvoid\niomap_invalidatepage(struct page *page, unsigned int offset, unsigned int len)\n{\n\t/*\n\t * If we are invalidating the entire page, clear the dirty state from it\n\t * and release it to avoid unnecessary buildup of the LRU.\n\t */\n\tif (offset == 0 && len == PAGE_SIZE) {\n\t\tWARN_ON_ONCE(PageWriteback(page));\n\t\tcancel_dirty_page(page);\n\t\tiomap_page_release(page);\n\t}\n}"
  },
  {
    "function_name": "iomap_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "516-528",
    "snippet": "int\niomap_releasepage(struct page *page, gfp_t gfp_mask)\n{\n\t/*\n\t * mm accommodates an old ext3 case where clean pages might not have had\n\t * the dirty bit cleared. Thus, it can send actual dirty pages to\n\t * ->releasepage() via shrink_active_list(), skip those here.\n\t */\n\tif (PageDirty(page) || PageWriteback(page))\n\t\treturn 0;\n\tiomap_page_release(page);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_page_release",
          "args": [
            "page"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_page_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "124-136",
          "snippet": "static void\niomap_page_release(struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (!iop)\n\t\treturn;\n\tWARN_ON_ONCE(atomic_read(&iop->read_count));\n\tWARN_ON_ONCE(atomic_read(&iop->write_count));\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tkfree(iop);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_page_release(struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (!iop)\n\t\treturn;\n\tWARN_ON_ONCE(atomic_read(&iop->read_count));\n\tWARN_ON_ONCE(atomic_read(&iop->write_count));\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tkfree(iop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_releasepage(struct page *page, gfp_t gfp_mask)\n{\n\t/*\n\t * mm accommodates an old ext3 case where clean pages might not have had\n\t * the dirty bit cleared. Thus, it can send actual dirty pages to\n\t * ->releasepage() via shrink_active_list(), skip those here.\n\t */\n\tif (PageDirty(page) || PageWriteback(page))\n\t\treturn 0;\n\tiomap_page_release(page);\n\treturn 1;\n}"
  },
  {
    "function_name": "iomap_is_partially_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "495-513",
    "snippet": "int\niomap_is_partially_uptodate(struct page *page, unsigned long from,\n\t\tunsigned long count)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = from >> inode->i_blkbits;\n\tunsigned last = (from + count - 1) >> inode->i_blkbits;\n\tunsigned i;\n\n\tif (iop) {\n\t\tfor (i = first; i <= last; i++)\n\t\t\tif (!test_bit(i, iop->uptodate))\n\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "iop->uptodate"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_iomap_page",
          "args": [
            "page"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_is_partially_uptodate(struct page *page, unsigned long from,\n\t\tunsigned long count)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = from >> inode->i_blkbits;\n\tunsigned last = (from + count - 1) >> inode->i_blkbits;\n\tunsigned i;\n\n\tif (iop) {\n\t\tfor (i = first; i <= last; i++)\n\t\t\tif (!test_bit(i, iop->uptodate))\n\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iomap_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "454-492",
    "snippet": "int\niomap_readpages(struct address_space *mapping, struct list_head *pages,\n\t\tunsigned nr_pages, const struct iomap_ops *ops)\n{\n\tstruct iomap_readpage_ctx ctx = {\n\t\t.pages\t\t= pages,\n\t\t.is_readahead\t= true,\n\t};\n\tloff_t pos = page_offset(list_entry(pages->prev, struct page, lru));\n\tloff_t last = page_offset(list_entry(pages->next, struct page, lru));\n\tloff_t length = last - pos + PAGE_SIZE, ret = 0;\n\n\twhile (length > 0) {\n\t\tret = iomap_apply(mapping->host, pos, length, 0, ops,\n\t\t\t\t&ctx, iomap_readpages_actor);\n\t\tif (ret <= 0) {\n\t\t\tWARN_ON_ONCE(ret == 0);\n\t\t\tgoto done;\n\t\t}\n\t\tpos += ret;\n\t\tlength -= ret;\n\t}\n\tret = 0;\ndone:\n\tif (ctx.bio)\n\t\tsubmit_bio(ctx.bio);\n\tif (ctx.cur_page) {\n\t\tif (!ctx.cur_page_in_bio)\n\t\t\tunlock_page(ctx.cur_page);\n\t\tput_page(ctx.cur_page);\n\t}\n\n\t/*\n\t * Check that we didn't lose a page due to the arcance calling\n\t * conventions..\n\t */\n\tWARN_ON_ONCE(!ret && !list_empty(ctx.pages));\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!ret && !list_empty(ctx.pages)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "ctx.pages"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "ctx.cur_page"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "ctx.cur_page"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "ctx.bio"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-116",
          "snippet": "static struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret == 0"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "mapping->host",
            "pos",
            "length",
            "0",
            "ops",
            "&ctx",
            "iomap_readpages_actor"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "list_entry(pages->next, struct page, lru)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pages->next",
            "structpage",
            "lru"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "list_entry(pages->prev, struct page, lru)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pages->prev",
            "structpage",
            "lru"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_readpages(struct address_space *mapping, struct list_head *pages,\n\t\tunsigned nr_pages, const struct iomap_ops *ops)\n{\n\tstruct iomap_readpage_ctx ctx = {\n\t\t.pages\t\t= pages,\n\t\t.is_readahead\t= true,\n\t};\n\tloff_t pos = page_offset(list_entry(pages->prev, struct page, lru));\n\tloff_t last = page_offset(list_entry(pages->next, struct page, lru));\n\tloff_t length = last - pos + PAGE_SIZE, ret = 0;\n\n\twhile (length > 0) {\n\t\tret = iomap_apply(mapping->host, pos, length, 0, ops,\n\t\t\t\t&ctx, iomap_readpages_actor);\n\t\tif (ret <= 0) {\n\t\t\tWARN_ON_ONCE(ret == 0);\n\t\t\tgoto done;\n\t\t}\n\t\tpos += ret;\n\t\tlength -= ret;\n\t}\n\tret = 0;\ndone:\n\tif (ctx.bio)\n\t\tsubmit_bio(ctx.bio);\n\tif (ctx.cur_page) {\n\t\tif (!ctx.cur_page_in_bio)\n\t\t\tunlock_page(ctx.cur_page);\n\t\tput_page(ctx.cur_page);\n\t}\n\n\t/*\n\t * Check that we didn't lose a page due to the arcance calling\n\t * conventions..\n\t */\n\tWARN_ON_ONCE(!ret && !list_empty(ctx.pages));\n\treturn ret;\n}"
  },
  {
    "function_name": "iomap_readpages_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "426-452",
    "snippet": "static loff_t\niomap_readpages_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tstruct iomap_readpage_ctx *ctx = data;\n\tloff_t done, ret;\n\n\tfor (done = 0; done < length; done += ret) {\n\t\tif (ctx->cur_page && offset_in_page(pos + done) == 0) {\n\t\t\tif (!ctx->cur_page_in_bio)\n\t\t\t\tunlock_page(ctx->cur_page);\n\t\t\tput_page(ctx->cur_page);\n\t\t\tctx->cur_page = NULL;\n\t\t}\n\t\tif (!ctx->cur_page) {\n\t\t\tctx->cur_page = iomap_next_page(inode, ctx->pages,\n\t\t\t\t\tpos, length, &done);\n\t\t\tif (!ctx->cur_page)\n\t\t\t\tbreak;\n\t\t\tctx->cur_page_in_bio = false;\n\t\t}\n\t\tret = iomap_readpage_actor(inode, pos + done, length - done,\n\t\t\t\tctx, iomap);\n\t}\n\n\treturn done;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_readpage_actor",
          "args": [
            "inode",
            "pos + done",
            "length - done",
            "ctx",
            "iomap"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_readpage_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "284-360",
          "snippet": "static loff_t\niomap_readpage_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct iomap_readpage_ctx *ctx = data;\n\tstruct page *page = ctx->cur_page;\n\tstruct iomap_page *iop = iomap_page_create(inode, page);\n\tbool is_contig = false;\n\tloff_t orig_pos = pos;\n\tunsigned poff, plen;\n\tsector_t sector;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tWARN_ON_ONCE(pos);\n\t\tiomap_read_inline_data(inode, page, iomap);\n\t\treturn PAGE_SIZE;\n\t}\n\n\t/* zero post-eof blocks as the page may be mapped */\n\tiomap_adjust_read_range(inode, iop, &pos, length, &poff, &plen);\n\tif (plen == 0)\n\t\tgoto done;\n\n\tif (iomap->type != IOMAP_MAPPED || pos >= i_size_read(inode)) {\n\t\tzero_user(page, poff, plen);\n\t\tiomap_set_range_uptodate(page, poff, plen);\n\t\tgoto done;\n\t}\n\n\tctx->cur_page_in_bio = true;\n\n\t/*\n\t * Try to merge into a previous segment if we can.\n\t */\n\tsector = iomap_sector(iomap, pos);\n\tif (ctx->bio && bio_end_sector(ctx->bio) == sector) {\n\t\tif (__bio_try_merge_page(ctx->bio, page, plen, poff))\n\t\t\tgoto done;\n\t\tis_contig = true;\n\t}\n\n\t/*\n\t * If we start a new segment we need to increase the read count, and we\n\t * need to do so before submitting any previous full bio to make sure\n\t * that we don't prematurely unlock the page.\n\t */\n\tif (iop)\n\t\tatomic_inc(&iop->read_count);\n\n\tif (!ctx->bio || !is_contig || bio_full(ctx->bio)) {\n\t\tgfp_t gfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t\tint nr_vecs = (length + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t\tif (ctx->bio)\n\t\t\tsubmit_bio(ctx->bio);\n\n\t\tif (ctx->is_readahead) /* same as readahead_gfp_mask */\n\t\t\tgfp |= __GFP_NORETRY | __GFP_NOWARN;\n\t\tctx->bio = bio_alloc(gfp, min(BIO_MAX_PAGES, nr_vecs));\n\t\tctx->bio->bi_opf = REQ_OP_READ;\n\t\tif (ctx->is_readahead)\n\t\t\tctx->bio->bi_opf |= REQ_RAHEAD;\n\t\tctx->bio->bi_iter.bi_sector = sector;\n\t\tbio_set_dev(ctx->bio, iomap->bdev);\n\t\tctx->bio->bi_end_io = iomap_read_end_io;\n\t}\n\n\t__bio_add_page(ctx->bio, page, plen, poff);\ndone:\n\t/*\n\t * Move the caller beyond our range so that it keeps making progress.\n\t * For that we have to include any leading non-uptodate ranges, but\n\t * we can skip trailing ones as they will be handled in the next\n\t * iteration.\n\t */\n\treturn pos - orig_pos + plen;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_readpage_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct iomap_readpage_ctx *ctx = data;\n\tstruct page *page = ctx->cur_page;\n\tstruct iomap_page *iop = iomap_page_create(inode, page);\n\tbool is_contig = false;\n\tloff_t orig_pos = pos;\n\tunsigned poff, plen;\n\tsector_t sector;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tWARN_ON_ONCE(pos);\n\t\tiomap_read_inline_data(inode, page, iomap);\n\t\treturn PAGE_SIZE;\n\t}\n\n\t/* zero post-eof blocks as the page may be mapped */\n\tiomap_adjust_read_range(inode, iop, &pos, length, &poff, &plen);\n\tif (plen == 0)\n\t\tgoto done;\n\n\tif (iomap->type != IOMAP_MAPPED || pos >= i_size_read(inode)) {\n\t\tzero_user(page, poff, plen);\n\t\tiomap_set_range_uptodate(page, poff, plen);\n\t\tgoto done;\n\t}\n\n\tctx->cur_page_in_bio = true;\n\n\t/*\n\t * Try to merge into a previous segment if we can.\n\t */\n\tsector = iomap_sector(iomap, pos);\n\tif (ctx->bio && bio_end_sector(ctx->bio) == sector) {\n\t\tif (__bio_try_merge_page(ctx->bio, page, plen, poff))\n\t\t\tgoto done;\n\t\tis_contig = true;\n\t}\n\n\t/*\n\t * If we start a new segment we need to increase the read count, and we\n\t * need to do so before submitting any previous full bio to make sure\n\t * that we don't prematurely unlock the page.\n\t */\n\tif (iop)\n\t\tatomic_inc(&iop->read_count);\n\n\tif (!ctx->bio || !is_contig || bio_full(ctx->bio)) {\n\t\tgfp_t gfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t\tint nr_vecs = (length + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t\tif (ctx->bio)\n\t\t\tsubmit_bio(ctx->bio);\n\n\t\tif (ctx->is_readahead) /* same as readahead_gfp_mask */\n\t\t\tgfp |= __GFP_NORETRY | __GFP_NOWARN;\n\t\tctx->bio = bio_alloc(gfp, min(BIO_MAX_PAGES, nr_vecs));\n\t\tctx->bio->bi_opf = REQ_OP_READ;\n\t\tif (ctx->is_readahead)\n\t\t\tctx->bio->bi_opf |= REQ_RAHEAD;\n\t\tctx->bio->bi_iter.bi_sector = sector;\n\t\tbio_set_dev(ctx->bio, iomap->bdev);\n\t\tctx->bio->bi_end_io = iomap_read_end_io;\n\t}\n\n\t__bio_add_page(ctx->bio, page, plen, poff);\ndone:\n\t/*\n\t * Move the caller beyond our range so that it keeps making progress.\n\t * For that we have to include any leading non-uptodate ranges, but\n\t * we can skip trailing ones as they will be handled in the next\n\t * iteration.\n\t */\n\treturn pos - orig_pos + plen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_next_page",
          "args": [
            "inode",
            "ctx->pages",
            "pos",
            "length",
            "&done"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_next_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "398-424",
          "snippet": "static struct page *\niomap_next_page(struct inode *inode, struct list_head *pages, loff_t pos,\n\t\tloff_t length, loff_t *done)\n{\n\twhile (!list_empty(pages)) {\n\t\tstruct page *page = lru_to_page(pages);\n\n\t\tif (page_offset(page) >= (u64)pos + length)\n\t\t\tbreak;\n\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, inode->i_mapping, page->index,\n\t\t\t\tGFP_NOFS))\n\t\t\treturn page;\n\n\t\t/*\n\t\t * If we already have a page in the page cache at index we are\n\t\t * done.  Upper layers don't care if it is uptodate after the\n\t\t * readpages call itself as every page gets checked again once\n\t\t * actually needed.\n\t\t */\n\t\t*done += PAGE_SIZE;\n\t\tput_page(page);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic struct page *\niomap_next_page(struct inode *inode, struct list_head *pages, loff_t pos,\n\t\tloff_t length, loff_t *done)\n{\n\twhile (!list_empty(pages)) {\n\t\tstruct page *page = lru_to_page(pages);\n\n\t\tif (page_offset(page) >= (u64)pos + length)\n\t\t\tbreak;\n\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, inode->i_mapping, page->index,\n\t\t\t\tGFP_NOFS))\n\t\t\treturn page;\n\n\t\t/*\n\t\t * If we already have a page in the page cache at index we are\n\t\t * done.  Upper layers don't care if it is uptodate after the\n\t\t * readpages call itself as every page gets checked again once\n\t\t * actually needed.\n\t\t */\n\t\t*done += PAGE_SIZE;\n\t\tput_page(page);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "ctx->cur_page"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "ctx->cur_page"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "pos + done"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_readpages_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tstruct iomap_readpage_ctx *ctx = data;\n\tloff_t done, ret;\n\n\tfor (done = 0; done < length; done += ret) {\n\t\tif (ctx->cur_page && offset_in_page(pos + done) == 0) {\n\t\t\tif (!ctx->cur_page_in_bio)\n\t\t\t\tunlock_page(ctx->cur_page);\n\t\t\tput_page(ctx->cur_page);\n\t\t\tctx->cur_page = NULL;\n\t\t}\n\t\tif (!ctx->cur_page) {\n\t\t\tctx->cur_page = iomap_next_page(inode, ctx->pages,\n\t\t\t\t\tpos, length, &done);\n\t\t\tif (!ctx->cur_page)\n\t\t\t\tbreak;\n\t\t\tctx->cur_page_in_bio = false;\n\t\t}\n\t\tret = iomap_readpage_actor(inode, pos + done, length - done,\n\t\t\t\tctx, iomap);\n\t}\n\n\treturn done;\n}"
  },
  {
    "function_name": "iomap_next_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "398-424",
    "snippet": "static struct page *\niomap_next_page(struct inode *inode, struct list_head *pages, loff_t pos,\n\t\tloff_t length, loff_t *done)\n{\n\twhile (!list_empty(pages)) {\n\t\tstruct page *page = lru_to_page(pages);\n\n\t\tif (page_offset(page) >= (u64)pos + length)\n\t\t\tbreak;\n\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, inode->i_mapping, page->index,\n\t\t\t\tGFP_NOFS))\n\t\t\treturn page;\n\n\t\t/*\n\t\t * If we already have a page in the page cache at index we are\n\t\t * done.  Upper layers don't care if it is uptodate after the\n\t\t * readpages call itself as every page gets checked again once\n\t\t * actually needed.\n\t\t */\n\t\t*done += PAGE_SIZE;\n\t\tput_page(page);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "inode->i_mapping",
            "page->index",
            "GFP_NOFS"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "pages"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic struct page *\niomap_next_page(struct inode *inode, struct list_head *pages, loff_t pos,\n\t\tloff_t length, loff_t *done)\n{\n\twhile (!list_empty(pages)) {\n\t\tstruct page *page = lru_to_page(pages);\n\n\t\tif (page_offset(page) >= (u64)pos + length)\n\t\t\tbreak;\n\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, inode->i_mapping, page->index,\n\t\t\t\tGFP_NOFS))\n\t\t\treturn page;\n\n\t\t/*\n\t\t * If we already have a page in the page cache at index we are\n\t\t * done.  Upper layers don't care if it is uptodate after the\n\t\t * readpages call itself as every page gets checked again once\n\t\t * actually needed.\n\t\t */\n\t\t*done += PAGE_SIZE;\n\t\tput_page(page);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "iomap_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "362-395",
    "snippet": "int\niomap_readpage(struct page *page, const struct iomap_ops *ops)\n{\n\tstruct iomap_readpage_ctx ctx = { .cur_page = page };\n\tstruct inode *inode = page->mapping->host;\n\tunsigned poff;\n\tloff_t ret;\n\n\tfor (poff = 0; poff < PAGE_SIZE; poff += ret) {\n\t\tret = iomap_apply(inode, page_offset(page) + poff,\n\t\t\t\tPAGE_SIZE - poff, 0, ops, &ctx,\n\t\t\t\tiomap_readpage_actor);\n\t\tif (ret <= 0) {\n\t\t\tWARN_ON_ONCE(ret == 0);\n\t\t\tSetPageError(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctx.bio) {\n\t\tsubmit_bio(ctx.bio);\n\t\tWARN_ON_ONCE(!ctx.cur_page_in_bio);\n\t} else {\n\t\tWARN_ON_ONCE(ctx.cur_page_in_bio);\n\t\tunlock_page(page);\n\t}\n\n\t/*\n\t * Just like mpage_readpages and block_read_full_page we always\n\t * return 0 and just mark the page as PageError on errors.  This\n\t * should be cleaned up all through the stack eventually.\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ctx.cur_page_in_bio"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!ctx.cur_page_in_bio"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "ctx.bio"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-116",
          "snippet": "static struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret == 0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_apply",
          "args": [
            "inode",
            "page_offset(page) + poff",
            "PAGE_SIZE - poff",
            "0",
            "ops",
            "&ctx",
            "iomap_readpage_actor"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "47-99",
          "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nint\niomap_readpage(struct page *page, const struct iomap_ops *ops)\n{\n\tstruct iomap_readpage_ctx ctx = { .cur_page = page };\n\tstruct inode *inode = page->mapping->host;\n\tunsigned poff;\n\tloff_t ret;\n\n\tfor (poff = 0; poff < PAGE_SIZE; poff += ret) {\n\t\tret = iomap_apply(inode, page_offset(page) + poff,\n\t\t\t\tPAGE_SIZE - poff, 0, ops, &ctx,\n\t\t\t\tiomap_readpage_actor);\n\t\tif (ret <= 0) {\n\t\t\tWARN_ON_ONCE(ret == 0);\n\t\t\tSetPageError(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctx.bio) {\n\t\tsubmit_bio(ctx.bio);\n\t\tWARN_ON_ONCE(!ctx.cur_page_in_bio);\n\t} else {\n\t\tWARN_ON_ONCE(ctx.cur_page_in_bio);\n\t\tunlock_page(page);\n\t}\n\n\t/*\n\t * Just like mpage_readpages and block_read_full_page we always\n\t * return 0 and just mark the page as PageError on errors.  This\n\t * should be cleaned up all through the stack eventually.\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "iomap_readpage_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "284-360",
    "snippet": "static loff_t\niomap_readpage_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct iomap_readpage_ctx *ctx = data;\n\tstruct page *page = ctx->cur_page;\n\tstruct iomap_page *iop = iomap_page_create(inode, page);\n\tbool is_contig = false;\n\tloff_t orig_pos = pos;\n\tunsigned poff, plen;\n\tsector_t sector;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tWARN_ON_ONCE(pos);\n\t\tiomap_read_inline_data(inode, page, iomap);\n\t\treturn PAGE_SIZE;\n\t}\n\n\t/* zero post-eof blocks as the page may be mapped */\n\tiomap_adjust_read_range(inode, iop, &pos, length, &poff, &plen);\n\tif (plen == 0)\n\t\tgoto done;\n\n\tif (iomap->type != IOMAP_MAPPED || pos >= i_size_read(inode)) {\n\t\tzero_user(page, poff, plen);\n\t\tiomap_set_range_uptodate(page, poff, plen);\n\t\tgoto done;\n\t}\n\n\tctx->cur_page_in_bio = true;\n\n\t/*\n\t * Try to merge into a previous segment if we can.\n\t */\n\tsector = iomap_sector(iomap, pos);\n\tif (ctx->bio && bio_end_sector(ctx->bio) == sector) {\n\t\tif (__bio_try_merge_page(ctx->bio, page, plen, poff))\n\t\t\tgoto done;\n\t\tis_contig = true;\n\t}\n\n\t/*\n\t * If we start a new segment we need to increase the read count, and we\n\t * need to do so before submitting any previous full bio to make sure\n\t * that we don't prematurely unlock the page.\n\t */\n\tif (iop)\n\t\tatomic_inc(&iop->read_count);\n\n\tif (!ctx->bio || !is_contig || bio_full(ctx->bio)) {\n\t\tgfp_t gfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t\tint nr_vecs = (length + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t\tif (ctx->bio)\n\t\t\tsubmit_bio(ctx->bio);\n\n\t\tif (ctx->is_readahead) /* same as readahead_gfp_mask */\n\t\t\tgfp |= __GFP_NORETRY | __GFP_NOWARN;\n\t\tctx->bio = bio_alloc(gfp, min(BIO_MAX_PAGES, nr_vecs));\n\t\tctx->bio->bi_opf = REQ_OP_READ;\n\t\tif (ctx->is_readahead)\n\t\t\tctx->bio->bi_opf |= REQ_RAHEAD;\n\t\tctx->bio->bi_iter.bi_sector = sector;\n\t\tbio_set_dev(ctx->bio, iomap->bdev);\n\t\tctx->bio->bi_end_io = iomap_read_end_io;\n\t}\n\n\t__bio_add_page(ctx->bio, page, plen, poff);\ndone:\n\t/*\n\t * Move the caller beyond our range so that it keeps making progress.\n\t * For that we have to include any leading non-uptodate ranges, but\n\t * we can skip trailing ones as they will be handled in the next\n\t * iteration.\n\t */\n\treturn pos - orig_pos + plen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bio_add_page",
          "args": [
            "ctx->bio",
            "page",
            "plen",
            "poff"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "ctx->bio",
            "iomap->bdev"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "gfp",
            "min(BIO_MAX_PAGES, nr_vecs)"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.c",
          "lines": "2667-2676",
          "snippet": "struct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set btrfs_bioset;\n\nstruct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "BIO_MAX_PAGES",
            "nr_vecs"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "ctx->bio"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-116",
          "snippet": "static struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_gfp_constraint",
          "args": [
            "page->mapping",
            "GFP_KERNEL"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_full",
          "args": [
            "ctx->bio"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&iop->read_count"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bio_try_merge_page",
          "args": [
            "ctx->bio",
            "page",
            "plen",
            "poff"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_end_sector",
          "args": [
            "ctx->bio"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_sector",
          "args": [
            "iomap",
            "pos"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "101-105",
          "snippet": "static sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_set_range_uptodate",
          "args": [
            "page",
            "poff",
            "plen"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_set_range_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "198-219",
          "snippet": "static void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "poff",
            "plen"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_adjust_read_range",
          "args": [
            "inode",
            "iop",
            "&pos",
            "length",
            "&poff",
            "&plen"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_adjust_read_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "141-196",
          "snippet": "static void\niomap_adjust_read_range(struct inode *inode, struct iomap_page *iop,\n\t\tloff_t *pos, loff_t length, unsigned *offp, unsigned *lenp)\n{\n\tloff_t orig_pos = *pos;\n\tloff_t isize = i_size_read(inode);\n\tunsigned block_bits = inode->i_blkbits;\n\tunsigned block_size = (1 << block_bits);\n\tunsigned poff = offset_in_page(*pos);\n\tunsigned plen = min_t(loff_t, PAGE_SIZE - poff, length);\n\tunsigned first = poff >> block_bits;\n\tunsigned last = (poff + plen - 1) >> block_bits;\n\n\t/*\n\t * If the block size is smaller than the page size we need to check the\n\t * per-block uptodate status and adjust the offset and length if needed\n\t * to avoid reading in already uptodate ranges.\n\t */\n\tif (iop) {\n\t\tunsigned int i;\n\n\t\t/* move forward for each leading block marked uptodate */\n\t\tfor (i = first; i <= last; i++) {\n\t\t\tif (!test_bit(i, iop->uptodate))\n\t\t\t\tbreak;\n\t\t\t*pos += block_size;\n\t\t\tpoff += block_size;\n\t\t\tplen -= block_size;\n\t\t\tfirst++;\n\t\t}\n\n\t\t/* truncate len if we find any trailing uptodate block(s) */\n\t\tfor ( ; i <= last; i++) {\n\t\t\tif (test_bit(i, iop->uptodate)) {\n\t\t\t\tplen -= (last - i + 1) * block_size;\n\t\t\t\tlast = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the extent spans the block that contains the i_size we need to\n\t * handle both halves separately so that we properly zero data in the\n\t * page cache for blocks that are entirely outside of i_size.\n\t */\n\tif (orig_pos <= isize && orig_pos + length > isize) {\n\t\tunsigned end = offset_in_page(isize - 1) >> block_bits;\n\n\t\tif (first <= end && last > end)\n\t\t\tplen -= (last - end) * block_size;\n\t}\n\n\t*offp = poff;\n\t*lenp = plen;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_adjust_read_range(struct inode *inode, struct iomap_page *iop,\n\t\tloff_t *pos, loff_t length, unsigned *offp, unsigned *lenp)\n{\n\tloff_t orig_pos = *pos;\n\tloff_t isize = i_size_read(inode);\n\tunsigned block_bits = inode->i_blkbits;\n\tunsigned block_size = (1 << block_bits);\n\tunsigned poff = offset_in_page(*pos);\n\tunsigned plen = min_t(loff_t, PAGE_SIZE - poff, length);\n\tunsigned first = poff >> block_bits;\n\tunsigned last = (poff + plen - 1) >> block_bits;\n\n\t/*\n\t * If the block size is smaller than the page size we need to check the\n\t * per-block uptodate status and adjust the offset and length if needed\n\t * to avoid reading in already uptodate ranges.\n\t */\n\tif (iop) {\n\t\tunsigned int i;\n\n\t\t/* move forward for each leading block marked uptodate */\n\t\tfor (i = first; i <= last; i++) {\n\t\t\tif (!test_bit(i, iop->uptodate))\n\t\t\t\tbreak;\n\t\t\t*pos += block_size;\n\t\t\tpoff += block_size;\n\t\t\tplen -= block_size;\n\t\t\tfirst++;\n\t\t}\n\n\t\t/* truncate len if we find any trailing uptodate block(s) */\n\t\tfor ( ; i <= last; i++) {\n\t\t\tif (test_bit(i, iop->uptodate)) {\n\t\t\t\tplen -= (last - i + 1) * block_size;\n\t\t\t\tlast = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the extent spans the block that contains the i_size we need to\n\t * handle both halves separately so that we properly zero data in the\n\t * page cache for blocks that are entirely outside of i_size.\n\t */\n\tif (orig_pos <= isize && orig_pos + length > isize) {\n\t\tunsigned end = offset_in_page(isize - 1) >> block_bits;\n\n\t\tif (first <= end && last > end)\n\t\t\tplen -= (last - end) * block_size;\n\t}\n\n\t*offp = poff;\n\t*lenp = plen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_read_inline_data",
          "args": [
            "inode",
            "page",
            "iomap"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "244-262",
          "snippet": "static void\niomap_read_inline_data(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap)\n{\n\tsize_t size = i_size_read(inode);\n\tvoid *addr;\n\n\tif (PageUptodate(page))\n\t\treturn;\n\n\tBUG_ON(page->index);\n\tBUG_ON(size > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(addr, iomap->inline_data, size);\n\tmemset(addr + size, 0, PAGE_SIZE - size);\n\tkunmap_atomic(addr);\n\tSetPageUptodate(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_read_inline_data(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap)\n{\n\tsize_t size = i_size_read(inode);\n\tvoid *addr;\n\n\tif (PageUptodate(page))\n\t\treturn;\n\n\tBUG_ON(page->index);\n\tBUG_ON(size > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(addr, iomap->inline_data, size);\n\tmemset(addr + size, 0, PAGE_SIZE - size);\n\tkunmap_atomic(addr);\n\tSetPageUptodate(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pos"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_page_create",
          "args": [
            "inode",
            "page"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_page_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "107-122",
          "snippet": "static struct iomap_page *\niomap_page_create(struct inode *inode, struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (iop || i_blocksize(inode) == PAGE_SIZE)\n\t\treturn iop;\n\n\tiop = kmalloc(sizeof(*iop), GFP_NOFS | __GFP_NOFAIL);\n\tatomic_set(&iop->read_count, 0);\n\tatomic_set(&iop->write_count, 0);\n\tbitmap_zero(iop->uptodate, PAGE_SIZE / SECTOR_SIZE);\n\tset_page_private(page, (unsigned long)iop);\n\tSetPagePrivate(page);\n\treturn iop;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic struct iomap_page *\niomap_page_create(struct inode *inode, struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (iop || i_blocksize(inode) == PAGE_SIZE)\n\t\treturn iop;\n\n\tiop = kmalloc(sizeof(*iop), GFP_NOFS | __GFP_NOFAIL);\n\tatomic_set(&iop->read_count, 0);\n\tatomic_set(&iop->write_count, 0);\n\tbitmap_zero(iop->uptodate, PAGE_SIZE / SECTOR_SIZE);\n\tset_page_private(page, (unsigned long)iop);\n\tSetPagePrivate(page);\n\treturn iop;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_readpage_actor(struct inode *inode, loff_t pos, loff_t length, void *data,\n\t\tstruct iomap *iomap)\n{\n\tstruct iomap_readpage_ctx *ctx = data;\n\tstruct page *page = ctx->cur_page;\n\tstruct iomap_page *iop = iomap_page_create(inode, page);\n\tbool is_contig = false;\n\tloff_t orig_pos = pos;\n\tunsigned poff, plen;\n\tsector_t sector;\n\n\tif (iomap->type == IOMAP_INLINE) {\n\t\tWARN_ON_ONCE(pos);\n\t\tiomap_read_inline_data(inode, page, iomap);\n\t\treturn PAGE_SIZE;\n\t}\n\n\t/* zero post-eof blocks as the page may be mapped */\n\tiomap_adjust_read_range(inode, iop, &pos, length, &poff, &plen);\n\tif (plen == 0)\n\t\tgoto done;\n\n\tif (iomap->type != IOMAP_MAPPED || pos >= i_size_read(inode)) {\n\t\tzero_user(page, poff, plen);\n\t\tiomap_set_range_uptodate(page, poff, plen);\n\t\tgoto done;\n\t}\n\n\tctx->cur_page_in_bio = true;\n\n\t/*\n\t * Try to merge into a previous segment if we can.\n\t */\n\tsector = iomap_sector(iomap, pos);\n\tif (ctx->bio && bio_end_sector(ctx->bio) == sector) {\n\t\tif (__bio_try_merge_page(ctx->bio, page, plen, poff))\n\t\t\tgoto done;\n\t\tis_contig = true;\n\t}\n\n\t/*\n\t * If we start a new segment we need to increase the read count, and we\n\t * need to do so before submitting any previous full bio to make sure\n\t * that we don't prematurely unlock the page.\n\t */\n\tif (iop)\n\t\tatomic_inc(&iop->read_count);\n\n\tif (!ctx->bio || !is_contig || bio_full(ctx->bio)) {\n\t\tgfp_t gfp = mapping_gfp_constraint(page->mapping, GFP_KERNEL);\n\t\tint nr_vecs = (length + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t\tif (ctx->bio)\n\t\t\tsubmit_bio(ctx->bio);\n\n\t\tif (ctx->is_readahead) /* same as readahead_gfp_mask */\n\t\t\tgfp |= __GFP_NORETRY | __GFP_NOWARN;\n\t\tctx->bio = bio_alloc(gfp, min(BIO_MAX_PAGES, nr_vecs));\n\t\tctx->bio->bi_opf = REQ_OP_READ;\n\t\tif (ctx->is_readahead)\n\t\t\tctx->bio->bi_opf |= REQ_RAHEAD;\n\t\tctx->bio->bi_iter.bi_sector = sector;\n\t\tbio_set_dev(ctx->bio, iomap->bdev);\n\t\tctx->bio->bi_end_io = iomap_read_end_io;\n\t}\n\n\t__bio_add_page(ctx->bio, page, plen, poff);\ndone:\n\t/*\n\t * Move the caller beyond our range so that it keeps making progress.\n\t * For that we have to include any leading non-uptodate ranges, but\n\t * we can skip trailing ones as they will be handled in the next\n\t * iteration.\n\t */\n\treturn pos - orig_pos + plen;\n}"
  },
  {
    "function_name": "iomap_read_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "264-274",
    "snippet": "static void\niomap_read_end_io(struct bio *bio)\n{\n\tint error = blk_status_to_errno(bio->bi_status);\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i)\n\t\tiomap_read_page_end_io(bvec, error);\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_read_page_end_io",
          "args": [
            "bvec",
            "error"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_read_page_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "228-242",
          "snippet": "static void\niomap_read_page_end_io(struct bio_vec *bvec, int error)\n{\n\tstruct page *page = bvec->bv_page;\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (unlikely(error)) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tiomap_set_range_uptodate(page, bvec->bv_offset, bvec->bv_len);\n\t}\n\n\tiomap_read_finish(iop, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_read_page_end_io(struct bio_vec *bvec, int error)\n{\n\tstruct page *page = bvec->bv_page;\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (unlikely(error)) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tiomap_set_range_uptodate(page, bvec->bv_offset, bvec->bv_len);\n\t}\n\n\tiomap_read_finish(iop, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_status_to_errno",
          "args": [
            "bio->bi_status"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_read_end_io(struct bio *bio)\n{\n\tint error = blk_status_to_errno(bio->bi_status);\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i)\n\t\tiomap_read_page_end_io(bvec, error);\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "iomap_read_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "244-262",
    "snippet": "static void\niomap_read_inline_data(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap)\n{\n\tsize_t size = i_size_read(inode);\n\tvoid *addr;\n\n\tif (PageUptodate(page))\n\t\treturn;\n\n\tBUG_ON(page->index);\n\tBUG_ON(size > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(addr, iomap->inline_data, size);\n\tmemset(addr + size, 0, PAGE_SIZE - size);\n\tkunmap_atomic(addr);\n\tSetPageUptodate(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr + size",
            "0",
            "PAGE_SIZE - size"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "addr",
            "iomap->inline_data",
            "size"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size > PAGE_SIZE - offset_in_page(iomap->inline_data)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "iomap->inline_data"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->index"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_read_inline_data(struct inode *inode, struct page *page,\n\t\tstruct iomap *iomap)\n{\n\tsize_t size = i_size_read(inode);\n\tvoid *addr;\n\n\tif (PageUptodate(page))\n\t\treturn;\n\n\tBUG_ON(page->index);\n\tBUG_ON(size > PAGE_SIZE - offset_in_page(iomap->inline_data));\n\n\taddr = kmap_atomic(page);\n\tmemcpy(addr, iomap->inline_data, size);\n\tmemset(addr + size, 0, PAGE_SIZE - size);\n\tkunmap_atomic(addr);\n\tSetPageUptodate(page);\n}"
  },
  {
    "function_name": "iomap_read_page_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "228-242",
    "snippet": "static void\niomap_read_page_end_io(struct bio_vec *bvec, int error)\n{\n\tstruct page *page = bvec->bv_page;\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (unlikely(error)) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tiomap_set_range_uptodate(page, bvec->bv_offset, bvec->bv_len);\n\t}\n\n\tiomap_read_finish(iop, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iomap_read_finish",
          "args": [
            "iop",
            "page"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_read_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "221-226",
          "snippet": "static void\niomap_read_finish(struct iomap_page *iop, struct page *page)\n{\n\tif (!iop || atomic_dec_and_test(&iop->read_count))\n\t\tunlock_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_read_finish(struct iomap_page *iop, struct page *page)\n{\n\tif (!iop || atomic_dec_and_test(&iop->read_count))\n\t\tunlock_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iomap_set_range_uptodate",
          "args": [
            "page",
            "bvec->bv_offset",
            "bvec->bv_len"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_set_range_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "198-219",
          "snippet": "static void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_iomap_page",
          "args": [
            "page"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_read_page_end_io(struct bio_vec *bvec, int error)\n{\n\tstruct page *page = bvec->bv_page;\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (unlikely(error)) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tiomap_set_range_uptodate(page, bvec->bv_offset, bvec->bv_len);\n\t}\n\n\tiomap_read_finish(iop, page);\n}"
  },
  {
    "function_name": "iomap_read_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "221-226",
    "snippet": "static void\niomap_read_finish(struct iomap_page *iop, struct page *page)\n{\n\tif (!iop || atomic_dec_and_test(&iop->read_count))\n\t\tunlock_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&iop->read_count"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_read_finish(struct iomap_page *iop, struct page *page)\n{\n\tif (!iop || atomic_dec_and_test(&iop->read_count))\n\t\tunlock_page(page);\n}"
  },
  {
    "function_name": "iomap_set_range_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "198-219",
    "snippet": "static void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "iop->uptodate"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "i",
            "iop->uptodate"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "914-918",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_iomap_page",
          "args": [
            "page"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_set_range_uptodate(struct page *page, unsigned off, unsigned len)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\tstruct inode *inode = page->mapping->host;\n\tunsigned first = off >> inode->i_blkbits;\n\tunsigned last = (off + len - 1) >> inode->i_blkbits;\n\tunsigned int i;\n\tbool uptodate = true;\n\n\tif (iop) {\n\t\tfor (i = 0; i < PAGE_SIZE / i_blocksize(inode); i++) {\n\t\t\tif (i >= first && i <= last)\n\t\t\t\tset_bit(i, iop->uptodate);\n\t\t\telse if (!test_bit(i, iop->uptodate))\n\t\t\t\tuptodate = false;\n\t\t}\n\t}\n\n\tif (uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n}"
  },
  {
    "function_name": "iomap_adjust_read_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "141-196",
    "snippet": "static void\niomap_adjust_read_range(struct inode *inode, struct iomap_page *iop,\n\t\tloff_t *pos, loff_t length, unsigned *offp, unsigned *lenp)\n{\n\tloff_t orig_pos = *pos;\n\tloff_t isize = i_size_read(inode);\n\tunsigned block_bits = inode->i_blkbits;\n\tunsigned block_size = (1 << block_bits);\n\tunsigned poff = offset_in_page(*pos);\n\tunsigned plen = min_t(loff_t, PAGE_SIZE - poff, length);\n\tunsigned first = poff >> block_bits;\n\tunsigned last = (poff + plen - 1) >> block_bits;\n\n\t/*\n\t * If the block size is smaller than the page size we need to check the\n\t * per-block uptodate status and adjust the offset and length if needed\n\t * to avoid reading in already uptodate ranges.\n\t */\n\tif (iop) {\n\t\tunsigned int i;\n\n\t\t/* move forward for each leading block marked uptodate */\n\t\tfor (i = first; i <= last; i++) {\n\t\t\tif (!test_bit(i, iop->uptodate))\n\t\t\t\tbreak;\n\t\t\t*pos += block_size;\n\t\t\tpoff += block_size;\n\t\t\tplen -= block_size;\n\t\t\tfirst++;\n\t\t}\n\n\t\t/* truncate len if we find any trailing uptodate block(s) */\n\t\tfor ( ; i <= last; i++) {\n\t\t\tif (test_bit(i, iop->uptodate)) {\n\t\t\t\tplen -= (last - i + 1) * block_size;\n\t\t\t\tlast = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the extent spans the block that contains the i_size we need to\n\t * handle both halves separately so that we properly zero data in the\n\t * page cache for blocks that are entirely outside of i_size.\n\t */\n\tif (orig_pos <= isize && orig_pos + length > isize) {\n\t\tunsigned end = offset_in_page(isize - 1) >> block_bits;\n\n\t\tif (first <= end && last > end)\n\t\t\tplen -= (last - end) * block_size;\n\t}\n\n\t*offp = poff;\n\t*lenp = plen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "isize - 1"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "iop->uptodate"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "PAGE_SIZE - poff",
            "length"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "*pos"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_adjust_read_range(struct inode *inode, struct iomap_page *iop,\n\t\tloff_t *pos, loff_t length, unsigned *offp, unsigned *lenp)\n{\n\tloff_t orig_pos = *pos;\n\tloff_t isize = i_size_read(inode);\n\tunsigned block_bits = inode->i_blkbits;\n\tunsigned block_size = (1 << block_bits);\n\tunsigned poff = offset_in_page(*pos);\n\tunsigned plen = min_t(loff_t, PAGE_SIZE - poff, length);\n\tunsigned first = poff >> block_bits;\n\tunsigned last = (poff + plen - 1) >> block_bits;\n\n\t/*\n\t * If the block size is smaller than the page size we need to check the\n\t * per-block uptodate status and adjust the offset and length if needed\n\t * to avoid reading in already uptodate ranges.\n\t */\n\tif (iop) {\n\t\tunsigned int i;\n\n\t\t/* move forward for each leading block marked uptodate */\n\t\tfor (i = first; i <= last; i++) {\n\t\t\tif (!test_bit(i, iop->uptodate))\n\t\t\t\tbreak;\n\t\t\t*pos += block_size;\n\t\t\tpoff += block_size;\n\t\t\tplen -= block_size;\n\t\t\tfirst++;\n\t\t}\n\n\t\t/* truncate len if we find any trailing uptodate block(s) */\n\t\tfor ( ; i <= last; i++) {\n\t\t\tif (test_bit(i, iop->uptodate)) {\n\t\t\t\tplen -= (last - i + 1) * block_size;\n\t\t\t\tlast = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the extent spans the block that contains the i_size we need to\n\t * handle both halves separately so that we properly zero data in the\n\t * page cache for blocks that are entirely outside of i_size.\n\t */\n\tif (orig_pos <= isize && orig_pos + length > isize) {\n\t\tunsigned end = offset_in_page(isize - 1) >> block_bits;\n\n\t\tif (first <= end && last > end)\n\t\t\tplen -= (last - end) * block_size;\n\t}\n\n\t*offp = poff;\n\t*lenp = plen;\n}"
  },
  {
    "function_name": "iomap_page_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "124-136",
    "snippet": "static void\niomap_page_release(struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (!iop)\n\t\treturn;\n\tWARN_ON_ONCE(atomic_read(&iop->read_count));\n\tWARN_ON_ONCE(atomic_read(&iop->write_count));\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tkfree(iop);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iop"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&iop->write_count)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&iop->write_count"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&iop->read_count)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&iop->read_count"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_iomap_page",
          "args": [
            "page"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic void\niomap_page_release(struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (!iop)\n\t\treturn;\n\tWARN_ON_ONCE(atomic_read(&iop->read_count));\n\tWARN_ON_ONCE(atomic_read(&iop->write_count));\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tkfree(iop);\n}"
  },
  {
    "function_name": "iomap_page_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "107-122",
    "snippet": "static struct iomap_page *\niomap_page_create(struct inode *inode, struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (iop || i_blocksize(inode) == PAGE_SIZE)\n\t\treturn iop;\n\n\tiop = kmalloc(sizeof(*iop), GFP_NOFS | __GFP_NOFAIL);\n\tatomic_set(&iop->read_count, 0);\n\tatomic_set(&iop->write_count, 0);\n\tbitmap_zero(iop->uptodate, PAGE_SIZE / SECTOR_SIZE);\n\tset_page_private(page, (unsigned long)iop);\n\tSetPagePrivate(page);\n\treturn iop;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long)iop"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "iop->uptodate",
            "PAGE_SIZE / SECTOR_SIZE"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&iop->write_count",
            "0"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&iop->read_count",
            "0"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*iop)",
            "GFP_NOFS | __GFP_NOFAIL"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_iomap_page",
          "args": [
            "page"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic struct iomap_page *\niomap_page_create(struct inode *inode, struct page *page)\n{\n\tstruct iomap_page *iop = to_iomap_page(page);\n\n\tif (iop || i_blocksize(inode) == PAGE_SIZE)\n\t\treturn iop;\n\n\tiop = kmalloc(sizeof(*iop), GFP_NOFS | __GFP_NOFAIL);\n\tatomic_set(&iop->read_count, 0);\n\tatomic_set(&iop->write_count, 0);\n\tbitmap_zero(iop->uptodate, PAGE_SIZE / SECTOR_SIZE);\n\tset_page_private(page, (unsigned long)iop);\n\tSetPagePrivate(page);\n\treturn iop;\n}"
  },
  {
    "function_name": "iomap_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "101-105",
    "snippet": "static sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic sector_t\niomap_sector(struct iomap *iomap, loff_t pos)\n{\n\treturn (iomap->addr + pos - iomap->offset) >> SECTOR_SHIFT;\n}"
  },
  {
    "function_name": "iomap_apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
    "lines": "47-99",
    "snippet": "loff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/dax.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/mm.h>",
      "#include <linux/migrate.h>",
      "#include <linux/gfp.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/compiler.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->iomap_end",
          "args": [
            "inode",
            "pos",
            "length",
            "written > 0 ? written : 0",
            "flags",
            "&iomap"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actor",
          "args": [
            "inode",
            "pos",
            "length",
            "data",
            "&iomap"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_bmap_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/iomap.c",
          "lines": "2106-2120",
          "snippet": "static loff_t\niomap_bmap_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tsector_t *bno = data, addr;\n\n\tif (iomap->type == IOMAP_MAPPED) {\n\t\taddr = (pos - iomap->offset + iomap->addr) >> inode->i_blkbits;\n\t\tif (addr > INT_MAX)\n\t\t\tWARN(1, \"would truncate bmap result\\n\");\n\t\telse\n\t\t\t*bno = addr;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/dax.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nstatic loff_t\niomap_bmap_actor(struct inode *inode, loff_t pos, loff_t length,\n\t\tvoid *data, struct iomap *iomap)\n{\n\tsector_t *bno = data, addr;\n\n\tif (iomap->type == IOMAP_MAPPED) {\n\t\taddr = (pos - iomap->offset + iomap->addr) >> inode->i_blkbits;\n\t\tif (addr > INT_MAX)\n\t\t\tWARN(1, \"would truncate bmap result\\n\");\n\t\telse\n\t\t\t*bno = addr;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "iomap.length == 0"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "iomap.offset > pos"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->iomap_begin",
          "args": [
            "inode",
            "pos",
            "length",
            "flags",
            "&iomap"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/dax.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n\nloff_t\niomap_apply(struct inode *inode, loff_t pos, loff_t length, unsigned flags,\n\t\tconst struct iomap_ops *ops, void *data, iomap_actor_t actor)\n{\n\tstruct iomap iomap = { 0 };\n\tloff_t written = 0, ret;\n\n\t/*\n\t * Need to map a range from start position for length bytes. This can\n\t * span multiple pages - it is only guaranteed to return a range of a\n\t * single type of pages (e.g. all into a hole, all mapped or all\n\t * unwritten). Failure at this point has nothing to undo.\n\t *\n\t * If allocation is required for this range, reserve the space now so\n\t * that the allocation is guaranteed to succeed later on. Once we copy\n\t * the data into the page cache pages, then we cannot fail otherwise we\n\t * expose transient stale data. If the reserve fails, we can safely\n\t * back out at this point as there is nothing to undo.\n\t */\n\tret = ops->iomap_begin(inode, pos, length, flags, &iomap);\n\tif (ret)\n\t\treturn ret;\n\tif (WARN_ON(iomap.offset > pos))\n\t\treturn -EIO;\n\tif (WARN_ON(iomap.length == 0))\n\t\treturn -EIO;\n\n\t/*\n\t * Cut down the length to the one actually provided by the filesystem,\n\t * as it might not be able to give us the whole size that we requested.\n\t */\n\tif (iomap.offset + iomap.length < pos + length)\n\t\tlength = iomap.offset + iomap.length - pos;\n\n\t/*\n\t * Now that we have guaranteed that the space allocation will succeed.\n\t * we can do the copy-in page by page without having to worry about\n\t * failures exposing transient data.\n\t */\n\twritten = actor(inode, pos, length, data, &iomap);\n\n\t/*\n\t * Now the data has been copied, commit the range we've copied.  This\n\t * should not fail unless the filesystem has had a fatal error.\n\t */\n\tif (ops->iomap_end) {\n\t\tret = ops->iomap_end(inode, pos, length,\n\t\t\t\t     written > 0 ? written : 0,\n\t\t\t\t     flags, &iomap);\n\t}\n\n\treturn written ? written : ret;\n}"
  }
]