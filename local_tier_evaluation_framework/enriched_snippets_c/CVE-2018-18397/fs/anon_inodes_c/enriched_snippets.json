[
  {
    "function_name": "anon_inode_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
    "lines": "147-158",
    "snippet": "static int __init anon_inode_init(void)\n{\n\tanon_inode_mnt = kern_mount(&anon_inode_fs_type);\n\tif (IS_ERR(anon_inode_mnt))\n\t\tpanic(\"anon_inode_init() kernel mount failed (%ld)\\n\", PTR_ERR(anon_inode_mnt));\n\n\tanon_inode_inode = alloc_anon_inode(anon_inode_mnt->mnt_sb);\n\tif (IS_ERR(anon_inode_inode))\n\t\tpanic(\"anon_inode_init() inode allocation failed (%ld)\\n\", PTR_ERR(anon_inode_inode));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *anon_inode_mnt",
      "static struct inode *anon_inode_inode;",
      "static struct file_system_type anon_inode_fs_type = {\n\t.name\t\t= \"anon_inodefs\",\n\t.mount\t\t= anon_inodefs_mount,\n\t.kill_sb\t= kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"anon_inode_init() inode allocation failed (%ld)\\n\"",
            "PTR_ERR(anon_inode_inode)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.c",
          "lines": "557-563",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tstruct inode *inode = tree->private_data;\n\n\tbtrfs_panic(btrfs_sb(inode->i_sb), err,\n\t\"locking error: extent tree was modified by another thread while locked\");\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tstruct inode *inode = tree->private_data;\n\n\tbtrfs_panic(btrfs_sb(inode->i_sb), err,\n\t\"locking error: extent tree was modified by another thread while locked\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "anon_inode_inode"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "anon_inode_inode"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_anon_inode",
          "args": [
            "anon_inode_mnt->mnt_sb"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_anon_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1123-1149",
          "snippet": "struct inode *alloc_anon_inode(struct super_block *s)\n{\n\tstatic const struct address_space_operations anon_aops = {\n\t\t.set_page_dirty = anon_set_page_dirty,\n\t};\n\tstruct inode *inode = new_inode_pseudo(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mapping->a_ops = &anon_aops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because mark_inode_dirty() will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_flags |= S_PRIVATE;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct inode *alloc_anon_inode(struct super_block *s)\n{\n\tstatic const struct address_space_operations anon_aops = {\n\t\t.set_page_dirty = anon_set_page_dirty,\n\t};\n\tstruct inode *inode = new_inode_pseudo(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mapping->a_ops = &anon_aops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because mark_inode_dirty() will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_flags |= S_PRIVATE;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "anon_inode_mnt"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "anon_inode_mnt"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&anon_inode_fs_type"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic struct vfsmount *anon_inode_mnt;\nstatic struct inode *anon_inode_inode;\nstatic struct file_system_type anon_inode_fs_type = {\n\t.name\t\t= \"anon_inodefs\",\n\t.mount\t\t= anon_inodefs_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic int __init anon_inode_init(void)\n{\n\tanon_inode_mnt = kern_mount(&anon_inode_fs_type);\n\tif (IS_ERR(anon_inode_mnt))\n\t\tpanic(\"anon_inode_init() kernel mount failed (%ld)\\n\", PTR_ERR(anon_inode_mnt));\n\n\tanon_inode_inode = alloc_anon_inode(anon_inode_mnt->mnt_sb);\n\tif (IS_ERR(anon_inode_inode))\n\t\tpanic(\"anon_inode_init() inode allocation failed (%ld)\\n\", PTR_ERR(anon_inode_inode));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "anon_inode_getfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
    "lines": "121-144",
    "snippet": "int anon_inode_getfd(const char *name, const struct file_operations *fops,\n\t\t     void *priv, int flags)\n{\n\tint error, fd;\n\tstruct file *file;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\treturn error;\n\tfd = error;\n\n\tfile = anon_inode_getfile(name, fops, priv, flags);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\tfd_install(fd, file);\n\n\treturn fd;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "556-562",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "file"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_inode_getfile",
          "args": [
            "name",
            "fops",
            "priv",
            "flags"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "anon_inode_getfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
          "lines": "70-102",
          "snippet": "struct file *anon_inode_getfile(const char *name,\n\t\t\t\tconst struct file_operations *fops,\n\t\t\t\tvoid *priv, int flags)\n{\n\tstruct file *file;\n\n\tif (IS_ERR(anon_inode_inode))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (fops->owner && !try_module_get(fops->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * We know the anon_inode inode count is always greater than zero,\n\t * so ihold() is safe.\n\t */\n\tihold(anon_inode_inode);\n\tfile = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,\n\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);\n\tif (IS_ERR(file))\n\t\tgoto err;\n\n\tfile->f_mapping = anon_inode_inode->i_mapping;\n\n\tfile->private_data = priv;\n\n\treturn file;\n\nerr:\n\tiput(anon_inode_inode);\n\tmodule_put(fops->owner);\n\treturn file;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *anon_inode_mnt",
            "static struct inode *anon_inode_inode;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic struct vfsmount *anon_inode_mnt;\nstatic struct inode *anon_inode_inode;\n\nstruct file *anon_inode_getfile(const char *name,\n\t\t\t\tconst struct file_operations *fops,\n\t\t\t\tvoid *priv, int flags)\n{\n\tstruct file *file;\n\n\tif (IS_ERR(anon_inode_inode))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (fops->owner && !try_module_get(fops->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * We know the anon_inode inode count is always greater than zero,\n\t * so ihold() is safe.\n\t */\n\tihold(anon_inode_inode);\n\tfile = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,\n\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);\n\tif (IS_ERR(file))\n\t\tgoto err;\n\n\tfile->f_mapping = anon_inode_inode->i_mapping;\n\n\tfile->private_data = priv;\n\n\treturn file;\n\nerr:\n\tiput(anon_inode_inode);\n\tmodule_put(fops->owner);\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "flags"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "542-545",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nint anon_inode_getfd(const char *name, const struct file_operations *fops,\n\t\t     void *priv, int flags)\n{\n\tint error, fd;\n\tstruct file *file;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\treturn error;\n\tfd = error;\n\n\tfile = anon_inode_getfile(name, fops, priv, flags);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\tfd_install(fd, file);\n\n\treturn fd;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\treturn error;\n}"
  },
  {
    "function_name": "anon_inode_getfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
    "lines": "70-102",
    "snippet": "struct file *anon_inode_getfile(const char *name,\n\t\t\t\tconst struct file_operations *fops,\n\t\t\t\tvoid *priv, int flags)\n{\n\tstruct file *file;\n\n\tif (IS_ERR(anon_inode_inode))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (fops->owner && !try_module_get(fops->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * We know the anon_inode inode count is always greater than zero,\n\t * so ihold() is safe.\n\t */\n\tihold(anon_inode_inode);\n\tfile = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,\n\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);\n\tif (IS_ERR(file))\n\t\tgoto err;\n\n\tfile->f_mapping = anon_inode_inode->i_mapping;\n\n\tfile->private_data = priv;\n\n\treturn file;\n\nerr:\n\tiput(anon_inode_inode);\n\tmodule_put(fops->owner);\n\treturn file;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *anon_inode_mnt",
      "static struct inode *anon_inode_inode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "fops->owner"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "anon_inode_inode"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_file_pseudo",
          "args": [
            "anon_inode_inode",
            "anon_inode_mnt",
            "name",
            "flags & (O_ACCMODE | O_NONBLOCK)",
            "fops"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_file_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "213-237",
          "snippet": "struct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,\n\t\t\t\tconst char *name, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstatic const struct dentry_operations anon_ops = {\n\t\t.d_dname = simple_dname\n\t};\n\tstruct qstr this = QSTR_INIT(name, strlen(name));\n\tstruct path path;\n\tstruct file *file;\n\n\tpath.dentry = d_alloc_pseudo(mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!mnt->mnt_sb->s_d_op)\n\t\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(mnt);\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, flags, fops);\n\tif (IS_ERR(file)) {\n\t\tihold(inode);\n\t\tpath_put(&path);\n\t}\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,\n\t\t\t\tconst char *name, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstatic const struct dentry_operations anon_ops = {\n\t\t.d_dname = simple_dname\n\t};\n\tstruct qstr this = QSTR_INIT(name, strlen(name));\n\tstruct path path;\n\tstruct file *file;\n\n\tpath.dentry = d_alloc_pseudo(mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!mnt->mnt_sb->s_d_op)\n\t\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(mnt);\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, flags, fops);\n\tif (IS_ERR(file)) {\n\t\tihold(inode);\n\t\tpath_put(&path);\n\t}\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "anon_inode_inode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "402-405",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "fops->owner"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "anon_inode_inode"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic struct vfsmount *anon_inode_mnt;\nstatic struct inode *anon_inode_inode;\n\nstruct file *anon_inode_getfile(const char *name,\n\t\t\t\tconst struct file_operations *fops,\n\t\t\t\tvoid *priv, int flags)\n{\n\tstruct file *file;\n\n\tif (IS_ERR(anon_inode_inode))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (fops->owner && !try_module_get(fops->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * We know the anon_inode inode count is always greater than zero,\n\t * so ihold() is safe.\n\t */\n\tihold(anon_inode_inode);\n\tfile = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,\n\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);\n\tif (IS_ERR(file))\n\t\tgoto err;\n\n\tfile->f_mapping = anon_inode_inode->i_mapping;\n\n\tfile->private_data = priv;\n\n\treturn file;\n\nerr:\n\tiput(anon_inode_inode);\n\tmodule_put(fops->owner);\n\treturn file;\n}"
  },
  {
    "function_name": "anon_inodefs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
    "lines": "41-46",
    "snippet": "static struct dentry *anon_inodefs_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"anon_inode:\", NULL,\n\t\t\t&anon_inodefs_dentry_operations, ANON_INODE_FS_MAGIC);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dentry_operations anon_inodefs_dentry_operations = {\n\t.d_dname\t= anon_inodefs_dname,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_pseudo",
          "args": [
            "fs_type",
            "\"anon_inode:\"",
            "NULL",
            "&anon_inodefs_dentry_operations",
            "ANON_INODE_FS_MAGIC"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic const struct dentry_operations anon_inodefs_dentry_operations = {\n\t.d_dname\t= anon_inodefs_dname,\n};\n\nstatic struct dentry *anon_inodefs_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"anon_inode:\", NULL,\n\t\t\t&anon_inodefs_dentry_operations, ANON_INODE_FS_MAGIC);\n}"
  },
  {
    "function_name": "anon_inodefs_dname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
    "lines": "31-35",
    "snippet": "static char *anon_inodefs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"anon_inode:%s\",\n\t\t\t\tdentry->d_name.name);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dynamic_dname",
          "args": [
            "dentry",
            "buffer",
            "buflen",
            "\"anon_inode:%s\"",
            "dentry->d_name.name"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "dynamic_dname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "291-307",
          "snippet": "char *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic char *anon_inodefs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"anon_inode:%s\",\n\t\t\t\tdentry->d_name.name);\n}"
  }
]